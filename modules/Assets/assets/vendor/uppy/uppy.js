"use strict"; (() => {
    var gb = Object.create; var Fl = Object.defineProperty; var yb = Object.getOwnPropertyDescriptor; var vb = Object.getOwnPropertyNames; var bb = Object.getPrototypeOf, wb = Object.prototype.hasOwnProperty; var n = (i, e) => Fl(i, "name", { value: e, configurable: !0 }); var me = (i, e) => () => (e || i((e = { exports: {} }).exports, e), e.exports), xl = (i, e) => { for (var t in e) Fl(i, t, { get: e[t], enumerable: !0 }) }, Sb = (i, e, t, r) => { if (e && typeof e == "object" || typeof e == "function") for (let s of vb(e)) !wb.call(i, s) && s !== t && Fl(i, s, { get: () => e[s], enumerable: !(r = yb(e, s)) || r.enumerable }); return i }; var de = (i, e, t) => (t = i != null ? gb(bb(i)) : {}, Sb(e || !i || !i.__esModule ? Fl(t, "default", { value: i, enumerable: !0 }) : t, i)); var ld = me((wF, Vp) => { Vp.exports = n(function () { var e = {}, t = e._fns = {}; e.emit = n(function (a, l, d, p, h, m, y) { var b = r(a); b.length && s(a, b, [l, d, p, h, m, y]) }, "emit"), e.on = n(function (a, l) { t[a] || (t[a] = []), t[a].push(l) }, "on"), e.once = n(function (a, l) { function d() { l.apply(this, arguments), e.off(a, d) } n(d, "one"), this.on(a, d) }, "once"), e.off = n(function (a, l) { var d = []; if (a && l) { var p = this._fns[a], h = 0, m = p ? p.length : 0; for (h; h < m; h++)p[h] !== l && d.push(p[h]) } d.length ? this._fns[a] = d : delete this._fns[a] }, "off"); function r(o) { var a = t[o] ? t[o] : [], l = o.indexOf(":"), d = l === -1 ? [o] : [o.substring(0, l), o.substring(l + 1)], p = Object.keys(t), h = 0, m = p.length; for (h; h < m; h++) { var y = p[h]; if (y === "*" && (a = a.concat(t[y])), d.length === 2 && d[0] === y) { a = a.concat(t[y]); break } } return a } n(r, "getListeners"); function s(o, a, l) { var d = 0, p = a.length; for (d; d < p && a[d]; d++)a[d].event = o, a[d].apply(a[d], l) } return n(s, "emitAll"), e }, "createNamespaceEmitter") }); var Ol = me((FF, Wp) => { function Eb(i) { var e = typeof i; return i != null && (e == "object" || e == "function") } n(Eb, "isObject"); Wp.exports = Eb }); var Kp = me((OF, Gp) => { var Cb = typeof global == "object" && global && global.Object === Object && global; Gp.exports = Cb }); var ud = me((EF, Xp) => { var Ab = Kp(), Tb = typeof self == "object" && self && self.Object === Object && self, Rb = Ab || Tb || Function("return this")(); Xp.exports = Rb }); var Qp = me((CF, Yp) => { var Ub = ud(), kb = n(function () { return Ub.Date.now() }, "now"); Yp.exports = kb }); var Zp = me((TF, Jp) => { var Db = /\s/; function Ib(i) { for (var e = i.length; e-- && Db.test(i.charAt(e));); return e } n(Ib, "trimmedEndIndex"); Jp.exports = Ib }); var tf = me((UF, ef) => { var Nb = Zp(), Mb = /^\s+/; function Bb(i) { return i && i.slice(0, Nb(i) + 1).replace(Mb, "") } n(Bb, "baseTrim"); ef.exports = Bb }); var dd = me((DF, rf) => { var Lb = ud(), jb = Lb.Symbol; rf.exports = jb }); var af = me((IF, nf) => { var sf = dd(), of = Object.prototype, zb = of.hasOwnProperty, Hb = of.toString, dn = sf ? sf.toStringTag : void 0; function $b(i) { var e = zb.call(i, dn), t = i[dn]; try { i[dn] = void 0; var r = !0 } catch { } var s = Hb.call(i); return r && (e ? i[dn] = t : delete i[dn]), s } n($b, "getRawTag"); nf.exports = $b }); var uf = me((MF, lf) => { var qb = Object.prototype, Vb = qb.toString; function Wb(i) { return Vb.call(i) } n(Wb, "objectToString"); lf.exports = Wb }); var pf = me((LF, cf) => { var df = dd(), Gb = af(), Kb = uf(), Xb = "[object Null]", Yb = "[object Undefined]", hf = df ? df.toStringTag : void 0; function Qb(i) { return i == null ? i === void 0 ? Yb : Xb : hf && hf in Object(i) ? Gb(i) : Kb(i) } n(Qb, "baseGetTag"); cf.exports = Qb }); var mf = me((zF, ff) => { function Jb(i) { return i != null && typeof i == "object" } n(Jb, "isObjectLike"); ff.exports = Jb }); var yf = me(($F, gf) => { var Zb = pf(), e1 = mf(), t1 = "[object Symbol]"; function i1(i) { return typeof i == "symbol" || e1(i) && Zb(i) == t1 } n(i1, "isSymbol"); gf.exports = i1 }); var Sf = me((VF, wf) => { var r1 = tf(), vf = Ol(), s1 = yf(), bf = 0 / 0, o1 = /^[-+]0x[0-9a-f]+$/i, n1 = /^0b[01]+$/i, a1 = /^0o[0-7]+$/i, l1 = parseInt; function u1(i) { if (typeof i == "number") return i; if (s1(i)) return bf; if (vf(i)) { var e = typeof i.valueOf == "function" ? i.valueOf() : i; i = vf(e) ? e + "" : e } if (typeof i != "string") return i === 0 ? i : +i; i = r1(i); var t = n1.test(i); return t || a1.test(i) ? l1(i.slice(2), t ? 2 : 8) : o1.test(i) ? bf : +i } n(u1, "toNumber"); wf.exports = u1 }); var cd = me((GF, _f) => { var d1 = Ol(), hd = Qp(), Pf = Sf(), h1 = "Expected a function", c1 = Math.max, p1 = Math.min; function f1(i, e, t) { var r, s, o, a, l, d, p = 0, h = !1, m = !1, y = !0; if (typeof i != "function") throw new TypeError(h1); e = Pf(e) || 0, d1(t) && (h = !!t.leading, m = "maxWait" in t, o = m ? c1(Pf(t.maxWait) || 0, e) : o, y = "trailing" in t ? !!t.trailing : y); function b(L) { var G = r, ee = s; return r = s = void 0, p = L, a = i.apply(ee, G), a } n(b, "invokeFunc"); function S(L) { return p = L, l = setTimeout(x, e), h ? b(L) : a } n(S, "leadingEdge"); function O(L) { var G = L - d, ee = L - p, be = e - G; return m ? p1(be, o - ee) : be } n(O, "remainingWait"); function F(L) { var G = L - d, ee = L - p; return d === void 0 || G >= e || G < 0 || m && ee >= o } n(F, "shouldInvoke"); function x() { var L = hd(); if (F(L)) return U(L); l = setTimeout(x, O(L)) } n(x, "timerExpired"); function U(L) { return l = void 0, y && r ? b(L) : (r = s = void 0, a) } n(U, "trailingEdge"); function H() { l !== void 0 && clearTimeout(l), p = 0, r = d = s = l = void 0 } n(H, "cancel"); function W() { return l === void 0 ? a : U(hd()) } n(W, "flush"); function J() { var L = hd(), G = F(L); if (r = arguments, s = this, d = L, G) { if (l === void 0) return S(d); if (m) return clearTimeout(l), l = setTimeout(x, e), b(d) } return l === void 0 && (l = setTimeout(x, e)), a } return n(J, "debounced"), J.cancel = H, J.flush = W, J } n(f1, "debounce"); _f.exports = f1 }); var El = me((XF, Ff) => { var m1 = cd(), g1 = Ol(), y1 = "Expected a function"; function v1(i, e, t) { var r = !0, s = !0; if (typeof i != "function") throw new TypeError(y1); return g1(t) && (r = "leading" in t ? !!t.leading : r, s = "trailing" in t ? !!t.trailing : s), m1(i, e, { leading: r, maxWait: e, trailing: s }) } n(v1, "throttle"); Ff.exports = v1 }); var Rl = me((yx, Af) => { Af.exports = n(function (e) { if (typeof e != "number" || isNaN(e)) throw new TypeError(`Expected a number, got ${typeof e}`); let t = e < 0, r = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]; if (t && (e = -e), e < 1) return `${(t ? "-" : "") + e} B`; let s = Math.min(Math.floor(Math.log(e) / Math.log(1024)), r.length - 1); e = Number(e / Math.pow(1024, s)); let o = r[s]; return e >= 10 || e % 1 === 0 ? `${(t ? "-" : "") + e.toFixed(0)} ${o}` : `${(t ? "-" : "") + e.toFixed(1)} ${o}` }, "prettierBytes") }); var Uf = me((bx, Rf) => { "use strict"; function Tf(i, e) { this.text = i = i || "", this.hasWild = ~i.indexOf("*"), this.separator = e, this.parts = i.split(e) } n(Tf, "WildcardMatcher"); Tf.prototype.match = function (i) { var e = !0, t = this.parts, r, s = t.length, o; if (typeof i == "string" || i instanceof String) if (!this.hasWild && this.text != i) e = !1; else { for (o = (i || "").split(this.separator), r = 0; e && r < s; r++)t[r] !== "*" && (r < o.length ? e = t[r] === o[r] : e = !1); e = e && o } else if (typeof i.splice == "function") for (e = [], r = i.length; r--;)this.match(i[r]) && (e[e.length] = i[r]); else if (typeof i == "object") { e = {}; for (var a in i) this.match(a) && (e[a] = i[a]) } return e }; Rf.exports = function (i, e, t) { var r = new Tf(i, t || /[\/\.]/); return typeof e < "u" ? r.match(e) : r } }); var Df = me((Sx, kf) => { var F1 = Uf(), x1 = /[\/\+\.]/; kf.exports = function (i, e) { function t(r) { var s = F1(r, i, x1); return s && s.length >= 2 } return n(t, "test"), e ? t(e.split(";")[0]) : t } }); var mm = me((G3, Td) => { "use strict"; var fw = Object.prototype.hasOwnProperty, Tt = "~"; function Un() { } n(Un, "Events"); Object.create && (Un.prototype = Object.create(null), new Un().__proto__ || (Tt = !1)); function mw(i, e, t) { this.fn = i, this.context = e, this.once = t || !1 } n(mw, "EE"); function fm(i, e, t, r, s) { if (typeof t != "function") throw new TypeError("The listener must be a function"); var o = new mw(t, r || i, s), a = Tt ? Tt + e : e; return i._events[a] ? i._events[a].fn ? i._events[a] = [i._events[a], o] : i._events[a].push(o) : (i._events[a] = o, i._eventsCount++), i } n(fm, "addListener"); function Hl(i, e) { --i._eventsCount === 0 ? i._events = new Un : delete i._events[e] } n(Hl, "clearEvent"); function Pt() { this._events = new Un, this._eventsCount = 0 } n(Pt, "EventEmitter"); Pt.prototype.eventNames = n(function () { var e = [], t, r; if (this._eventsCount === 0) return e; for (r in t = this._events) fw.call(t, r) && e.push(Tt ? r.slice(1) : r); return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(t)) : e }, "eventNames"); Pt.prototype.listeners = n(function (e) { var t = Tt ? Tt + e : e, r = this._events[t]; if (!r) return []; if (r.fn) return [r.fn]; for (var s = 0, o = r.length, a = new Array(o); s < o; s++)a[s] = r[s].fn; return a }, "listeners"); Pt.prototype.listenerCount = n(function (e) { var t = Tt ? Tt + e : e, r = this._events[t]; return r ? r.fn ? 1 : r.length : 0 }, "listenerCount"); Pt.prototype.emit = n(function (e, t, r, s, o, a) { var l = Tt ? Tt + e : e; if (!this._events[l]) return !1; var d = this._events[l], p = arguments.length, h, m; if (d.fn) { switch (d.once && this.removeListener(e, d.fn, void 0, !0), p) { case 1: return d.fn.call(d.context), !0; case 2: return d.fn.call(d.context, t), !0; case 3: return d.fn.call(d.context, t, r), !0; case 4: return d.fn.call(d.context, t, r, s), !0; case 5: return d.fn.call(d.context, t, r, s, o), !0; case 6: return d.fn.call(d.context, t, r, s, o, a), !0 }for (m = 1, h = new Array(p - 1); m < p; m++)h[m - 1] = arguments[m]; d.fn.apply(d.context, h) } else { var y = d.length, b; for (m = 0; m < y; m++)switch (d[m].once && this.removeListener(e, d[m].fn, void 0, !0), p) { case 1: d[m].fn.call(d[m].context); break; case 2: d[m].fn.call(d[m].context, t); break; case 3: d[m].fn.call(d[m].context, t, r); break; case 4: d[m].fn.call(d[m].context, t, r, s); break; default: if (!h) for (b = 1, h = new Array(p - 1); b < p; b++)h[b - 1] = arguments[b]; d[m].fn.apply(d[m].context, h) } } return !0 }, "emit"); Pt.prototype.on = n(function (e, t, r) { return fm(this, e, t, r, !1) }, "on"); Pt.prototype.once = n(function (e, t, r) { return fm(this, e, t, r, !0) }, "once"); Pt.prototype.removeListener = n(function (e, t, r, s) { var o = Tt ? Tt + e : e; if (!this._events[o]) return this; if (!t) return Hl(this, o), this; var a = this._events[o]; if (a.fn) a.fn === t && (!s || a.once) && (!r || a.context === r) && Hl(this, o); else { for (var l = 0, d = [], p = a.length; l < p; l++)(a[l].fn !== t || s && !a[l].once || r && a[l].context !== r) && d.push(a[l]); d.length ? this._events[o] = d.length === 1 ? d[0] : d : Hl(this, o) } return this }, "removeListener"); Pt.prototype.removeAllListeners = n(function (e) { var t; return e ? (t = Tt ? Tt + e : e, this._events[t] && Hl(this, t)) : (this._events = new Un, this._eventsCount = 0), this }, "removeAllListeners"); Pt.prototype.off = Pt.prototype.removeListener; Pt.prototype.addListener = Pt.prototype.on; Pt.prefixed = Tt; Pt.EventEmitter = Pt; typeof Td < "u" && (Td.exports = Pt) }); var Jt = me((bO, Ql) => { (function () { "use strict"; var i = {}.hasOwnProperty; function e() { for (var t = [], r = 0; r < arguments.length; r++) { var s = arguments[r]; if (s) { var o = typeof s; if (o === "string" || o === "number") t.push(s); else if (Array.isArray(s)) { if (s.length) { var a = e.apply(null, s); a && t.push(a) } } else if (o === "object") if (s.toString === Object.prototype.toString) for (var l in s) i.call(s, l) && s[l] && t.push(l); else t.push(s.toString()) } } return t.join(" ") } n(e, "classNames"), typeof Ql < "u" && Ql.exports ? (e.default = e, Ql.exports = e) : typeof define == "function" && typeof define.amd == "object" && define.amd ? define("classnames", [], function () { return e }) : window.classNames = e })() }); var Ng = me((M4, Ig) => { Ig.exports = n(function (e, t) { if (e === t) return !0; for (var r in e) if (!(r in t)) return !1; for (var r in t) if (e[r] !== t[r]) return !1; return !0 }, "isShallowEqual") }); var Lg = me((sA, Bg) => { Bg.exports = n(function (e) { if (typeof e != "number" || isNaN(e)) throw new TypeError("Expected a number, got " + typeof e); var t = e < 0, r = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]; if (t && (e = -e), e < 1) return (t ? "-" : "") + e + " B"; var s = Math.min(Math.floor(Math.log(e) / Math.log(1024)), r.length - 1); e = Number(e / Math.pow(1024, s)); var o = r[s]; return e >= 10 || e % 1 === 0 ? (t ? "-" : "") + e.toFixed(0) + " " + o : (t ? "-" : "") + e.toFixed(1) + " " + o }, "prettierBytes") }); var dy = me((Uh, kh) => {
        (function (i, e) { typeof Uh == "object" && typeof kh < "u" ? kh.exports = e() : typeof define == "function" && define.amd ? define(e) : (i = i || self, i.Cropper = e()) })(Uh, function () {
            "use strict"; function i(v) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? i = n(function (c) { return typeof c }, "_typeof") : i = n(function (c) { return c && typeof Symbol == "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c }, "_typeof"), i(v) } n(i, "_typeof"); function e(v, c) { if (!(v instanceof c)) throw new TypeError("Cannot call a class as a function") } n(e, "_classCallCheck"); function t(v, c) { for (var g = 0; g < c.length; g++) { var f = c[g]; f.enumerable = f.enumerable || !1, f.configurable = !0, "value" in f && (f.writable = !0), Object.defineProperty(v, f.key, f) } } n(t, "_defineProperties"); function r(v, c, g) { return c && t(v.prototype, c), g && t(v, g), v } n(r, "_createClass"); function s(v, c, g) { return c in v ? Object.defineProperty(v, c, { value: g, enumerable: !0, configurable: !0, writable: !0 }) : v[c] = g, v } n(s, "_defineProperty"); function o(v, c) { var g = Object.keys(v); if (Object.getOwnPropertySymbols) { var f = Object.getOwnPropertySymbols(v); c && (f = f.filter(function (P) { return Object.getOwnPropertyDescriptor(v, P).enumerable })), g.push.apply(g, f) } return g } n(o, "ownKeys"); function a(v) { for (var c = 1; c < arguments.length; c++) { var g = arguments[c] != null ? arguments[c] : {}; c % 2 ? o(Object(g), !0).forEach(function (f) { s(v, f, g[f]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(v, Object.getOwnPropertyDescriptors(g)) : o(Object(g)).forEach(function (f) { Object.defineProperty(v, f, Object.getOwnPropertyDescriptor(g, f)) }) } return v } n(a, "_objectSpread2"); function l(v) { return d(v) || p(v) || h(v) || y() } n(l, "_toConsumableArray"); function d(v) { if (Array.isArray(v)) return m(v) } n(d, "_arrayWithoutHoles"); function p(v) { if (typeof Symbol < "u" && Symbol.iterator in Object(v)) return Array.from(v) } n(p, "_iterableToArray"); function h(v, c) { if (v) { if (typeof v == "string") return m(v, c); var g = Object.prototype.toString.call(v).slice(8, -1); if (g === "Object" && v.constructor && (g = v.constructor.name), g === "Map" || g === "Set") return Array.from(v); if (g === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(g)) return m(v, c) } } n(h, "_unsupportedIterableToArray"); function m(v, c) { (c == null || c > v.length) && (c = v.length); for (var g = 0, f = new Array(c); g < c; g++)f[g] = v[g]; return f } n(m, "_arrayLikeToArray"); function y() {
                throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
            } n(y, "_nonIterableSpread"); var b = typeof window < "u" && typeof window.document < "u", S = b ? window : {}, O = b && S.document.documentElement ? "ontouchstart" in S.document.documentElement : !1, F = b ? "PointerEvent" in S : !1, x = "cropper", U = "all", H = "crop", W = "move", J = "zoom", L = "e", G = "w", ee = "s", be = "n", yt = "ne", nt = "nw", jt = "se", vt = "sw", Me = "".concat(x, "-crop"), bt = "".concat(x, "-disabled"), $e = "".concat(x, "-hidden"), ki = "".concat(x, "-hide"), q = "".concat(x, "-invisible"), R = "".concat(x, "-modal"), I = "".concat(x, "-move"), B = "".concat(x, "Action"), Y = "".concat(x, "Preview"), K = "crop", ye = "move", ce = "none", oe = "crop", re = "cropend", _e = "cropmove", Fe = "cropstart", Ft = "dblclick", xt = O ? "touchstart" : "mousedown", te = O ? "touchmove" : "mousemove", Ot = O ? "touchend touchcancel" : "mouseup", qe = F ? "pointerdown" : xt, nr = F ? "pointermove" : te, vo = F ? "pointerup pointercancel" : Ot, jr = "ready", zr = "resize", Hr = "wheel", ar = "zoom", lr = "image/jpeg", it = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/, rt = /^data:/, gl = /^data:image\/jpeg;base64,/, yl = /^img|canvas$/i, sn = { viewMode: 0, dragMode: K, initialAspectRatio: NaN, aspectRatio: NaN, data: null, preview: "", responsive: !0, restore: !0, checkCrossOrigin: !0, checkOrientation: !0, modal: !0, guides: !0, center: !0, highlight: !0, background: !0, autoCrop: !0, autoCropArea: .8, movable: !0, rotatable: !0, scalable: !0, zoomable: !0, zoomOnTouch: !0, zoomOnWheel: !0, wheelZoomRatio: .1, cropBoxMovable: !0, cropBoxResizable: !0, toggleDragModeOnDblclick: !0, minCanvasWidth: 0, minCanvasHeight: 0, minCropBoxWidth: 0, minCropBoxHeight: 0, minContainerWidth: 200, minContainerHeight: 100, ready: null, cropstart: null, cropmove: null, cropend: null, crop: null, zoom: null }, vl = '<div class="cropper-container" touch-action="none"><div class="cropper-wrap-box"><div class="cropper-canvas"></div></div><div class="cropper-drag-box"></div><div class="cropper-crop-box"><span class="cropper-view-box"></span><span class="cropper-dashed dashed-h"></span><span class="cropper-dashed dashed-v"></span><span class="cropper-center"></span><span class="cropper-face"></span><span class="cropper-line line-e" data-cropper-action="e"></span><span class="cropper-line line-n" data-cropper-action="n"></span><span class="cropper-line line-w" data-cropper-action="w"></span><span class="cropper-line line-s" data-cropper-action="s"></span><span class="cropper-point point-e" data-cropper-action="e"></span><span class="cropper-point point-n" data-cropper-action="n"></span><span class="cropper-point point-w" data-cropper-action="w"></span><span class="cropper-point point-s" data-cropper-action="s"></span><span class="cropper-point point-ne" data-cropper-action="ne"></span><span class="cropper-point point-nw" data-cropper-action="nw"></span><span class="cropper-point point-sw" data-cropper-action="sw"></span><span class="cropper-point point-se" data-cropper-action="se"></span></div></div>', bl = Number.isNaN || S.isNaN; function ie(v) { return typeof v == "number" && !bl(v) } n(ie, "isNumber"); var on = n(function (c) { return c > 0 && c < 1 / 0 }, "isPositiveNumber"); function bo(v) { return typeof v > "u" } n(bo, "isUndefined"); function Di(v) { return i(v) === "object" && v !== null } n(Di, "isObject"); var td = Object.prototype.hasOwnProperty; function $r(v) { if (!Di(v)) return !1; try { var c = v.constructor, g = c.prototype; return c && g && td.call(g, "isPrototypeOf") } catch { return !1 } } n($r, "isPlainObject"); function wt(v) { return typeof v == "function" } n(wt, "isFunction"); var id = Array.prototype.slice; function wo(v) { return Array.from ? Array.from(v) : id.call(v) } n(wo, "toArray"); function Ae(v, c) { return v && wt(c) && (Array.isArray(v) || ie(v.length) ? wo(v).forEach(function (g, f) { c.call(v, g, f, v) }) : Di(v) && Object.keys(v).forEach(function (g) { c.call(v, v[g], g, v) })), v } n(Ae, "forEach"); var we = Object.assign || n(function (c) { for (var g = arguments.length, f = new Array(g > 1 ? g - 1 : 0), P = 1; P < g; P++)f[P - 1] = arguments[P]; return Di(c) && f.length > 0 && f.forEach(function (w) { Di(w) && Object.keys(w).forEach(function (_) { c[_] = w[_] }) }), c }, "assign"), nn = /\.\d*(?:0|9){12}\d*$/; function Ii(v) { var c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e11; return nn.test(v) ? Math.round(v * c) / c : v } n(Ii, "normalizeDecimalNumber"); var wl = /^width|height|left|top|marginLeft|marginTop$/; function gi(v, c) { var g = v.style; Ae(c, function (f, P) { wl.test(P) && ie(f) && (f = "".concat(f, "px")), g[P] = f }) } n(gi, "setStyle"); function Sl(v, c) { return v.classList ? v.classList.contains(c) : v.className.indexOf(c) > -1 } n(Sl, "hasClass"); function Be(v, c) { if (c) { if (ie(v.length)) { Ae(v, function (f) { Be(f, c) }); return } if (v.classList) { v.classList.add(c); return } var g = v.className.trim(); g ? g.indexOf(c) < 0 && (v.className = "".concat(g, " ").concat(c)) : v.className = c } } n(Be, "addClass"); function yi(v, c) { if (c) { if (ie(v.length)) { Ae(v, function (g) { yi(g, c) }); return } if (v.classList) { v.classList.remove(c); return } v.className.indexOf(c) >= 0 && (v.className = v.className.replace(c, "")) } } n(yi, "removeClass"); function qr(v, c, g) { if (c) { if (ie(v.length)) { Ae(v, function (f) { qr(f, c, g) }); return } g ? Be(v, c) : yi(v, c) } } n(qr, "toggleClass"); var K0 = /([a-z\d])([A-Z])/g; function rd(v) { return v.replace(K0, "$1-$2").toLowerCase() } n(rd, "toParamCase"); function sd(v, c) { return Di(v[c]) ? v[c] : v.dataset ? v.dataset[c] : v.getAttribute("data-".concat(rd(c))) } n(sd, "getData"); function an(v, c, g) { Di(g) ? v[c] = g : v.dataset ? v.dataset[c] = g : v.setAttribute("data-".concat(rd(c)), g) } n(an, "setData"); function X0(v, c) { if (Di(v[c])) try { delete v[c] } catch { v[c] = void 0 } else if (v.dataset) try { delete v.dataset[c] } catch { v.dataset[c] = void 0 } else v.removeAttribute("data-".concat(rd(c))) } n(X0, "removeData"); var Up = /\s\s*/, kp = function () { var v = !1; if (b) { var c = !1, g = n(function () { }, "listener"), f = Object.defineProperty({}, "once", { get: n(function () { return v = !0, c }, "get"), set: n(function (w) { c = w }, "set") }); S.addEventListener("test", g, f), S.removeEventListener("test", g, f) } return v }(); function vi(v, c, g) { var f = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, P = g; c.trim().split(Up).forEach(function (w) { if (!kp) { var _ = v.listeners; _ && _[w] && _[w][g] && (P = _[w][g], delete _[w][g], Object.keys(_[w]).length === 0 && delete _[w], Object.keys(_).length === 0 && delete v.listeners) } v.removeEventListener(w, P, f) }) } n(vi, "removeListener"); function di(v, c, g) { var f = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, P = g; c.trim().split(Up).forEach(function (w) { if (f.once && !kp) { var _ = v.listeners, E = _ === void 0 ? {} : _; P = n(function () { delete E[w][g], v.removeEventListener(w, P, f); for (var T = arguments.length, A = new Array(T), C = 0; C < T; C++)A[C] = arguments[C]; g.apply(v, A) }, "handler"), E[w] || (E[w] = {}), E[w][g] && v.removeEventListener(w, E[w][g], f), E[w][g] = P, v.listeners = E } v.addEventListener(w, P, f) }) } n(di, "addListener"); function So(v, c, g) { var f; return wt(Event) && wt(CustomEvent) ? f = new CustomEvent(c, { detail: g, bubbles: !0, cancelable: !0 }) : (f = document.createEvent("CustomEvent"), f.initCustomEvent(c, !0, !0, g)), v.dispatchEvent(f) } n(So, "dispatchEvent"); function Dp(v) { var c = v.getBoundingClientRect(); return { left: c.left + (window.pageXOffset - document.documentElement.clientLeft), top: c.top + (window.pageYOffset - document.documentElement.clientTop) } } n(Dp, "getOffset"); var od = S.location, Y0 = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i; function Ip(v) { var c = v.match(Y0); return c !== null && (c[1] !== od.protocol || c[2] !== od.hostname || c[3] !== od.port) } n(Ip, "isCrossOriginURL"); function Np(v) { var c = "timestamp=".concat(new Date().getTime()); return v + (v.indexOf("?") === -1 ? "?" : "&") + c } n(Np, "addTimestamp"); function ln(v) { var c = v.rotate, g = v.scaleX, f = v.scaleY, P = v.translateX, w = v.translateY, _ = []; ie(P) && P !== 0 && _.push("translateX(".concat(P, "px)")), ie(w) && w !== 0 && _.push("translateY(".concat(w, "px)")), ie(c) && c !== 0 && _.push("rotate(".concat(c, "deg)")), ie(g) && g !== 1 && _.push("scaleX(".concat(g, ")")), ie(f) && f !== 1 && _.push("scaleY(".concat(f, ")")); var E = _.length ? _.join(" ") : "none"; return { WebkitTransform: E, msTransform: E, transform: E } } n(ln, "getTransforms"); function Q0(v) { var c = a({}, v), g = []; return Ae(v, function (f, P) { delete c[P], Ae(c, function (w) { var _ = Math.abs(f.startX - w.startX), E = Math.abs(f.startY - w.startY), D = Math.abs(f.endX - w.endX), T = Math.abs(f.endY - w.endY), A = Math.sqrt(_ * _ + E * E), C = Math.sqrt(D * D + T * T), k = (C - A) / A; g.push(k) }) }), g.sort(function (f, P) { return Math.abs(f) < Math.abs(P) }), g[0] } n(Q0, "getMaxZoomRatio"); function Pl(v, c) { var g = v.pageX, f = v.pageY, P = { endX: g, endY: f }; return c ? P : a({ startX: g, startY: f }, P) } n(Pl, "getPointer"); function J0(v) { var c = 0, g = 0, f = 0; return Ae(v, function (P) { var w = P.startX, _ = P.startY; c += w, g += _, f += 1 }), c /= f, g /= f, { pageX: c, pageY: g } } n(J0, "getPointersCenter"); function Vr(v) { var c = v.aspectRatio, g = v.height, f = v.width, P = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "contain", w = on(f), _ = on(g); if (w && _) { var E = g * c; P === "contain" && E > f || P === "cover" && E < f ? g = f / c : f = g * c } else w ? g = f / c : _ && (f = g * c); return { width: f, height: g } } n(Vr, "getAdjustedSizes"); function Z0(v) { var c = v.width, g = v.height, f = v.degree; if (f = Math.abs(f) % 180, f === 90) return { width: g, height: c }; var P = f % 90 * Math.PI / 180, w = Math.sin(P), _ = Math.cos(P), E = c * _ + g * w, D = c * w + g * _; return f > 90 ? { width: D, height: E } : { width: E, height: D } } n(Z0, "getRotatedSizes"); function eb(v, c, g, f) { var P = c.aspectRatio, w = c.naturalWidth, _ = c.naturalHeight, E = c.rotate, D = E === void 0 ? 0 : E, T = c.scaleX, A = T === void 0 ? 1 : T, C = c.scaleY, k = C === void 0 ? 1 : C, ue = g.aspectRatio, le = g.naturalWidth, Ee = g.naturalHeight, pe = f.fillColor, Xe = pe === void 0 ? "transparent" : pe, st = f.imageSmoothingEnabled, Ve = st === void 0 ? !0 : st, ur = f.imageSmoothingQuality, Gt = ur === void 0 ? "low" : ur, M = f.maxWidth, fe = M === void 0 ? 1 / 0 : M, Ye = f.maxHeight, hi = Ye === void 0 ? 1 / 0 : Ye, dr = f.minWidth, ps = dr === void 0 ? 0 : dr, fs = f.minHeight, Wr = fs === void 0 ? 0 : fs, Ni = document.createElement("canvas"), zt = Ni.getContext("2d"), ms = Vr({ aspectRatio: ue, width: fe, height: hi }), _l = Vr({ aspectRatio: ue, width: ps, height: Wr }, "cover"), nd = Math.min(ms.width, Math.max(_l.width, le)), ad = Math.min(ms.height, Math.max(_l.height, Ee)), Lp = Vr({ aspectRatio: P, width: fe, height: hi }), jp = Vr({ aspectRatio: P, width: ps, height: Wr }, "cover"), zp = Math.min(Lp.width, Math.max(jp.width, w)), Hp = Math.min(Lp.height, Math.max(jp.height, _)), fb = [-zp / 2, -Hp / 2, zp, Hp]; return Ni.width = Ii(nd), Ni.height = Ii(ad), zt.fillStyle = Xe, zt.fillRect(0, 0, nd, ad), zt.save(), zt.translate(nd / 2, ad / 2), zt.rotate(D * Math.PI / 180), zt.scale(A, k), zt.imageSmoothingEnabled = Ve, zt.imageSmoothingQuality = Gt, zt.drawImage.apply(zt, [v].concat(l(fb.map(function (mb) { return Math.floor(Ii(mb)) })))), zt.restore(), Ni } n(eb, "getSourceCanvas"); var Mp = String.fromCharCode; function tb(v, c, g) { var f = ""; g += c; for (var P = c; P < g; P += 1)f += Mp(v.getUint8(P)); return f } n(tb, "getStringFromCharCode"); var ib = /^data:.*,/; function rb(v) { var c = v.replace(ib, ""), g = atob(c), f = new ArrayBuffer(g.length), P = new Uint8Array(f); return Ae(P, function (w, _) { P[_] = g.charCodeAt(_) }), f } n(rb, "dataURLToArrayBuffer"); function sb(v, c) { for (var g = [], f = 8192, P = new Uint8Array(v); P.length > 0;)g.push(Mp.apply(null, wo(P.subarray(0, f)))), P = P.subarray(f); return "data:".concat(c, ";base64,").concat(btoa(g.join(""))) } n(sb, "arrayBufferToDataURL"); function ob(v) { var c = new DataView(v), g; try { var f, P, w; if (c.getUint8(0) === 255 && c.getUint8(1) === 216) for (var _ = c.byteLength, E = 2; E + 1 < _;) { if (c.getUint8(E) === 255 && c.getUint8(E + 1) === 225) { P = E; break } E += 1 } if (P) { var D = P + 4, T = P + 10; if (tb(c, D, 4) === "Exif") { var A = c.getUint16(T); if (f = A === 18761, (f || A === 19789) && c.getUint16(T + 2, f) === 42) { var C = c.getUint32(T + 4, f); C >= 8 && (w = T + C) } } } if (w) { var k = c.getUint16(w, f), ue, le; for (le = 0; le < k; le += 1)if (ue = w + le * 12 + 2, c.getUint16(ue, f) === 274) { ue += 8, g = c.getUint16(ue, f), c.setUint16(ue, 1, f); break } } } catch { g = 1 } return g } n(ob, "resetAndGetOrientation"); function nb(v) { var c = 0, g = 1, f = 1; switch (v) { case 2: g = -1; break; case 3: c = -180; break; case 4: f = -1; break; case 5: c = 90, f = -1; break; case 6: c = 90; break; case 7: c = 90, g = -1; break; case 8: c = -90; break }return { rotate: c, scaleX: g, scaleY: f } } n(nb, "parseOrientation"); var ab = { render: n(function () { this.initContainer(), this.initCanvas(), this.initCropBox(), this.renderCanvas(), this.cropped && this.renderCropBox() }, "render"), initContainer: n(function () { var c = this.element, g = this.options, f = this.container, P = this.cropper; Be(P, $e), yi(c, $e); var w = { width: Math.max(f.offsetWidth, Number(g.minContainerWidth) || 200), height: Math.max(f.offsetHeight, Number(g.minContainerHeight) || 100) }; this.containerData = w, gi(P, { width: w.width, height: w.height }), Be(c, $e), yi(P, $e) }, "initContainer"), initCanvas: n(function () { var c = this.containerData, g = this.imageData, f = this.options.viewMode, P = Math.abs(g.rotate) % 180 === 90, w = P ? g.naturalHeight : g.naturalWidth, _ = P ? g.naturalWidth : g.naturalHeight, E = w / _, D = c.width, T = c.height; c.height * E > c.width ? f === 3 ? D = c.height * E : T = c.width / E : f === 3 ? T = c.width / E : D = c.height * E; var A = { aspectRatio: E, naturalWidth: w, naturalHeight: _, width: D, height: T }; A.left = (c.width - D) / 2, A.top = (c.height - T) / 2, A.oldLeft = A.left, A.oldTop = A.top, this.canvasData = A, this.limited = f === 1 || f === 2, this.limitCanvas(!0, !0), this.initialImageData = we({}, g), this.initialCanvasData = we({}, A) }, "initCanvas"), limitCanvas: n(function (c, g) { var f = this.options, P = this.containerData, w = this.canvasData, _ = this.cropBoxData, E = f.viewMode, D = w.aspectRatio, T = this.cropped && _; if (c) { var A = Number(f.minCanvasWidth) || 0, C = Number(f.minCanvasHeight) || 0; E > 1 ? (A = Math.max(A, P.width), C = Math.max(C, P.height), E === 3 && (C * D > A ? A = C * D : C = A / D)) : E > 0 && (A ? A = Math.max(A, T ? _.width : 0) : C ? C = Math.max(C, T ? _.height : 0) : T && (A = _.width, C = _.height, C * D > A ? A = C * D : C = A / D)); var k = Vr({ aspectRatio: D, width: A, height: C }); A = k.width, C = k.height, w.minWidth = A, w.minHeight = C, w.maxWidth = 1 / 0, w.maxHeight = 1 / 0 } if (g) if (E > (T ? 0 : 1)) { var ue = P.width - w.width, le = P.height - w.height; w.minLeft = Math.min(0, ue), w.minTop = Math.min(0, le), w.maxLeft = Math.max(0, ue), w.maxTop = Math.max(0, le), T && this.limited && (w.minLeft = Math.min(_.left, _.left + (_.width - w.width)), w.minTop = Math.min(_.top, _.top + (_.height - w.height)), w.maxLeft = _.left, w.maxTop = _.top, E === 2 && (w.width >= P.width && (w.minLeft = Math.min(0, ue), w.maxLeft = Math.max(0, ue)), w.height >= P.height && (w.minTop = Math.min(0, le), w.maxTop = Math.max(0, le)))) } else w.minLeft = -w.width, w.minTop = -w.height, w.maxLeft = P.width, w.maxTop = P.height }, "limitCanvas"), renderCanvas: n(function (c, g) { var f = this.canvasData, P = this.imageData; if (g) { var w = Z0({ width: P.naturalWidth * Math.abs(P.scaleX || 1), height: P.naturalHeight * Math.abs(P.scaleY || 1), degree: P.rotate || 0 }), _ = w.width, E = w.height, D = f.width * (_ / f.naturalWidth), T = f.height * (E / f.naturalHeight); f.left -= (D - f.width) / 2, f.top -= (T - f.height) / 2, f.width = D, f.height = T, f.aspectRatio = _ / E, f.naturalWidth = _, f.naturalHeight = E, this.limitCanvas(!0, !1) } (f.width > f.maxWidth || f.width < f.minWidth) && (f.left = f.oldLeft), (f.height > f.maxHeight || f.height < f.minHeight) && (f.top = f.oldTop), f.width = Math.min(Math.max(f.width, f.minWidth), f.maxWidth), f.height = Math.min(Math.max(f.height, f.minHeight), f.maxHeight), this.limitCanvas(!1, !0), f.left = Math.min(Math.max(f.left, f.minLeft), f.maxLeft), f.top = Math.min(Math.max(f.top, f.minTop), f.maxTop), f.oldLeft = f.left, f.oldTop = f.top, gi(this.canvas, we({ width: f.width, height: f.height }, ln({ translateX: f.left, translateY: f.top }))), this.renderImage(c), this.cropped && this.limited && this.limitCropBox(!0, !0) }, "renderCanvas"), renderImage: n(function (c) { var g = this.canvasData, f = this.imageData, P = f.naturalWidth * (g.width / g.naturalWidth), w = f.naturalHeight * (g.height / g.naturalHeight); we(f, { width: P, height: w, left: (g.width - P) / 2, top: (g.height - w) / 2 }), gi(this.image, we({ width: f.width, height: f.height }, ln(we({ translateX: f.left, translateY: f.top }, f)))), c && this.output() }, "renderImage"), initCropBox: n(function () { var c = this.options, g = this.canvasData, f = c.aspectRatio || c.initialAspectRatio, P = Number(c.autoCropArea) || .8, w = { width: g.width, height: g.height }; f && (g.height * f > g.width ? w.height = w.width / f : w.width = w.height * f), this.cropBoxData = w, this.limitCropBox(!0, !0), w.width = Math.min(Math.max(w.width, w.minWidth), w.maxWidth), w.height = Math.min(Math.max(w.height, w.minHeight), w.maxHeight), w.width = Math.max(w.minWidth, w.width * P), w.height = Math.max(w.minHeight, w.height * P), w.left = g.left + (g.width - w.width) / 2, w.top = g.top + (g.height - w.height) / 2, w.oldLeft = w.left, w.oldTop = w.top, this.initialCropBoxData = we({}, w) }, "initCropBox"), limitCropBox: n(function (c, g) { var f = this.options, P = this.containerData, w = this.canvasData, _ = this.cropBoxData, E = this.limited, D = f.aspectRatio; if (c) { var T = Number(f.minCropBoxWidth) || 0, A = Number(f.minCropBoxHeight) || 0, C = E ? Math.min(P.width, w.width, w.width + w.left, P.width - w.left) : P.width, k = E ? Math.min(P.height, w.height, w.height + w.top, P.height - w.top) : P.height; T = Math.min(T, P.width), A = Math.min(A, P.height), D && (T && A ? A * D > T ? A = T / D : T = A * D : T ? A = T / D : A && (T = A * D), k * D > C ? k = C / D : C = k * D), _.minWidth = Math.min(T, C), _.minHeight = Math.min(A, k), _.maxWidth = C, _.maxHeight = k } g && (E ? (_.minLeft = Math.max(0, w.left), _.minTop = Math.max(0, w.top), _.maxLeft = Math.min(P.width, w.left + w.width) - _.width, _.maxTop = Math.min(P.height, w.top + w.height) - _.height) : (_.minLeft = 0, _.minTop = 0, _.maxLeft = P.width - _.width, _.maxTop = P.height - _.height)) }, "limitCropBox"), renderCropBox: n(function () { var c = this.options, g = this.containerData, f = this.cropBoxData; (f.width > f.maxWidth || f.width < f.minWidth) && (f.left = f.oldLeft), (f.height > f.maxHeight || f.height < f.minHeight) && (f.top = f.oldTop), f.width = Math.min(Math.max(f.width, f.minWidth), f.maxWidth), f.height = Math.min(Math.max(f.height, f.minHeight), f.maxHeight), this.limitCropBox(!1, !0), f.left = Math.min(Math.max(f.left, f.minLeft), f.maxLeft), f.top = Math.min(Math.max(f.top, f.minTop), f.maxTop), f.oldLeft = f.left, f.oldTop = f.top, c.movable && c.cropBoxMovable && an(this.face, B, f.width >= g.width && f.height >= g.height ? W : U), gi(this.cropBox, we({ width: f.width, height: f.height }, ln({ translateX: f.left, translateY: f.top }))), this.cropped && this.limited && this.limitCanvas(!0, !0), this.disabled || this.output() }, "renderCropBox"), output: n(function () { this.preview(), So(this.element, oe, this.getData()) }, "output") }, lb = { initPreview: n(function () { var c = this.element, g = this.crossOrigin, f = this.options.preview, P = g ? this.crossOriginUrl : this.url, w = c.alt || "The image to preview", _ = document.createElement("img"); if (g && (_.crossOrigin = g), _.src = P, _.alt = w, this.viewBox.appendChild(_), this.viewBoxImage = _, !!f) { var E = f; typeof f == "string" ? E = c.ownerDocument.querySelectorAll(f) : f.querySelector && (E = [f]), this.previews = E, Ae(E, function (D) { var T = document.createElement("img"); an(D, Y, { width: D.offsetWidth, height: D.offsetHeight, html: D.innerHTML }), g && (T.crossOrigin = g), T.src = P, T.alt = w, T.style.cssText = 'display:block;width:100%;height:auto;min-width:0!important;min-height:0!important;max-width:none!important;max-height:none!important;image-orientation:0deg!important;"', D.innerHTML = "", D.appendChild(T) }) } }, "initPreview"), resetPreview: n(function () { Ae(this.previews, function (c) { var g = sd(c, Y); gi(c, { width: g.width, height: g.height }), c.innerHTML = g.html, X0(c, Y) }) }, "resetPreview"), preview: n(function () { var c = this.imageData, g = this.canvasData, f = this.cropBoxData, P = f.width, w = f.height, _ = c.width, E = c.height, D = f.left - g.left - c.left, T = f.top - g.top - c.top; !this.cropped || this.disabled || (gi(this.viewBoxImage, we({ width: _, height: E }, ln(we({ translateX: -D, translateY: -T }, c)))), Ae(this.previews, function (A) { var C = sd(A, Y), k = C.width, ue = C.height, le = k, Ee = ue, pe = 1; P && (pe = k / P, Ee = w * pe), w && Ee > ue && (pe = ue / w, le = P * pe, Ee = ue), gi(A, { width: le, height: Ee }), gi(A.getElementsByTagName("img")[0], we({ width: _ * pe, height: E * pe }, ln(we({ translateX: -D * pe, translateY: -T * pe }, c)))) })) }, "preview") }, ub = { bind: n(function () { var c = this.element, g = this.options, f = this.cropper; wt(g.cropstart) && di(c, Fe, g.cropstart), wt(g.cropmove) && di(c, _e, g.cropmove), wt(g.cropend) && di(c, re, g.cropend), wt(g.crop) && di(c, oe, g.crop), wt(g.zoom) && di(c, ar, g.zoom), di(f, qe, this.onCropStart = this.cropStart.bind(this)), g.zoomable && g.zoomOnWheel && di(f, Hr, this.onWheel = this.wheel.bind(this), { passive: !1, capture: !0 }), g.toggleDragModeOnDblclick && di(f, Ft, this.onDblclick = this.dblclick.bind(this)), di(c.ownerDocument, nr, this.onCropMove = this.cropMove.bind(this)), di(c.ownerDocument, vo, this.onCropEnd = this.cropEnd.bind(this)), g.responsive && di(window, zr, this.onResize = this.resize.bind(this)) }, "bind"), unbind: n(function () { var c = this.element, g = this.options, f = this.cropper; wt(g.cropstart) && vi(c, Fe, g.cropstart), wt(g.cropmove) && vi(c, _e, g.cropmove), wt(g.cropend) && vi(c, re, g.cropend), wt(g.crop) && vi(c, oe, g.crop), wt(g.zoom) && vi(c, ar, g.zoom), vi(f, qe, this.onCropStart), g.zoomable && g.zoomOnWheel && vi(f, Hr, this.onWheel, { passive: !1, capture: !0 }), g.toggleDragModeOnDblclick && vi(f, Ft, this.onDblclick), vi(c.ownerDocument, nr, this.onCropMove), vi(c.ownerDocument, vo, this.onCropEnd), g.responsive && vi(window, zr, this.onResize) }, "unbind") }, db = { resize: n(function () { if (!this.disabled) { var c = this.options, g = this.container, f = this.containerData, P = g.offsetWidth / f.width; if (P !== 1 || g.offsetHeight !== f.height) { var w, _; c.restore && (w = this.getCanvasData(), _ = this.getCropBoxData()), this.render(), c.restore && (this.setCanvasData(Ae(w, function (E, D) { w[D] = E * P })), this.setCropBoxData(Ae(_, function (E, D) { _[D] = E * P }))) } } }, "resize"), dblclick: n(function () { this.disabled || this.options.dragMode === ce || this.setDragMode(Sl(this.dragBox, Me) ? ye : K) }, "dblclick"), wheel: n(function (c) { var g = this, f = Number(this.options.wheelZoomRatio) || .1, P = 1; this.disabled || (c.preventDefault(), !this.wheeling && (this.wheeling = !0, setTimeout(function () { g.wheeling = !1 }, 50), c.deltaY ? P = c.deltaY > 0 ? 1 : -1 : c.wheelDelta ? P = -c.wheelDelta / 120 : c.detail && (P = c.detail > 0 ? 1 : -1), this.zoom(-P * f, c))) }, "wheel"), cropStart: n(function (c) { var g = c.buttons, f = c.button; if (!(this.disabled || (c.type === "mousedown" || c.type === "pointerdown" && c.pointerType === "mouse") && (ie(g) && g !== 1 || ie(f) && f !== 0 || c.ctrlKey))) { var P = this.options, w = this.pointers, _; c.changedTouches ? Ae(c.changedTouches, function (E) { w[E.identifier] = Pl(E) }) : w[c.pointerId || 0] = Pl(c), Object.keys(w).length > 1 && P.zoomable && P.zoomOnTouch ? _ = J : _ = sd(c.target, B), it.test(_) && So(this.element, Fe, { originalEvent: c, action: _ }) !== !1 && (c.preventDefault(), this.action = _, this.cropping = !1, _ === H && (this.cropping = !0, Be(this.dragBox, R))) } }, "cropStart"), cropMove: n(function (c) { var g = this.action; if (!(this.disabled || !g)) { var f = this.pointers; c.preventDefault(), So(this.element, _e, { originalEvent: c, action: g }) !== !1 && (c.changedTouches ? Ae(c.changedTouches, function (P) { we(f[P.identifier] || {}, Pl(P, !0)) }) : we(f[c.pointerId || 0] || {}, Pl(c, !0)), this.change(c)) } }, "cropMove"), cropEnd: n(function (c) { if (!this.disabled) { var g = this.action, f = this.pointers; c.changedTouches ? Ae(c.changedTouches, function (P) { delete f[P.identifier] }) : delete f[c.pointerId || 0], g && (c.preventDefault(), Object.keys(f).length || (this.action = ""), this.cropping && (this.cropping = !1, qr(this.dragBox, R, this.cropped && this.options.modal)), So(this.element, re, { originalEvent: c, action: g })) } }, "cropEnd") }, hb = { change: n(function (c) { var g = this.options, f = this.canvasData, P = this.containerData, w = this.cropBoxData, _ = this.pointers, E = this.action, D = g.aspectRatio, T = w.left, A = w.top, C = w.width, k = w.height, ue = T + C, le = A + k, Ee = 0, pe = 0, Xe = P.width, st = P.height, Ve = !0, ur; !D && c.shiftKey && (D = C && k ? C / k : 1), this.limited && (Ee = w.minLeft, pe = w.minTop, Xe = Ee + Math.min(P.width, f.width, f.left + f.width), st = pe + Math.min(P.height, f.height, f.top + f.height)); var Gt = _[Object.keys(_)[0]], M = { x: Gt.endX - Gt.startX, y: Gt.endY - Gt.startY }, fe = n(function (hi) { switch (hi) { case L: ue + M.x > Xe && (M.x = Xe - ue); break; case G: T + M.x < Ee && (M.x = Ee - T); break; case be: A + M.y < pe && (M.y = pe - A); break; case ee: le + M.y > st && (M.y = st - le); break } }, "check"); switch (E) { case U: T += M.x, A += M.y; break; case L: if (M.x >= 0 && (ue >= Xe || D && (A <= pe || le >= st))) { Ve = !1; break } fe(L), C += M.x, C < 0 && (E = G, C = -C, T -= C), D && (k = C / D, A += (w.height - k) / 2); break; case be: if (M.y <= 0 && (A <= pe || D && (T <= Ee || ue >= Xe))) { Ve = !1; break } fe(be), k -= M.y, A += M.y, k < 0 && (E = ee, k = -k, A -= k), D && (C = k * D, T += (w.width - C) / 2); break; case G: if (M.x <= 0 && (T <= Ee || D && (A <= pe || le >= st))) { Ve = !1; break } fe(G), C -= M.x, T += M.x, C < 0 && (E = L, C = -C, T -= C), D && (k = C / D, A += (w.height - k) / 2); break; case ee: if (M.y >= 0 && (le >= st || D && (T <= Ee || ue >= Xe))) { Ve = !1; break } fe(ee), k += M.y, k < 0 && (E = be, k = -k, A -= k), D && (C = k * D, T += (w.width - C) / 2); break; case yt: if (D) { if (M.y <= 0 && (A <= pe || ue >= Xe)) { Ve = !1; break } fe(be), k -= M.y, A += M.y, C = k * D } else fe(be), fe(L), M.x >= 0 ? ue < Xe ? C += M.x : M.y <= 0 && A <= pe && (Ve = !1) : C += M.x, M.y <= 0 ? A > pe && (k -= M.y, A += M.y) : (k -= M.y, A += M.y); C < 0 && k < 0 ? (E = vt, k = -k, C = -C, A -= k, T -= C) : C < 0 ? (E = nt, C = -C, T -= C) : k < 0 && (E = jt, k = -k, A -= k); break; case nt: if (D) { if (M.y <= 0 && (A <= pe || T <= Ee)) { Ve = !1; break } fe(be), k -= M.y, A += M.y, C = k * D, T += w.width - C } else fe(be), fe(G), M.x <= 0 ? T > Ee ? (C -= M.x, T += M.x) : M.y <= 0 && A <= pe && (Ve = !1) : (C -= M.x, T += M.x), M.y <= 0 ? A > pe && (k -= M.y, A += M.y) : (k -= M.y, A += M.y); C < 0 && k < 0 ? (E = jt, k = -k, C = -C, A -= k, T -= C) : C < 0 ? (E = yt, C = -C, T -= C) : k < 0 && (E = vt, k = -k, A -= k); break; case vt: if (D) { if (M.x <= 0 && (T <= Ee || le >= st)) { Ve = !1; break } fe(G), C -= M.x, T += M.x, k = C / D } else fe(ee), fe(G), M.x <= 0 ? T > Ee ? (C -= M.x, T += M.x) : M.y >= 0 && le >= st && (Ve = !1) : (C -= M.x, T += M.x), M.y >= 0 ? le < st && (k += M.y) : k += M.y; C < 0 && k < 0 ? (E = yt, k = -k, C = -C, A -= k, T -= C) : C < 0 ? (E = jt, C = -C, T -= C) : k < 0 && (E = nt, k = -k, A -= k); break; case jt: if (D) { if (M.x >= 0 && (ue >= Xe || le >= st)) { Ve = !1; break } fe(L), C += M.x, k = C / D } else fe(ee), fe(L), M.x >= 0 ? ue < Xe ? C += M.x : M.y >= 0 && le >= st && (Ve = !1) : C += M.x, M.y >= 0 ? le < st && (k += M.y) : k += M.y; C < 0 && k < 0 ? (E = nt, k = -k, C = -C, A -= k, T -= C) : C < 0 ? (E = vt, C = -C, T -= C) : k < 0 && (E = yt, k = -k, A -= k); break; case W: this.move(M.x, M.y), Ve = !1; break; case J: this.zoom(Q0(_), c), Ve = !1; break; case H: if (!M.x || !M.y) { Ve = !1; break } ur = Dp(this.cropper), T = Gt.startX - ur.left, A = Gt.startY - ur.top, C = w.minWidth, k = w.minHeight, M.x > 0 ? E = M.y > 0 ? jt : yt : M.x < 0 && (T -= C, E = M.y > 0 ? vt : nt), M.y < 0 && (A -= k), this.cropped || (yi(this.cropBox, $e), this.cropped = !0, this.limited && this.limitCropBox(!0, !0)); break }Ve && (w.width = C, w.height = k, w.left = T, w.top = A, this.action = E, this.renderCropBox()), Ae(_, function (Ye) { Ye.startX = Ye.endX, Ye.startY = Ye.endY }) }, "change") }, cb = { crop: n(function () { return this.ready && !this.cropped && !this.disabled && (this.cropped = !0, this.limitCropBox(!0, !0), this.options.modal && Be(this.dragBox, R), yi(this.cropBox, $e), this.setCropBoxData(this.initialCropBoxData)), this }, "crop"), reset: n(function () { return this.ready && !this.disabled && (this.imageData = we({}, this.initialImageData), this.canvasData = we({}, this.initialCanvasData), this.cropBoxData = we({}, this.initialCropBoxData), this.renderCanvas(), this.cropped && this.renderCropBox()), this }, "reset"), clear: n(function () { return this.cropped && !this.disabled && (we(this.cropBoxData, { left: 0, top: 0, width: 0, height: 0 }), this.cropped = !1, this.renderCropBox(), this.limitCanvas(!0, !0), this.renderCanvas(), yi(this.dragBox, R), Be(this.cropBox, $e)), this }, "clear"), replace: n(function (c) { var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1; return !this.disabled && c && (this.isImg && (this.element.src = c), g ? (this.url = c, this.image.src = c, this.ready && (this.viewBoxImage.src = c, Ae(this.previews, function (f) { f.getElementsByTagName("img")[0].src = c }))) : (this.isImg && (this.replaced = !0), this.options.data = null, this.uncreate(), this.load(c))), this }, "replace"), enable: n(function () { return this.ready && this.disabled && (this.disabled = !1, yi(this.cropper, bt)), this }, "enable"), disable: n(function () { return this.ready && !this.disabled && (this.disabled = !0, Be(this.cropper, bt)), this }, "disable"), destroy: n(function () { var c = this.element; return c[x] ? (c[x] = void 0, this.isImg && this.replaced && (c.src = this.originalUrl), this.uncreate(), this) : this }, "destroy"), move: n(function (c) { var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c, f = this.canvasData, P = f.left, w = f.top; return this.moveTo(bo(c) ? c : P + Number(c), bo(g) ? g : w + Number(g)) }, "move"), moveTo: n(function (c) { var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c, f = this.canvasData, P = !1; return c = Number(c), g = Number(g), this.ready && !this.disabled && this.options.movable && (ie(c) && (f.left = c, P = !0), ie(g) && (f.top = g, P = !0), P && this.renderCanvas(!0)), this }, "moveTo"), zoom: n(function (c, g) { var f = this.canvasData; return c = Number(c), c < 0 ? c = 1 / (1 - c) : c = 1 + c, this.zoomTo(f.width * c / f.naturalWidth, null, g) }, "zoom"), zoomTo: n(function (c, g, f) { var P = this.options, w = this.canvasData, _ = w.width, E = w.height, D = w.naturalWidth, T = w.naturalHeight; if (c = Number(c), c >= 0 && this.ready && !this.disabled && P.zoomable) { var A = D * c, C = T * c; if (So(this.element, ar, { ratio: c, oldRatio: _ / D, originalEvent: f }) === !1) return this; if (f) { var k = this.pointers, ue = Dp(this.cropper), le = k && Object.keys(k).length ? J0(k) : { pageX: f.pageX, pageY: f.pageY }; w.left -= (A - _) * ((le.pageX - ue.left - w.left) / _), w.top -= (C - E) * ((le.pageY - ue.top - w.top) / E) } else $r(g) && ie(g.x) && ie(g.y) ? (w.left -= (A - _) * ((g.x - w.left) / _), w.top -= (C - E) * ((g.y - w.top) / E)) : (w.left -= (A - _) / 2, w.top -= (C - E) / 2); w.width = A, w.height = C, this.renderCanvas(!0) } return this }, "zoomTo"), rotate: n(function (c) { return this.rotateTo((this.imageData.rotate || 0) + Number(c)) }, "rotate"), rotateTo: n(function (c) { return c = Number(c), ie(c) && this.ready && !this.disabled && this.options.rotatable && (this.imageData.rotate = c % 360, this.renderCanvas(!0, !0)), this }, "rotateTo"), scaleX: n(function (c) { var g = this.imageData.scaleY; return this.scale(c, ie(g) ? g : 1) }, "scaleX"), scaleY: n(function (c) { var g = this.imageData.scaleX; return this.scale(ie(g) ? g : 1, c) }, "scaleY"), scale: n(function (c) { var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c, f = this.imageData, P = !1; return c = Number(c), g = Number(g), this.ready && !this.disabled && this.options.scalable && (ie(c) && (f.scaleX = c, P = !0), ie(g) && (f.scaleY = g, P = !0), P && this.renderCanvas(!0, !0)), this }, "scale"), getData: n(function () { var c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, g = this.options, f = this.imageData, P = this.canvasData, w = this.cropBoxData, _; if (this.ready && this.cropped) { _ = { x: w.left - P.left, y: w.top - P.top, width: w.width, height: w.height }; var E = f.width / f.naturalWidth; if (Ae(_, function (A, C) { _[C] = A / E }), c) { var D = Math.round(_.y + _.height), T = Math.round(_.x + _.width); _.x = Math.round(_.x), _.y = Math.round(_.y), _.width = T - _.x, _.height = D - _.y } } else _ = { x: 0, y: 0, width: 0, height: 0 }; return g.rotatable && (_.rotate = f.rotate || 0), g.scalable && (_.scaleX = f.scaleX || 1, _.scaleY = f.scaleY || 1), _ }, "getData"), setData: n(function (c) { var g = this.options, f = this.imageData, P = this.canvasData, w = {}; if (this.ready && !this.disabled && $r(c)) { var _ = !1; g.rotatable && ie(c.rotate) && c.rotate !== f.rotate && (f.rotate = c.rotate, _ = !0), g.scalable && (ie(c.scaleX) && c.scaleX !== f.scaleX && (f.scaleX = c.scaleX, _ = !0), ie(c.scaleY) && c.scaleY !== f.scaleY && (f.scaleY = c.scaleY, _ = !0)), _ && this.renderCanvas(!0, !0); var E = f.width / f.naturalWidth; ie(c.x) && (w.left = c.x * E + P.left), ie(c.y) && (w.top = c.y * E + P.top), ie(c.width) && (w.width = c.width * E), ie(c.height) && (w.height = c.height * E), this.setCropBoxData(w) } return this }, "setData"), getContainerData: n(function () { return this.ready ? we({}, this.containerData) : {} }, "getContainerData"), getImageData: n(function () { return this.sized ? we({}, this.imageData) : {} }, "getImageData"), getCanvasData: n(function () { var c = this.canvasData, g = {}; return this.ready && Ae(["left", "top", "width", "height", "naturalWidth", "naturalHeight"], function (f) { g[f] = c[f] }), g }, "getCanvasData"), setCanvasData: n(function (c) { var g = this.canvasData, f = g.aspectRatio; return this.ready && !this.disabled && $r(c) && (ie(c.left) && (g.left = c.left), ie(c.top) && (g.top = c.top), ie(c.width) ? (g.width = c.width, g.height = c.width / f) : ie(c.height) && (g.height = c.height, g.width = c.height * f), this.renderCanvas(!0)), this }, "setCanvasData"), getCropBoxData: n(function () { var c = this.cropBoxData, g; return this.ready && this.cropped && (g = { left: c.left, top: c.top, width: c.width, height: c.height }), g || {} }, "getCropBoxData"), setCropBoxData: n(function (c) { var g = this.cropBoxData, f = this.options.aspectRatio, P, w; return this.ready && this.cropped && !this.disabled && $r(c) && (ie(c.left) && (g.left = c.left), ie(c.top) && (g.top = c.top), ie(c.width) && c.width !== g.width && (P = !0, g.width = c.width), ie(c.height) && c.height !== g.height && (w = !0, g.height = c.height), f && (P ? g.height = g.width / f : w && (g.width = g.height * f)), this.renderCropBox()), this }, "setCropBoxData"), getCroppedCanvas: n(function () { var c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; if (!this.ready || !window.HTMLCanvasElement) return null; var g = this.canvasData, f = eb(this.image, this.imageData, g, c); if (!this.cropped) return f; var P = this.getData(), w = P.x, _ = P.y, E = P.width, D = P.height, T = f.width / Math.floor(g.naturalWidth); T !== 1 && (w *= T, _ *= T, E *= T, D *= T); var A = E / D, C = Vr({ aspectRatio: A, width: c.maxWidth || 1 / 0, height: c.maxHeight || 1 / 0 }), k = Vr({ aspectRatio: A, width: c.minWidth || 0, height: c.minHeight || 0 }, "cover"), ue = Vr({ aspectRatio: A, width: c.width || (T !== 1 ? f.width : E), height: c.height || (T !== 1 ? f.height : D) }), le = ue.width, Ee = ue.height; le = Math.min(C.width, Math.max(k.width, le)), Ee = Math.min(C.height, Math.max(k.height, Ee)); var pe = document.createElement("canvas"), Xe = pe.getContext("2d"); pe.width = Ii(le), pe.height = Ii(Ee), Xe.fillStyle = c.fillColor || "transparent", Xe.fillRect(0, 0, le, Ee); var st = c.imageSmoothingEnabled, Ve = st === void 0 ? !0 : st, ur = c.imageSmoothingQuality; Xe.imageSmoothingEnabled = Ve, ur && (Xe.imageSmoothingQuality = ur); var Gt = f.width, M = f.height, fe = w, Ye = _, hi, dr, ps, fs, Wr, Ni; fe <= -E || fe > Gt ? (fe = 0, hi = 0, ps = 0, Wr = 0) : fe <= 0 ? (ps = -fe, fe = 0, hi = Math.min(Gt, E + fe), Wr = hi) : fe <= Gt && (ps = 0, hi = Math.min(E, Gt - fe), Wr = hi), hi <= 0 || Ye <= -D || Ye > M ? (Ye = 0, dr = 0, fs = 0, Ni = 0) : Ye <= 0 ? (fs = -Ye, Ye = 0, dr = Math.min(M, D + Ye), Ni = dr) : Ye <= M && (fs = 0, dr = Math.min(D, M - Ye), Ni = dr); var zt = [fe, Ye, hi, dr]; if (Wr > 0 && Ni > 0) { var ms = le / E; zt.push(ps * ms, fs * ms, Wr * ms, Ni * ms) } return Xe.drawImage.apply(Xe, [f].concat(l(zt.map(function (_l) { return Math.floor(Ii(_l)) })))), pe }, "getCroppedCanvas"), setAspectRatio: n(function (c) { var g = this.options; return !this.disabled && !bo(c) && (g.aspectRatio = Math.max(0, c) || NaN, this.ready && (this.initCropBox(), this.cropped && this.renderCropBox())), this }, "setAspectRatio"), setDragMode: n(function (c) { var g = this.options, f = this.dragBox, P = this.face; if (this.ready && !this.disabled) { var w = c === K, _ = g.movable && c === ye; c = w || _ ? c : ce, g.dragMode = c, an(f, B, c), qr(f, Me, w), qr(f, I, _), g.cropBoxMovable || (an(P, B, c), qr(P, Me, w), qr(P, I, _)) } return this }, "setDragMode") }, pb = S.Cropper, Bp = function () { function v(c) { var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; if (e(this, v), !c || !yl.test(c.tagName)) throw new Error("The first argument is required and must be an <img> or <canvas> element."); this.element = c, this.options = we({}, sn, $r(g) && g), this.cropped = !1, this.disabled = !1, this.pointers = {}, this.ready = !1, this.reloading = !1, this.replaced = !1, this.sized = !1, this.sizing = !1, this.init() } return n(v, "Cropper"), r(v, [{ key: "init", value: n(function () { var g = this.element, f = g.tagName.toLowerCase(), P; if (!g[x]) { if (g[x] = this, f === "img") { if (this.isImg = !0, P = g.getAttribute("src") || "", this.originalUrl = P, !P) return; P = g.src } else f === "canvas" && window.HTMLCanvasElement && (P = g.toDataURL()); this.load(P) } }, "init") }, { key: "load", value: n(function (g) { var f = this; if (g) { this.url = g, this.imageData = {}; var P = this.element, w = this.options; if (!w.rotatable && !w.scalable && (w.checkOrientation = !1), !w.checkOrientation || !window.ArrayBuffer) { this.clone(); return } if (rt.test(g)) { gl.test(g) ? this.read(rb(g)) : this.clone(); return } var _ = new XMLHttpRequest, E = this.clone.bind(this); this.reloading = !0, this.xhr = _, _.onabort = E, _.onerror = E, _.ontimeout = E, _.onprogress = function () { _.getResponseHeader("content-type") !== lr && _.abort() }, _.onload = function () { f.read(_.response) }, _.onloadend = function () { f.reloading = !1, f.xhr = null }, w.checkCrossOrigin && Ip(g) && P.crossOrigin && (g = Np(g)), _.open("GET", g), _.responseType = "arraybuffer", _.withCredentials = P.crossOrigin === "use-credentials", _.send() } }, "load") }, { key: "read", value: n(function (g) { var f = this.options, P = this.imageData, w = ob(g), _ = 0, E = 1, D = 1; if (w > 1) { this.url = sb(g, lr); var T = nb(w); _ = T.rotate, E = T.scaleX, D = T.scaleY } f.rotatable && (P.rotate = _), f.scalable && (P.scaleX = E, P.scaleY = D), this.clone() }, "read") }, { key: "clone", value: n(function () { var g = this.element, f = this.url, P = g.crossOrigin, w = f; this.options.checkCrossOrigin && Ip(f) && (P || (P = "anonymous"), w = Np(f)), this.crossOrigin = P, this.crossOriginUrl = w; var _ = document.createElement("img"); P && (_.crossOrigin = P), _.src = w || f, _.alt = g.alt || "The image to crop", this.image = _, _.onload = this.start.bind(this), _.onerror = this.stop.bind(this), Be(_, ki), g.parentNode.insertBefore(_, g.nextSibling) }, "clone") }, { key: "start", value: n(function () { var g = this, f = this.image; f.onload = null, f.onerror = null, this.sizing = !0; var P = S.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(S.navigator.userAgent), w = n(function (T, A) { we(g.imageData, { naturalWidth: T, naturalHeight: A, aspectRatio: T / A }), g.sizing = !1, g.sized = !0, g.build() }, "done"); if (f.naturalWidth && !P) { w(f.naturalWidth, f.naturalHeight); return } var _ = document.createElement("img"), E = document.body || document.documentElement; this.sizingImage = _, _.onload = function () { w(_.width, _.height), P || E.removeChild(_) }, _.src = f.src, P || (_.style.cssText = "left:0;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;opacity:0;position:absolute;top:0;z-index:-1;", E.appendChild(_)) }, "start") }, { key: "stop", value: n(function () { var g = this.image; g.onload = null, g.onerror = null, g.parentNode.removeChild(g), this.image = null }, "stop") }, { key: "build", value: n(function () { if (!(!this.sized || this.ready)) { var g = this.element, f = this.options, P = this.image, w = g.parentNode, _ = document.createElement("div"); _.innerHTML = vl; var E = _.querySelector(".".concat(x, "-container")), D = E.querySelector(".".concat(x, "-canvas")), T = E.querySelector(".".concat(x, "-drag-box")), A = E.querySelector(".".concat(x, "-crop-box")), C = A.querySelector(".".concat(x, "-face")); this.container = w, this.cropper = E, this.canvas = D, this.dragBox = T, this.cropBox = A, this.viewBox = E.querySelector(".".concat(x, "-view-box")), this.face = C, D.appendChild(P), Be(g, $e), w.insertBefore(E, g.nextSibling), this.isImg || yi(P, ki), this.initPreview(), this.bind(), f.initialAspectRatio = Math.max(0, f.initialAspectRatio) || NaN, f.aspectRatio = Math.max(0, f.aspectRatio) || NaN, f.viewMode = Math.max(0, Math.min(3, Math.round(f.viewMode))) || 0, Be(A, $e), f.guides || Be(A.getElementsByClassName("".concat(x, "-dashed")), $e), f.center || Be(A.getElementsByClassName("".concat(x, "-center")), $e), f.background && Be(E, "".concat(x, "-bg")), f.highlight || Be(C, q), f.cropBoxMovable && (Be(C, I), an(C, B, U)), f.cropBoxResizable || (Be(A.getElementsByClassName("".concat(x, "-line")), $e), Be(A.getElementsByClassName("".concat(x, "-point")), $e)), this.render(), this.ready = !0, this.setDragMode(f.dragMode), f.autoCrop && this.crop(), this.setData(f.data), wt(f.ready) && di(g, jr, f.ready, { once: !0 }), So(g, jr) } }, "build") }, { key: "unbuild", value: n(function () { this.ready && (this.ready = !1, this.unbind(), this.resetPreview(), this.cropper.parentNode.removeChild(this.cropper), yi(this.element, $e)) }, "unbuild") }, { key: "uncreate", value: n(function () { this.ready ? (this.unbuild(), this.ready = !1, this.cropped = !1) : this.sizing ? (this.sizingImage.onload = null, this.sizing = !1, this.sized = !1) : this.reloading ? (this.xhr.onabort = null, this.xhr.abort()) : this.image && this.stop() }, "uncreate") }], [{ key: "noConflict", value: n(function () { return window.Cropper = pb, v }, "noConflict") }, { key: "setDefaults", value: n(function (g) { we(sn, $r(g) && g) }, "setDefaults") }]), v }(); return we(Bp.prototype, ab, lb, ub, db, hb, cb), Bp
        })
    }); var Ny = me((yk, Tu) => { "use strict"; Tu.exports = Zh; Tu.exports.isMobile = Zh; Tu.exports.default = Zh; var $S = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i, qS = /CrOS/, VS = /android|ipad|playbook|silk/i; function Zh(i) { i || (i = {}); let e = i.ua; if (!e && typeof navigator < "u" && (e = navigator.userAgent), e && e.headers && typeof e.headers["user-agent"] == "string" && (e = e.headers["user-agent"]), typeof e != "string") return !1; let t = $S.test(e) && !qS.test(e) || !!i.tablet && VS.test(e); return !t && i.tablet && i.featureDetect && navigator && navigator.maxTouchPoints > 1 && e.indexOf("Macintosh") !== -1 && e.indexOf("Safari") !== -1 && (t = !0), t } n(Zh, "isMobile") }); var xv = me((v7, Fv) => { "use strict"; Fv.exports = n(function (e, t) { if (t = t.split(":")[0], e = +e, !e) return !1; switch (t) { case "http": case "ws": return e !== 80; case "https": case "wss": return e !== 443; case "ftp": return e !== 21; case "gopher": return e !== 70; case "file": return !1 }return e !== 0 }, "required") }); var Cv = me(Uc => { "use strict"; var ZP = Object.prototype.hasOwnProperty, e_; function Ov(i) { try { return decodeURIComponent(i.replace(/\+/g, " ")) } catch { return null } } n(Ov, "decode"); function Ev(i) { try { return encodeURIComponent(i) } catch { return null } } n(Ev, "encode"); function t_(i) { for (var e = /([^=?#&]+)=?([^&]*)/g, t = {}, r; r = e.exec(i);) { var s = Ov(r[1]), o = Ov(r[2]); s === null || o === null || s in t || (t[s] = o) } return t } n(t_, "querystring"); function i_(i, e) { e = e || ""; var t = [], r, s; typeof e != "string" && (e = "?"); for (s in i) if (ZP.call(i, s)) { if (r = i[s], !r && (r === null || r === e_ || isNaN(r)) && (r = ""), s = Ev(s), r = Ev(r), s === null || r === null) continue; t.push(s + "=" + r) } return t.length ? e + t.join("&") : "" } n(i_, "querystringify"); Uc.stringify = i_; Uc.parse = t_ }); var Nv = me((P7, Iv) => { "use strict"; var Tv = xv(), zu = Cv(), r_ = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, Rv = /[\n\r\t]/g, s_ = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//, Uv = /:\d+$/, o_ = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i, n_ = /^[a-zA-Z]:/; function Dc(i) { return (i || "").toString().replace(r_, "") } n(Dc, "trimLeft"); var kc = [["#", "hash"], ["?", "query"], n(function (e, t) { return tr(t.protocol) ? e.replace(/\\/g, "/") : e }, "sanitize"), ["/", "pathname"], ["@", "auth", 1], [NaN, "host", void 0, 1, 1], [/:(\d*)$/, "port", void 0, 1], [NaN, "hostname", void 0, 1, 1]], Av = { hash: 1, query: 1 }; function kv(i) { var e; typeof window < "u" ? e = window : typeof global < "u" ? e = global : typeof self < "u" ? e = self : e = {}; var t = e.location || {}; i = i || t; var r = {}, s = typeof i, o; if (i.protocol === "blob:") r = new ir(unescape(i.pathname), {}); else if (s === "string") { r = new ir(i, {}); for (o in Av) delete r[o] } else if (s === "object") { for (o in i) o in Av || (r[o] = i[o]); r.slashes === void 0 && (r.slashes = s_.test(i.href)) } return r } n(kv, "lolcation"); function tr(i) { return i === "file:" || i === "ftp:" || i === "http:" || i === "https:" || i === "ws:" || i === "wss:" } n(tr, "isSpecial"); function Dv(i, e) { i = Dc(i), i = i.replace(Rv, ""), e = e || {}; var t = o_.exec(i), r = t[1] ? t[1].toLowerCase() : "", s = !!t[2], o = !!t[3], a = 0, l; return s ? o ? (l = t[2] + t[3] + t[4], a = t[2].length + t[3].length) : (l = t[2] + t[4], a = t[2].length) : o ? (l = t[3] + t[4], a = t[3].length) : l = t[4], r === "file:" ? a >= 2 && (l = l.slice(2)) : tr(r) ? l = t[4] : r ? s && (l = l.slice(2)) : a >= 2 && tr(e.protocol) && (l = t[4]), { protocol: r, slashes: s || tr(r), slashesCount: a, rest: l } } n(Dv, "extractProtocol"); function a_(i, e) { if (i === "") return e; for (var t = (e || "/").split("/").slice(0, -1).concat(i.split("/")), r = t.length, s = t[r - 1], o = !1, a = 0; r--;)t[r] === "." ? t.splice(r, 1) : t[r] === ".." ? (t.splice(r, 1), a++) : a && (r === 0 && (o = !0), t.splice(r, 1), a--); return o && t.unshift(""), (s === "." || s === "..") && t.push(""), t.join("/") } n(a_, "resolve"); function ir(i, e, t) { if (i = Dc(i), i = i.replace(Rv, ""), !(this instanceof ir)) return new ir(i, e, t); var r, s, o, a, l, d, p = kc.slice(), h = typeof e, m = this, y = 0; for (h !== "object" && h !== "string" && (t = e, e = null), t && typeof t != "function" && (t = zu.parse), e = kv(e), s = Dv(i || "", e), r = !s.protocol && !s.slashes, m.slashes = s.slashes || r && e.slashes, m.protocol = s.protocol || e.protocol || "", i = s.rest, (s.protocol === "file:" && (s.slashesCount !== 2 || n_.test(i)) || !s.slashes && (s.protocol || s.slashesCount < 2 || !tr(m.protocol))) && (p[3] = [/(.*)/, "pathname"]); y < p.length; y++) { if (a = p[y], typeof a == "function") { i = a(i, m); continue } o = a[0], d = a[1], o !== o ? m[d] = i : typeof o == "string" ? (l = o === "@" ? i.lastIndexOf(o) : i.indexOf(o), ~l && (typeof a[2] == "number" ? (m[d] = i.slice(0, l), i = i.slice(l + a[2])) : (m[d] = i.slice(l), i = i.slice(0, l)))) : (l = o.exec(i)) && (m[d] = l[1], i = i.slice(0, l.index)), m[d] = m[d] || r && a[3] && e[d] || "", a[4] && (m[d] = m[d].toLowerCase()) } t && (m.query = t(m.query)), r && e.slashes && m.pathname.charAt(0) !== "/" && (m.pathname !== "" || e.pathname !== "") && (m.pathname = a_(m.pathname, e.pathname)), m.pathname.charAt(0) !== "/" && tr(m.protocol) && (m.pathname = "/" + m.pathname), Tv(m.port, m.protocol) || (m.host = m.hostname, m.port = ""), m.username = m.password = "", m.auth && (l = m.auth.indexOf(":"), ~l ? (m.username = m.auth.slice(0, l), m.username = encodeURIComponent(decodeURIComponent(m.username)), m.password = m.auth.slice(l + 1), m.password = encodeURIComponent(decodeURIComponent(m.password))) : m.username = encodeURIComponent(decodeURIComponent(m.auth)), m.auth = m.password ? m.username + ":" + m.password : m.username), m.origin = m.protocol !== "file:" && tr(m.protocol) && m.host ? m.protocol + "//" + m.host : "null", m.href = m.toString() } n(ir, "Url"); function l_(i, e, t) { var r = this; switch (i) { case "query": typeof e == "string" && e.length && (e = (t || zu.parse)(e)), r[i] = e; break; case "port": r[i] = e, Tv(e, r.protocol) ? e && (r.host = r.hostname + ":" + e) : (r.host = r.hostname, r[i] = ""); break; case "hostname": r[i] = e, r.port && (e += ":" + r.port), r.host = e; break; case "host": r[i] = e, Uv.test(e) ? (e = e.split(":"), r.port = e.pop(), r.hostname = e.join(":")) : (r.hostname = e, r.port = ""); break; case "protocol": r.protocol = e.toLowerCase(), r.slashes = !t; break; case "pathname": case "hash": if (e) { var s = i === "pathname" ? "/" : "#"; r[i] = e.charAt(0) !== s ? s + e : e } else r[i] = e; break; case "username": case "password": r[i] = encodeURIComponent(e); break; case "auth": var o = e.indexOf(":"); ~o ? (r.username = e.slice(0, o), r.username = encodeURIComponent(decodeURIComponent(r.username)), r.password = e.slice(o + 1), r.password = encodeURIComponent(decodeURIComponent(r.password))) : r.username = encodeURIComponent(decodeURIComponent(e)) }for (var a = 0; a < kc.length; a++) { var l = kc[a]; l[4] && (r[l[1]] = r[l[1]].toLowerCase()) } return r.auth = r.password ? r.username + ":" + r.password : r.username, r.origin = r.protocol !== "file:" && tr(r.protocol) && r.host ? r.protocol + "//" + r.host : "null", r.href = r.toString(), r } n(l_, "set"); function u_(i) { (!i || typeof i != "function") && (i = zu.stringify); var e, t = this, r = t.host, s = t.protocol; s && s.charAt(s.length - 1) !== ":" && (s += ":"); var o = s + (t.protocol && t.slashes || tr(t.protocol) ? "//" : ""); return t.username ? (o += t.username, t.password && (o += ":" + t.password), o += "@") : t.password ? (o += ":" + t.password, o += "@") : t.protocol !== "file:" && tr(t.protocol) && !r && t.pathname !== "/" && (o += "@"), (r[r.length - 1] === ":" || Uv.test(t.hostname) && !t.port) && (r += ":"), o += r + t.pathname, e = typeof t.query == "object" ? i(t.query) : t.query, e && (o += e.charAt(0) !== "?" ? "?" + e : e), t.hash && (o += t.hash), o } n(u_, "toString"); ir.prototype = { set: l_, toString: u_ }; ir.extractProtocol = Dv; ir.location = kv; ir.trimLeft = Dc; ir.qs = zu; Iv.exports = ir }); var Zc = me((I9, Jc) => { typeof Jc < "u" && (Jc.exports = ai); function ai(i) { if (i) return l5(i) } n(ai, "Emitter"); function l5(i) { for (var e in ai.prototype) i[e] = ai.prototype[e]; return i } n(l5, "mixin"); ai.prototype.on = ai.prototype.addEventListener = function (i, e) { return this._callbacks = this._callbacks || {}, (this._callbacks["$" + i] = this._callbacks["$" + i] || []).push(e), this }; ai.prototype.once = function (i, e) { function t() { this.off(i, t), e.apply(this, arguments) } return n(t, "on"), t.fn = e, this.on(i, t), this }; ai.prototype.off = ai.prototype.removeListener = ai.prototype.removeAllListeners = ai.prototype.removeEventListener = function (i, e) { if (this._callbacks = this._callbacks || {}, arguments.length == 0) return this._callbacks = {}, this; var t = this._callbacks["$" + i]; if (!t) return this; if (arguments.length == 1) return delete this._callbacks["$" + i], this; for (var r, s = 0; s < t.length; s++)if (r = t[s], r === e || r.fn === e) { t.splice(s, 1); break } return t.length === 0 && delete this._callbacks["$" + i], this }; ai.prototype.emit = function (i) { this._callbacks = this._callbacks || {}; for (var e = new Array(arguments.length - 1), t = this._callbacks["$" + i], r = 1; r < arguments.length; r++)e[r - 1] = arguments[r]; if (t) { t = t.slice(0); for (var r = 0, s = t.length; r < s; ++r)t[r].apply(this, e) } return this }; ai.prototype.listeners = function (i) { return this._callbacks = this._callbacks || {}, this._callbacks["$" + i] || [] }; ai.prototype.hasListeners = function (i) { return !!this.listeners(i).length } }); var A0 = me((Cp, Ap) => { (function (i, e) { typeof Cp == "object" && typeof Ap < "u" ? Ap.exports = e() : typeof define == "function" && define.amd ? define(e) : (i = typeof globalThis < "u" ? globalThis : i || self, i.Compressor = e()) })(Cp, function () { "use strict"; function i(q, R) { var I = Object.keys(q); if (Object.getOwnPropertySymbols) { var B = Object.getOwnPropertySymbols(q); R && (B = B.filter(function (Y) { return Object.getOwnPropertyDescriptor(q, Y).enumerable })), I.push.apply(I, B) } return I } n(i, "ownKeys"); function e(q) { for (var R = 1; R < arguments.length; R++) { var I = arguments[R] != null ? arguments[R] : {}; R % 2 ? i(Object(I), !0).forEach(function (B) { o(q, B, I[B]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(q, Object.getOwnPropertyDescriptors(I)) : i(Object(I)).forEach(function (B) { Object.defineProperty(q, B, Object.getOwnPropertyDescriptor(I, B)) }) } return q } n(e, "_objectSpread2"); function t(q, R) { if (!(q instanceof R)) throw new TypeError("Cannot call a class as a function") } n(t, "_classCallCheck"); function r(q, R) { for (var I = 0; I < R.length; I++) { var B = R[I]; B.enumerable = B.enumerable || !1, B.configurable = !0, "value" in B && (B.writable = !0), Object.defineProperty(q, B.key, B) } } n(r, "_defineProperties"); function s(q, R, I) { return R && r(q.prototype, R), I && r(q, I), q } n(s, "_createClass"); function o(q, R, I) { return R in q ? Object.defineProperty(q, R, { value: I, enumerable: !0, configurable: !0, writable: !0 }) : q[R] = I, q } n(o, "_defineProperty"); function a() { return a = Object.assign || function (q) { for (var R = 1; R < arguments.length; R++) { var I = arguments[R]; for (var B in I) Object.prototype.hasOwnProperty.call(I, B) && (q[B] = I[B]) } return q }, a.apply(this, arguments) } n(a, "_extends"); var l = { exports: {} }; (function (q) { typeof window > "u" || function (R) { var I = R.HTMLCanvasElement && R.HTMLCanvasElement.prototype, B = R.Blob && function () { try { return !!new Blob } catch { return !1 } }(), Y = B && R.Uint8Array && function () { try { return new Blob([new Uint8Array(100)]).size === 100 } catch { return !1 } }(), K = R.BlobBuilder || R.WebKitBlobBuilder || R.MozBlobBuilder || R.MSBlobBuilder, ye = /^data:((.*?)(;charset=.*?)?)(;base64)?,/, ce = (B || K) && R.atob && R.ArrayBuffer && R.Uint8Array && function (oe) { var re, _e, Fe, Ft, xt, te, Ot, qe, nr; if (re = oe.match(ye), !re) throw new Error("invalid data URI"); for (_e = re[2] ? re[1] : "text/plain" + (re[3] || ";charset=US-ASCII"), Fe = !!re[4], Ft = oe.slice(re[0].length), Fe ? xt = atob(Ft) : xt = decodeURIComponent(Ft), te = new ArrayBuffer(xt.length), Ot = new Uint8Array(te), qe = 0; qe < xt.length; qe += 1)Ot[qe] = xt.charCodeAt(qe); return B ? new Blob([Y ? Ot : te], { type: _e }) : (nr = new K, nr.append(te), nr.getBlob(_e)) }; R.HTMLCanvasElement && !I.toBlob && (I.mozGetAsFile ? I.toBlob = function (oe, re, _e) { var Fe = this; setTimeout(function () { _e && I.toDataURL && ce ? oe(ce(Fe.toDataURL(re, _e))) : oe(Fe.mozGetAsFile("blob", re)) }) } : I.toDataURL && ce && (I.msToBlob ? I.toBlob = function (oe, re, _e) { var Fe = this; setTimeout(function () { (re && re !== "image/png" || _e) && I.toDataURL && ce ? oe(ce(Fe.toDataURL(re, _e))) : oe(Fe.msToBlob(re)) }) } : I.toBlob = function (oe, re, _e) { var Fe = this; setTimeout(function () { oe(ce(Fe.toDataURL(re, _e))) }) })), q.exports ? q.exports = ce : R.dataURLtoBlob = ce }(window) })(l); var d = l.exports, p = n(function (R) { return typeof Blob > "u" ? !1 : R instanceof Blob || Object.prototype.toString.call(R) === "[object Blob]" }, "isBlob"), h = { strict: !0, checkOrientation: !0, maxWidth: 1 / 0, maxHeight: 1 / 0, minWidth: 0, minHeight: 0, width: void 0, height: void 0, resize: "none", quality: .8, mimeType: "auto", convertTypes: ["image/png"], convertSize: 5e6, beforeDraw: null, drew: null, success: null, error: null }, m = typeof window < "u" && typeof window.document < "u", y = m ? window : {}, b = n(function (R) { return R > 0 && R < 1 / 0 }, "isPositiveNumber"), S = Array.prototype.slice; function O(q) { return Array.from ? Array.from(q) : S.call(q) } n(O, "toArray"); var F = /^image\/.+$/; function x(q) { return F.test(q) } n(x, "isImageType"); function U(q) { var R = x(q) ? q.substr(6) : ""; return R === "jpeg" && (R = "jpg"), ".".concat(R) } n(U, "imageTypeToExtension"); var H = String.fromCharCode; function W(q, R, I) { var B = "", Y; for (I += R, Y = R; Y < I; Y += 1)B += H(q.getUint8(Y)); return B } n(W, "getStringFromCharCode"); var J = y.btoa; function L(q, R) { for (var I = [], B = 8192, Y = new Uint8Array(q); Y.length > 0;)I.push(H.apply(null, O(Y.subarray(0, B)))), Y = Y.subarray(B); return "data:".concat(R, ";base64,").concat(J(I.join(""))) } n(L, "arrayBufferToDataURL"); function G(q) { var R = new DataView(q), I; try { var B, Y, K; if (R.getUint8(0) === 255 && R.getUint8(1) === 216) for (var ye = R.byteLength, ce = 2; ce + 1 < ye;) { if (R.getUint8(ce) === 255 && R.getUint8(ce + 1) === 225) { Y = ce; break } ce += 1 } if (Y) { var oe = Y + 4, re = Y + 10; if (W(R, oe, 4) === "Exif") { var _e = R.getUint16(re); if (B = _e === 18761, (B || _e === 19789) && R.getUint16(re + 2, B) === 42) { var Fe = R.getUint32(re + 4, B); Fe >= 8 && (K = re + Fe) } } } if (K) { var Ft = R.getUint16(K, B), xt, te; for (te = 0; te < Ft; te += 1)if (xt = K + te * 12 + 2, R.getUint16(xt, B) === 274) { xt += 8, I = R.getUint16(xt, B), R.setUint16(xt, 1, B); break } } } catch { I = 1 } return I } n(G, "resetAndGetOrientation"); function ee(q) { var R = 0, I = 1, B = 1; switch (q) { case 2: I = -1; break; case 3: R = -180; break; case 4: B = -1; break; case 5: R = 90, B = -1; break; case 6: R = 90; break; case 7: R = 90, I = -1; break; case 8: R = -90; break }return { rotate: R, scaleX: I, scaleY: B } } n(ee, "parseOrientation"); var be = /\.\d*(?:0|9){12}\d*$/; function yt(q) { var R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e11; return be.test(q) ? Math.round(q * R) / R : q } n(yt, "normalizeDecimalNumber"); function nt(q) { var R = q.aspectRatio, I = q.height, B = q.width, Y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "none", K = b(B), ye = b(I); if (K && ye) { var ce = I * R; (Y === "contain" || Y === "none") && ce > B || Y === "cover" && ce < B ? I = B / R : B = I * R } else K ? I = B / R : ye && (B = I * R); return { width: B, height: I } } n(nt, "getAdjustedSizes"); var jt = y.ArrayBuffer, vt = y.FileReader, Me = y.URL || y.webkitURL, bt = /\.\w+$/, $e = y.Compressor, ki = function () { function q(R, I) { t(this, q), this.file = R, this.image = new Image, this.options = e(e({}, h), I), this.aborted = !1, this.result = null, this.init() } return n(q, "Compressor"), s(q, [{ key: "init", value: n(function () { var I = this, B = this.file, Y = this.options; if (!p(B)) { this.fail(new Error("The first argument must be a File or Blob object.")); return } var K = B.type; if (!x(K)) { this.fail(new Error("The first argument must be an image File or Blob object.")); return } if (!Me || !vt) { this.fail(new Error("The current browser does not support image compression.")); return } if (jt || (Y.checkOrientation = !1), Me && !Y.checkOrientation) this.load({ url: Me.createObjectURL(B) }); else { var ye = new vt, ce = Y.checkOrientation && K === "image/jpeg"; this.reader = ye, ye.onload = function (oe) { var re = oe.target, _e = re.result, Fe = {}; if (ce) { var Ft = G(_e); Ft > 1 || !Me ? (Fe.url = L(_e, K), Ft > 1 && a(Fe, ee(Ft))) : Fe.url = Me.createObjectURL(B) } else Fe.url = _e; I.load(Fe) }, ye.onabort = function () { I.fail(new Error("Aborted to read the image with FileReader.")) }, ye.onerror = function () { I.fail(new Error("Failed to read the image with FileReader.")) }, ye.onloadend = function () { I.reader = null }, ce ? ye.readAsArrayBuffer(B) : ye.readAsDataURL(B) } }, "init") }, { key: "load", value: n(function (I) { var B = this, Y = this.file, K = this.image; K.onload = function () { B.draw(e(e({}, I), {}, { naturalWidth: K.naturalWidth, naturalHeight: K.naturalHeight })) }, K.onabort = function () { B.fail(new Error("Aborted to load the image.")) }, K.onerror = function () { B.fail(new Error("Failed to load the image.")) }, y.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(y.navigator.userAgent) && (K.crossOrigin = "anonymous"), K.alt = Y.name, K.src = I.url }, "load") }, { key: "draw", value: n(function (I) { var B = this, Y = I.naturalWidth, K = I.naturalHeight, ye = I.rotate, ce = ye === void 0 ? 0 : ye, oe = I.scaleX, re = oe === void 0 ? 1 : oe, _e = I.scaleY, Fe = _e === void 0 ? 1 : _e, Ft = this.file, xt = this.image, te = this.options, Ot = document.createElement("canvas"), qe = Ot.getContext("2d"), nr = Math.abs(ce) % 180 === 90, vo = (te.resize === "contain" || te.resize === "cover") && b(te.width) && b(te.height), jr = Math.max(te.maxWidth, 0) || 1 / 0, zr = Math.max(te.maxHeight, 0) || 1 / 0, Hr = Math.max(te.minWidth, 0) || 0, ar = Math.max(te.minHeight, 0) || 0, lr = Y / K, it = te.width, rt = te.height; if (nr) { var gl = [zr, jr]; jr = gl[0], zr = gl[1]; var yl = [ar, Hr]; Hr = yl[0], ar = yl[1]; var sn = [rt, it]; it = sn[0], rt = sn[1] } vo && (lr = it / rt); var vl = nt({ aspectRatio: lr, width: jr, height: zr }, "contain"); jr = vl.width, zr = vl.height; var bl = nt({ aspectRatio: lr, width: Hr, height: ar }, "cover"); if (Hr = bl.width, ar = bl.height, vo) { var ie = nt({ aspectRatio: lr, width: it, height: rt }, te.resize); it = ie.width, rt = ie.height } else { var on = nt({ aspectRatio: lr, width: it, height: rt }), bo = on.width; it = bo === void 0 ? Y : bo; var Di = on.height; rt = Di === void 0 ? K : Di } it = Math.floor(yt(Math.min(Math.max(it, Hr), jr))), rt = Math.floor(yt(Math.min(Math.max(rt, ar), zr))); var td = -it / 2, $r = -rt / 2, wt = it, id = rt, wo = []; if (vo) { var Ae = 0, we = 0, nn = Y, Ii = K, wl = nt({ aspectRatio: lr, width: Y, height: K }, { contain: "cover", cover: "contain" }[te.resize]); nn = wl.width, Ii = wl.height, Ae = (Y - nn) / 2, we = (K - Ii) / 2, wo.push(Ae, we, nn, Ii) } if (wo.push(td, $r, wt, id), nr) { var gi = [rt, it]; it = gi[0], rt = gi[1] } Ot.width = it, Ot.height = rt, x(te.mimeType) || (te.mimeType = Ft.type); var Sl = "transparent"; if (Ft.size > te.convertSize && te.convertTypes.indexOf(te.mimeType) >= 0 && (te.mimeType = "image/jpeg"), te.mimeType === "image/jpeg" && (Sl = "#fff"), qe.fillStyle = Sl, qe.fillRect(0, 0, it, rt), te.beforeDraw && te.beforeDraw.call(this, qe, Ot), !this.aborted && (qe.save(), qe.translate(it / 2, rt / 2), qe.rotate(ce * Math.PI / 180), qe.scale(re, Fe), qe.drawImage.apply(qe, [xt].concat(wo)), qe.restore(), te.drew && te.drew.call(this, qe, Ot), !this.aborted)) { var Be = n(function (qr) { B.aborted || B.done({ naturalWidth: Y, naturalHeight: K, result: qr }) }, "done"); Ot.toBlob ? Ot.toBlob(Be, te.mimeType, te.quality) : Be(d(Ot.toDataURL(te.mimeType, te.quality))) } }, "draw") }, { key: "done", value: n(function (I) { var B = I.naturalWidth, Y = I.naturalHeight, K = I.result, ye = this.file, ce = this.image, oe = this.options; if (Me && !oe.checkOrientation && Me.revokeObjectURL(ce.src), K) if (oe.strict && K.size > ye.size && oe.mimeType === ye.type && !(oe.width > B || oe.height > Y || oe.minWidth > B || oe.minHeight > Y || oe.maxWidth < B || oe.maxHeight < Y)) K = ye; else { var re = new Date; K.lastModified = re.getTime(), K.lastModifiedDate = re, K.name = ye.name, K.name && K.type !== ye.type && (K.name = K.name.replace(bt, U(K.type))) } else K = ye; this.result = K, oe.success && oe.success.call(this, K) }, "done") }, { key: "fail", value: n(function (I) { var B = this.options; if (B.error) B.error.call(this, I); else throw I }, "fail") }, { key: "abort", value: n(function () { this.aborted || (this.aborted = !0, this.reader ? this.reader.abort() : this.image.complete ? this.fail(new Error("The compression process has been aborted.")) : (this.image.onload = null, this.image.onabort())) }, "abort") }], [{ key: "noConflict", value: n(function () { return window.Compressor = $e, q }, "noConflict") }, { key: "setDefaults", value: n(function (I) { a(h, I) }, "setDefaults") }]), q }(); return ki }) }); var Rp = {}; xl(Rp, { Audio: () => ns, AwsS3: () => ro, AwsS3Multipart: () => Ci, Box: () => Gi, Compressor: () => rn, Core: () => hF, Dashboard: () => qi, DefaultStore: () => Al, DragDrop: () => Vi, DropTarget: () => ks, Dropbox: () => Ki, Facebook: () => Xi, FileInput: () => rs, Form: () => po, GoldenRetriever: () => go, GoogleDrive: () => Yi, ImageEditor: () => ss, Informer: () => zi, Instagram: () => Qi, OneDrive: () => Ji, ProgressBar: () => os, ReduxDevTools: () => yo, ReduxStore: () => Km, RemoteSources: () => Ms, ScreenCapture: () => as, StatusBar: () => ji, ThumbnailGenerator: () => Er, Transloadit: () => mi, Tus: () => rr, Unsplash: () => Zi, Uppy: () => kl, Url: () => Oi, Webcam: () => ls, XHRUpload: () => co, Zoom: () => er, debugLogger: () => pn, locales: () => pF, server: () => Ad, views: () => cF }); function Et(i, e) { return Object.prototype.hasOwnProperty.call(i, e) } n(Et, "has"); function $p(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n($p, "_classPrivateFieldLooseBase"); var Pb = 0; function _b(i) { return "__private_" + Pb++ + "_" + i } n(_b, "_classPrivateFieldLooseKey"); function Fb(i, e, t) { let r = []; return i.forEach(s => typeof s != "string" ? r.push(s) : e[Symbol.split](s).forEach((o, a, l) => { o !== "" && r.push(o), a < l.length - 1 && r.push(t) })), r } n(Fb, "insertReplacement"); function qp(i, e) { let t = /\$/g, r = "$$$$", s = [i]; if (e == null) return s; for (let o of Object.keys(e)) if (o !== "_") { let a = e[o]; typeof a == "string" && (a = t[Symbol.replace](a, r)), s = Fb(s, new RegExp(`%\\{${o}\\}`, "g"), a) } return s } n(qp, "interpolate"); var un = _b("apply"), Gr = class { constructor(e) { Object.defineProperty(this, un, { value: xb }), this.locale = { strings: {}, pluralize(t) { return t === 1 ? 0 : 1 } }, Array.isArray(e) ? e.forEach($p(this, un)[un], this) : $p(this, un)[un](e) } translate(e, t) { return this.translateArray(e, t).join("") } translateArray(e, t) { if (!Et(this.locale.strings, e)) throw new Error(`missing string: ${e}`); let r = this.locale.strings[e]; if (typeof r == "object") { if (t && typeof t.smart_count < "u") { let o = this.locale.pluralize(t.smart_count); return qp(r[o], t) } throw new Error("Attempted to use a string with plural forms, but no value was given for %{smart_count}") } return qp(r, t) } }; n(Gr, "Translator"); function xb(i) { if (!(i != null && i.strings)) return; let e = this.locale; this.locale = { ...e, strings: { ...e.strings, ...i.strings } }, this.locale.pluralize = i.pluralize || e.pluralize } n(xb, "_apply2"); var jf = de(ld(), 1); var Ob = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"; var St = n((i = 21) => { let e = "", t = i; for (; t--;)e += Ob[Math.random() * 64 | 0]; return e }, "nanoid"); var zf = de(El(), 1); function Cl(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Cl, "_classPrivateFieldLooseBase"); var b1 = 0; function xf(i) { return "__private_" + b1++ + "_" + i } n(xf, "_classPrivateFieldLooseKey"); var w1 = { version: "3.0.4" }, gs = xf("callbacks"), pd = xf("publish"), hn = class { constructor() { Object.defineProperty(this, pd, { value: S1 }), Object.defineProperty(this, gs, { writable: !0, value: new Set }), this.state = {} } getState() { return this.state } setState(e) { let t = { ...this.state }, r = { ...this.state, ...e }; this.state = r, Cl(this, pd)[pd](t, r, e) } subscribe(e) { return Cl(this, gs)[gs].add(e), () => { Cl(this, gs)[gs].delete(e) } } }; n(hn, "DefaultStore"); function S1() { for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)e[t] = arguments[t]; Cl(this, gs)[gs].forEach(r => { r(...e) }) } n(S1, "_publish2"); hn.VERSION = w1.version; var Al = hn; function Mi(i) { let e = i.lastIndexOf("."); return e === -1 || e === i.length - 1 ? { name: i, extension: void 0 } : { name: i.slice(0, e), extension: i.slice(e + 1) } } n(Mi, "getFileNameAndExtension"); var cn = { md: "text/markdown", markdown: "text/markdown", mp4: "video/mp4", mp3: "audio/mp3", svg: "image/svg+xml", jpg: "image/jpeg", png: "image/png", webp: "image/webp", gif: "image/gif", heic: "image/heic", heif: "image/heif", yaml: "text/yaml", yml: "text/yaml", csv: "text/csv", tsv: "text/tab-separated-values", tab: "text/tab-separated-values", avi: "video/x-msvideo", mks: "video/x-matroska", mkv: "video/x-matroska", mov: "video/quicktime", dicom: "application/dicom", doc: "application/msword", docm: "application/vnd.ms-word.document.macroenabled.12", docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document", dot: "application/msword", dotm: "application/vnd.ms-word.template.macroenabled.12", dotx: "application/vnd.openxmlformats-officedocument.wordprocessingml.template", xla: "application/vnd.ms-excel", xlam: "application/vnd.ms-excel.addin.macroenabled.12", xlc: "application/vnd.ms-excel", xlf: "application/x-xliff+xml", xlm: "application/vnd.ms-excel", xls: "application/vnd.ms-excel", xlsb: "application/vnd.ms-excel.sheet.binary.macroenabled.12", xlsm: "application/vnd.ms-excel.sheet.macroenabled.12", xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", xlt: "application/vnd.ms-excel", xltm: "application/vnd.ms-excel.template.macroenabled.12", xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template", xlw: "application/vnd.ms-excel", txt: "text/plain", text: "text/plain", conf: "text/plain", log: "text/plain", pdf: "application/pdf", zip: "application/zip", "7z": "application/x-7z-compressed", rar: "application/x-rar-compressed", tar: "application/x-tar", gz: "application/gzip", dmg: "application/x-apple-diskimage" }; function ys(i) { var e; if (i.type) return i.type; let t = i.name ? (e = Mi(i.name).extension) == null ? void 0 : e.toLowerCase() : null; return t && t in cn ? cn[t] : "application/octet-stream" } n(ys, "getFileType"); function P1(i) { return i.charCodeAt(0).toString(32) } n(P1, "encodeCharacter"); function Of(i) { let e = ""; return i.replace(/[^A-Z0-9]/ig, t => (e += `-${P1(t)}`, "/")) + e } n(Of, "encodeFilename"); function Ef(i) { let e = "uppy"; return typeof i.name == "string" && (e += `-${Of(i.name.toLowerCase())}`), i.type !== void 0 && (e += `-${i.type}`), i.meta && typeof i.meta.relativePath == "string" && (e += `-${Of(i.meta.relativePath.toLowerCase())}`), i.data.size !== void 0 && (e += `-${i.data.size}`), i.data.lastModified !== void 0 && (e += `-${i.data.lastModified}`), e } n(Ef, "generateFileID"); function _1(i) { return !i.isRemote || !i.remote ? !1 : new Set(["box", "dropbox", "drive", "facebook", "unsplash"]).has(i.remote.provider) } n(_1, "hasFileStableId"); function Tl(i) { if (_1(i)) return i.id; let e = ys(i); return Ef({ ...i, type: e }) } n(Tl, "getSafeFileId"); function fd(i) { if (i == null && typeof navigator < "u" && (i = navigator.userAgent), !i) return !0; let e = /Edge\/(\d+\.\d+)/.exec(i); if (!e) return !0; let t = e[1], [r, s] = t.split("."); return r = parseInt(r, 10), s = parseInt(s, 10), r < 15 || r === 15 && s < 15063 || r > 18 || r === 18 && s >= 18218 } n(fd, "supportsUploadProgress"); function md(i, e) { return e.name ? e.name : i.split("/")[0] === "image" ? `${i.split("/")[0]}.${i.split("/")[1]}` : "noname" } n(md, "getFileName"); function gd(i) { return i < 10 ? `0${i}` : i.toString() } n(gd, "pad"); function Po() { let i = new Date, e = gd(i.getHours()), t = gd(i.getMinutes()), r = gd(i.getSeconds()); return `${e}:${t}:${r}` } n(Po, "getTimeStamp"); var Cf = { debug: () => { }, warn: () => { }, error: function () { for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)e[t] = arguments[t]; return console.error(`[Uppy] [${Po()}]`, ...e) } }, pn = { debug: function () { for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)e[t] = arguments[t]; return console.debug(`[Uppy] [${Po()}]`, ...e) }, warn: function () { for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)e[t] = arguments[t]; return console.warn(`[Uppy] [${Po()}]`, ...e) }, error: function () { for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)e[t] = arguments[t]; return console.error(`[Uppy] [${Po()}]`, ...e) } }; var Ul = de(Rl(), 1), If = de(Df(), 1); var Nf = { maxFileSize: null, minFileSize: null, maxTotalFileSize: null, maxNumberOfFiles: null, minNumberOfFiles: null, allowedFileTypes: null, requiredMetaFields: [] }, Ct = class extends Error { constructor(e, t) { let { isUserFacing: r = !0, file: s } = t === void 0 ? {} : t; super(e), this.isRestriction = !0, this.isUserFacing = r, s != null && (this.file = s) } }; n(Ct, "RestrictionError"); var fn = class { constructor(e, t) { this.i18n = t, this.getOpts = () => { let r = e(); if (r.restrictions.allowedFileTypes != null && !Array.isArray(r.restrictions.allowedFileTypes)) throw new TypeError("`restrictions.allowedFileTypes` must be an array"); return r } } validateAggregateRestrictions(e, t) { let { maxTotalFileSize: r, maxNumberOfFiles: s } = this.getOpts().restrictions; if (s && e.filter(a => !a.isGhost).length + t.length > s) throw new Ct(`${this.i18n("youCanOnlyUploadX", { smart_count: s })}`); if (r) { let o = e.reduce((a, l) => a + l.size, 0); for (let a of t) if (a.size != null && (o += a.size, o > r)) throw new Ct(this.i18n("exceedsSize", { size: (0, Ul.default)(r), file: a.name })) } } validateSingleFile(e) { let { maxFileSize: t, minFileSize: r, allowedFileTypes: s } = this.getOpts().restrictions; if (s && !s.some(a => a.includes("/") ? e.type ? (0, If.default)(e.type.replace(/;.*?$/, ""), a) : !1 : a[0] === "." && e.extension ? e.extension.toLowerCase() === a.slice(1).toLowerCase() : !1)) { let a = s.join(", "); throw new Ct(this.i18n("youCanOnlyUploadFileTypes", { types: a }), { file: e }) } if (t && e.size != null && e.size > t) throw new Ct(this.i18n("exceedsSize", { size: (0, Ul.default)(t), file: e.name }), { file: e }); if (r && e.size != null && e.size < r) throw new Ct(this.i18n("inferiorSize", { size: (0, Ul.default)(r) }), { file: e }) } validate(e, t) { t.forEach(r => { this.validateSingleFile(r) }), this.validateAggregateRestrictions(e, t) } validateMinNumberOfFiles(e) { let { minNumberOfFiles: t } = this.getOpts().restrictions; if (Object.keys(e).length < t) throw new Ct(this.i18n("youHaveToAtLeastSelectX", { smart_count: t })) } getMissingRequiredMetaFields(e) { let t = new Ct(this.i18n("missingRequiredMetaFieldOnFile", { fileName: e.name })), { requiredMetaFields: r } = this.getOpts().restrictions, s = []; for (let o of r) (!Object.hasOwn(e.meta, o) || e.meta[o] === "") && s.push(o); return { missingFields: s, error: t } } }; n(fn, "Restricter"); var Mf = { strings: { addBulkFilesFailed: { 0: "Failed to add %{smart_count} file due to an internal error", 1: "Failed to add %{smart_count} files due to internal errors" }, youCanOnlyUploadX: { 0: "You can only upload %{smart_count} file", 1: "You can only upload %{smart_count} files" }, youHaveToAtLeastSelectX: { 0: "You have to select at least %{smart_count} file", 1: "You have to select at least %{smart_count} files" }, exceedsSize: "%{file} exceeds maximum allowed size of %{size}", missingRequiredMetaField: "Missing required meta fields", missingRequiredMetaFieldOnFile: "Missing required meta fields in %{fileName}", inferiorSize: "This file is smaller than the allowed size of %{size}", youCanOnlyUploadFileTypes: "You can only upload: %{types}", noMoreFilesAllowed: "Cannot add more files", noDuplicates: "Cannot add the duplicate file '%{fileName}', it already exists", companionError: "Connection with Companion failed", authAborted: "Authentication aborted", companionUnauthorizeHint: "To unauthorize to your %{provider} account, please go to %{url}", failedToUpload: "Failed to upload %{file}", noInternetConnection: "No Internet connection", connectedToInternet: "Connected to the Internet", noFilesFound: "You have no files or folders here", noSearchResults: "Unfortunately, there are no results for this search", selectX: { 0: "Select %{smart_count}", 1: "Select %{smart_count}" }, allFilesFromFolderNamed: "All files from folder %{name}", openFolderNamed: "Open folder %{name}", cancel: "Cancel", logOut: "Log out", filter: "Filter", resetFilter: "Reset filter", loading: "Loading...", loadedXFiles: "Loaded %{numFiles} files", authenticateWithTitle: "Please authenticate with %{pluginName} to select files", authenticateWith: "Connect to %{pluginName}", signInWithGoogle: "Sign in with Google", searchImages: "Search for images", enterTextToSearch: "Enter text to search for images", search: "Search", resetSearch: "Reset search", emptyFolderAdded: "No files were added from empty folder", addedNumFiles: "Added %{numFiles} file(s)", folderAlreadyAdded: 'The folder "%{folder}" was already added', folderAdded: { 0: "Added %{smart_count} file from %{folder}", 1: "Added %{smart_count} files from %{folder}" }, additionalRestrictionsFailed: "%{count} additional restrictions were not fulfilled" } }; var Bf, Lf; function $(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n($, "_classPrivateFieldLooseBase"); var O1 = 0; function We(i) { return "__private_" + O1++ + "_" + i } n(We, "_classPrivateFieldLooseKey"); var E1 = { version: "3.5.1" }, at = We("plugins"), Kt = We("restricter"), mn = We("storeUnsubscribe"), hr = We("emitter"), vs = We("preProcessors"), bs = We("uploaders"), fr = We("postProcessors"), Xt = We("informAndEmit"), wn = We("checkRequiredMetaFieldsOnFile"), yd = We("checkRequiredMetaFields"), gn = We("assertNewUploadAllowed"), wd = We("transformFile"), yn = We("startIfAutoProceed"), vn = We("checkAndUpdateFileState"), vd = We("addListeners"), bi = We("updateOnlineStatus"), cr = We("createUpload"), bd = We("getUpload"), ws = We("removeUpload"), pr = We("runUpload"); Bf = Symbol.for("uppy test: getPlugins"); Lf = Symbol.for("uppy test: createUpload"); var bn = class {
        constructor(e) { Object.defineProperty(this, pr, { value: L1 }), Object.defineProperty(this, ws, { value: B1 }), Object.defineProperty(this, bd, { value: M1 }), Object.defineProperty(this, cr, { value: N1 }), Object.defineProperty(this, vd, { value: I1 }), Object.defineProperty(this, vn, { value: D1 }), Object.defineProperty(this, yn, { value: k1 }), Object.defineProperty(this, wd, { value: U1 }), Object.defineProperty(this, gn, { value: R1 }), Object.defineProperty(this, yd, { value: T1 }), Object.defineProperty(this, wn, { value: A1 }), Object.defineProperty(this, Xt, { value: C1 }), Object.defineProperty(this, at, { writable: !0, value: Object.create(null) }), Object.defineProperty(this, Kt, { writable: !0, value: void 0 }), Object.defineProperty(this, mn, { writable: !0, value: void 0 }), Object.defineProperty(this, hr, { writable: !0, value: (0, jf.default)() }), Object.defineProperty(this, vs, { writable: !0, value: new Set }), Object.defineProperty(this, bs, { writable: !0, value: new Set }), Object.defineProperty(this, fr, { writable: !0, value: new Set }), this.calculateProgress = (0, zf.default)((r, s) => { let o = this.getFile(r?.id); if (r == null || !o) { this.log(`Not setting progress for a file that has been removed: ${r?.id}`); return } if (o.progress.percentage === 100) { this.log(`Not setting progress for a file that has been already uploaded: ${r.id}`); return } let a = Number.isFinite(s.bytesTotal) && s.bytesTotal > 0; this.setFileState(r.id, { progress: { ...o.progress, bytesUploaded: s.bytesUploaded, bytesTotal: s.bytesTotal, percentage: a ? Math.round(s.bytesUploaded / s.bytesTotal * 100) : 0 } }), this.calculateTotalProgress() }, 500, { leading: !0, trailing: !0 }), Object.defineProperty(this, bi, { writable: !0, value: this.updateOnlineStatus.bind(this) }), this.defaultLocale = Mf; let t = { id: "uppy", autoProceed: !1, allowMultipleUploadBatches: !0, debug: !1, restrictions: Nf, meta: {}, onBeforeFileAdded: (r, s) => !Object.hasOwn(s, r.id), onBeforeUpload: r => r, store: new Al, logger: Cf, infoTimeout: 5e3 }; this.opts = { ...t, ...e, restrictions: { ...t.restrictions, ...e && e.restrictions } }, e && e.logger && e.debug ? this.log("You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.", "warning") : e && e.debug && (this.opts.logger = pn), this.log(`Using Core v${this.constructor.VERSION}`), this.i18nInit(), this.store = this.opts.store, this.setState({ plugins: {}, files: {}, currentUploads: {}, allowNewUpload: !0, capabilities: { uploadProgress: fd(), individualCancellation: !0, resumableUploads: !1 }, totalProgress: 0, meta: { ...this.opts.meta }, info: [], recoveredState: null }), $(this, Kt)[Kt] = new fn(() => this.opts, this.i18n), $(this, mn)[mn] = this.store.subscribe((r, s, o) => { this.emit("state-update", r, s, o), this.updateAll(s) }), this.opts.debug && typeof window < "u" && (window[this.opts.id] = this), $(this, vd)[vd]() } emit(e) { for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)r[s - 1] = arguments[s]; $(this, hr)[hr].emit(e, ...r) } on(e, t) { return $(this, hr)[hr].on(e, t), this } once(e, t) { return $(this, hr)[hr].once(e, t), this } off(e, t) { return $(this, hr)[hr].off(e, t), this } updateAll(e) { this.iteratePlugins(t => { t.update(e) }) } setState(e) { this.store.setState(e) } getState() { return this.store.getState() } patchFilesState(e) { let t = this.getState().files; this.setState({ files: { ...t, ...Object.fromEntries(Object.entries(e).map(r => { let [s, o] = r; return [s, { ...t[s], ...o }] })) } }) } setFileState(e, t) { if (!this.getState().files[e]) throw new Error(`Can\u2019t set state for ${e} (the file could have been removed)`); this.patchFilesState({ [e]: t }) } i18nInit() { let e = new Gr([this.defaultLocale, this.opts.locale]); this.i18n = e.translate.bind(e), this.i18nArray = e.translateArray.bind(e), this.locale = e.locale } setOptions(e) { this.opts = { ...this.opts, ...e, restrictions: { ...this.opts.restrictions, ...e && e.restrictions } }, e.meta && this.setMeta(e.meta), this.i18nInit(), e.locale && this.iteratePlugins(t => { t.setOptions(e) }), this.setState() } resetProgress() { let e = { percentage: 0, bytesUploaded: 0, uploadComplete: !1, uploadStarted: null }, t = { ...this.getState().files }, r = {}; Object.keys(t).forEach(s => { r[s] = { ...t[s], progress: { ...t[s].progress, ...e } } }), this.setState({ files: r, totalProgress: 0, allowNewUpload: !0, error: null, recoveredState: null }), this.emit("reset-progress") } addPreProcessor(e) { $(this, vs)[vs].add(e) } removePreProcessor(e) { return $(this, vs)[vs].delete(e) } addPostProcessor(e) { $(this, fr)[fr].add(e) } removePostProcessor(e) { return $(this, fr)[fr].delete(e) } addUploader(e) { $(this, bs)[bs].add(e) } removeUploader(e) { return $(this, bs)[bs].delete(e) } setMeta(e) { let t = { ...this.getState().meta, ...e }, r = { ...this.getState().files }; Object.keys(r).forEach(s => { r[s] = { ...r[s], meta: { ...r[s].meta, ...e } } }), this.log("Adding metadata:"), this.log(e), this.setState({ meta: t, files: r }) } setFileMeta(e, t) { let r = { ...this.getState().files }; if (!r[e]) { this.log("Was trying to set metadata for a file that has been removed: ", e); return } let s = { ...r[e].meta, ...t }; r[e] = { ...r[e], meta: s }, this.setState({ files: r }) } getFile(e) { return this.getState().files[e] } getFiles() { let { files: e } = this.getState(); return Object.values(e) } getFilesByIds(e) { return e.map(t => this.getFile(t)) } getObjectOfFilesPerState() { let { files: e, totalProgress: t, error: r } = this.getState(), s = Object.values(e), o = s.filter(S => { let { progress: O } = S; return !O.uploadComplete && O.uploadStarted }), a = s.filter(S => !S.progress.uploadStarted), l = s.filter(S => S.progress.uploadStarted || S.progress.preprocess || S.progress.postprocess), d = s.filter(S => S.progress.uploadStarted), p = s.filter(S => S.isPaused), h = s.filter(S => S.progress.uploadComplete), m = s.filter(S => S.error), y = o.filter(S => !S.isPaused), b = s.filter(S => S.progress.preprocess || S.progress.postprocess); return { newFiles: a, startedFiles: l, uploadStartedFiles: d, pausedFiles: p, completeFiles: h, erroredFiles: m, inProgressFiles: o, inProgressNotPausedFiles: y, processingFiles: b, isUploadStarted: d.length > 0, isAllComplete: t === 100 && h.length === s.length && b.length === 0, isAllErrored: !!r && m.length === s.length, isAllPaused: o.length !== 0 && p.length === o.length, isUploadInProgress: o.length > 0, isSomeGhost: s.some(S => S.isGhost) } } validateRestrictions(e, t) { t === void 0 && (t = this.getFiles()); try { $(this, Kt)[Kt].validate(t, [e]) } catch (r) { return r } return null } checkIfFileAlreadyExists(e) { let { files: t } = this.getState(); return !!(t[e] && !t[e].isGhost) } addFile(e) { $(this, gn)[gn](e); let { nextFilesState: t, validFilesToAdd: r, errors: s } = $(this, vn)[vn]([e]), o = s.filter(l => l.isRestriction); if ($(this, Xt)[Xt](o), s.length > 0) throw s[0]; this.setState({ files: t }); let [a] = r; return this.emit("file-added", a), this.emit("files-added", r), this.log(`Added file: ${a.name}, ${a.id}, mime type: ${a.type}`), $(this, yn)[yn](), a.id } addFiles(e) {
            $(this, gn)[gn](); let { nextFilesState: t, validFilesToAdd: r, errors: s } = $(this, vn)[vn](e), o = s.filter(l => l.isRestriction); $(this, Xt)[Xt](o); let a = s.filter(l => !l.isRestriction); if (a.length > 0) {
                let l = `Multiple errors occurred while adding files:
`; if (a.forEach(d => {
                    l += `
 * ${d.message}`
                }), this.info({ message: this.i18n("addBulkFilesFailed", { smart_count: a.length }), details: l }, "error", this.opts.infoTimeout), typeof AggregateError == "function") throw new AggregateError(a, l); { let d = new Error(l); throw d.errors = a, d }
            } this.setState({ files: t }), r.forEach(l => { this.emit("file-added", l) }), this.emit("files-added", r), r.length > 5 ? this.log(`Added batch of ${r.length} files`) : Object.values(r).forEach(l => {
                this.log(`Added file: ${l.name}
 id: ${l.id}
 type: ${l.type}`)
            }), r.length > 0 && $(this, yn)[yn]()
        } removeFiles(e, t) { let { files: r, currentUploads: s } = this.getState(), o = { ...r }, a = { ...s }, l = Object.create(null); e.forEach(m => { r[m] && (l[m] = r[m], delete o[m]) }); function d(m) { return l[m] === void 0 } n(d, "fileIsNotRemoved"), Object.keys(a).forEach(m => { let y = s[m].fileIDs.filter(d); if (y.length === 0) { delete a[m]; return } let { capabilities: b } = this.getState(); if (y.length !== s[m].fileIDs.length && !b.individualCancellation) throw new Error("individualCancellation is disabled"); a[m] = { ...s[m], fileIDs: y } }); let p = { currentUploads: a, files: o }; Object.keys(o).length === 0 && (p.allowNewUpload = !0, p.error = null, p.recoveredState = null), this.setState(p), this.calculateTotalProgress(); let h = Object.keys(l); h.forEach(m => { this.emit("file-removed", l[m], t) }), h.length > 5 ? this.log(`Removed ${h.length} files`) : this.log(`Removed files: ${h.join(", ")}`) } removeFile(e, t) { t === void 0 && (t = null), this.removeFiles([e], t) } pauseResume(e) { if (!this.getState().capabilities.resumableUploads || this.getFile(e).uploadComplete) return; let r = !(this.getFile(e).isPaused || !1); return this.setFileState(e, { isPaused: r }), this.emit("upload-pause", e, r), r } pauseAll() { let e = { ...this.getState().files }; Object.keys(e).filter(r => !e[r].progress.uploadComplete && e[r].progress.uploadStarted).forEach(r => { let s = { ...e[r], isPaused: !0 }; e[r] = s }), this.setState({ files: e }), this.emit("pause-all") } resumeAll() { let e = { ...this.getState().files }; Object.keys(e).filter(r => !e[r].progress.uploadComplete && e[r].progress.uploadStarted).forEach(r => { let s = { ...e[r], isPaused: !1, error: null }; e[r] = s }), this.setState({ files: e }), this.emit("resume-all") } retryAll() { let e = { ...this.getState().files }, t = Object.keys(e).filter(s => e[s].error); if (t.forEach(s => { let o = { ...e[s], isPaused: !1, error: null }; e[s] = o }), this.setState({ files: e, error: null }), this.emit("retry-all", t), t.length === 0) return Promise.resolve({ successful: [], failed: [] }); let r = $(this, cr)[cr](t, { forceAllowNewUpload: !0 }); return $(this, pr)[pr](r) } cancelAll(e) { let { reason: t = "user" } = e === void 0 ? {} : e; if (this.emit("cancel-all", { reason: t }), t === "user") { let { files: r } = this.getState(), s = Object.keys(r); s.length && this.removeFiles(s, "cancel-all"), this.setState({ totalProgress: 0, error: null, recoveredState: null }) } } retryUpload(e) { this.setFileState(e, { error: null, isPaused: !1 }), this.emit("upload-retry", e); let t = $(this, cr)[cr]([e], { forceAllowNewUpload: !0 }); return $(this, pr)[pr](t) } logout() { this.iteratePlugins(e => { e.provider && e.provider.logout && e.provider.logout() }) } calculateTotalProgress() { let t = this.getFiles().filter(p => p.progress.uploadStarted || p.progress.preprocess || p.progress.postprocess); if (t.length === 0) { this.emit("progress", 0), this.setState({ totalProgress: 0 }); return } let r = t.filter(p => p.progress.bytesTotal != null), s = t.filter(p => p.progress.bytesTotal == null); if (r.length === 0) { let p = t.length * 100, h = s.reduce((y, b) => y + b.progress.percentage, 0), m = Math.round(h / p * 100); this.setState({ totalProgress: m }); return } let o = r.reduce((p, h) => p + h.progress.bytesTotal, 0), a = o / r.length; o += a * s.length; let l = 0; r.forEach(p => { l += p.progress.bytesUploaded }), s.forEach(p => { l += a * (p.progress.percentage || 0) / 100 }); let d = o === 0 ? 0 : Math.round(l / o * 100); d > 100 && (d = 100), this.setState({ totalProgress: d }), this.emit("progress", d) } updateOnlineStatus() { (typeof window.navigator.onLine < "u" ? window.navigator.onLine : !0) ? (this.emit("is-online"), this.wasOffline && (this.emit("back-online"), this.info(this.i18n("connectedToInternet"), "success", 3e3), this.wasOffline = !1)) : (this.emit("is-offline"), this.info(this.i18n("noInternetConnection"), "error", 0), this.wasOffline = !0) } getID() { return this.opts.id } use(e, t) {
            if (typeof e != "function") { let a = `Expected a plugin class, but got ${e === null ? "null" : typeof e}. Please verify that the plugin was imported and spelled correctly.`; throw new TypeError(a) } let r = new e(this, t), s = r.id; if (!s) throw new Error("Your plugin must have an id"); if (!r.type) throw new Error("Your plugin must have a type"); let o = this.getPlugin(s); if (o) {
                let a = `Already found a plugin named '${o.id}'. Tried to use: '${s}'.
Uppy plugins must have unique \`id\` options. See https://uppy.io/docs/plugins/#id.`; throw new Error(a)
            } return e.VERSION && this.log(`Using ${s} v${e.VERSION}`), r.type in $(this, at)[at] ? $(this, at)[at][r.type].push(r) : $(this, at)[at][r.type] = [r], r.install(), this
        } getPlugin(e) { for (let t of Object.values($(this, at)[at])) { let r = t.find(s => s.id === e); if (r != null) return r } } [Bf](e) { return $(this, at)[at][e] } iteratePlugins(e) { Object.values($(this, at)[at]).flat(1).forEach(e) } removePlugin(e) { this.log(`Removing plugin ${e.id}`), this.emit("plugin-remove", e), e.uninstall && e.uninstall(); let t = $(this, at)[at][e.type], r = t.findIndex(a => a.id === e.id); r !== -1 && t.splice(r, 1); let o = { plugins: { ...this.getState().plugins, [e.id]: void 0 } }; this.setState(o) } close(e) { let { reason: t } = e === void 0 ? {} : e; this.log(`Closing Uppy instance ${this.opts.id}: removing all files and uninstalling plugins`), this.cancelAll({ reason: t }), $(this, mn)[mn](), this.iteratePlugins(r => { this.removePlugin(r) }), typeof window < "u" && window.removeEventListener && (window.removeEventListener("online", $(this, bi)[bi]), window.removeEventListener("offline", $(this, bi)[bi])) } hideInfo() { let { info: e } = this.getState(); this.setState({ info: e.slice(1) }), this.emit("info-hidden") } info(e, t, r) { t === void 0 && (t = "info"), r === void 0 && (r = 3e3); let s = typeof e == "object"; this.setState({ info: [...this.getState().info, { type: t, message: s ? e.message : e, details: s ? e.details : null }] }), setTimeout(() => this.hideInfo(), r), this.emit("info-visible") } log(e, t) { let { logger: r } = this.opts; switch (t) { case "error": r.error(e); break; case "warning": r.warn(e); break; default: r.debug(e); break } } restore(e) { return this.log(`Core: attempting to restore upload "${e}"`), this.getState().currentUploads[e] ? $(this, pr)[pr](e) : ($(this, ws)[ws](e), Promise.reject(new Error("Nonexistent upload"))) } [Lf]() { return $(this, cr)[cr](...arguments) } addResultData(e, t) { if (!$(this, bd)[bd](e)) { this.log(`Not setting result for an upload that has been removed: ${e}`); return } let { currentUploads: r } = this.getState(), s = { ...r[e], result: { ...r[e].result, ...t } }; this.setState({ currentUploads: { ...r, [e]: s } }) } upload() { var e; (e = $(this, at)[at].uploader) != null && e.length || this.log("No uploader type plugins are used", "warning"); let { files: t } = this.getState(), r = this.opts.onBeforeUpload(t); return r === !1 ? Promise.reject(new Error("Not starting the upload because onBeforeUpload returned false")) : (r && typeof r == "object" && (t = r, this.setState({ files: t })), Promise.resolve().then(() => $(this, Kt)[Kt].validateMinNumberOfFiles(t)).catch(s => { throw $(this, Xt)[Xt]([s]), s }).then(() => { if (!$(this, yd)[yd](t)) throw new Ct(this.i18n("missingRequiredMetaField")) }).catch(s => { throw s }).then(() => { let { currentUploads: s } = this.getState(), o = Object.values(s).flatMap(d => d.fileIDs), a = []; Object.keys(t).forEach(d => { let p = this.getFile(d); !p.progress.uploadStarted && o.indexOf(d) === -1 && a.push(p.id) }); let l = $(this, cr)[cr](a); return $(this, pr)[pr](l) }).catch(s => { throw this.emit("error", s), this.log(s, "error"), s })) }
    }; n(bn, "Uppy"); function C1(i) { for (let o of i) { let { file: a, isRestriction: l } = o; l ? this.emit("restriction-failed", a, o) : this.emit("error", o), this.log(o, "warning") } let e = i.filter(o => o.isUserFacing), t = 4, r = e.slice(0, t), s = e.slice(t); r.forEach(o => { let { message: a, details: l = "" } = o; this.info({ message: a, details: l }, "error", this.opts.infoTimeout) }), s.length > 0 && this.info({ message: this.i18n("additionalRestrictionsFailed", { count: s.length }) }) } n(C1, "_informAndEmit2"); function A1(i) { let { missingFields: e, error: t } = $(this, Kt)[Kt].getMissingRequiredMetaFields(i); return e.length > 0 ? (this.setFileState(i.id, { missingRequiredMetaFields: e }), this.log(t.message), this.emit("restriction-failed", i, t), !1) : !0 } n(A1, "_checkRequiredMetaFieldsOnFile2"); function T1(i) { let e = !0; for (let t of Object.values(i)) $(this, wn)[wn](t) || (e = !1); return e } n(T1, "_checkRequiredMetaFields2"); function R1(i) { let { allowNewUpload: e } = this.getState(); if (e === !1) { let t = new Ct(this.i18n("noMoreFilesAllowed"), { file: i }); throw $(this, Xt)[Xt]([t]), t } } n(R1, "_assertNewUploadAllowed2"); function U1(i) { let e = i instanceof File ? { name: i.name, type: i.type, size: i.size, data: i } : i, t = ys(e), r = md(t, e), s = Mi(r).extension, o = !!e.isRemote, a = Tl(e), l = e.meta || {}; l.name = r, l.type = t; let d = Number.isFinite(e.data.size) ? e.data.size : null; return { source: e.source || "", id: a, name: r, extension: s || "", meta: { ...this.getState().meta, ...l }, type: t, data: e.data, progress: { percentage: 0, bytesUploaded: 0, bytesTotal: d, uploadComplete: !1, uploadStarted: null }, size: d, isRemote: o, remote: e.remote || "", preview: e.preview } } n(U1, "_transformFile2"); function k1() { this.opts.autoProceed && !this.scheduledAutoProceed && (this.scheduledAutoProceed = setTimeout(() => { this.scheduledAutoProceed = null, this.upload().catch(i => { i.isRestriction || this.log(i.stack || i.message || i) }) }, 4)) } n(k1, "_startIfAutoProceed2"); function D1(i) { let { files: e } = this.getState(), t = { ...e }, r = [], s = []; for (let a of i) try { var o; let l = $(this, wd)[wd](a); if ((o = e[l.id]) != null && o.isGhost) { let { isGhost: p, ...h } = e[l.id]; l = { ...h, data: a.data }, this.log(`Replaced the blob in the restored ghost file: ${l.name}, ${l.id}`) } let d = this.opts.onBeforeFileAdded(l, t); if (!d && this.checkIfFileAlreadyExists(l.id)) throw new Ct(this.i18n("noDuplicates", { fileName: l.name }), { file: a }); if (d === !1) throw new Ct("Cannot add the file because onBeforeFileAdded returned false.", { isUserFacing: !1, file: a }); typeof d == "object" && d !== null && (l = d), $(this, Kt)[Kt].validateSingleFile(l), t[l.id] = l, r.push(l) } catch (l) { s.push(l) } try { $(this, Kt)[Kt].validateAggregateRestrictions(Object.values(e), r) } catch (a) { return s.push(a), { nextFilesState: e, validFilesToAdd: [], errors: s } } return { nextFilesState: t, validFilesToAdd: r, errors: s } } n(D1, "_checkAndUpdateFileState2"); function I1() { let i = n((r, s, o) => { let a = r.message || "Unknown error"; r.details && (a += ` ${r.details}`), this.setState({ error: a }), s != null && s.id in this.getState().files && this.setFileState(s.id, { error: a, response: o }) }, "errorHandler"); this.on("error", i), this.on("upload-error", (r, s, o) => { if (i(s, r, o), typeof s == "object" && s.message) { this.log(s.message, "error"); let a = new Error(this.i18n("failedToUpload", { file: r?.name })); a.isUserFacing = !0, a.details = s.message, s.details && (a.details += ` ${s.details}`), $(this, Xt)[Xt]([a]) } else $(this, Xt)[Xt]([s]) }); let e; this.on("upload-stalled", (r, s) => { let { message: o } = r, a = s.map(l => l.meta.name).join(", "); e || (this.info({ message: o, details: a }, "warning", this.opts.infoTimeout), e = setTimeout(() => { e = null }, this.opts.infoTimeout)), this.log(`${o} ${a}`.trim(), "warning") }), this.on("upload", () => { this.setState({ error: null }) }); let t = n(r => { let s = r.filter(a => { let l = a != null && this.getFile(a.id); return l || this.log(`Not setting progress for a file that has been removed: ${a?.id}`), l }), o = Object.fromEntries(s.map(a => [a.id, { progress: { uploadStarted: Date.now(), uploadComplete: !1, percentage: 0, bytesUploaded: 0, bytesTotal: a.size } }])); this.patchFilesState(o) }, "onUploadStarted"); this.on("upload-start", r => { r.forEach(s => { this.emit("upload-started", s) }), t(r) }), this.on("upload-progress", this.calculateProgress), this.on("upload-success", (r, s) => { if (r == null || !this.getFile(r.id)) { this.log(`Not setting progress for a file that has been removed: ${r?.id}`); return } let o = this.getFile(r.id).progress; this.setFileState(r.id, { progress: { ...o, postprocess: $(this, fr)[fr].size > 0 ? { mode: "indeterminate" } : null, uploadComplete: !0, percentage: 100, bytesUploaded: o.bytesTotal }, response: s, uploadURL: s.uploadURL, isPaused: !1 }), r.size == null && this.setFileState(r.id, { size: s.bytesUploaded || o.bytesTotal }), this.calculateTotalProgress() }), this.on("preprocess-progress", (r, s) => { if (r == null || !this.getFile(r.id)) { this.log(`Not setting progress for a file that has been removed: ${r?.id}`); return } this.setFileState(r.id, { progress: { ...this.getFile(r.id).progress, preprocess: s } }) }), this.on("preprocess-complete", r => { if (r == null || !this.getFile(r.id)) { this.log(`Not setting progress for a file that has been removed: ${r?.id}`); return } let s = { ...this.getState().files }; s[r.id] = { ...s[r.id], progress: { ...s[r.id].progress } }, delete s[r.id].progress.preprocess, this.setState({ files: s }) }), this.on("postprocess-progress", (r, s) => { if (r == null || !this.getFile(r.id)) { this.log(`Not setting progress for a file that has been removed: ${r?.id}`); return } this.setFileState(r.id, { progress: { ...this.getState().files[r.id].progress, postprocess: s } }) }), this.on("postprocess-complete", r => { if (r == null || !this.getFile(r.id)) { this.log(`Not setting progress for a file that has been removed: ${r?.id}`); return } let s = { ...this.getState().files }; s[r.id] = { ...s[r.id], progress: { ...s[r.id].progress } }, delete s[r.id].progress.postprocess, this.setState({ files: s }) }), this.on("restored", () => { this.calculateTotalProgress() }), this.on("dashboard:file-edit-complete", r => { r && $(this, wn)[wn](r) }), typeof window < "u" && window.addEventListener && (window.addEventListener("online", $(this, bi)[bi]), window.addEventListener("offline", $(this, bi)[bi]), setTimeout($(this, bi)[bi], 3e3)) } n(I1, "_addListeners2"); function N1(i, e) { e === void 0 && (e = {}); let { forceAllowNewUpload: t = !1 } = e, { allowNewUpload: r, currentUploads: s } = this.getState(); if (!r && !t) throw new Error("Cannot create a new upload: already uploading."); let o = St(); return this.emit("upload", { id: o, fileIDs: i }), this.setState({ allowNewUpload: this.opts.allowMultipleUploadBatches !== !1 && this.opts.allowMultipleUploads !== !1, currentUploads: { ...s, [o]: { fileIDs: i, step: 0, result: {} } } }), o } n(N1, "_createUpload2"); function M1(i) { let { currentUploads: e } = this.getState(); return e[i] } n(M1, "_getUpload2"); function B1(i) { let e = { ...this.getState().currentUploads }; delete e[i], this.setState({ currentUploads: e }) } n(B1, "_removeUpload2"); async function L1(i) { let e = n(() => { let { currentUploads: o } = this.getState(); return o[i] }, "getCurrentUpload"), t = e(), r = [...$(this, vs)[vs], ...$(this, bs)[bs], ...$(this, fr)[fr]]; try { for (let o = t.step || 0; o < r.length && t; o++) { let a = r[o]; this.setState({ currentUploads: { ...this.getState().currentUploads, [i]: { ...t, step: o } } }); let { fileIDs: l } = t; await a(l, i), t = e() } } catch (o) { throw $(this, ws)[ws](i), o } if (t) { t.fileIDs.forEach(d => { let p = this.getFile(d); p && p.progress.postprocess && this.emit("postprocess-complete", p) }); let o = t.fileIDs.map(d => this.getFile(d)), a = o.filter(d => !d.error), l = o.filter(d => d.error); await this.addResultData(i, { successful: a, failed: l, uploadID: i }), t = e() } let s; return t && (s = t.result, this.emit("complete", s), $(this, ws)[ws](i)), s == null && this.log(`Not setting result for an upload that has been removed: ${i}`), s } n(L1, "_runUpload2"); bn.VERSION = E1.version; var kl = bn; var _n, Z, Gf, j1, Sn, Hf, z1, Dl = {}, Kf = [], H1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i; function mr(i, e) { for (var t in e) i[t] = e[t]; return i } n(mr, "s"); function Xf(i) { var e = i.parentNode; e && e.removeChild(i) } n(Xf, "a"); function u(i, e, t) { var r, s, o, a = {}; for (o in e) o == "key" ? r = e[o] : o == "ref" ? s = e[o] : a[o] = e[o]; if (arguments.length > 2 && (a.children = arguments.length > 3 ? _n.call(arguments, 2) : t), typeof i == "function" && i.defaultProps != null) for (o in i.defaultProps) a[o] === void 0 && (a[o] = i.defaultProps[o]); return Pn(i, a, r, s, null) } n(u, "h"); function Pn(i, e, t, r, s) { var o = { type: i, props: e, key: t, ref: r, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: s ?? ++Gf }; return s == null && Z.vnode != null && Z.vnode(o), o } n(Pn, "v"); function Yf() { return { current: null } } n(Yf, "y"); function Ht(i) { return i.children } n(Ht, "p"); function ve(i, e) { this.props = i, this.context = e } n(ve, "d"); function _o(i, e) { if (e == null) return i.__ ? _o(i.__, i.__.__k.indexOf(i) + 1) : null; for (var t; e < i.__k.length; e++)if ((t = i.__k[e]) != null && t.__e != null) return t.__e; return typeof i.type == "function" ? _o(i) : null } n(_o, "_"); function Qf(i) { var e, t; if ((i = i.__) != null && i.__c != null) { for (i.__e = i.__c.base = null, e = 0; e < i.__k.length; e++)if ((t = i.__k[e]) != null && t.__e != null) { i.__e = i.__c.base = t.__e; break } return Qf(i) } } n(Qf, "k"); function $f(i) { (!i.__d && (i.__d = !0) && Sn.push(i) && !Il.__r++ || Hf !== Z.debounceRendering) && ((Hf = Z.debounceRendering) || setTimeout)(Il) } n($f, "b"); function Il() { for (var i; Il.__r = Sn.length;)i = Sn.sort(function (e, t) { return e.__v.__b - t.__v.__b }), Sn = [], i.some(function (e) { var t, r, s, o, a, l; e.__d && (a = (o = (t = e).__v).__e, (l = t.__P) && (r = [], (s = mr({}, o)).__v = o.__v + 1, Sd(l, o, s, t.__n, l.ownerSVGElement !== void 0, o.__h != null ? [a] : null, r, a ?? _o(o), o.__h), tm(r, o), o.__e != a && Qf(o))) }) } n(Il, "g"); function Jf(i, e, t, r, s, o, a, l, d, p) { var h, m, y, b, S, O, F, x = r && r.__k || Kf, U = x.length; for (t.__k = [], h = 0; h < e.length; h++)if ((b = t.__k[h] = (b = e[h]) == null || typeof b == "boolean" ? null : typeof b == "string" || typeof b == "number" || typeof b == "bigint" ? Pn(null, b, null, null, b) : Array.isArray(b) ? Pn(Ht, { children: b }, null, null, null) : b.__b > 0 ? Pn(b.type, b.props, b.key, null, b.__v) : b) != null) { if (b.__ = t, b.__b = t.__b + 1, (y = x[h]) === null || y && b.key == y.key && b.type === y.type) x[h] = void 0; else for (m = 0; m < U; m++) { if ((y = x[m]) && b.key == y.key && b.type === y.type) { x[m] = void 0; break } y = null } Sd(i, b, y = y || Dl, s, o, a, l, d, p), S = b.__e, (m = b.ref) && y.ref != m && (F || (F = []), y.ref && F.push(y.ref, null, b), F.push(m, b.__c || S, b)), S != null ? (O == null && (O = S), typeof b.type == "function" && b.__k === y.__k ? b.__d = d = Zf(b, d, i) : d = em(i, b, y, x, S, d), typeof t.type == "function" && (t.__d = d)) : d && y.__e == d && d.parentNode != i && (d = _o(y)) } for (t.__e = O, h = U; h--;)x[h] != null && (typeof t.type == "function" && x[h].__e != null && x[h].__e == t.__d && (t.__d = _o(r, h + 1)), rm(x[h], x[h])); if (F) for (h = 0; h < F.length; h++)im(F[h], F[++h], F[++h]) } n(Jf, "w"); function Zf(i, e, t) { for (var r, s = i.__k, o = 0; s && o < s.length; o++)(r = s[o]) && (r.__ = i, e = typeof r.type == "function" ? Zf(r, e, t) : em(t, r, r, s, r.__e, e)); return e } n(Zf, "m"); function ci(i, e) { return e = e || [], i == null || typeof i == "boolean" || (Array.isArray(i) ? i.some(function (t) { ci(t, e) }) : e.push(i)), e } n(ci, "x"); function em(i, e, t, r, s, o) { var a, l, d; if (e.__d !== void 0) a = e.__d, e.__d = void 0; else if (t == null || s != o || s.parentNode == null) e: if (o == null || o.parentNode !== i) i.appendChild(s), a = null; else { for (l = o, d = 0; (l = l.nextSibling) && d < r.length; d += 2)if (l == s) break e; i.insertBefore(s, o), a = o } return a !== void 0 ? a : s.nextSibling } n(em, "A"); function $1(i, e, t, r, s) { var o; for (o in t) o === "children" || o === "key" || o in e || Nl(i, o, null, t[o], r); for (o in e) s && typeof e[o] != "function" || o === "children" || o === "key" || o === "value" || o === "checked" || t[o] === e[o] || Nl(i, o, e[o], t[o], r) } n($1, "C"); function qf(i, e, t) { e[0] === "-" ? i.setProperty(e, t) : i[e] = t == null ? "" : typeof t != "number" || H1.test(e) ? t : t + "px" } n(qf, "$"); function Nl(i, e, t, r, s) { var o; e: if (e === "style") if (typeof t == "string") i.style.cssText = t; else { if (typeof r == "string" && (i.style.cssText = r = ""), r) for (e in r) t && e in t || qf(i.style, e, ""); if (t) for (e in t) r && t[e] === r[e] || qf(i.style, e, t[e]) } else if (e[0] === "o" && e[1] === "n") o = e !== (e = e.replace(/Capture$/, "")), e = e.toLowerCase() in i ? e.toLowerCase().slice(2) : e.slice(2), i.l || (i.l = {}), i.l[e + o] = t, t ? r || i.addEventListener(e, o ? Wf : Vf, o) : i.removeEventListener(e, o ? Wf : Vf, o); else if (e !== "dangerouslySetInnerHTML") { if (s) e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s"); else if (e !== "href" && e !== "list" && e !== "form" && e !== "tabIndex" && e !== "download" && e in i) try { i[e] = t ?? ""; break e } catch { } typeof t == "function" || (t != null && (t !== !1 || e[0] === "a" && e[1] === "r") ? i.setAttribute(e, t) : i.removeAttribute(e)) } } n(Nl, "H"); function Vf(i) { this.l[i.type + !1](Z.event ? Z.event(i) : i) } n(Vf, "I"); function Wf(i) { this.l[i.type + !0](Z.event ? Z.event(i) : i) } n(Wf, "T"); function Sd(i, e, t, r, s, o, a, l, d) { var p, h, m, y, b, S, O, F, x, U, H, W, J, L = e.type; if (e.constructor !== void 0) return null; t.__h != null && (d = t.__h, l = e.__e = t.__e, e.__h = null, o = [l]), (p = Z.__b) && p(e); try { e: if (typeof L == "function") { if (F = e.props, x = (p = L.contextType) && r[p.__c], U = p ? x ? x.props.value : p.__ : r, t.__c ? O = (h = e.__c = t.__c).__ = h.__E : ("prototype" in L && L.prototype.render ? e.__c = h = new L(F, U) : (e.__c = h = new ve(F, U), h.constructor = L, h.render = V1), x && x.sub(h), h.props = F, h.state || (h.state = {}), h.context = U, h.__n = r, m = h.__d = !0, h.__h = []), h.__s == null && (h.__s = h.state), L.getDerivedStateFromProps != null && (h.__s == h.state && (h.__s = mr({}, h.__s)), mr(h.__s, L.getDerivedStateFromProps(F, h.__s))), y = h.props, b = h.state, m) L.getDerivedStateFromProps == null && h.componentWillMount != null && h.componentWillMount(), h.componentDidMount != null && h.__h.push(h.componentDidMount); else { if (L.getDerivedStateFromProps == null && F !== y && h.componentWillReceiveProps != null && h.componentWillReceiveProps(F, U), !h.__e && h.shouldComponentUpdate != null && h.shouldComponentUpdate(F, h.__s, U) === !1 || e.__v === t.__v) { h.props = F, h.state = h.__s, e.__v !== t.__v && (h.__d = !1), h.__v = e, e.__e = t.__e, e.__k = t.__k, e.__k.forEach(function (G) { G && (G.__ = e) }), h.__h.length && a.push(h); break e } h.componentWillUpdate != null && h.componentWillUpdate(F, h.__s, U), h.componentDidUpdate != null && h.__h.push(function () { h.componentDidUpdate(y, b, S) }) } if (h.context = U, h.props = F, h.__v = e, h.__P = i, H = Z.__r, W = 0, "prototype" in L && L.prototype.render) h.state = h.__s, h.__d = !1, H && H(e), p = h.render(h.props, h.state, h.context); else do h.__d = !1, H && H(e), p = h.render(h.props, h.state, h.context), h.state = h.__s; while (h.__d && ++W < 25); h.state = h.__s, h.getChildContext != null && (r = mr(mr({}, r), h.getChildContext())), m || h.getSnapshotBeforeUpdate == null || (S = h.getSnapshotBeforeUpdate(y, b)), J = p != null && p.type === Ht && p.key == null ? p.props.children : p, Jf(i, Array.isArray(J) ? J : [J], e, t, r, s, o, a, l, d), h.base = e.__e, e.__h = null, h.__h.length && a.push(h), O && (h.__E = h.__ = null), h.__e = !1 } else o == null && e.__v === t.__v ? (e.__k = t.__k, e.__e = t.__e) : e.__e = q1(t.__e, e, t, r, s, o, a, d); (p = Z.diffed) && p(e) } catch (G) { e.__v = null, (d || o != null) && (e.__e = l, e.__h = !!d, o[o.indexOf(l)] = null), Z.__e(G, e, t) } } n(Sd, "j"); function tm(i, e) { Z.__c && Z.__c(e, i), i.some(function (t) { try { i = t.__h, t.__h = [], i.some(function (r) { r.call(t) }) } catch (r) { Z.__e(r, t.__v) } }) } n(tm, "z"); function q1(i, e, t, r, s, o, a, l) { var d, p, h, m = t.props, y = e.props, b = e.type, S = 0; if (b === "svg" && (s = !0), o != null) { for (; S < o.length; S++)if ((d = o[S]) && "setAttribute" in d == !!b && (b ? d.localName === b : d.nodeType === 3)) { i = d, o[S] = null; break } } if (i == null) { if (b === null) return document.createTextNode(y); i = s ? document.createElementNS("http://www.w3.org/2000/svg", b) : document.createElement(b, y.is && y), o = null, l = !1 } if (b === null) m === y || l && i.data === y || (i.data = y); else { if (o = o && _n.call(i.childNodes), p = (m = t.props || Dl).dangerouslySetInnerHTML, h = y.dangerouslySetInnerHTML, !l) { if (o != null) for (m = {}, S = 0; S < i.attributes.length; S++)m[i.attributes[S].name] = i.attributes[S].value; (h || p) && (h && (p && h.__html == p.__html || h.__html === i.innerHTML) || (i.innerHTML = h && h.__html || "")) } if ($1(i, y, m, s, l), h) e.__k = []; else if (S = e.props.children, Jf(i, Array.isArray(S) ? S : [S], e, t, r, s && b !== "foreignObject", o, a, o ? o[0] : t.__k && _o(t, 0), l), o != null) for (S = o.length; S--;)o[S] != null && Xf(o[S]); l || ("value" in y && (S = y.value) !== void 0 && (S !== i.value || b === "progress" && !S || b === "option" && S !== m.value) && Nl(i, "value", S, m.value, !1), "checked" in y && (S = y.checked) !== void 0 && S !== i.checked && Nl(i, "checked", S, m.checked, !1)) } return i } n(q1, "L"); function im(i, e, t) { try { typeof i == "function" ? i(e) : i.current = e } catch (r) { Z.__e(r, t) } } n(im, "M"); function rm(i, e, t) { var r, s; if (Z.unmount && Z.unmount(i), (r = i.ref) && (r.current && r.current !== i.__e || im(r, null, e)), (r = i.__c) != null) { if (r.componentWillUnmount) try { r.componentWillUnmount() } catch (o) { Z.__e(o, e) } r.base = r.__P = null } if (r = i.__k) for (s = 0; s < r.length; s++)r[s] && rm(r[s], e, typeof i.type != "function"); t || i.__e == null || Xf(i.__e), i.__e = i.__d = void 0 } n(rm, "N"); function V1(i, e, t) { return this.constructor(i, t) } n(V1, "O"); function Pd(i, e, t) { var r, s, o; Z.__ && Z.__(i, e), s = (r = typeof t == "function") ? null : t && t.__k || e.__k, o = [], Sd(e, i = (!r && t || e).__k = u(Ht, null, [i]), s || Dl, Dl, e.ownerSVGElement !== void 0, !r && t ? [t] : s ? null : e.firstChild ? _n.call(e.childNodes) : null, o, !r && t ? t : s ? s.__e : e.firstChild, r), tm(o, i) } n(Pd, "P"); function Ml(i, e, t) { var r, s, o, a = mr({}, i.props); for (o in e) o == "key" ? r = e[o] : o == "ref" ? s = e[o] : a[o] = e[o]; return arguments.length > 2 && (a.children = arguments.length > 3 ? _n.call(arguments, 2) : t), Pn(i.type, a, r || i.key, s || i.ref, null) } n(Ml, "q"); _n = Kf.slice, Z = { __e: function (i, e, t, r) { for (var s, o, a; e = e.__;)if ((s = e.__c) && !s.__) try { if ((o = s.constructor) && o.getDerivedStateFromError != null && (s.setState(o.getDerivedStateFromError(i)), a = s.__d), s.componentDidCatch != null && (s.componentDidCatch(i, r || {}), a = s.__d), a) return s.__E = s } catch (l) { i = l } throw i } }, Gf = 0, j1 = n(function (i) { return i != null && i.constructor === void 0 }, "i"), ve.prototype.setState = function (i, e) { var t; t = this.__s != null && this.__s !== this.state ? this.__s : this.__s = mr({}, this.state), typeof i == "function" && (i = i(mr({}, t), this.props)), i && mr(t, i), i != null && this.__v && (e && this.__h.push(e), $f(this)) }, ve.prototype.forceUpdate = function (i) { this.__v && (this.__e = !0, i && this.__h.push(i), $f(this)) }, ve.prototype.render = Ht, Sn = [], Il.__r = 0, z1 = 0; function Fn(i) { return i?.nodeType === Node.ELEMENT_NODE } n(Fn, "isDOMElement"); function xn(i, e) { return e === void 0 && (e = document), typeof i == "string" ? e.querySelector(i) : Fn(i) ? i : null } n(xn, "findDOMElement"); function W1(i) { for (var e; i && !i.dir;)i = i.parentNode; return (e = i) == null ? void 0 : e.dir } n(W1, "getTextDirection"); var Bl = W1; var Se = class { constructor(e, t) { t === void 0 && (t = {}), this.uppy = e, this.opts = t } getPluginState() { let { plugins: e } = this.uppy.getState(); return e[this.id] || {} } setPluginState(e) { let { plugins: t } = this.uppy.getState(); this.uppy.setState({ plugins: { ...t, [this.id]: { ...t[this.id], ...e } } }) } setOptions(e) { this.opts = { ...this.opts, ...e }, this.setPluginState(), this.i18nInit() } i18nInit() { let e = new Gr([this.defaultLocale, this.uppy.locale, this.opts.locale]); this.i18n = e.translate.bind(e), this.i18nArray = e.translateArray.bind(e), this.setPluginState() } addTarget() { throw new Error("Extend the addTarget method to add your plugin to another plugin's target") } install() { } uninstall() { } render() { throw new Error("Extend the render method to add your plugin to a DOM element") } update() { } afterUpdate() { } }; n(Se, "BasePlugin"); function sm(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(sm, "_classPrivateFieldLooseBase"); var G1 = 0; function K1(i) { return "__private_" + G1++ + "_" + i } n(K1, "_classPrivateFieldLooseKey"); function X1(i) { let e = null, t = null; return function () { for (var r = arguments.length, s = new Array(r), o = 0; o < r; o++)s[o] = arguments[o]; return t = s, e || (e = Promise.resolve().then(() => (e = null, i(...t)))), e } } n(X1, "debounce"); var On = K1("updateUI"), Fo = class extends Se { constructor() { super(...arguments), Object.defineProperty(this, On, { writable: !0, value: void 0 }) } getTargetPlugin(e) { let t; if (typeof e == "object" && e instanceof Fo) t = e; else if (typeof e == "function") { let r = e; this.uppy.iteratePlugins(s => { s instanceof r && (t = s) }) } return t } mount(e, t) { let r = t.id, s = xn(e); if (s) { this.isTargetDOMEl = !0; let l = document.createElement("div"); return l.classList.add("uppy-Root"), sm(this, On)[On] = X1(d => { this.uppy.getPlugin(this.id) && (Pd(this.render(d), l), this.afterUpdate()) }), this.uppy.log(`Installing ${r} to a DOM element '${e}'`), this.opts.replaceTargetContent && (s.innerHTML = ""), Pd(this.render(this.uppy.getState()), l), this.el = l, s.appendChild(l), l.dir = this.opts.direction || Bl(l) || "ltr", this.onMount(), this.el } let o = this.getTargetPlugin(e); if (o) return this.uppy.log(`Installing ${r} to ${o.id}`), this.parent = o, this.el = o.addTarget(t), this.onMount(), this.el; this.uppy.log(`Not installing ${r}`); let a = `Invalid target option given to ${r}.`; throw typeof e == "function" ? a += " The given target is not a Plugin class. Please check that you're not specifying a React Component instead of a plugin. If you are using @uppy/* packages directly, make sure you have only 1 version of @uppy/core installed: run `npm ls @uppy/core` on the command line and verify that all the versions match and are deduped correctly." : a += "If you meant to target an HTML element, please make sure that the element exists. Check that the <script> tag initializing Uppy is right before the closing </body> tag at the end of the page. (see https://github.com/transloadit/uppy/issues/1042)\n\nIf you meant to target a plugin, please confirm that your `import` statements or `require` calls are correct.", new Error(a) } update(e) { if (this.el != null) { var t, r; (t = (r = sm(this, On))[On]) == null || t.call(r, e) } } unmount() { if (this.isTargetDOMEl) { var e; (e = this.el) == null || e.remove() } this.onUnmount() } onMount() { } onUnmount() { } }; n(Fo, "UIPlugin"); var Q = Fo; var Ad = {}; xl(Ad, { Provider: () => ne, RequestClient: () => xe, SearchProvider: () => Yr, Socket: () => Kr }); var Ll = class extends Error { constructor(e, t) { t === void 0 && (t = null), super("This looks like a network error, the endpoint might be blocked by an internet provider or a firewall."), this.cause = e, this.isNetworkError = !0, this.request = t } }; n(Ll, "NetworkError"); var wi = Ll; function Ss() { return fetch(...arguments).catch(i => { throw i.name === "AbortError" ? i : new wi(i) }) } n(Ss, "fetchWithNetworkError"); var jl = class extends Error { constructor(e, t) { t === void 0 && (t = {}), super(e), this.cause = t.cause, this.cause && Et(this.cause, "isNetworkError") && (this.isNetworkError = this.cause.isNetworkError) } }; n(jl, "ErrorWithCause"); var gr = jl; var om = de(El(), 1); function Y1(i, e, t) { let { progress: r, bytesUploaded: s, bytesTotal: o } = e; r && (i.uppy.log(`Upload progress: ${r}`), i.uppy.emit("upload-progress", t, { uploader: i, bytesUploaded: s, bytesTotal: o })) } n(Y1, "emitSocketProgress"); var nm = (0, om.default)(Y1, 300, { leading: !0, trailing: !0 }); function _d(i) { let t = /^(?:https?:\/\/|\/\/)?(?:[^@\n]+@)?(?:www\.)?([^\n]+)/i.exec(i)[1]; return `${/^http:\/\//i.test(i) ? "ws" : "wss"}://${t}` } n(_d, "getSocketHost"); function yr(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(yr, "_classPrivateFieldLooseBase"); var Q1 = 0; function am(i) { return "__private_" + Q1++ + "_" + i } n(am, "_classPrivateFieldLooseKey"); var At = am("uppy"), En = am("events"), $t = class { constructor(e) { Object.defineProperty(this, At, { writable: !0, value: void 0 }), Object.defineProperty(this, En, { writable: !0, value: [] }), yr(this, At)[At] = e } on(e, t) { return yr(this, En)[En].push([e, t]), yr(this, At)[At].on(e, t) } remove() { for (let [e, t] of yr(this, En)[En].splice(0)) yr(this, At)[At].off(e, t) } onFilePause(e, t) { this.on("upload-pause", (r, s) => { e === r && t(s) }) } onFileRemove(e, t) { this.on("file-removed", r => { e === r.id && t(r.id) }) } onPause(e, t) { this.on("upload-pause", (r, s) => { e === r && t(s) }) } onRetry(e, t) { this.on("upload-retry", r => { e === r && t() }) } onRetryAll(e, t) { this.on("retry-all", () => { yr(this, At)[At].getFile(e) && t() }) } onPauseAll(e, t) { this.on("pause-all", () => { yr(this, At)[At].getFile(e) && t() }) } onCancelAll(e, t) { var r = this; this.on("cancel-all", function () { yr(r, At)[At].getFile(e) && t(...arguments) }) } onResumeAll(e, t) { this.on("resume-all", () => { yr(this, At)[At].getFile(e) && t() }) } }; n($t, "EventManager"); var zl = class extends Error { constructor() { super("Authorization required"), this.name = "AuthError", this.isAuthError = !0 } }; n(zl, "AuthError"); var lm = zl; var hm = de(ld(), 1); var um, dm; function Ie(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Ie, "_classPrivateFieldLooseBase"); var J1 = 0; function Cn(i) { return "__private_" + J1++ + "_" + i } n(Cn, "_classPrivateFieldLooseKey"); var vr = Cn("queued"), Ps = Cn("emitter"), Si = Cn("isOpen"), Qe = Cn("socket"), Fd = Cn("handleMessage"); um = Symbol.for("uppy test: getSocket"); dm = Symbol.for("uppy test: getQueued"); var Kr = class { constructor(e) { Object.defineProperty(this, vr, { writable: !0, value: [] }), Object.defineProperty(this, Ps, { writable: !0, value: (0, hm.default)() }), Object.defineProperty(this, Si, { writable: !0, value: !1 }), Object.defineProperty(this, Qe, { writable: !0, value: void 0 }), Object.defineProperty(this, Fd, { writable: !0, value: t => { try { let r = JSON.parse(t.data); this.emit(r.action, r.payload) } catch (r) { console.log(r) } } }), this.opts = e, (!e || e.autoOpen !== !1) && this.open() } get isOpen() { return Ie(this, Si)[Si] } [um]() { return Ie(this, Qe)[Qe] } [dm]() { return Ie(this, vr)[vr] } open() { Ie(this, Qe)[Qe] == null && (Ie(this, Qe)[Qe] = new WebSocket(this.opts.target), Ie(this, Qe)[Qe].onopen = () => { for (Ie(this, Si)[Si] = !0; Ie(this, vr)[vr].length > 0 && Ie(this, Si)[Si];) { let e = Ie(this, vr)[vr].shift(); this.send(e.action, e.payload) } }, Ie(this, Qe)[Qe].onclose = () => { Ie(this, Si)[Si] = !1, Ie(this, Qe)[Qe] = null }, Ie(this, Qe)[Qe].onmessage = Ie(this, Fd)[Fd]) } close() { var e; (e = Ie(this, Qe)[Qe]) == null || e.close() } send(e, t) { if (!Ie(this, Si)[Si]) { Ie(this, vr)[vr].push({ action: e, payload: t }); return } Ie(this, Qe)[Qe].send(JSON.stringify({ action: e, payload: t })) } on(e, t) { Ie(this, Ps)[Ps].on(e, t) } emit(e, t) { Ie(this, Ps)[Ps].emit(e, t) } once(e, t) { Ie(this, Ps)[Ps].once(e, t) } }; n(Kr, "UppySocket"); var cm; function Xr(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Xr, "_classPrivateFieldLooseBase"); var Z1 = 0; function Od(i) { return "__private_" + Z1++ + "_" + i } n(Od, "_classPrivateFieldLooseKey"); var ew = { version: "3.4.1" }; function tw(i) { return i.replace(/\/$/, "") } n(tw, "stripSlash"); async function iw(i) { if (i.status === 401) throw new lm; let e = i.json(); if (i.ok) return e; let t = `Failed request with status: ${i.status}. ${i.statusText}`; try { let r = await e; t = r.message ? `${t} message: ${r.message}` : t, t = r.requestId ? `${t} request-Id: ${r.requestId}` : t } catch { } throw new Error(t) } n(iw, "handleJSONResponse"); var An = new Map, br = Od("companionHeaders"), _s = Od("getUrl"), xd = Od("requestSocketToken"); cm = Symbol.for("uppy test: getCompanionHeaders"); var xe = class { constructor(e, t, r) { Object.defineProperty(this, _s, { value: rw }), Object.defineProperty(this, br, { writable: !0, value: void 0 }), Object.defineProperty(this, xd, { writable: !0, value: async (s, o) => { if (s.remote.url == null) throw new Error("Cannot connect to an undefined URL"); return (await this.post(s.remote.url, { ...s.remote.body, ...o })).token } }), this.uppy = e, this.opts = t, this.getQueue = r, this.onReceiveResponse = this.onReceiveResponse.bind(this), Xr(this, br)[br] = t?.companionHeaders } setCompanionHeaders(e) { Xr(this, br)[br] = e } [cm]() { return Xr(this, br)[br] } get hostname() { let { companion: e } = this.uppy.getState(), t = this.opts.companionUrl; return tw(e && e[t] ? e[t] : t) } async headers() { return { ...{ Accept: "application/json", "Content-Type": "application/json", "Uppy-Versions": `@uppy/companion-client=${xe.VERSION}` }, ...Xr(this, br)[br] } } onReceiveResponse(e) { let { headers: t } = e, s = this.uppy.getState().companion || {}, o = this.opts.companionUrl; t.has("i-am") && t.get("i-am") !== s[o] && this.uppy.setState({ companion: { ...s, [o]: t.get("i-am") } }) } async preflight(e) { let t = An.get(this.hostname); if (t != null) return t; let r = ["accept", "content-type", "uppy-auth-token"], s = (async () => { try { let a = (await fetch(Xr(this, _s)[_s](e), { method: "OPTIONS" })).headers.get("access-control-allow-headers"); if (a == null || a === "*") return An.set(this.hostname, r), r; this.uppy.log(`[CompanionClient] adding allowed preflight headers to companion cache: ${this.hostname} ${a}`); let l = a.split(",").map(d => d.trim().toLowerCase()); return An.set(this.hostname, l), l } catch (o) { return this.uppy.log(`[CompanionClient] unable to make preflight request ${o}`, "warning"), An.delete(this.hostname), r } })(); return An.set(this.hostname, s), s } async preflightAndHeaders(e) { let [t, r] = await Promise.all([this.preflight(e), this.headers()]); return Object.fromEntries(Object.entries(r).filter(s => { let [o] = s; return t.includes(o.toLowerCase()) ? !0 : (this.uppy.log(`[CompanionClient] excluding disallowed header ${o}`), !1) })) } async request(e) { let { path: t, method: r = "GET", data: s, skipPostResponse: o, signal: a } = e; try { let l = await this.preflightAndHeaders(t), d = await Ss(Xr(this, _s)[_s](t), { method: r, signal: a, headers: l, credentials: this.opts.companionCookiesRule || "same-origin", body: s ? JSON.stringify(s) : null }); return o || this.onReceiveResponse(d), iw(d) } catch (l) { throw l != null && l.isAuthError ? l : new gr(`Could not ${r} ${Xr(this, _s)[_s](t)}`, { cause: l }) } } async get(e, t) { return t === void 0 && (t = void 0), typeof t == "boolean" && (t = { skipPostResponse: t }), this.request({ ...t, path: e }) } async post(e, t, r) { return r === void 0 && (r = void 0), typeof r == "boolean" && (r = { skipPostResponse: r }), this.request({ ...r, path: e, method: "POST", data: t }) } async delete(e, t, r) { return t === void 0 && (t = void 0), typeof r == "boolean" && (r = { skipPostResponse: r }), this.request({ ...r, path: e, method: "DELETE", data: t }) } async uploadRemoteFile(e, t, r) { r === void 0 && (r = {}); try { if (e.serverToken) return await this.connectToServerSocket(e, this.getQueue()); let a = await this.getQueue().wrapPromiseFunction(Xr(this, xd)[xd], { priority: -1 })(e, t).abortOn(r.signal); return this.uppy.getState().files[e.id] ? (this.uppy.setFileState(e.id, { serverToken: a }), await this.connectToServerSocket(this.uppy.getFile(e.id), this.getQueue())) : void 0 } catch (o) { var s; if ((o == null || (s = o.cause) == null ? void 0 : s.name) === "AbortError") return; throw this.uppy.setFileState(e.id, { serverToken: void 0 }), this.uppy.emit("upload-error", e, o), o } } async connectToServerSocket(e, t) { return new Promise((r, s) => { let o = e.serverToken, a = _d(e.remote.companionUrl), l = new Kr({ target: `${a}/api/${o}`, autoOpen: !1 }), d = new $t(this.uppy), p; d.onFileRemove(e.id, () => { l.send("cancel", {}), p.abort(), r(`upload ${e.id} was removed`) }), d.onPause(e.id, h => { h ? (l.send("pause", {}), p.abort()) : (p.abort(), p = t.run(() => (l.open(), l.send("resume", {}), () => { }))) }), d.onPauseAll(e.id, () => { l.send("pause", {}), p.abort() }), d.onCancelAll(e.id, function (h) { let { reason: m } = h === void 0 ? {} : h; m === "user" && (l.send("cancel", {}), p.abort()), r(`upload ${e.id} was canceled`) }), d.onResumeAll(e.id, () => { p.abort(), e.error && l.send("pause", {}), p = t.run(() => (l.open(), l.send("resume", {}), () => { })) }), d.onRetry(e.id, () => { l.isOpen && (l.send("pause", {}), l.send("resume", {})) }), d.onRetryAll(e.id, () => { l.isOpen && (l.send("pause", {}), l.send("resume", {})) }), l.on("progress", h => nm(this, h, e)), l.on("error", h => { let { message: m } = h.error, y = Object.assign(new Error(m), { cause: h.error }); this.opts.useFastRemoteRetry ? l.close() : this.uppy.setFileState(e.id, { serverToken: null }), this.uppy.emit("upload-error", e, y), p.done(), s(y) }), l.on("success", h => { let m = { uploadURL: h.url }; this.uppy.emit("upload-success", e, m), p.done(), l.close(), r() }), p = t.run(() => (e.isPaused ? l.send("pause", {}) : l.open(), () => { })) }) } }; n(xe, "RequestClient"); function rw(i) { return /^(https?:|)\/\//.test(i) ? i : `${this.hostname}/${i}` } n(rw, "_getUrl2"); xe.VERSION = ew.version; var Ed = {}; xl(Ed, { getItem: () => ow, removeItem: () => nw, setItem: () => sw }); function sw(i, e) { return new Promise(t => { localStorage.setItem(i, e), t() }) } n(sw, "setItem"); function ow(i) { return Promise.resolve(localStorage.getItem(i)) } n(ow, "getItem"); function nw(i) { return new Promise(e => { localStorage.removeItem(i), e() }) } n(nw, "removeItem"); function wr(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(wr, "_classPrivateFieldLooseBase"); var aw = 0; function Cd(i) { return "__private_" + aw++ + "_" + i } n(Cd, "_classPrivateFieldLooseKey"); var lw = n(i => i.split("-").map(e => e.charAt(0).toUpperCase() + e.slice(1)).join(" "), "getName"); function uw() { return location.origin } n(uw, "getOrigin"); function pm(i) { if (typeof i == "string") return new RegExp(`^${i}$`); if (i instanceof RegExp) return i } n(pm, "getRegex"); function dw(i, e) { return (Array.isArray(e) ? e.map(pm) : [pm(e)]).some(r => r?.test(i) || r?.test(`${i}/`)) } n(dw, "isOriginAllowed"); var Pi = Cd("refreshingTokenPromise"), Tn = Cd("getAuthToken"), Rn = Cd("removeAuthToken"), ne = class extends xe { constructor(e, t, r) { super(e, t, r), Object.defineProperty(this, Rn, { value: cw }), Object.defineProperty(this, Tn, { value: hw }), Object.defineProperty(this, Pi, { writable: !0, value: void 0 }), this.provider = t.provider, this.id = this.provider, this.name = this.opts.name || lw(this.id), this.pluginId = this.opts.pluginId, this.tokenKey = `companion-${this.pluginId}-auth-token`, this.companionKeysParams = this.opts.companionKeysParams, this.preAuthToken = null } async headers() { let [e, t] = await Promise.all([super.headers(), wr(this, Tn)[Tn]()]), r = {}; return t && (r["uppy-auth-token"] = t), this.companionKeysParams && (r["uppy-credentials-params"] = btoa(JSON.stringify({ params: this.companionKeysParams }))), { ...e, ...r } } onReceiveResponse(e) { super.onReceiveResponse(e); let t = this.uppy.getPlugin(this.pluginId), s = t.getPluginState().authenticated ? e.status !== 401 : e.status < 400; return t.setPluginState({ authenticated: s }), e } async setAuthToken(e) { return this.uppy.getPlugin(this.pluginId).storage.setItem(this.tokenKey, e) } async ensurePreAuth() { if (this.companionKeysParams && !this.preAuthToken && (await this.fetchPreAuthToken(), !this.preAuthToken)) throw new Error("Could not load authentication data required for third-party login. Please try again later.") } authUrl(e) { e === void 0 && (e = {}); let t = new URLSearchParams({ state: btoa(JSON.stringify({ origin: uw() })), ...e }); return this.preAuthToken && t.set("uppyPreAuthToken", this.preAuthToken), `${this.hostname}/${this.id}/connect?${t}` } async login(e) { return await this.ensurePreAuth(), new Promise((t, r) => { let s = this.authUrl(e), o = window.open(s, "_blank"), a = n(l => { if (l.source !== o) { this.uppy.log.warn("ignoring event from unknown source", l); return } let { companionAllowedHosts: d } = this.uppy.getPlugin(this.pluginId).opts; if (!dw(l.origin, d)) { r(new Error(`rejecting event from ${l.origin} vs allowed pattern ${d}`)); return } let p = typeof l.data == "string" ? JSON.parse(l.data) : l.data; if (p.error) { let { uppy: h } = this, m = h.i18n("authAborted"); h.info({ message: m }, "warning", 5e3), r(new Error("auth aborted")); return } if (!p.token) { r(new Error("did not receive token from auth window")); return } o.close(), window.removeEventListener("message", a), this.setAuthToken(p.token), t() }, "handleToken"); window.addEventListener("message", a) }) } refreshTokenUrl() { return `${this.hostname}/${this.id}/refresh-token` } fileUrl(e) { return `${this.hostname}/${this.id}/get/${e}` } async request() { await wr(this, Pi)[Pi]; try { return await super.request(...arguments) } catch (e) { if (!e.isAuthError || !await wr(this, Tn)[Tn]()) throw e; return wr(this, Pi)[Pi] == null && (wr(this, Pi)[Pi] = (async () => { try { let t = await super.request({ path: this.refreshTokenUrl(), method: "POST" }); await this.setAuthToken(t.uppyAuthToken) } catch (t) { throw t.isAuthError && await wr(this, Rn)[Rn](), e } finally { wr(this, Pi)[Pi] = void 0 } })()), await wr(this, Pi)[Pi], super.request(...arguments) } } async fetchPreAuthToken() { if (this.companionKeysParams) try { let e = await this.post(`${this.id}/preauth/`, { params: this.companionKeysParams }); this.preAuthToken = e.token } catch (e) { this.uppy.log(`[CompanionClient] unable to fetch preAuthToken ${e}`, "warning") } } list(e, t) { return this.get(`${this.id}/list/${e || ""}`, t) } async logout(e) { let t = await this.get(`${this.id}/logout`, e); return await wr(this, Rn)[Rn](), t } static initPlugin(e, t, r) { if (e.type = "acquirer", e.files = [], r && (e.opts = { ...r, ...t }), t.serverUrl || t.serverPattern) throw new Error("`serverUrl` and `serverPattern` have been renamed to `companionUrl` and `companionAllowedHosts` respectively in the 0.30.5 release. Please consult the docs (for example, https://uppy.io/docs/instagram/ for the Instagram plugin) and use the updated options.`"); if (t.companionAllowedHosts) { let s = t.companionAllowedHosts; if (typeof s != "string" && !Array.isArray(s) && !(s instanceof RegExp)) throw new TypeError(`${e.id}: the option "companionAllowedHosts" must be one of string, Array, RegExp`); e.opts.companionAllowedHosts = s } else /^(?!https?:\/\/).*$/i.test(t.companionUrl) ? e.opts.companionAllowedHosts = `https://${t.companionUrl.replace(/^\/\//, "")}` : e.opts.companionAllowedHosts = new URL(t.companionUrl).origin; e.storage = e.opts.storage || Ed } }; n(ne, "Provider"); async function hw() { return this.uppy.getPlugin(this.pluginId).storage.getItem(this.tokenKey) } n(hw, "_getAuthToken2"); async function cw() { return this.uppy.getPlugin(this.pluginId).storage.removeItem(this.tokenKey) } n(cw, "_removeAuthToken2"); var pw = n(i => i.split("-").map(e => e.charAt(0).toUpperCase() + e.slice(1)).join(" "), "getName"), Yr = class extends xe { constructor(e, t) { super(e, t), this.provider = t.provider, this.id = this.provider, this.name = this.opts.name || pw(this.id), this.pluginId = this.opts.pluginId } fileUrl(e) { return `${this.hostname}/search/${this.id}/get/${e}` } search(e, t) { return this.get(`search/${this.id}/list?q=${encodeURIComponent(e)}${t ? `&${t}` : ""}`) } }; n(Yr, "SearchProvider"); var qd = {}; xl(qd, { ProviderViews: () => Ce, SearchProviderViews: () => Bi, defaultPickerIcon: () => Ro }); var Fm = de(mm(), 1); var xo = class extends Error { constructor(e) { super(e), this.name = "TimeoutError" } }; n(xo, "TimeoutError"); var $l = class extends Error { constructor(e) { super(), this.name = "AbortError", this.message = e } }; n($l, "AbortError"); var gm = n(i => globalThis.DOMException === void 0 ? new $l(i) : new DOMException(i), "getDOMException"), ym = n(i => { let e = i.reason === void 0 ? gm("This operation was aborted.") : i.reason; return e instanceof Error ? e : gm(e) }, "getAbortedReason"); function Rd(i, e, t, r) { let s, o = new Promise((a, l) => { if (typeof e != "number" || Math.sign(e) !== 1) throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${e}\``); if (e === Number.POSITIVE_INFINITY) { a(i); return } if (r = { customTimers: { setTimeout, clearTimeout }, ...r }, r.signal) { let { signal: d } = r; d.aborted && l(ym(d)), d.addEventListener("abort", () => { l(ym(d)) }) } s = r.customTimers.setTimeout.call(void 0, () => { if (typeof t == "function") { try { a(t()) } catch (h) { l(h) } return } let d = typeof t == "string" ? t : `Promise timed out after ${e} milliseconds`, p = t instanceof Error ? t : new xo(d); typeof i.cancel == "function" && i.cancel(), l(p) }, e), (async () => { try { a(await i) } catch (d) { l(d) } finally { r.customTimers.clearTimeout.call(void 0, s) } })() }); return o.clear = () => { clearTimeout(s), s = void 0 }, o } n(Rd, "pTimeout"); function Ud(i, e, t) { let r = 0, s = i.length; for (; s > 0;) { let o = Math.trunc(s / 2), a = r + o; t(i[a], e) <= 0 ? (r = ++a, s -= o + 1) : s = o } return r } n(Ud, "lowerBound"); var Fs = function (i, e, t, r) { if (t === "a" && !r) throw new TypeError("Private accessor was defined without a getter"); if (typeof e == "function" ? i !== e || !r : !e.has(i)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return t === "m" ? r : t === "a" ? r.call(i) : r ? r.value : e.get(i) }, Sr, Oo = class { constructor() { Sr.set(this, []) } enqueue(e, t) { t = { priority: 0, ...t }; let r = { priority: t.priority, run: e }; if (this.size && Fs(this, Sr, "f")[this.size - 1].priority >= t.priority) { Fs(this, Sr, "f").push(r); return } let s = Ud(Fs(this, Sr, "f"), r, (o, a) => a.priority - o.priority); Fs(this, Sr, "f").splice(s, 0, r) } dequeue() { let e = Fs(this, Sr, "f").shift(); return e?.run } filter(e) { return Fs(this, Sr, "f").filter(t => t.priority === e.priority).map(t => t.run) } get size() { return Fs(this, Sr, "f").length } }; n(Oo, "PriorityQueue"); Sr = new WeakMap; var Te = function (i, e, t, r, s) { if (r === "m") throw new TypeError("Private method is not writable"); if (r === "a" && !s) throw new TypeError("Private accessor was defined without a setter"); if (typeof e == "function" ? i !== e || !s : !e.has(i)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return r === "a" ? s.call(i, t) : s ? s.value = t : e.set(i, t), t }, V = function (i, e, t, r) { if (t === "a" && !r) throw new TypeError("Private accessor was defined without a getter"); if (typeof e == "function" ? i !== e || !r : !e.has(i)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return t === "m" ? r : t === "a" ? r.call(i) : r ? r.value : e.get(i) }, Le, Dn, In, Jr, Xl, Nn, ql, _i, kn, Yt, Vl, Qt, Mn, Qr, Wl, vm, bm, Pm, wm, Sm, Gl, kd, Dd, Yl, _m, Kl, Bn = class extends Error { }; n(Bn, "AbortError"); var Eo = class extends Fm.default { constructor(e) { var t, r, s, o; if (super(), Le.add(this), Dn.set(this, void 0), In.set(this, void 0), Jr.set(this, 0), Xl.set(this, void 0), Nn.set(this, void 0), ql.set(this, 0), _i.set(this, void 0), kn.set(this, void 0), Yt.set(this, void 0), Vl.set(this, void 0), Qt.set(this, 0), Mn.set(this, void 0), Qr.set(this, void 0), Wl.set(this, void 0), Object.defineProperty(this, "timeout", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), e = { carryoverConcurrencyCount: !1, intervalCap: Number.POSITIVE_INFINITY, interval: 0, concurrency: Number.POSITIVE_INFINITY, autoStart: !0, queueClass: Oo, ...e }, !(typeof e.intervalCap == "number" && e.intervalCap >= 1)) throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(r = (t = e.intervalCap) === null || t === void 0 ? void 0 : t.toString()) !== null && r !== void 0 ? r : ""}\` (${typeof e.intervalCap})`); if (e.interval === void 0 || !(Number.isFinite(e.interval) && e.interval >= 0)) throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(o = (s = e.interval) === null || s === void 0 ? void 0 : s.toString()) !== null && o !== void 0 ? o : ""}\` (${typeof e.interval})`); Te(this, Dn, e.carryoverConcurrencyCount, "f"), Te(this, In, e.intervalCap === Number.POSITIVE_INFINITY || e.interval === 0, "f"), Te(this, Xl, e.intervalCap, "f"), Te(this, Nn, e.interval, "f"), Te(this, Yt, new e.queueClass, "f"), Te(this, Vl, e.queueClass, "f"), this.concurrency = e.concurrency, this.timeout = e.timeout, Te(this, Wl, e.throwOnTimeout === !0, "f"), Te(this, Qr, e.autoStart === !1, "f") } get concurrency() { return V(this, Mn, "f") } set concurrency(e) { if (!(typeof e == "number" && e >= 1)) throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`); Te(this, Mn, e, "f"), V(this, Le, "m", Yl).call(this) } async add(e, t = {}) { return t = { timeout: this.timeout, throwOnTimeout: V(this, Wl, "f"), ...t }, new Promise((r, s) => { V(this, Yt, "f").enqueue(async () => { var o, a, l; Te(this, Qt, (a = V(this, Qt, "f"), a++, a), "f"), Te(this, Jr, (l = V(this, Jr, "f"), l++, l), "f"); try { if (!((o = t.signal) === null || o === void 0) && o.aborted) throw new Bn("The task was aborted."); let d = e({ signal: t.signal }); t.timeout && (d = Rd(Promise.resolve(d), t.timeout)), t.signal && (d = Promise.race([d, V(this, Le, "m", _m).call(this, t.signal)])); let p = await d; r(p), this.emit("completed", p) } catch (d) { if (d instanceof xo && !t.throwOnTimeout) { r(); return } s(d), this.emit("error", d) } finally { V(this, Le, "m", Pm).call(this) } }, t), this.emit("add"), V(this, Le, "m", Gl).call(this) }) } async addAll(e, t) { return Promise.all(e.map(async r => this.add(r, t))) } start() { return V(this, Qr, "f") ? (Te(this, Qr, !1, "f"), V(this, Le, "m", Yl).call(this), this) : this } pause() { Te(this, Qr, !0, "f") } clear() { Te(this, Yt, new (V(this, Vl, "f")), "f") } async onEmpty() { V(this, Yt, "f").size !== 0 && await V(this, Le, "m", Kl).call(this, "empty") } async onSizeLessThan(e) { V(this, Yt, "f").size < e || await V(this, Le, "m", Kl).call(this, "next", () => V(this, Yt, "f").size < e) } async onIdle() { V(this, Qt, "f") === 0 && V(this, Yt, "f").size === 0 || await V(this, Le, "m", Kl).call(this, "idle") } get size() { return V(this, Yt, "f").size } sizeBy(e) { return V(this, Yt, "f").filter(e).length } get pending() { return V(this, Qt, "f") } get isPaused() { return V(this, Qr, "f") } }; n(Eo, "PQueue"); Dn = new WeakMap, In = new WeakMap, Jr = new WeakMap, Xl = new WeakMap, Nn = new WeakMap, ql = new WeakMap, _i = new WeakMap, kn = new WeakMap, Yt = new WeakMap, Vl = new WeakMap, Qt = new WeakMap, Mn = new WeakMap, Qr = new WeakMap, Wl = new WeakMap, Le = new WeakSet, vm = n(function () { return V(this, In, "f") || V(this, Jr, "f") < V(this, Xl, "f") }, "_PQueue_doesIntervalAllowAnother_get"), bm = n(function () { return V(this, Qt, "f") < V(this, Mn, "f") }, "_PQueue_doesConcurrentAllowAnother_get"), Pm = n(function () { var e; Te(this, Qt, (e = V(this, Qt, "f"), e--, e), "f"), V(this, Le, "m", Gl).call(this), this.emit("next") }, "_PQueue_next"), wm = n(function () { V(this, Le, "m", Dd).call(this), V(this, Le, "m", kd).call(this), Te(this, kn, void 0, "f") }, "_PQueue_onResumeInterval"), Sm = n(function () { let e = Date.now(); if (V(this, _i, "f") === void 0) { let t = V(this, ql, "f") - e; if (t < 0) Te(this, Jr, V(this, Dn, "f") ? V(this, Qt, "f") : 0, "f"); else return V(this, kn, "f") === void 0 && Te(this, kn, setTimeout(() => { V(this, Le, "m", wm).call(this) }, t), "f"), !0 } return !1 }, "_PQueue_isIntervalPaused_get"), Gl = n(function () { if (V(this, Yt, "f").size === 0) return V(this, _i, "f") && clearInterval(V(this, _i, "f")), Te(this, _i, void 0, "f"), this.emit("empty"), V(this, Qt, "f") === 0 && this.emit("idle"), !1; if (!V(this, Qr, "f")) { let e = !V(this, Le, "a", Sm); if (V(this, Le, "a", vm) && V(this, Le, "a", bm)) { let t = V(this, Yt, "f").dequeue(); return t ? (this.emit("active"), t(), e && V(this, Le, "m", kd).call(this), !0) : !1 } } return !1 }, "_PQueue_tryToStartAnother"), kd = n(function () { V(this, In, "f") || V(this, _i, "f") !== void 0 || (Te(this, _i, setInterval(() => { V(this, Le, "m", Dd).call(this) }, V(this, Nn, "f")), "f"), Te(this, ql, Date.now() + V(this, Nn, "f"), "f")) }, "_PQueue_initializeIntervalIfNeeded"), Dd = n(function () { V(this, Jr, "f") === 0 && V(this, Qt, "f") === 0 && V(this, _i, "f") && (clearInterval(V(this, _i, "f")), Te(this, _i, void 0, "f")), Te(this, Jr, V(this, Dn, "f") ? V(this, Qt, "f") : 0, "f"), V(this, Le, "m", Yl).call(this) }, "_PQueue_onInterval"), Yl = n(function () { for (; V(this, Le, "m", Gl).call(this);); }, "_PQueue_processQueue"), _m = n(async function (e) { return new Promise((t, r) => { e.addEventListener("abort", () => { r(new Bn("The task was aborted.")) }, { once: !0 }) }) }, "_PQueue_throwOnAbort"), Kl = n(async function (e, t) { return new Promise(r => { let s = n(() => { t && !t() || (this.off(e, s), r()) }, "listener"); this.on(e, s) }) }, "_PQueue_onEvent"); function gw() { return u("svg", { width: "26", height: "26", viewBox: "0 0 26 26", xmlns: "http://www.w3.org/2000/svg" }, u("g", { fill: "none", "fill-rule": "evenodd" }, u("circle", { fill: "#FFF", cx: "13", cy: "13", r: "13" }), u("path", { d: "M21.64 13.205c0-.639-.057-1.252-.164-1.841H13v3.481h4.844a4.14 4.14 0 01-1.796 2.716v2.259h2.908c1.702-1.567 2.684-3.875 2.684-6.615z", fill: "#4285F4", "fill-rule": "nonzero" }), u("path", { d: "M13 22c2.43 0 4.467-.806 5.956-2.18l-2.908-2.259c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H4.957v2.332A8.997 8.997 0 0013 22z", fill: "#34A853", "fill-rule": "nonzero" }), u("path", { d: "M7.964 14.71A5.41 5.41 0 017.682 13c0-.593.102-1.17.282-1.71V8.958H4.957A8.996 8.996 0 004 13c0 1.452.348 2.827.957 4.042l3.007-2.332z", fill: "#FBBC05", "fill-rule": "nonzero" }), u("path", { d: "M13 7.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C17.463 4.891 15.426 4 13 4a8.997 8.997 0 00-8.043 4.958l3.007 2.332C8.672 9.163 10.656 7.58 13 7.58z", fill: "#EA4335", "fill-rule": "nonzero" }), u("path", { d: "M4 4h18v18H4z" }))) } n(gw, "GoogleIcon"); function yw(i) { let { pluginName: e, pluginIcon: t, i18nArray: r, handleAuth: s } = i, o = e === "Google Drive", a = u("span", { className: "uppy-Provider-authTitleName" }, e, u("br", null)); return u("div", { className: "uppy-Provider-auth" }, u("div", { className: "uppy-Provider-authIcon" }, t()), u("div", { className: "uppy-Provider-authTitle" }, r("authenticateWithTitle", { pluginName: a })), o ? u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Provider-authBtn uppy-Provider-btn-google", onClick: s, "data-uppy-super-focusable": !0 }, u(gw, null), r("signInWithGoogle")) : u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Provider-authBtn", onClick: s, "data-uppy-super-focusable": !0 }, r("authenticateWith", { pluginName: e }))) } n(yw, "AuthView"); var xm = yw; var Om = n(i => { let { i18n: e, logout: t, username: r } = i; return [u("span", { className: "uppy-ProviderBrowser-user", key: "username" }, r), u("button", { type: "button", onClick: t, className: "uppy-u-reset uppy-c-btn uppy-ProviderBrowser-userLogout", key: "logout" }, e("logOut"))] }, "default"); var vw = n(i => { let { getFolder: e, title: t, isLast: r } = i; return u(Ht, null, u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", onClick: e }, t), r ? "" : " / ") }, "Breadcrumb"), Em = n(i => { let { getFolder: e, title: t, breadcrumbsIcon: r, breadcrumbs: s } = i; return u("div", { className: "uppy-Provider-breadcrumbs" }, u("div", { className: "uppy-Provider-breadcrumbsIcon" }, r), s.map((o, a) => u(vw, { key: o.id, getFolder: () => e(o.requestPath), title: a === 0 ? t : o.name, isLast: a + 1 === s.length }))) }, "default"); var Cm = n(i => { let e = []; return i.showBreadcrumbs && e.push(Em({ getFolder: i.getFolder, breadcrumbs: i.breadcrumbs, breadcrumbsIcon: i.pluginIcon && i.pluginIcon(), title: i.title })), e.push(Om({ logout: i.logout, username: i.username, i18n: i.i18n })), e }, "default"); var Hd = de(Jt(), 1); function Ln(i) { return { ...i, type: i.mimeType, extension: i.name ? Mi(i.name).extension : null } } n(Ln, "remoteFileObjToLocal"); var eu, Rt, Id, Am, jn = 0, Nm = [], Jl = [], Tm = Z.__b, Rm = Z.__r, Um = Z.diffed, km = Z.__c, Dm = Z.unmount; function Md(i, e) { Z.__h && Z.__h(Rt, i, jn || e), jn = 0; var t = Rt.__H || (Rt.__H = { __: [], __h: [] }); return i >= t.__.length && t.__.push({ __V: Jl }), t.__[i] } n(Md, "p"); function Co(i) { return jn = 1, bw(Bm, i) } n(Co, "y"); function bw(i, e, t) { var r = Md(eu++, 2); return r.t = i, r.__c || (r.__ = [t ? t(e) : Bm(void 0, e), function (s) { var o = r.t(r.__[0], s); r.__[0] !== o && (r.__ = [o, r.__[1]], r.__c.setState({})) }], r.__c = Rt), r.__ } n(bw, "d"); function xs(i, e) { var t = Md(eu++, 3); !Z.__s && Mm(t.__H, e) && (t.__ = i, t.u = e, Rt.__H.__h.push(t)) } n(xs, "_"); function Bd(i) { return jn = 5, Ao(function () { return { current: i } }, []) } n(Bd, "s"); function Ao(i, e) { var t = Md(eu++, 7); return Mm(t.__H, e) ? (t.__V = i(), t.u = e, t.__h = i, t.__V) : t.__ } n(Ao, "F"); function zn(i, e) { return jn = 8, Ao(function () { return i }, e) } n(zn, "T"); function ww() { for (var i; i = Nm.shift();)if (i.__P) try { i.__H.__h.forEach(Zl), i.__H.__h.forEach(Nd), i.__H.__h = [] } catch (e) { i.__H.__h = [], Z.__e(e, i.__v) } } n(ww, "b"); Z.__b = function (i) { Rt = null, Tm && Tm(i) }, Z.__r = function (i) { Rm && Rm(i), eu = 0; var e = (Rt = i.__c).__H; e && (Id === Rt ? (e.__h = [], Rt.__h = [], e.__.forEach(function (t) { t.__V = Jl, t.u = void 0 })) : (e.__h.forEach(Zl), e.__h.forEach(Nd), e.__h = [])), Id = Rt }, Z.diffed = function (i) { Um && Um(i); var e = i.__c; e && e.__H && (e.__H.__h.length && (Nm.push(e) !== 1 && Am === Z.requestAnimationFrame || ((Am = Z.requestAnimationFrame) || function (t) { var r, s = n(function () { clearTimeout(o), Im && cancelAnimationFrame(r), setTimeout(t) }, "u"), o = setTimeout(s, 100); Im && (r = requestAnimationFrame(s)) })(ww)), e.__H.__.forEach(function (t) { t.u && (t.__H = t.u), t.__V !== Jl && (t.__ = t.__V), t.u = void 0, t.__V = Jl })), Id = Rt = null }, Z.__c = function (i, e) { e.some(function (t) { try { t.__h.forEach(Zl), t.__h = t.__h.filter(function (r) { return !r.__ || Nd(r) }) } catch (r) { e.some(function (s) { s.__h && (s.__h = []) }), e = [], Z.__e(r, t.__v) } }), km && km(i, e) }, Z.unmount = function (i) { Dm && Dm(i); var e, t = i.__c; t && t.__H && (t.__H.__.forEach(function (r) { try { Zl(r) } catch (s) { e = s } }), e && Z.__e(e, t.__v)) }; var Im = typeof requestAnimationFrame == "function"; function Zl(i) { var e = Rt, t = i.__c; typeof t == "function" && (i.__c = void 0, t()), Rt = e } n(Zl, "j"); function Nd(i) { var e = Rt; i.__c = i.__(), Rt = e } n(Nd, "k"); function Mm(i, e) { return !i || i.length !== e.length || e.some(function (t, r) { return t !== i[r] }) } n(Mm, "w"); function Bm(i, e) { return typeof e == "function" ? e(i) : e } n(Bm, "z"); function Ld() { return Ld = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, Ld.apply(this, arguments) } n(Ld, "_extends"); var Sw = { position: "relative", width: "100%", minHeight: "100%" }, Pw = { position: "absolute", top: 0, left: 0, width: "100%", overflow: "visible" }, tu = class extends ve { constructor(e) { super(e), this.handleScroll = () => { this.setState({ offset: this.base.scrollTop }) }, this.handleResize = () => { this.resize() }, this.focusElement = null, this.state = { offset: 0, height: 0 } } componentDidMount() { this.resize(), window.addEventListener("resize", this.handleResize) } componentWillUpdate() { this.base.contains(document.activeElement) && (this.focusElement = document.activeElement) } componentDidUpdate() { this.focusElement && this.focusElement.parentNode && document.activeElement !== this.focusElement && this.focusElement.focus(), this.focusElement = null, this.resize() } componentWillUnmount() { window.removeEventListener("resize", this.handleResize) } resize() { let { height: e } = this.state; e !== this.base.offsetHeight && this.setState({ height: this.base.offsetHeight }) } render(e) { let { data: t, rowHeight: r, renderRow: s, overscanCount: o = 10, ...a } = e, { offset: l, height: d } = this.state, p = Math.floor(l / r), h = Math.floor(d / r); o && (p = Math.max(0, p - p % o), h += o); let m = p + h + 4, y = t.slice(p, m), b = { ...Sw, height: t.length * r }, S = { ...Pw, top: p * r }; return u("div", Ld({ onScroll: this.handleScroll }, a), u("div", { role: "presentation", style: b }, u("div", { role: "presentation", style: S }, y.map(s)))) } }; n(tu, "VirtualList"); var iu = tu; function Hn(i) { let { search: e, searchOnInput: t, searchTerm: r, showButton: s, inputLabel: o, clearSearchLabel: a, buttonLabel: l, clearSearch: d, inputClassName: p, buttonCSSClassName: h } = i, [m, y] = Co(r ?? ""), b = zn(x => { x.preventDefault(), e(m) }, [e, m]), S = zn(x => { let U = x.target.value; y(U), t && e(U) }, [y, t, e]), O = n(() => { y(""), d && d() }, "handleReset"), [F] = Co(() => { let x = document.createElement("form"); return x.setAttribute("tabindex", "-1"), x.id = St(), x }); return xs(() => (document.body.appendChild(F), F.addEventListener("submit", b), () => { F.removeEventListener("submit", b), document.body.removeChild(F) }), [F, b]), u(Ht, null, u("input", { className: `uppy-u-reset ${p}`, type: "search", "aria-label": o, placeholder: o, value: m, onInput: S, form: F.id, "data-uppy-super-focusable": !0 }), !s && u("svg", { "aria-hidden": "true", focusable: "false", class: "uppy-c-icon uppy-ProviderBrowser-searchFilterIcon", width: "12", height: "12", viewBox: "0 0 12 12" }, u("path", { d: "M8.638 7.99l3.172 3.172a.492.492 0 1 1-.697.697L7.91 8.656a4.977 4.977 0 0 1-2.983.983C2.206 9.639 0 7.481 0 4.819 0 2.158 2.206 0 4.927 0c2.721 0 4.927 2.158 4.927 4.82a4.74 4.74 0 0 1-1.216 3.17zm-3.71.685c2.176 0 3.94-1.726 3.94-3.856 0-2.129-1.764-3.855-3.94-3.855C2.75.964.984 2.69.984 4.819c0 2.13 1.765 3.856 3.942 3.856z" })), !s && m && u("button", { className: "uppy-u-reset uppy-ProviderBrowser-searchFilterReset", type: "button", "aria-label": a, title: a, onClick: O }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", viewBox: "0 0 19 19" }, u("path", { d: "M17.318 17.232L9.94 9.854 9.586 9.5l-.354.354-7.378 7.378h.707l-.62-.62v.706L9.318 9.94l.354-.354-.354-.354L1.94 1.854v.707l.62-.62h-.706l7.378 7.378.354.354.354-.354 7.378-7.378h-.707l.622.62v-.706L9.854 9.232l-.354.354.354.354 7.378 7.378.708-.707-7.38-7.378v.708l7.38-7.38.353-.353-.353-.353-.622-.622-.353-.353-.354.352-7.378 7.38h.708L2.56 1.23 2.208.88l-.353.353-.622.62-.353.355.352.353 7.38 7.38v-.708l-7.38 7.38-.353.353.352.353.622.622.353.353.354-.353 7.38-7.38h-.708l7.38 7.38z" }))), s && u("button", { className: `uppy-u-reset uppy-c-btn uppy-c-btn-primary ${h}`, type: "submit", form: F.id }, l)) } n(Hn, "SearchFilterInput"); var Lm = n(i => { let { cancel: e, done: t, i18n: r, selected: s } = i; return u("div", { className: "uppy-ProviderBrowser-footer" }, u("button", { className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary", onClick: t, type: "button" }, r("selectX", { smart_count: s })), u("button", { className: "uppy-u-reset uppy-c-btn uppy-c-btn-link", onClick: e, type: "button" }, r("cancel"))) }, "default"); var $m = de(Jt(), 1); function _w() { return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: 11, height: 14.5, viewBox: "0 0 44 58" }, u("path", { d: "M27.437.517a1 1 0 0 0-.094.03H4.25C2.037.548.217 2.368.217 4.58v48.405c0 2.212 1.82 4.03 4.03 4.03H39.03c2.21 0 4.03-1.818 4.03-4.03V15.61a1 1 0 0 0-.03-.28 1 1 0 0 0 0-.093 1 1 0 0 0-.03-.032 1 1 0 0 0 0-.03 1 1 0 0 0-.032-.063 1 1 0 0 0-.03-.063 1 1 0 0 0-.032 0 1 1 0 0 0-.03-.063 1 1 0 0 0-.032-.03 1 1 0 0 0-.03-.063 1 1 0 0 0-.063-.062l-14.593-14a1 1 0 0 0-.062-.062A1 1 0 0 0 28 .708a1 1 0 0 0-.374-.157 1 1 0 0 0-.156 0 1 1 0 0 0-.03-.03l-.003-.003zM4.25 2.547h22.218v9.97c0 2.21 1.82 4.03 4.03 4.03h10.564v36.438a2.02 2.02 0 0 1-2.032 2.032H4.25c-1.13 0-2.032-.9-2.032-2.032V4.58c0-1.13.902-2.032 2.03-2.032zm24.218 1.345l10.375 9.937.75.718H30.5c-1.13 0-2.032-.9-2.032-2.03V3.89z" })) } n(_w, "FileIcon"); function Fw() { return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", style: { minWidth: 16, marginRight: 3 }, viewBox: "0 0 276.157 276.157" }, u("path", { d: "M273.08 101.378c-3.3-4.65-8.86-7.32-15.254-7.32h-24.34V67.59c0-10.2-8.3-18.5-18.5-18.5h-85.322c-3.63 0-9.295-2.875-11.436-5.805l-6.386-8.735c-4.982-6.814-15.104-11.954-23.546-11.954H58.73c-9.292 0-18.638 6.608-21.737 15.372l-2.033 5.752c-.958 2.71-4.72 5.37-7.596 5.37H18.5C8.3 49.09 0 57.39 0 67.59v167.07c0 .886.16 1.73.443 2.52.152 3.306 1.18 6.424 3.053 9.064 3.3 4.652 8.86 7.32 15.255 7.32h188.487c11.395 0 23.27-8.425 27.035-19.18l40.677-116.188c2.11-6.035 1.43-12.164-1.87-16.816zM18.5 64.088h8.864c9.295 0 18.64-6.607 21.738-15.37l2.032-5.75c.96-2.712 4.722-5.373 7.597-5.373h29.565c3.63 0 9.295 2.876 11.437 5.806l6.386 8.735c4.982 6.815 15.104 11.954 23.546 11.954h85.322c1.898 0 3.5 1.602 3.5 3.5v26.47H69.34c-11.395 0-23.27 8.423-27.035 19.178L15 191.23V67.59c0-1.898 1.603-3.5 3.5-3.5zm242.29 49.15l-40.676 116.188c-1.674 4.78-7.812 9.135-12.877 9.135H18.75c-1.447 0-2.576-.372-3.02-.997-.442-.625-.422-1.814.057-3.18l40.677-116.19c1.674-4.78 7.812-9.134 12.877-9.134h188.487c1.448 0 2.577.372 3.02.997.443.625.423 1.814-.056 3.18z" })) } n(Fw, "FolderIcon"); function xw() { return u("svg", { "aria-hidden": "true", focusable: "false", style: { width: 16, marginRight: 4 }, viewBox: "0 0 58 58" }, u("path", { d: "M36.537 28.156l-11-7a1.005 1.005 0 0 0-1.02-.033C24.2 21.3 24 21.635 24 22v14a1 1 0 0 0 1.537.844l11-7a1.002 1.002 0 0 0 0-1.688zM26 34.18V23.82L34.137 29 26 34.18z" }), u("path", { d: "M57 6H1a1 1 0 0 0-1 1v44a1 1 0 0 0 1 1h56a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zM10 28H2v-9h8v9zm-8 2h8v9H2v-9zm10 10V8h34v42H12V40zm44-12h-8v-9h8v9zm-8 2h8v9h-8v-9zm8-22v9h-8V8h8zM2 8h8v9H2V8zm0 42v-9h8v9H2zm54 0h-8v-9h8v9z" })) } n(xw, "VideoIcon"); var jm = n(i => { let { itemIconString: e } = i; if (e !== null) switch (e) { case "file": return u(_w, null); case "folder": return u(Fw, null); case "video": return u(xw, null); default: { let { alt: t } = i; return u("img", { src: e, alt: t, loading: "lazy", width: 16, height: 16 }) } } }, "default"); var zm = de(Jt(), 1); function Ow(i) { let { className: e, isDisabled: t, restrictionError: r, isChecked: s, title: o, itemIconEl: a, showTitles: l, toggleCheckbox: d, recordShiftKeyPress: p, id: h, children: m } = i, y = (0, zm.default)("uppy-u-reset", "uppy-ProviderBrowserItem-checkbox", "uppy-ProviderBrowserItem-checkbox--grid", { "uppy-ProviderBrowserItem-checkbox--is-checked": s }); return u("li", { className: e, title: t ? r?.message : null }, u("input", { type: "checkbox", className: y, onChange: d, onKeyDown: p, onMouseDown: p, name: "listitem", id: h, checked: s, disabled: t, "data-uppy-super-focusable": !0 }), u("label", { htmlFor: h, "aria-label": o, className: "uppy-u-reset uppy-ProviderBrowserItem-inner" }, a, l && o, m)) } n(Ow, "GridListItem"); var jd = Ow; function Ew(i) { let { className: e, isDisabled: t, restrictionError: r, isCheckboxDisabled: s, isChecked: o, toggleCheckbox: a, recordShiftKeyPress: l, type: d, id: p, itemIconEl: h, title: m, handleFolderClick: y, showTitles: b, i18n: S } = i; return u("li", { className: e, title: t ? r?.message : null }, s ? null : u("input", { type: "checkbox", className: `uppy-u-reset uppy-ProviderBrowserItem-checkbox ${o ? "uppy-ProviderBrowserItem-checkbox--is-checked" : ""}`, onChange: a, onKeyDown: l, onMouseDown: l, name: "listitem", id: p, checked: o, "aria-label": d === "file" ? null : S("allFilesFromFolderNamed", { name: m }), disabled: t, "data-uppy-super-focusable": !0 }), d === "file" ? u("label", { htmlFor: p, className: "uppy-u-reset uppy-ProviderBrowserItem-inner" }, u("div", { className: "uppy-ProviderBrowserItem-iconWrap" }, h), b && m) : u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-ProviderBrowserItem-inner", onClick: y, "aria-label": S("openFolderNamed", { name: m }) }, u("div", { className: "uppy-ProviderBrowserItem-iconWrap" }, h), b && u("span", null, m))) } n(Ew, "ListItem"); var Hm = Ew; function $n() { return $n = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, $n.apply(this, arguments) } n($n, "_extends"); var zd = n(i => { let { author: e, getItemIcon: t, isChecked: r, isDisabled: s, viewType: o } = i, a = t(), l = (0, $m.default)("uppy-ProviderBrowserItem", { "uppy-ProviderBrowserItem--selected": r }, { "uppy-ProviderBrowserItem--disabled": s }, { "uppy-ProviderBrowserItem--noPreview": a === "video" }), d = u(jm, { itemIconString: a }); switch (o) { case "grid": return u(jd, $n({}, i, { className: l, itemIconEl: d })); case "list": return u(Hm, $n({}, i, { className: l, itemIconEl: d })); case "unsplash": return u(jd, $n({}, i, { className: l, itemIconEl: d }), u("a", { href: `${e.url}?utm_source=Companion&utm_medium=referral`, target: "_blank", rel: "noopener noreferrer", className: "uppy-ProviderBrowserItem-author", tabIndex: "-1" }, e.name)); default: throw new Error(`There is no such type ${o}`) } }, "default"); var Cw = "shared-with-me"; function qm(i) { let { currentSelection: e, uppyFiles: t, viewType: r, isChecked: s, toggleCheckbox: o, recordShiftKeyPress: a, showTitles: l, i18n: d, validateRestrictions: p, getNextFolder: h, columns: m, f: y } = i; if (y.isFolder) { var b; return zd({ columns: m, showTitles: l, viewType: r, i18n: d, id: y.id, title: y.name, getItemIcon: () => y.icon, isChecked: s(y), toggleCheckbox: O => o(O, y), recordShiftKeyPress: a, type: "folder", isDisabled: (b = s(y)) == null ? void 0 : b.loading, isCheckboxDisabled: y.id === Cw, handleFolderClick: () => h(y) }) } let S = p(Ln(y), [...t, ...e]); return zd({ id: y.id, title: y.name, author: y.author, getItemIcon: () => y.icon, isChecked: s(y), toggleCheckbox: O => o(O, y), recordShiftKeyPress: a, columns: m, showTitles: l, viewType: r, i18n: d, type: "file", isDisabled: S && !s(y), restrictionError: S }) } n(qm, "ListItem"); function Aw(i) { let { currentSelection: e, folders: t, files: r, uppyFiles: s, viewType: o, headerComponent: a, showBreadcrumbs: l, isChecked: d, toggleCheckbox: p, recordShiftKeyPress: h, handleScroll: m, showTitles: y, i18n: b, validateRestrictions: S, isLoading: O, showSearchFilter: F, search: x, searchTerm: U, clearSearch: H, searchOnInput: W, searchInputLabel: J, clearSearchLabel: L, getNextFolder: G, cancel: ee, done: be, columns: yt, noResultsLabel: nt, loadAllFiles: jt } = i, vt = e.length, Me = Ao(() => [...t, ...r], [t, r]); return u("div", { className: (0, Hd.default)("uppy-ProviderBrowser", `uppy-ProviderBrowser-viewType--${o}`) }, a && u("div", { className: "uppy-ProviderBrowser-header" }, u("div", { className: (0, Hd.default)("uppy-ProviderBrowser-headerBar", !l && "uppy-ProviderBrowser-headerBar--simple") }, a)), F && u("div", { class: "uppy-ProviderBrowser-searchFilter" }, u(Hn, { search: x, searchTerm: U, clearSearch: H, inputLabel: J, clearSearchLabel: L, inputClassName: "uppy-ProviderBrowser-searchFilterInput", searchOnInput: W })), (() => O ? u("div", { className: "uppy-Provider-loading" }, u("span", null, b("loading"))) : !t.length && !r.length ? u("div", { className: "uppy-Provider-empty" }, nt) : jt ? u("div", { className: "uppy-ProviderBrowser-body" }, u("ul", { className: "uppy-ProviderBrowser-list" }, u(iu, { data: Me, renderRow: bt => u(qm, { currentSelection: e, uppyFiles: s, viewType: o, isChecked: d, toggleCheckbox: p, recordShiftKeyPress: h, showTitles: y, i18n: b, validateRestrictions: S, getNextFolder: G, columns: yt, f: bt }), rowHeight: 31 }))) : u("div", { className: "uppy-ProviderBrowser-body" }, u("ul", { className: "uppy-ProviderBrowser-list", onScroll: m, role: "listbox", tabIndex: "-1" }, Me.map(bt => u(qm, { currentSelection: e, uppyFiles: s, viewType: o, isChecked: d, toggleCheckbox: p, recordShiftKeyPress: h, showTitles: y, i18n: b, validateRestrictions: S, getNextFolder: G, columns: yt, f: bt })))))(), vt > 0 && u(Lm, { selected: vt, done: be, cancel: ee, i18n: b })) } n(Aw, "Browser"); var ru = Aw; var Vm = n(i => { let { i18n: e, loading: t } = i; return u("div", { className: "uppy-Provider-loading" }, u("span", null, e("loading")), typeof t == "string" && u("span", { style: { marginTop: ".7em" } }, t)) }, "default"); var Fi = class extends ve { componentWillUnmount() { let { onUnmount: e } = this.props; e() } render() { let { children: e } = this.props; return ci(e)[0] } }; n(Fi, "CloseWrapper"); function To(i) { return i ? /^[^/]+\/(jpe?g|gif|png|svg|svg\+xml|bmp|webp|avif)$/.test(i) : !1 } n(To, "isPreviewSupported"); var Zr = class { constructor(e, t) { this.filterItems = r => { let s = this.plugin.getPluginState(); return !s.filterInput || s.filterInput === "" ? r : r.filter(o => o.name.toLowerCase().indexOf(s.filterInput.toLowerCase()) !== -1) }, this.recordShiftKeyPress = r => { this.isShiftKeyPressed = r.shiftKey }, this.toggleCheckbox = (r, s) => { r.stopPropagation(), r.preventDefault(), r.currentTarget.focus(); let { folders: o, files: a } = this.plugin.getPluginState(), l = this.filterItems(o.concat(a)); if (this.lastCheckbox && this.isShiftKeyPressed) { let { currentSelection: p } = this.plugin.getPluginState(), h = l.indexOf(this.lastCheckbox), m = l.indexOf(s), y = h < m ? l.slice(h, m + 1) : l.slice(m, h + 1), b = []; for (let S of y) { let { uppy: O } = this.plugin, F = O.validateRestrictions(Ln(S), [...O.getFiles(), ...b]); F ? O.info({ message: F.message }, "error", O.opts.infoTimeout) : b.push(S) } this.plugin.setPluginState({ currentSelection: [...new Set([...p, ...b])] }); return } this.lastCheckbox = s; let { currentSelection: d } = this.plugin.getPluginState(); this.isChecked(s) ? this.plugin.setPluginState({ currentSelection: d.filter(p => p.id !== s.id) }) : this.plugin.setPluginState({ currentSelection: d.concat([s]) }) }, this.isChecked = r => { let { currentSelection: s } = this.plugin.getPluginState(); return s.some(o => o.id === r.id) }, this.plugin = e, this.provider = t.provider, this.isHandlingScroll = !1, this.preFirstRender = this.preFirstRender.bind(this), this.handleError = this.handleError.bind(this), this.clearSelection = this.clearSelection.bind(this), this.cancelPicking = this.cancelPicking.bind(this) } preFirstRender() { this.plugin.setPluginState({ didFirstRender: !0 }), this.plugin.onFirstRender() } shouldHandleScroll(e) { let { scrollHeight: t, scrollTop: r, offsetHeight: s } = e.target; return t - (r + s) < 50 && !this.isHandlingScroll } clearSelection() { this.plugin.setPluginState({ currentSelection: [], filterInput: "" }) } cancelPicking() { this.clearSelection(); let e = this.plugin.uppy.getPlugin("Dashboard"); e && e.hideAllPanels() } handleError(e) { var t; let { uppy: r } = this.plugin, s = r.i18n("companionError"); r.log(e.toString()), !(e.isAuthError || ((t = e.cause) == null ? void 0 : t.name) === "AbortError") && r.info({ message: s, details: e.toString() }, "error", 5e3) } getTagFile(e) { let t = { id: e.id, source: this.plugin.id, data: e, name: e.name || e.id, type: e.mimeType, isRemote: !0, meta: {}, body: { fileId: e.id }, remote: { companionUrl: this.plugin.opts.companionUrl, url: `${this.provider.fileUrl(e.requestPath)}`, body: { fileId: e.id }, providerOptions: this.provider.opts, providerName: this.provider.name, provider: this.provider.provider } }, r = ys(t); return r && To(r) && (t.preview = e.thumbnail), e.author && (e.author.name != null && (t.meta.authorName = String(e.author.name)), e.author.url && (t.meta.authorUrl = e.author.url)), e.relDirPath != null && (t.meta.relativePath = e.relDirPath ? `${e.relDirPath}/${t.name}` : null), e.absDirPath != null && (t.meta.absolutePath = e.absDirPath ? `/${e.absDirPath}/${t.name}` : `/${t.name}`), t } setLoading(e) { this.plugin.setPluginState({ loading: e }) } }; n(Zr, "View"); function Zt(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Zt, "_classPrivateFieldLooseBase"); var Tw = 0; function Gn(i) { return "__private_" + Tw++ + "_" + i } n(Gn, "_classPrivateFieldLooseKey"); var Rw = { version: "3.5.0" }; function Uw(i) { return i.slice(1).map(e => e.name).join("/") } n(Uw, "formatBreadcrumbs"); function $d(i, e) { return i ? `${i}/${e}` : e } n($d, "prependPath"); function Ro() { return u("svg", { "aria-hidden": "true", focusable: "false", width: "30", height: "30", viewBox: "0 0 30 30" }, u("path", { d: "M15 30c8.284 0 15-6.716 15-15 0-8.284-6.716-15-15-15C6.716 0 0 6.716 0 15c0 8.284 6.716 15 15 15zm4.258-12.676v6.846h-8.426v-6.846H5.204l9.82-12.364 9.82 12.364H19.26z" })) } n(Ro, "defaultPickerIcon"); var Os = Gn("abortController"), Pr = Gn("withAbort"), Wn = Gn("list"), qn = Gn("listFilesAndFolders"), Vn = Gn("recursivelyListAllFiles"), Ce = class extends Zr { constructor(e, t) { super(e, t), Object.defineProperty(this, Vn, { value: Nw }), Object.defineProperty(this, qn, { value: Iw }), Object.defineProperty(this, Wn, { value: Dw }), Object.defineProperty(this, Pr, { value: kw }), Object.defineProperty(this, Os, { writable: !0, value: void 0 }); let r = { viewType: "list", showTitles: !0, showFilter: !0, showBreadcrumbs: !0, loadAllFiles: !1 }; this.opts = { ...r, ...t }, this.filterQuery = this.filterQuery.bind(this), this.clearFilter = this.clearFilter.bind(this), this.getFolder = this.getFolder.bind(this), this.getNextFolder = this.getNextFolder.bind(this), this.logout = this.logout.bind(this), this.handleAuth = this.handleAuth.bind(this), this.handleScroll = this.handleScroll.bind(this), this.donePicking = this.donePicking.bind(this), this.render = this.render.bind(this), this.plugin.setPluginState({ authenticated: !1, files: [], folders: [], breadcrumbs: [], filterInput: "", isSearchVisible: !1, currentSelection: [] }) } tearDown() { } async getFolder(e, t) { this.setLoading(!0); try { await Zt(this, Pr)[Pr](async r => { this.lastCheckbox = void 0; let { breadcrumbs: s } = this.plugin.getPluginState(), o = s.findIndex(d => e === d.requestPath); o !== -1 ? s = s.slice(0, o + 1) : s = [...s, { requestPath: e, name: t }], this.nextPagePath = e; let a = [], l = []; do { let { files: d, folders: p } = await Zt(this, qn)[qn]({ breadcrumbs: s, signal: r }); a = a.concat(d), l = l.concat(p), this.setLoading(this.plugin.uppy.i18n("loadedXFiles", { numFiles: a.length + l.length })) } while (this.opts.loadAllFiles && this.nextPagePath); this.plugin.setPluginState({ folders: l, files: a, breadcrumbs: s, filterInput: "" }) }) } catch (r) { this.handleError(r) } finally { this.setLoading(!1) } } getNextFolder(e) { this.getFolder(e.requestPath, e.name), this.lastCheckbox = void 0 } async logout() { try { await Zt(this, Pr)[Pr](async e => { let t = await this.provider.logout({ signal: e }); if (t.ok) { if (!t.revoked) { let s = this.plugin.uppy.i18n("companionUnauthorizeHint", { provider: this.plugin.title, url: t.manual_revoke_url }); this.plugin.uppy.info(s, "info", 7e3) } let r = { authenticated: !1, files: [], folders: [], breadcrumbs: [], filterInput: "" }; this.plugin.setPluginState(r) } }) } catch (e) { this.handleError(e) } } filterQuery(e) { this.plugin.setPluginState({ filterInput: e }) } clearFilter() { this.plugin.setPluginState({ filterInput: "" }) } async handleAuth() { let e = `@uppy/provider-views=${Ce.VERSION}`; try { await this.provider.login({ uppyVersions: e }), this.plugin.setPluginState({ authenticated: !0 }), this.preFirstRender() } catch (t) { this.plugin.uppy.log(`login failed: ${t.message}`) } } async handleScroll(e) { if (this.shouldHandleScroll(e) && this.nextPagePath) { this.isHandlingScroll = !0; try { await Zt(this, Pr)[Pr](async t => { let { files: r, folders: s, breadcrumbs: o } = this.plugin.getPluginState(), { files: a, folders: l } = await Zt(this, qn)[qn]({ breadcrumbs: o, signal: t }), d = r.concat(a), p = s.concat(l); this.plugin.setPluginState({ folders: p, files: d }) }) } catch (t) { this.handleError(t) } finally { this.isHandlingScroll = !1 } } } async donePicking() { this.setLoading(!0); try { await Zt(this, Pr)[Pr](async e => { let { currentSelection: t } = this.plugin.getPluginState(), r = [], s = []; for (let o of t) { let { requestPath: a } = o, l = n(d => ({ ...d, relDirPath: d.absDirPath.replace(o.absDirPath, "").replace(/^\//, "") }), "withRelDirPath"); if (o.isFolder) { let d = !0, p = 0, h = new Eo({ concurrency: 6 }), m = n(b => { for (let S of b) { let O = this.getTagFile(S), F = Tl(O); this.plugin.uppy.checkIfFileAlreadyExists(F) || (s.push(l(S)), p++, this.setLoading(this.plugin.uppy.i18n("addedNumFiles", { numFiles: p }))), d = !1 } }, "onFiles"); await Zt(this, Vn)[Vn]({ requestPath: a, absDirPath: $d(o.absDirPath, o.name), relDirPath: o.name, queue: h, onFiles: m, signal: e }), await h.onIdle(); let y; d ? y = this.plugin.uppy.i18n("emptyFolderAdded") : p === 0 ? y = this.plugin.uppy.i18n("folderAlreadyAdded", { folder: o.name }) : y = this.plugin.uppy.i18n("folderAdded", { smart_count: p, folder: o.name }), r.push(y) } else s.push(l(o)) } this.plugin.uppy.log("Adding remote provider files"), this.plugin.uppy.addFiles(s.map(o => this.getTagFile(o))), this.plugin.setPluginState({ filterInput: "" }), r.forEach(o => this.plugin.uppy.info(o)), this.clearSelection() }) } catch (e) { this.handleError(e) } finally { this.setLoading(!1) } } render(e, t) { var r = this; t === void 0 && (t = {}); let { authenticated: s, didFirstRender: o } = this.plugin.getPluginState(), { i18n: a } = this.plugin.uppy; o || this.preFirstRender(); let l = { ...this.opts, ...t }, { files: d, folders: p, filterInput: h, loading: m, currentSelection: y } = this.plugin.getPluginState(), { isChecked: b, toggleCheckbox: S, recordShiftKeyPress: O, filterItems: F } = this, x = h !== "", U = this.plugin.icon || Ro, H = { showBreadcrumbs: l.showBreadcrumbs, getFolder: this.getFolder, breadcrumbs: this.plugin.getPluginState().breadcrumbs, pluginIcon: U, title: this.plugin.title, logout: this.logout, username: this.username, i18n: a }, W = { isChecked: b, toggleCheckbox: S, recordShiftKeyPress: O, currentSelection: y, files: x ? F(d) : d, folders: x ? F(p) : p, username: this.username, getNextFolder: this.getNextFolder, getFolder: this.getFolder, loadAllFiles: this.opts.loadAllFiles, showSearchFilter: l.showFilter, search: this.filterQuery, clearSearch: this.clearFilter, searchTerm: h, searchOnInput: !0, searchInputLabel: a("filter"), clearSearchLabel: a("resetFilter"), noResultsLabel: a("noFilesFound"), logout: this.logout, handleScroll: this.handleScroll, done: this.donePicking, cancel: this.cancelPicking, headerComponent: Cm(H), title: this.plugin.title, viewType: l.viewType, showTitles: l.showTitles, showBreadcrumbs: l.showBreadcrumbs, pluginIcon: U, i18n: this.plugin.uppy.i18n, uppyFiles: this.plugin.uppy.getFiles(), validateRestrictions: function () { return r.plugin.uppy.validateRestrictions(...arguments) } }; return m ? u(Fi, { onUnmount: this.clearSelection }, u(Vm, { i18n: this.plugin.uppy.i18n, loading: m })) : s ? u(Fi, { onUnmount: this.clearSelection }, u(ru, W)) : u(Fi, { onUnmount: this.clearSelection }, u(xm, { pluginName: this.plugin.title, pluginIcon: U, handleAuth: this.handleAuth, i18n: this.plugin.uppy.i18n, i18nArray: this.plugin.uppy.i18nArray })) } }; n(Ce, "ProviderView"); async function kw(i) { var e; (e = Zt(this, Os)[Os]) == null || e.abort(); let t = new AbortController; Zt(this, Os)[Os] = t; let r = n(() => { t.abort(), this.clearSelection() }, "cancelRequest"); try { this.plugin.uppy.on("dashboard:close-panel", r), this.plugin.uppy.on("cancel-all", r), await i(t.signal) } finally { this.plugin.uppy.off("dashboard:close-panel", r), this.plugin.uppy.off("cancel-all", r), Zt(this, Os)[Os] = void 0 } } n(kw, "_withAbort2"); async function Dw(i) { let { requestPath: e, absDirPath: t, signal: r } = i, { username: s, nextPagePath: o, items: a } = await this.provider.list(e, { signal: r }); return this.username = s || this.username, { items: a.map(l => ({ ...l, absDirPath: t })), nextPagePath: o } } n(Dw, "_list2"); async function Iw(i) { let { breadcrumbs: e, signal: t } = i, r = Uw(e), { items: s, nextPagePath: o } = await Zt(this, Wn)[Wn]({ requestPath: this.nextPagePath, absDirPath: r, signal: t }); this.nextPagePath = o; let a = [], l = []; return s.forEach(d => { d.isFolder ? l.push(d) : a.push(d) }), { files: a, folders: l } } n(Iw, "_listFilesAndFolders2"); async function Nw(i) { let { requestPath: e, absDirPath: t, relDirPath: r, queue: s, onFiles: o, signal: a } = i, l = e; for (; l;) { let d = await Zt(this, Wn)[Wn]({ requestPath: l, absDirPath: t, signal: a }); l = d.nextPagePath; let p = d.items.filter(y => !y.isFolder), h = d.items.filter(y => y.isFolder); o(p); let m = h.map(async y => s.add(async () => Zt(this, Vn)[Vn]({ requestPath: y.requestPath, absDirPath: $d(t, y.name), relDirPath: $d(r, y.name), queue: s, onFiles: o, signal: a }))); await Promise.all(m) } } n(Nw, "_recursivelyListAllFiles2"); Ce.VERSION = Rw.version; function Wm(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Wm, "_classPrivateFieldLooseBase"); var Mw = 0; function Bw(i) { return "__private_" + Mw++ + "_" + i } n(Bw, "_classPrivateFieldLooseKey"); var Lw = { version: "3.5.0" }, Kn = Bw("updateFilesAndInputMode"), Bi = class extends Zr { constructor(e, t) { super(e, t), Object.defineProperty(this, Kn, { value: jw }); let r = { viewType: "grid", showTitles: !1, showFilter: !1, showBreadcrumbs: !1 }; this.opts = { ...r, ...t }, this.search = this.search.bind(this), this.clearSearch = this.clearSearch.bind(this), this.resetPluginState = this.resetPluginState.bind(this), this.handleScroll = this.handleScroll.bind(this), this.donePicking = this.donePicking.bind(this), this.render = this.render.bind(this), this.defaultState = { isInputMode: !0, files: [], folders: [], breadcrumbs: [], filterInput: "", currentSelection: [], searchTerm: null }, this.plugin.setPluginState(this.defaultState) } tearDown() { } resetPluginState() { this.plugin.setPluginState(this.defaultState) } async search(e) { let { searchTerm: t } = this.plugin.getPluginState(); if (!(e && e === t)) { this.setLoading(!0); try { let r = await this.provider.search(e); Wm(this, Kn)[Kn](r, []) } catch (r) { this.handleError(r) } finally { this.setLoading(!1) } } } clearSearch() { this.plugin.setPluginState({ currentSelection: [], files: [], searchTerm: null }) } async handleScroll(e) { let t = this.nextPageQuery || null; if (this.shouldHandleScroll(e) && t) { this.isHandlingScroll = !0; try { let { files: r, searchTerm: s } = this.plugin.getPluginState(), o = await this.provider.search(s, t); Wm(this, Kn)[Kn](o, r) } catch (r) { this.handleError(r) } finally { this.isHandlingScroll = !1 } } } donePicking() { let { currentSelection: e } = this.plugin.getPluginState(); this.plugin.uppy.log("Adding remote search provider files"), this.plugin.uppy.addFiles(e.map(t => this.getTagFile(t))), this.resetPluginState() } render(e, t) { var r = this; t === void 0 && (t = {}); let { didFirstRender: s, isInputMode: o, searchTerm: a } = this.plugin.getPluginState(), { i18n: l } = this.plugin.uppy; s || this.preFirstRender(); let d = { ...this.opts, ...t }, { files: p, folders: h, filterInput: m, loading: y, currentSelection: b } = this.plugin.getPluginState(), { isChecked: S, toggleCheckbox: O, filterItems: F, recordShiftKeyPress: x } = this, U = m !== "", H = { isChecked: S, toggleCheckbox: O, recordShiftKeyPress: x, currentSelection: b, files: U ? F(p) : p, folders: U ? F(h) : h, handleScroll: this.handleScroll, done: this.donePicking, cancel: this.cancelPicking, showSearchFilter: d.showFilter, search: this.search, clearSearch: this.clearSearch, searchTerm: a, searchOnInput: !1, searchInputLabel: l("search"), clearSearchLabel: l("resetSearch"), noResultsLabel: l("noSearchResults"), title: this.plugin.title, viewType: d.viewType, showTitles: d.showTitles, showFilter: d.showFilter, isLoading: y, showBreadcrumbs: d.showBreadcrumbs, pluginIcon: this.plugin.icon, i18n: l, uppyFiles: this.plugin.uppy.getFiles(), validateRestrictions: function () { return r.plugin.uppy.validateRestrictions(...arguments) } }; return o ? u(Fi, { onUnmount: this.resetPluginState }, u("div", { className: "uppy-SearchProvider" }, u(Hn, { search: this.search, clearSelection: this.clearSelection, inputLabel: l("enterTextToSearch"), buttonLabel: l("searchImages"), inputClassName: "uppy-c-textInput uppy-SearchProvider-input", buttonCSSClassName: "uppy-SearchProvider-searchButton", showButton: !0 }))) : u(Fi, { onUnmount: this.resetPluginState }, u(ru, H)) } }; n(Bi, "SearchProviderView"); function jw(i, e) { this.nextPageQuery = i.nextPageQuery, i.items.forEach(t => { e.push(t) }), this.plugin.setPluginState({ currentSelection: [], isInputMode: !1, files: e, searchTerm: i.searchedFor }) } n(jw, "_updateFilesAndInputMode2"); Bi.VERSION = Lw.version; var Gm; function Li(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Li, "_classPrivateFieldLooseBase"); var zw = 0; function Vd(i) { return "__private_" + zw++ + "_" + i } n(Vd, "_classPrivateFieldLooseKey"); var Hw = { version: "3.0.4" }, $w = "uppy/STATE_UPDATE", qw = n(i => e => e.uppy[i], "defaultSelector"); function Vw(i, e) { let t = Object.keys(e), r = {}; return t.forEach(s => { i[s] !== e[s] && (r[s] = e[s]) }), r } n(Vw, "getPatch"); var _r = Vd("id"), Xn = Vd("selector"), Fr = Vd("store"); Gm = Symbol.for("uppy test: get id"); var Yn = class { constructor(e) { Object.defineProperty(this, _r, { writable: !0, value: void 0 }), Object.defineProperty(this, Xn, { writable: !0, value: void 0 }), Object.defineProperty(this, Fr, { writable: !0, value: void 0 }), Li(this, Fr)[Fr] = e.store, Li(this, _r)[_r] = e.id || St(), Li(this, Xn)[Xn] = e.selector || qw(Li(this, _r)[_r]), this.setState({}) } setState(e) { Li(this, Fr)[Fr].dispatch({ type: $w, id: Li(this, _r)[_r], payload: e }) } getState() { return Li(this, Xn)[Xn](Li(this, Fr)[Fr].getState()) } subscribe(e) { let t = this.getState(); return Li(this, Fr)[Fr].subscribe(() => { let r = this.getState(); if (t !== r) { let s = Vw(t, r); e(t, r, s), t = r } }) } [Gm]() { return Li(this, _r)[_r] } }; n(Yn, "ReduxStore"); Yn.VERSION = Hw.version; var Km = Yn; function su(i, e, t, r) { return t === 0 || i === e ? i : r === 0 ? e : i + (e - i) * 2 ** (-r / t) } n(su, "emaFilter"); var Ut = { STATE_ERROR: "error", STATE_WAITING: "waiting", STATE_PREPROCESSING: "preprocessing", STATE_UPLOADING: "uploading", STATE_POSTPROCESSING: "postprocessing", STATE_COMPLETE: "complete" }; var Jd = de(Jt(), 1); function Qn(i) { let e = [], t, r; for (let { progress: o } of Object.values(i)) { let { preprocess: a, postprocess: l } = o; r == null && (a || l) && ({ mode: t, message: r } = a || l), a?.mode === "determinate" && e.push(a.value), l?.mode === "determinate" && e.push(l.value) } let s = e.reduce((o, a) => o + a / e.length, 0); return { mode: t, message: r, value: s } } n(Qn, "calculateProcessingProgress"); var Xd = de(Jt(), 1), Kd = de(Rl(), 1); function Wd(i) { let e = Math.floor(i / 3600) % 24, t = Math.floor(i / 60) % 60, r = Math.floor(i % 60); return { hours: e, minutes: t, seconds: r } } n(Wd, "secondsToTime"); function Gd(i) { let e = Wd(i), t = e.hours === 0 ? "" : `${e.hours}h`, r = e.minutes === 0 ? "" : `${e.hours === 0 ? e.minutes : ` ${e.minutes.toString(10).padStart(2, "0")}`}m`, s = e.hours !== 0 ? "" : `${e.minutes === 0 ? e.seconds : ` ${e.seconds.toString(10).padStart(2, "0")}`}s`; return `${t}${r}${s}` } n(Gd, "prettyETA"); var Ww = "\xB7", Xm = n(() => ` ${Ww} `, "renderDot"); function Ym(i) { let { newFiles: e, isUploadStarted: t, recoveredState: r, i18n: s, uploadState: o, isSomeGhost: a, startUpload: l } = i, d = (0, Xd.default)("uppy-u-reset", "uppy-c-btn", "uppy-StatusBar-actionBtn", "uppy-StatusBar-actionBtn--upload", { "uppy-c-btn-primary": o === Ut.STATE_WAITING }, { "uppy-StatusBar-actionBtn--disabled": a }), p = e && t && !r ? s("uploadXNewFiles", { smart_count: e }) : s("uploadXFiles", { smart_count: e }); return u("button", { type: "button", className: d, "aria-label": s("uploadXFiles", { smart_count: e }), onClick: l, disabled: a, "data-uppy-super-focusable": !0 }, p) } n(Ym, "UploadBtn"); function Qm(i) { let { i18n: e, uppy: t } = i; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--retry", "aria-label": e("retryUpload"), onClick: () => t.retryAll().catch(() => { }), "data-uppy-super-focusable": !0, "data-cy": "retry" }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "8", height: "10", viewBox: "0 0 8 10" }, u("path", { d: "M4 2.408a2.75 2.75 0 1 0 2.75 2.75.626.626 0 0 1 1.25.018v.023a4 4 0 1 1-4-4.041V.25a.25.25 0 0 1 .389-.208l2.299 1.533a.25.25 0 0 1 0 .416l-2.3 1.533A.25.25 0 0 1 4 3.316v-.908z" })), e("retry")) } n(Qm, "RetryBtn"); function Jm(i) { let { i18n: e, uppy: t } = i; return u("button", { type: "button", className: "uppy-u-reset uppy-StatusBar-actionCircleBtn", title: e("cancel"), "aria-label": e("cancel"), onClick: () => t.cancelAll(), "data-cy": "cancel", "data-uppy-super-focusable": !0 }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "16", height: "16", viewBox: "0 0 16 16" }, u("g", { fill: "none", fillRule: "evenodd" }, u("circle", { fill: "#888", cx: "8", cy: "8", r: "8" }), u("path", { fill: "#FFF", d: "M9.283 8l2.567 2.567-1.283 1.283L8 9.283 5.433 11.85 4.15 10.567 6.717 8 4.15 5.433 5.433 4.15 8 6.717l2.567-2.567 1.283 1.283z" })))) } n(Jm, "CancelBtn"); function Zm(i) { let { isAllPaused: e, i18n: t, isAllComplete: r, resumableUploads: s, uppy: o } = i, a = t(e ? "resume" : "pause"); function l() { return r ? null : s ? e ? o.resumeAll() : o.pauseAll() : o.cancelAll() } return n(l, "togglePauseResume"), u("button", { title: a, "aria-label": a, className: "uppy-u-reset uppy-StatusBar-actionCircleBtn", type: "button", onClick: l, "data-cy": "togglePauseResume", "data-uppy-super-focusable": !0 }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "16", height: "16", viewBox: "0 0 16 16" }, u("g", { fill: "none", fillRule: "evenodd" }, u("circle", { fill: "#888", cx: "8", cy: "8", r: "8" }), u("path", { fill: "#FFF", d: e ? "M6 4.25L11.5 8 6 11.75z" : "M5 4.5h2v7H5v-7zm4 0h2v7H9v-7z" })))) } n(Zm, "PauseResumeButton"); function eg(i) { let { i18n: e, doneButtonHandler: t } = i; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--done", onClick: t, "data-uppy-super-focusable": !0 }, e("done")) } n(eg, "DoneBtn"); function tg() { return u("svg", { className: "uppy-StatusBar-spinner", "aria-hidden": "true", focusable: "false", width: "14", height: "14" }, u("path", { d: "M13.983 6.547c-.12-2.509-1.64-4.893-3.939-5.936-2.48-1.127-5.488-.656-7.556 1.094C.524 3.367-.398 6.048.162 8.562c.556 2.495 2.46 4.52 4.94 5.183 2.932.784 5.61-.602 7.256-3.015-1.493 1.993-3.745 3.309-6.298 2.868-2.514-.434-4.578-2.349-5.153-4.84a6.226 6.226 0 0 1 2.98-6.778C6.34.586 9.74 1.1 11.373 3.493c.407.596.693 1.282.842 1.988.127.598.073 1.197.161 1.794.078.525.543 1.257 1.15.864.525-.341.49-1.05.456-1.592-.007-.15.02.3 0 0", fillRule: "evenodd" })) } n(tg, "LoadingSpinner"); function ig(i) { let { progress: e } = i, { value: t, mode: r, message: s } = e, o = Math.round(t * 100), a = "\xB7"; return u("div", { className: "uppy-StatusBar-content" }, u(tg, null), r === "determinate" ? `${o}% ${a} ` : "", s) } n(ig, "ProgressBarProcessing"); function Gw(i) { let { numUploads: e, complete: t, totalUploadedSize: r, totalSize: s, totalETA: o, i18n: a } = i, l = e > 1; return u("div", { className: "uppy-StatusBar-statusSecondary" }, l && a("filesUploadedOfTotal", { complete: t, smart_count: e }), u("span", { className: "uppy-StatusBar-additionalInfo" }, l && Xm(), a("dataUploadedOfTotal", { complete: (0, Kd.default)(r), total: (0, Kd.default)(s) }), Xm(), a("xTimeLeft", { time: Gd(o) }))) } n(Gw, "ProgressDetails"); function rg(i) { let { i18n: e, complete: t, numUploads: r } = i; return u("div", { className: "uppy-StatusBar-statusSecondary" }, e("filesUploadedOfTotal", { complete: t, smart_count: r })) } n(rg, "FileUploadCount"); function Kw(i) { let { i18n: e, newFiles: t, startUpload: r } = i, s = (0, Xd.default)("uppy-u-reset", "uppy-c-btn", "uppy-StatusBar-actionBtn", "uppy-StatusBar-actionBtn--uploadNewlyAdded"); return u("div", { className: "uppy-StatusBar-statusSecondary" }, u("div", { className: "uppy-StatusBar-statusSecondaryHint" }, e("xMoreFilesAdded", { smart_count: t })), u("button", { type: "button", className: s, "aria-label": e("uploadXFiles", { smart_count: t }), onClick: r }, e("upload"))) } n(Kw, "UploadNewlyAddedFiles"); function sg(i) { let { i18n: e, supportsUploadProgress: t, totalProgress: r, showProgressDetails: s, isUploadStarted: o, isAllComplete: a, isAllPaused: l, newFiles: d, numUploads: p, complete: h, totalUploadedSize: m, totalSize: y, totalETA: b, startUpload: S } = i, O = d && o; if (!o || a) return null; let F = e(l ? "paused" : "uploading"); function x() { return !l && !O && s ? t ? u(Gw, { numUploads: p, complete: h, totalUploadedSize: m, totalSize: y, totalETA: b, i18n: e }) : u(rg, { i18n: e, complete: h, numUploads: p }) : null } return n(x, "renderProgressDetails"), u("div", { className: "uppy-StatusBar-content", "aria-label": F, title: F }, l ? null : u(tg, null), u("div", { className: "uppy-StatusBar-status" }, u("div", { className: "uppy-StatusBar-statusPrimary" }, t ? `${F}: ${r}%` : F), x(), O ? u(Kw, { i18n: e, newFiles: d, startUpload: S }) : null)) } n(sg, "ProgressBarUploading"); function og(i) { let { i18n: e } = i; return u("div", { className: "uppy-StatusBar-content", role: "status", title: e("complete") }, u("div", { className: "uppy-StatusBar-status" }, u("div", { className: "uppy-StatusBar-statusPrimary" }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-StatusBar-statusIndicator uppy-c-icon", width: "15", height: "11", viewBox: "0 0 15 11" }, u("path", { d: "M.414 5.843L1.627 4.63l3.472 3.472L13.202 0l1.212 1.213L5.1 10.528z" })), e("complete")))) } n(og, "ProgressBarComplete"); function ng(i) {
        let { error: e, i18n: t, complete: r, numUploads: s } = i; function o() {
            let a = `${t("uploadFailed")}

 ${e}`; alert(a)
        } return n(o, "displayErrorAlert"), u("div", { className: "uppy-StatusBar-content", title: t("uploadFailed") }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-StatusBar-statusIndicator uppy-c-icon", width: "11", height: "11", viewBox: "0 0 11 11" }, u("path", { d: "M4.278 5.5L0 1.222 1.222 0 5.5 4.278 9.778 0 11 1.222 6.722 5.5 11 9.778 9.778 11 5.5 6.722 1.222 11 0 9.778z" })), u("div", { className: "uppy-StatusBar-status" }, u("div", { className: "uppy-StatusBar-statusPrimary" }, t("uploadFailed"), u("button", { className: "uppy-u-reset uppy-StatusBar-details", "aria-label": t("showErrorDetails"), "data-microtip-position": "top-right", "data-microtip-size": "medium", onClick: o, type: "button" }, "?")), u(rg, { i18n: t, complete: r, numUploads: s })))
    } n(ng, "ProgressBarError"); var { STATE_ERROR: ag, STATE_WAITING: lg, STATE_PREPROCESSING: Yd, STATE_UPLOADING: ou, STATE_POSTPROCESSING: Qd, STATE_COMPLETE: nu } = Ut; function Zd(i) { let { newFiles: e, allowNewUpload: t, isUploadInProgress: r, isAllPaused: s, resumableUploads: o, error: a, hideUploadButton: l, hidePauseResumeButton: d, hideCancelButton: p, hideRetryButton: h, recoveredState: m, uploadState: y, totalProgress: b, files: S, supportsUploadProgress: O, hideAfterFinish: F, isSomeGhost: x, doneButtonHandler: U, isUploadStarted: H, i18n: W, startUpload: J, uppy: L, isAllComplete: G, showProgressDetails: ee, numUploads: be, complete: yt, totalSize: nt, totalETA: jt, totalUploadedSize: vt } = i; function Me() { switch (y) { case Qd: case Yd: { let re = Qn(S); return re.mode === "determinate" ? re.value * 100 : b } case ag: return null; case ou: return O ? b : null; default: return b } } n(Me, "getProgressValue"); function bt() { switch (y) { case Qd: case Yd: { let { mode: re } = Qn(S); return re === "indeterminate" } case ou: return !O; default: return !1 } } n(bt, "getIsIndeterminate"); function $e() { if (m) return !1; switch (y) { case lg: return l || e === 0; case nu: return F; default: return !1 } } n($e, "getIsHidden"); let ki = Me(), q = $e(), R = ki ?? 100, I = !a && e && !r && !s && t && !l, B = !p && y !== lg && y !== nu, Y = o && !d && y === ou, K = a && !G && !h, ye = U && y === nu, ce = (0, Jd.default)("uppy-StatusBar-progress", { "is-indeterminate": bt() }), oe = (0, Jd.default)("uppy-StatusBar", `is-${y}`, { "has-ghosts": x }); return u("div", { className: oe, "aria-hidden": q }, u("div", { className: ce, style: { width: `${R}%` }, role: "progressbar", "aria-label": `${R}%`, "aria-valuetext": `${R}%`, "aria-valuemin": "0", "aria-valuemax": "100", "aria-valuenow": ki }), (() => { switch (y) { case Yd: case Qd: return u(ig, { progress: Qn(S) }); case nu: return u(og, { i18n: W }); case ag: return u(ng, { error: a, i18n: W, numUploads: be, complete: yt }); case ou: return u(sg, { i18n: W, supportsUploadProgress: O, totalProgress: b, showProgressDetails: ee, isUploadStarted: H, isAllComplete: G, isAllPaused: s, newFiles: e, numUploads: be, complete: yt, totalUploadedSize: vt, totalSize: nt, totalETA: jt, startUpload: J }); default: return null } })(), u("div", { className: "uppy-StatusBar-actions" }, m || I ? u(Ym, { newFiles: e, isUploadStarted: H, recoveredState: m, i18n: W, isSomeGhost: x, startUpload: J, uploadState: y }) : null, K ? u(Qm, { i18n: W, uppy: L }) : null, Y ? u(Zm, { isAllPaused: s, i18n: W, isAllComplete: G, resumableUploads: o, uppy: L }) : null, B ? u(Jm, { i18n: W, uppy: L }) : null, ye ? u(eg, { i18n: W, doneButtonHandler: U }) : null)) } n(Zd, "StatusBar"); var ug = { strings: { uploading: "Uploading", complete: "Complete", uploadFailed: "Upload failed", paused: "Paused", retry: "Retry", cancel: "Cancel", pause: "Pause", resume: "Resume", done: "Done", filesUploadedOfTotal: { 0: "%{complete} of %{smart_count} file uploaded", 1: "%{complete} of %{smart_count} files uploaded" }, dataUploadedOfTotal: "%{complete} of %{total}", xTimeLeft: "%{time} left", uploadXFiles: { 0: "Upload %{smart_count} file", 1: "Upload %{smart_count} files" }, uploadXNewFiles: { 0: "Upload +%{smart_count} file", 1: "Upload +%{smart_count} files" }, upload: "Upload", retryUpload: "Retry upload", xMoreFilesAdded: { 0: "%{smart_count} more file added", 1: "%{smart_count} more files added" }, showErrorDetails: "Show error details" } }; function Re(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Re, "_classPrivateFieldLooseBase"); var Xw = 0; function Uo(i) { return "__private_" + Xw++ + "_" + i } n(Uo, "_classPrivateFieldLooseKey"); var Yw = { version: "3.2.4" }, Qw = 2e3, Jw = 2e3; function Zw(i, e, t, r) { if (i) return Ut.STATE_ERROR; if (e) return Ut.STATE_COMPLETE; if (t) return Ut.STATE_WAITING; let s = Ut.STATE_WAITING, o = Object.keys(r); for (let a = 0; a < o.length; a++) { let { progress: l } = r[o[a]]; if (l.uploadStarted && !l.uploadComplete) return Ut.STATE_UPLOADING; l.preprocess && s !== Ut.STATE_UPLOADING && (s = Ut.STATE_PREPROCESSING), l.postprocess && s !== Ut.STATE_UPLOADING && s !== Ut.STATE_PREPROCESSING && (s = Ut.STATE_POSTPROCESSING) } return s } n(Zw, "getUploadingState"); var pi = Uo("lastUpdateTime"), xi = Uo("previousUploadedBytes"), xr = Uo("previousSpeed"), ei = Uo("previousETA"), eh = Uo("computeSmoothETA"), Jn = Uo("onUploadStart"), ji = class extends Q { constructor(e, t) { super(e, t), Object.defineProperty(this, eh, { value: e2 }), Object.defineProperty(this, pi, { writable: !0, value: void 0 }), Object.defineProperty(this, xi, { writable: !0, value: void 0 }), Object.defineProperty(this, xr, { writable: !0, value: void 0 }), Object.defineProperty(this, ei, { writable: !0, value: void 0 }), this.startUpload = () => this.uppy.upload().catch(() => { }), Object.defineProperty(this, Jn, { writable: !0, value: () => { let { recoveredState: s } = this.uppy.getState(); if (Re(this, xr)[xr] = null, Re(this, ei)[ei] = null, s) { Re(this, xi)[xi] = Object.values(s.files).reduce((o, a) => { let { progress: l } = a; return o + l.bytesUploaded }, 0), this.uppy.emit("restore-confirmed"); return } Re(this, pi)[pi] = performance.now(), Re(this, xi)[xi] = 0 } }), this.id = this.opts.id || "StatusBar", this.title = "StatusBar", this.type = "progressindicator", this.defaultLocale = ug; let r = { target: "body", hideUploadButton: !1, hideRetryButton: !1, hidePauseResumeButton: !1, hideCancelButton: !1, showProgressDetails: !1, hideAfterFinish: !0, doneButtonHandler: null }; this.opts = { ...r, ...t }, this.i18nInit(), this.render = this.render.bind(this), this.install = this.install.bind(this) } render(e) { let { capabilities: t, files: r, allowNewUpload: s, totalProgress: o, error: a, recoveredState: l } = e, { newFiles: d, startedFiles: p, completeFiles: h, isUploadStarted: m, isAllComplete: y, isAllErrored: b, isAllPaused: S, isUploadInProgress: O, isSomeGhost: F } = this.uppy.getObjectOfFilesPerState(), x = l ? Object.values(r) : d, U = !!t.resumableUploads, H = t.uploadProgress !== !1, W = 0, J = 0; p.forEach(G => { W += G.progress.bytesTotal || 0, J += G.progress.bytesUploaded || 0 }); let L = Re(this, eh)[eh]({ uploaded: J, total: W, remaining: W - J }); return Zd({ error: a, uploadState: Zw(a, y, l, e.files || {}), allowNewUpload: s, totalProgress: o, totalSize: W, totalUploadedSize: J, isAllComplete: !1, isAllPaused: S, isAllErrored: b, isUploadStarted: m, isUploadInProgress: O, isSomeGhost: F, recoveredState: l, complete: h.length, newFiles: x.length, numUploads: p.length, totalETA: L, files: r, i18n: this.i18n, uppy: this.uppy, startUpload: this.startUpload, doneButtonHandler: this.opts.doneButtonHandler, resumableUploads: U, supportsUploadProgress: H, showProgressDetails: this.opts.showProgressDetails, hideUploadButton: this.opts.hideUploadButton, hideRetryButton: this.opts.hideRetryButton, hidePauseResumeButton: this.opts.hidePauseResumeButton, hideCancelButton: this.opts.hideCancelButton, hideAfterFinish: this.opts.hideAfterFinish, isTargetDOMEl: this.isTargetDOMEl }) } onMount() { let e = this.el; Bl(e) || (e.dir = "ltr") } install() { let { target: e } = this.opts; e && this.mount(e, this), this.uppy.on("upload", Re(this, Jn)[Jn]), Re(this, pi)[pi] = performance.now(), Re(this, xi)[xi] = this.uppy.getFiles().reduce((t, r) => t + r.progress.bytesUploaded, 0) } uninstall() { this.unmount(), this.uppy.off("upload", Re(this, Jn)[Jn]) } }; n(ji, "StatusBar"); function e2(i) { var e, t; if (i.total === 0 || i.remaining === 0) return 0; (t = (e = Re(this, pi))[pi]) != null || (e[pi] = performance.now()); let r = performance.now() - Re(this, pi)[pi]; if (r === 0) { var s; return Math.round(((s = Re(this, ei)[ei]) != null ? s : 0) / 100) / 10 } let o = i.uploaded - Re(this, xi)[xi]; if (Re(this, xi)[xi] = i.uploaded, o <= 0) { var a; return Math.round(((a = Re(this, ei)[ei]) != null ? a : 0) / 100) / 10 } let l = o / r, d = Re(this, xr)[xr] == null ? l : su(l, Re(this, xr)[xr], Qw, r); Re(this, xr)[xr] = d; let p = i.remaining / d, h = Math.max(Re(this, ei)[ei] - r, 0), m = Re(this, ei)[ei] == null ? p : su(p, h, Jw, r); return Re(this, ei)[ei] = m, Re(this, pi)[pi] = performance.now(), Math.round(m / 100) / 10 } n(e2, "_computeSmoothETA2"); ji.VERSION = Yw.version; var dg = 300, ko = class extends ve { constructor() { super(...arguments), this.ref = Yf() } componentWillEnter(e) { this.ref.current.style.opacity = "1", this.ref.current.style.transform = "none", setTimeout(e, dg) } componentWillLeave(e) { this.ref.current.style.opacity = "0", this.ref.current.style.transform = "translateY(350%)", setTimeout(e, dg) } render() { let { children: e } = this.props; return u("div", { className: "uppy-Informer-animated", ref: this.ref }, e) } }; n(ko, "FadeIn"); function t2(i, e) { return Object.assign(i, e) } n(t2, "assign"); function i2(i, e) { var t; return (t = i?.key) != null ? t : e } n(i2, "getKey"); function r2(i, e) { let t = i._ptgLinkedRefs || (i._ptgLinkedRefs = {}); return t[e] || (t[e] = r => { i.refs[e] = r }) } n(r2, "linkRef"); function Zn(i) { let e = {}; for (let t = 0; t < i.length; t++)if (i[t] != null) { let r = i2(i[t], t.toString(36)); e[r] = i[t] } return e } n(Zn, "getChildMapping"); function s2(i, e) { i = i || {}, e = e || {}; let t = n(a => e.hasOwnProperty(a) ? e[a] : i[a], "getValueForKey"), r = {}, s = []; for (let a in i) e.hasOwnProperty(a) ? s.length && (r[a] = s, s = []) : s.push(a); let o = {}; for (let a in e) { if (r.hasOwnProperty(a)) for (let l = 0; l < r[a].length; l++) { let d = r[a][l]; o[r[a][l]] = t(d) } o[a] = t(a) } for (let a = 0; a < s.length; a++)o[s[a]] = t(s[a]); return o } n(s2, "mergeChildMappings"); var o2 = n(i => i, "identity"), ea = class extends ve { constructor(e, t) { super(e, t), this.refs = {}, this.state = { children: Zn(ci(ci(this.props.children)) || []) }, this.performAppear = this.performAppear.bind(this), this.performEnter = this.performEnter.bind(this), this.performLeave = this.performLeave.bind(this) } componentWillMount() { this.currentlyTransitioningKeys = {}, this.keysToAbortLeave = [], this.keysToEnter = [], this.keysToLeave = [] } componentDidMount() { let e = this.state.children; for (let t in e) e[t] && this.performAppear(t) } componentWillReceiveProps(e) { let t = Zn(ci(e.children) || []), r = this.state.children; this.setState(o => ({ children: s2(o.children, t) })); let s; for (s in t) if (t.hasOwnProperty(s)) { let o = r && r.hasOwnProperty(s); t[s] && o && this.currentlyTransitioningKeys[s] ? (this.keysToEnter.push(s), this.keysToAbortLeave.push(s)) : t[s] && !o && !this.currentlyTransitioningKeys[s] && this.keysToEnter.push(s) } for (s in r) if (r.hasOwnProperty(s)) { let o = t && t.hasOwnProperty(s); r[s] && !o && !this.currentlyTransitioningKeys[s] && this.keysToLeave.push(s) } } componentDidUpdate() { let { keysToEnter: e } = this; this.keysToEnter = [], e.forEach(this.performEnter); let { keysToLeave: t } = this; this.keysToLeave = [], t.forEach(this.performLeave) } _finishAbort(e) { let t = this.keysToAbortLeave.indexOf(e); t !== -1 && this.keysToAbortLeave.splice(t, 1) } performAppear(e) { this.currentlyTransitioningKeys[e] = !0; let t = this.refs[e]; t != null && t.componentWillAppear ? t.componentWillAppear(this._handleDoneAppearing.bind(this, e)) : this._handleDoneAppearing(e) } _handleDoneAppearing(e) { let t = this.refs[e]; t != null && t.componentDidAppear && t.componentDidAppear(), delete this.currentlyTransitioningKeys[e], this._finishAbort(e); let r = Zn(ci(this.props.children) || []); (!r || !r.hasOwnProperty(e)) && this.performLeave(e) } performEnter(e) { this.currentlyTransitioningKeys[e] = !0; let t = this.refs[e]; t != null && t.componentWillEnter ? t.componentWillEnter(this._handleDoneEntering.bind(this, e)) : this._handleDoneEntering(e) } _handleDoneEntering(e) { let t = this.refs[e]; t != null && t.componentDidEnter && t.componentDidEnter(), delete this.currentlyTransitioningKeys[e], this._finishAbort(e); let r = Zn(ci(this.props.children) || []); (!r || !r.hasOwnProperty(e)) && this.performLeave(e) } performLeave(e) { if (this.keysToAbortLeave.indexOf(e) !== -1) return; this.currentlyTransitioningKeys[e] = !0; let r = this.refs[e]; r != null && r.componentWillLeave ? r.componentWillLeave(this._handleDoneLeaving.bind(this, e)) : this._handleDoneLeaving(e) } _handleDoneLeaving(e) { if (this.keysToAbortLeave.indexOf(e) !== -1) return; let r = this.refs[e]; r != null && r.componentDidLeave && r.componentDidLeave(), delete this.currentlyTransitioningKeys[e]; let s = Zn(ci(this.props.children) || []); if (s && s.hasOwnProperty(e)) this.performEnter(e); else { let o = t2({}, this.state.children); delete o[e], this.setState({ children: o }) } } render(e, t) { let { childFactory: r, transitionLeave: s, transitionName: o, transitionAppear: a, transitionEnter: l, transitionLeaveTimeout: d, transitionEnterTimeout: p, transitionAppearTimeout: h, component: m, ...y } = e, { children: b } = t, S = Object.entries(b).map(O => { let [F, x] = O; if (!x) return; let U = r2(this, F); return Ml(r(x), { ref: U, key: F }) }).filter(Boolean); return u(m, y, S) } }; n(ea, "TransitionGroup"); ea.defaultProps = { component: "span", childFactory: o2 }; var hg = ea; var n2 = { version: "3.0.3" }, zi = class extends Q {
        constructor(e, t) {
            super(e, t), this.render = s => u("div", { className: "uppy uppy-Informer" }, u(hg, null, s.info.map(o => u(ko, { key: o.message }, u("p", { role: "alert" }, o.message, " ", o.details && u("span", {
                "aria-label": o.details, "data-microtip-position": "top-left", "data-microtip-size": "medium", role: "tooltip", onClick: () => alert(`${o.message}

 ${o.details}`)
            }, "?")))))), this.type = "progressindicator", this.id = this.opts.id || "Informer", this.title = "Informer"; let r = {}; this.opts = { ...r, ...t }
        } install() { let { target: e } = this.opts; e && this.mount(e, this) }
    }; n(zi, "Informer"); zi.VERSION = n2.version; var a2 = /^data:([^/]+\/[^,;]+(?:[^,]*?))(;base64)?,([\s\S]*)$/; function th(i, e, t) { var r, s; let o = a2.exec(i), a = (r = (s = e.mimeType) != null ? s : o?.[1]) != null ? r : "plain/text", l; if (o[2] != null) { let d = atob(decodeURIComponent(o[3])), p = new Uint8Array(d.length); for (let h = 0; h < d.length; h++)p[h] = d.charCodeAt(h); l = [p] } else l = [decodeURIComponent(o[3])]; return t ? new File(l, e.name || "", { type: a }) : new Blob(l, { type: a }) } n(th, "dataURItoBlob"); function au(i) { return i.startsWith("blob:") } n(au, "isObjectURL"); function ge(i, e, t) { return e in i ? Object.defineProperty(i, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = t, i } n(ge, "e"); var wg = typeof self < "u" ? self : global, oa = typeof navigator < "u", l2 = oa && typeof HTMLImageElement > "u", cg = !(typeof global > "u" || typeof process > "u" || !process.versions || !process.versions.node), Sg = wg.Buffer, Pg = !!Sg, u2 = n(i => i !== void 0, "h"); function _g(i) { return i === void 0 || (i instanceof Map ? i.size === 0 : Object.values(i).filter(u2).length === 0) } n(_g, "f"); function ot(i) { let e = new Error(i); throw delete e.stack, e } n(ot, "l"); function pg(i) { let e = function (t) { let r = 0; return t.ifd0.enabled && (r += 1024), t.exif.enabled && (r += 2048), t.makerNote && (r += 2048), t.userComment && (r += 1024), t.gps.enabled && (r += 512), t.interop.enabled && (r += 100), t.ifd1.enabled && (r += 1024), r + 2048 }(i); return i.jfif.enabled && (e += 50), i.xmp.enabled && (e += 2e4), i.iptc.enabled && (e += 14e3), i.icc.enabled && (e += 6e3), e } n(pg, "o"); var ih = n(i => String.fromCharCode.apply(null, i), "u"), fg = typeof TextDecoder < "u" ? new TextDecoder("utf-8") : void 0, qt = class { static from(e, t) { return e instanceof this && e.le === t ? e : new qt(e, void 0, void 0, t) } constructor(e, t = 0, r, s) { if (typeof s == "boolean" && (this.le = s), Array.isArray(e) && (e = new Uint8Array(e)), e === 0) this.byteOffset = 0, this.byteLength = 0; else if (e instanceof ArrayBuffer) { r === void 0 && (r = e.byteLength - t); let o = new DataView(e, t, r); this._swapDataView(o) } else if (e instanceof Uint8Array || e instanceof DataView || e instanceof qt) { r === void 0 && (r = e.byteLength - t), (t += e.byteOffset) + r > e.byteOffset + e.byteLength && ot("Creating view outside of available memory in ArrayBuffer"); let o = new DataView(e.buffer, t, r); this._swapDataView(o) } else if (typeof e == "number") { let o = new DataView(new ArrayBuffer(e)); this._swapDataView(o) } else ot("Invalid input argument for BufferView: " + e) } _swapArrayBuffer(e) { this._swapDataView(new DataView(e)) } _swapBuffer(e) { this._swapDataView(new DataView(e.buffer, e.byteOffset, e.byteLength)) } _swapDataView(e) { this.dataView = e, this.buffer = e.buffer, this.byteOffset = e.byteOffset, this.byteLength = e.byteLength } _lengthToEnd(e) { return this.byteLength - e } set(e, t, r = qt) { return e instanceof DataView || e instanceof qt ? e = new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e instanceof ArrayBuffer && (e = new Uint8Array(e)), e instanceof Uint8Array || ot("BufferView.set(): Invalid data argument."), this.toUint8().set(e, t), new r(this, t, e.byteLength) } subarray(e, t) { return t = t || this._lengthToEnd(e), new qt(this, e, t) } toUint8() { return new Uint8Array(this.buffer, this.byteOffset, this.byteLength) } getUint8Array(e, t) { return new Uint8Array(this.buffer, this.byteOffset + e, t) } getString(e = 0, t = this.byteLength) { return s = this.getUint8Array(e, t), fg ? fg.decode(s) : Pg ? Buffer.from(s).toString("utf8") : decodeURIComponent(escape(ih(s))); var s } getLatin1String(e = 0, t = this.byteLength) { let r = this.getUint8Array(e, t); return ih(r) } getUnicodeString(e = 0, t = this.byteLength) { let r = []; for (let s = 0; s < t && e + s < this.byteLength; s += 2)r.push(this.getUint16(e + s)); return ih(r) } getInt8(e) { return this.dataView.getInt8(e) } getUint8(e) { return this.dataView.getUint8(e) } getInt16(e, t = this.le) { return this.dataView.getInt16(e, t) } getInt32(e, t = this.le) { return this.dataView.getInt32(e, t) } getUint16(e, t = this.le) { return this.dataView.getUint16(e, t) } getUint32(e, t = this.le) { return this.dataView.getUint32(e, t) } getFloat32(e, t = this.le) { return this.dataView.getFloat32(e, t) } getFloat64(e, t = this.le) { return this.dataView.getFloat64(e, t) } getFloat(e, t = this.le) { return this.dataView.getFloat32(e, t) } getDouble(e, t = this.le) { return this.dataView.getFloat64(e, t) } getUintBytes(e, t, r) { switch (t) { case 1: return this.getUint8(e, r); case 2: return this.getUint16(e, r); case 4: return this.getUint32(e, r); case 8: return this.getUint64 && this.getUint64(e, r) } } getUint(e, t, r) { switch (t) { case 8: return this.getUint8(e, r); case 16: return this.getUint16(e, r); case 32: return this.getUint32(e, r); case 64: return this.getUint64 && this.getUint64(e, r) } } toString(e) { return this.dataView.toString(e, this.constructor.name) } ensureChunk() { } }; n(qt, "c"); function sh(i, e) { ot(`${i} '${e}' was not loaded, try using full build of exifr.`) } n(sh, "p"); var Bo = class extends Map { constructor(e) { super(), this.kind = e } get(e, t) { return this.has(e) || sh(this.kind, e), t && (e in t || function (r, s) { ot(`Unknown ${r} '${s}'.`) }(this.kind, e), t[e].enabled || sh(this.kind, e)), super.get(e) } keyList() { return Array.from(this.keys()) } }; n(Bo, "g"); var mu = new Bo("file parser"), ti = new Bo("segment parser"), la = new Bo("file reader"), d2 = wg.fetch; function mg(i, e) { return (t = i).startsWith("data:") || t.length > 1e4 ? nh(i, e, "base64") : cg && i.includes("://") ? oh(i, e, "url", pu) : cg ? nh(i, e, "fs") : oa ? oh(i, e, "url", pu) : void ot("Invalid input argument"); var t } n(mg, "k"); async function oh(i, e, t, r) { return la.has(t) ? nh(i, e, t) : r ? async function (s, o) { let a = await o(s); return new qt(a) }(i, r) : void ot(`Parser ${t} is not loaded`) } n(oh, "O"); async function nh(i, e, t) { let r = new (la.get(t))(i, e); return await r.read(), r } n(nh, "v"); var pu = n(i => d2(i).then(e => e.arrayBuffer()), "S"), na = n(i => new Promise((e, t) => { let r = new FileReader; r.onloadend = () => e(r.result || new ArrayBuffer), r.onerror = t, r.readAsArrayBuffer(i) }), "A"), lu = class extends Map { get tagKeys() { return this.allKeys || (this.allKeys = Array.from(this.keys())), this.allKeys } get tagValues() { return this.allValues || (this.allValues = Array.from(this.values())), this.allValues } }; n(lu, "U"); function Fg(i, e, t) { let r = new lu; for (let [s, o] of t) r.set(s, o); if (Array.isArray(e)) for (let s of e) i.set(s, r); else i.set(e, r); return r } n(Fg, "x"); function xg(i, e, t) { let r, s = i.get(e); for (r of t) s.set(r[0], r[1]) } n(xg, "C"); var ua = new Map, ah = new Map, lh = new Map, Do = ["chunked", "firstChunkSize", "firstChunkSizeNode", "firstChunkSizeBrowser", "chunkSize", "chunkLimit"], gu = ["jfif", "xmp", "icc", "iptc", "ihdr"], aa = ["tiff", ...gu], Ge = ["ifd0", "ifd1", "exif", "gps", "interop"], Io = [...aa, ...Ge], No = ["makerNote", "userComment"], yu = ["translateKeys", "translateValues", "reviveValues", "multiSegment"], Mo = [...yu, "sanitize", "mergeOutput", "silentErrors"], ra = class { get translate() { return this.translateKeys || this.translateValues || this.reviveValues } }; n(ra, "_"); var es = class extends ra { get needed() { return this.enabled || this.deps.size > 0 } constructor(e, t, r, s) { if (super(), ge(this, "enabled", !1), ge(this, "skip", new Set), ge(this, "pick", new Set), ge(this, "deps", new Set), ge(this, "translateKeys", !1), ge(this, "translateValues", !1), ge(this, "reviveValues", !1), this.key = e, this.enabled = t, this.parse = this.enabled, this.applyInheritables(s), this.canBeFiltered = Ge.includes(e), this.canBeFiltered && (this.dict = ua.get(e)), r !== void 0) if (Array.isArray(r)) this.parse = this.enabled = !0, this.canBeFiltered && r.length > 0 && this.translateTagSet(r, this.pick); else if (typeof r == "object") { if (this.enabled = !0, this.parse = r.parse !== !1, this.canBeFiltered) { let { pick: o, skip: a } = r; o && o.length > 0 && this.translateTagSet(o, this.pick), a && a.length > 0 && this.translateTagSet(a, this.skip) } this.applyInheritables(r) } else r === !0 || r === !1 ? this.parse = this.enabled = r : ot(`Invalid options argument: ${r}`) } applyInheritables(e) { let t, r; for (t of yu) r = e[t], r !== void 0 && (this[t] = r) } translateTagSet(e, t) { if (this.dict) { let r, s, { tagKeys: o, tagValues: a } = this.dict; for (r of e) typeof r == "string" ? (s = a.indexOf(r), s === -1 && (s = o.indexOf(Number(r))), s !== -1 && t.add(Number(o[s]))) : t.add(r) } else for (let r of e) t.add(r) } finalizeFilters() { !this.enabled && this.deps.size > 0 ? (this.enabled = !0, fu(this.pick, this.deps)) : this.enabled && this.pick.size > 0 && fu(this.pick, this.deps) } }; n(es, "D"); var kt = { jfif: !1, tiff: !0, xmp: !1, icc: !1, iptc: !1, ifd0: !0, ifd1: !1, exif: !0, gps: !0, interop: !1, ihdr: void 0, makerNote: !1, userComment: !1, multiSegment: !1, skip: [], pick: [], translateKeys: !0, translateValues: !0, reviveValues: !0, sanitize: !0, mergeOutput: !0, silentErrors: !0, chunked: !0, firstChunkSize: void 0, firstChunkSizeNode: 512, firstChunkSizeBrowser: 65536, chunkSize: 65536, chunkLimit: 5 }, gg = new Map, ts = class extends ra { static useCached(e) { let t = gg.get(e); return t !== void 0 || (t = new this(e), gg.set(e, t)), t } constructor(e) { super(), e === !0 ? this.setupFromTrue() : e === void 0 ? this.setupFromUndefined() : Array.isArray(e) ? this.setupFromArray(e) : typeof e == "object" ? this.setupFromObject(e) : ot(`Invalid options argument ${e}`), this.firstChunkSize === void 0 && (this.firstChunkSize = oa ? this.firstChunkSizeBrowser : this.firstChunkSizeNode), this.mergeOutput && (this.ifd1.enabled = !1), this.filterNestedSegmentTags(), this.traverseTiffDependencyTree(), this.checkLoadedPlugins() } setupFromUndefined() { let e; for (e of Do) this[e] = kt[e]; for (e of Mo) this[e] = kt[e]; for (e of No) this[e] = kt[e]; for (e of Io) this[e] = new es(e, kt[e], void 0, this) } setupFromTrue() { let e; for (e of Do) this[e] = kt[e]; for (e of Mo) this[e] = kt[e]; for (e of No) this[e] = !0; for (e of Io) this[e] = new es(e, !0, void 0, this) } setupFromArray(e) { let t; for (t of Do) this[t] = kt[t]; for (t of Mo) this[t] = kt[t]; for (t of No) this[t] = kt[t]; for (t of Io) this[t] = new es(t, !1, void 0, this); this.setupGlobalFilters(e, void 0, Ge) } setupFromObject(e) { let t; for (t of (Ge.ifd0 = Ge.ifd0 || Ge.image, Ge.ifd1 = Ge.ifd1 || Ge.thumbnail, Object.assign(this, e), Do)) this[t] = rh(e[t], kt[t]); for (t of Mo) this[t] = rh(e[t], kt[t]); for (t of No) this[t] = rh(e[t], kt[t]); for (t of aa) this[t] = new es(t, kt[t], e[t], this); for (t of Ge) this[t] = new es(t, kt[t], e[t], this.tiff); this.setupGlobalFilters(e.pick, e.skip, Ge, Io), e.tiff === !0 ? this.batchEnableWithBool(Ge, !0) : e.tiff === !1 ? this.batchEnableWithUserValue(Ge, e) : Array.isArray(e.tiff) ? this.setupGlobalFilters(e.tiff, void 0, Ge) : typeof e.tiff == "object" && this.setupGlobalFilters(e.tiff.pick, e.tiff.skip, Ge) } batchEnableWithBool(e, t) { for (let r of e) this[r].enabled = t } batchEnableWithUserValue(e, t) { for (let r of e) { let s = t[r]; this[r].enabled = s !== !1 && s !== void 0 } } setupGlobalFilters(e, t, r, s = r) { if (e && e.length) { for (let a of s) this[a].enabled = !1; let o = yg(e, r); for (let [a, l] of o) fu(this[a].pick, l), this[a].enabled = !0 } else if (t && t.length) { let o = yg(t, r); for (let [a, l] of o) fu(this[a].skip, l) } } filterNestedSegmentTags() { let { ifd0: e, exif: t, xmp: r, iptc: s, icc: o } = this; this.makerNote ? t.deps.add(37500) : t.skip.add(37500), this.userComment ? t.deps.add(37510) : t.skip.add(37510), r.enabled || e.skip.add(700), s.enabled || e.skip.add(33723), o.enabled || e.skip.add(34675) } traverseTiffDependencyTree() { let { ifd0: e, exif: t, gps: r, interop: s } = this; s.needed && (t.deps.add(40965), e.deps.add(40965)), t.needed && e.deps.add(34665), r.needed && e.deps.add(34853), this.tiff.enabled = Ge.some(o => this[o].enabled === !0) || this.makerNote || this.userComment; for (let o of Ge) this[o].finalizeFilters() } get onlyTiff() { return !gu.map(e => this[e].enabled).some(e => e === !0) && this.tiff.enabled } checkLoadedPlugins() { for (let e of aa) this[e].enabled && !ti.has(e) && sh("segment parser", e) } }; n(ts, "R"); function yg(i, e) { let t, r, s, o, a = []; for (s of e) { for (o of (t = ua.get(s), r = [], t)) (i.includes(o[0]) || i.includes(o[1])) && r.push(o[0]); r.length && a.push([s, r]) } return a } n(yg, "K"); function rh(i, e) { return i !== void 0 ? i : e !== void 0 ? e : void 0 } n(rh, "W"); function fu(i, e) { for (let t of e) i.add(t) } n(fu, "X"); ge(ts, "default", kt); var Es = class { constructor(e) { ge(this, "parsers", {}), ge(this, "output", {}), ge(this, "errors", []), ge(this, "pushToErrors", t => this.errors.push(t)), this.options = ts.useCached(e) } async read(e) { this.file = await function (t, r) { return typeof t == "string" ? mg(t, r) : oa && !l2 && t instanceof HTMLImageElement ? mg(t.src, r) : t instanceof Uint8Array || t instanceof ArrayBuffer || t instanceof DataView ? new qt(t) : oa && t instanceof Blob ? oh(t, r, "blob", na) : void ot("Invalid input argument") }(e, this.options) } setup() { if (this.fileParser) return; let { file: e } = this, t = e.getUint16(0); for (let [r, s] of mu) if (s.canHandle(e, t)) return this.fileParser = new s(this.options, this.file, this.parsers), e[r] = !0; this.file.close && this.file.close(), ot("Unknown file format") } async parse() { let { output: e, errors: t } = this; return this.setup(), this.options.silentErrors ? (await this.executeParsers().catch(this.pushToErrors), t.push(...this.fileParser.errors)) : await this.executeParsers(), this.file.close && this.file.close(), this.options.silentErrors && t.length > 0 && (e.errors = t), _g(r = e) ? void 0 : r; var r } async executeParsers() { let { output: e } = this; await this.fileParser.parse(); let t = Object.values(this.parsers).map(async r => { let s = await r.parse(); r.assignToOutput(e, s) }); this.options.silentErrors && (t = t.map(r => r.catch(this.pushToErrors))), await Promise.all(t) } async extractThumbnail() { this.setup(); let { options: e, file: t } = this, r = ti.get("tiff", e); var s; if (t.tiff ? s = { start: 0, type: "tiff" } : t.jpeg && (s = await this.fileParser.getOrFindSegment("tiff")), s === void 0) return; let o = await this.fileParser.ensureSegmentChunk(s), a = this.parsers.tiff = new r(o, e, t), l = await a.extractThumbnail(); return t.close && t.close(), l } }; n(Es, "H"); async function Og(i, e) { let t = new Es(e); return await t.read(i), t.parse() } n(Og, "Y"); var h2 = Object.freeze({ __proto__: null, parse: Og, Exifr: Es, fileParsers: mu, segmentParsers: ti, fileReaders: la, tagKeys: ua, tagValues: ah, tagRevivers: lh, createDictionary: Fg, extendDictionary: xg, fetchUrlAsArrayBuffer: pu, readBlobAsArrayBuffer: na, chunkedProps: Do, otherSegments: gu, segments: aa, tiffBlocks: Ge, segmentsAndBlocks: Io, tiffExtractables: No, inheritables: yu, allFormatters: Mo, Options: ts }), Or = class { static findPosition(e, t) { let r = e.getUint16(t + 2) + 2, s = typeof this.headerLength == "function" ? this.headerLength(e, t, r) : this.headerLength, o = t + s, a = r - s; return { offset: t, length: r, headerLength: s, start: o, size: a, end: o + a } } static parse(e, t = {}) { return new this(e, new ts({ [this.type]: t }), e).parse() } normalizeInput(e) { return e instanceof qt ? e : new qt(e) } constructor(e, t = {}, r) { ge(this, "errors", []), ge(this, "raw", new Map), ge(this, "handleError", s => { if (!this.options.silentErrors) throw s; this.errors.push(s.message) }), this.chunk = this.normalizeInput(e), this.file = r, this.type = this.constructor.type, this.globalOptions = this.options = t, this.localOptions = t[this.type], this.canTranslate = this.localOptions && this.localOptions.translate } translate() { this.canTranslate && (this.translated = this.translateBlock(this.raw, this.type)) } get output() { return this.translated ? this.translated : this.raw ? Object.fromEntries(this.raw) : void 0 } translateBlock(e, t) { let r = lh.get(t), s = ah.get(t), o = ua.get(t), a = this.options[t], l = a.reviveValues && !!r, d = a.translateValues && !!s, p = a.translateKeys && !!o, h = {}; for (let [m, y] of e) l && r.has(m) ? y = r.get(m)(y) : d && s.has(m) && (y = this.translateValue(y, s.get(m))), p && o.has(m) && (m = o.get(m) || m), h[m] = y; return h } translateValue(e, t) { return t[e] || t.DEFAULT || e } assignToOutput(e, t) { this.assignObjectToOutput(e, this.constructor.type, t) } assignObjectToOutput(e, t, r) { if (this.globalOptions.mergeOutput) return Object.assign(e, r); e[t] ? Object.assign(e[t], r) : e[t] = r } }; n(Or, "J"); ge(Or, "headerLength", 4), ge(Or, "type", void 0), ge(Or, "multiSegment", !1), ge(Or, "canHandle", () => !1); function c2(i) { return i === 192 || i === 194 || i === 196 || i === 219 || i === 221 || i === 218 || i === 254 } n(c2, "q"); function p2(i) { return i >= 224 && i <= 239 } n(p2, "Q"); function f2(i, e, t) { for (let [r, s] of ti) if (s.canHandle(i, e, t)) return r } n(f2, "Z"); var sa = class extends class { constructor(e, t, r) { ge(this, "errors", []), ge(this, "ensureSegmentChunk", async s => { let o = s.start, a = s.size || 65536; if (this.file.chunked) if (this.file.available(o, a)) s.chunk = this.file.subarray(o, a); else try { s.chunk = await this.file.readChunk(o, a) } catch (l) { ot(`Couldn't read segment: ${JSON.stringify(s)}. ${l.message}`) } else this.file.byteLength > o + a ? s.chunk = this.file.subarray(o, a) : s.size === void 0 ? s.chunk = this.file.subarray(o) : ot("Segment unreachable: " + JSON.stringify(s)); return s.chunk }), this.extendOptions && this.extendOptions(e), this.options = e, this.file = t, this.parsers = r } injectSegment(e, t) { this.options[e].enabled && this.createParser(e, t) } createParser(e, t) { let r = new (ti.get(e))(t, this.options, this.file); return this.parsers[e] = r } createParsers(e) { for (let t of e) { let { type: r, chunk: s } = t, o = this.options[r]; if (o && o.enabled) { let a = this.parsers[r]; a && a.append || a || this.createParser(r, s) } } } async readSegments(e) { let t = e.map(this.ensureSegmentChunk); await Promise.all(t) } }{ constructor(...e) { super(...e), ge(this, "appSegments", []), ge(this, "jpegSegments", []), ge(this, "unknownSegments", []) } static canHandle(e, t) { return t === 65496 } async parse() { await this.findAppSegments(), await this.readSegments(this.appSegments), this.mergeMultiSegments(), this.createParsers(this.mergedAppSegments || this.appSegments) } setupSegmentFinderArgs(e) { e === !0 ? (this.findAll = !0, this.wanted = new Set(ti.keyList())) : (e = e === void 0 ? ti.keyList().filter(t => this.options[t].enabled) : e.filter(t => this.options[t].enabled && ti.has(t)), this.findAll = !1, this.remaining = new Set(e), this.wanted = new Set(e)), this.unfinishedMultiSegment = !1 } async findAppSegments(e = 0, t) { this.setupSegmentFinderArgs(t); let { file: r, findAll: s, wanted: o, remaining: a } = this; if (!s && this.file.chunked && (s = Array.from(o).some(l => { let d = ti.get(l), p = this.options[l]; return d.multiSegment && p.multiSegment }), s && await this.file.readWhole()), e = this.findAppSegmentsInRange(e, r.byteLength), !this.options.onlyTiff && r.chunked) { let l = !1; for (; a.size > 0 && !l && (r.canReadNextChunk || this.unfinishedMultiSegment);) { let { nextChunkOffset: d } = r, p = this.appSegments.some(h => !this.file.available(h.offset || h.start, h.length || h.size)); if (l = e > d && !p ? !await r.readNextChunk(e) : !await r.readNextChunk(d), (e = this.findAppSegmentsInRange(e, r.byteLength)) === void 0) return } } } findAppSegmentsInRange(e, t) { t -= 2; let r, s, o, a, l, d, { file: p, findAll: h, wanted: m, remaining: y, options: b } = this; for (; e < t; e++)if (p.getUint8(e) === 255) { if (r = p.getUint8(e + 1), p2(r)) { if (s = p.getUint16(e + 2), o = f2(p, e, s), o && m.has(o) && (a = ti.get(o), l = a.findPosition(p, e), d = b[o], l.type = o, this.appSegments.push(l), !h && (a.multiSegment && d.multiSegment ? (this.unfinishedMultiSegment = l.chunkNumber < l.chunkCount, this.unfinishedMultiSegment || y.delete(o)) : y.delete(o), y.size === 0))) break; b.recordUnknownSegments && (l = Or.findPosition(p, e), l.marker = r, this.unknownSegments.push(l)), e += s + 1 } else if (c2(r)) { if (s = p.getUint16(e + 2), r === 218 && b.stopAfterSos !== !1) return; b.recordJpegSegments && this.jpegSegments.push({ offset: e, length: s, marker: r }), e += s + 1 } } return e } mergeMultiSegments() { if (!this.appSegments.some(t => t.multiSegment)) return; let e = function (t, r) { let s, o, a, l = new Map; for (let d = 0; d < t.length; d++)s = t[d], o = s[r], l.has(o) ? a = l.get(o) : l.set(o, a = []), a.push(s); return Array.from(l) }(this.appSegments, "type"); this.mergedAppSegments = e.map(([t, r]) => { let s = ti.get(t, this.options); return s.handleMultiSegments ? { type: t, chunk: s.handleMultiSegments(r) } : r[0] }) } getSegment(e) { return this.appSegments.find(t => t.type === e) } async getOrFindSegment(e) { let t = this.getSegment(e); return t === void 0 && (await this.findAppSegments(0, [e]), t = this.getSegment(e)), t } }; n(sa, "ee"); ge(sa, "type", "jpeg"), mu.set("jpeg", sa); var m2 = [void 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, 4], uu = class extends Or { parseHeader() { var e = this.chunk.getUint16(); e === 18761 ? this.le = !0 : e === 19789 && (this.le = !1), this.chunk.le = this.le, this.headerParsed = !0 } parseTags(e, t, r = new Map) { let { pick: s, skip: o } = this.options[t]; s = new Set(s); let a = s.size > 0, l = o.size === 0, d = this.chunk.getUint16(e); e += 2; for (let p = 0; p < d; p++) { let h = this.chunk.getUint16(e); if (a) { if (s.has(h) && (r.set(h, this.parseTag(e, h, t)), s.delete(h), s.size === 0)) break } else !l && o.has(h) || r.set(h, this.parseTag(e, h, t)); e += 12 } return r } parseTag(e, t, r) { let { chunk: s } = this, o = s.getUint16(e + 2), a = s.getUint32(e + 4), l = m2[o]; if (l * a <= 4 ? e += 8 : e = s.getUint32(e + 8), (o < 1 || o > 13) && ot(`Invalid TIFF value type. block: ${r.toUpperCase()}, tag: ${t.toString(16)}, type: ${o}, offset ${e}`), e > s.byteLength && ot(`Invalid TIFF value offset. block: ${r.toUpperCase()}, tag: ${t.toString(16)}, type: ${o}, offset ${e} is outside of chunk size ${s.byteLength}`), o === 1) return s.getUint8Array(e, a); if (o === 2) return (d = function (p) { for (; p.endsWith("\0");)p = p.slice(0, -1); return p }(d = s.getString(e, a)).trim()) === "" ? void 0 : d; var d; if (o === 7) return s.getUint8Array(e, a); if (a === 1) return this.parseTagValue(o, e); { let p = new (function (m) { switch (m) { case 1: return Uint8Array; case 3: return Uint16Array; case 4: return Uint32Array; case 5: return Array; case 6: return Int8Array; case 8: return Int16Array; case 9: return Int32Array; case 10: return Array; case 11: return Float32Array; case 12: return Float64Array; default: return Array } }(o))(a), h = l; for (let m = 0; m < a; m++)p[m] = this.parseTagValue(o, e), e += h; return p } } parseTagValue(e, t) { let { chunk: r } = this; switch (e) { case 1: return r.getUint8(t); case 3: return r.getUint16(t); case 4: return r.getUint32(t); case 5: return r.getUint32(t) / r.getUint32(t + 4); case 6: return r.getInt8(t); case 8: return r.getInt16(t); case 9: return r.getInt32(t); case 10: return r.getInt32(t) / r.getInt32(t + 4); case 11: return r.getFloat(t); case 12: return r.getDouble(t); case 13: return r.getUint32(t); default: ot(`Invalid tiff type ${e}`) } } }; n(uu, "se"); var Lo = class extends uu {
        static canHandle(e, t) { return e.getUint8(t + 1) === 225 && e.getUint32(t + 4) === 1165519206 && e.getUint16(t + 8) === 0 } async parse() { this.parseHeader(); let { options: e } = this; return e.ifd0.enabled && await this.parseIfd0Block(), e.exif.enabled && await this.safeParse("parseExifBlock"), e.gps.enabled && await this.safeParse("parseGpsBlock"), e.interop.enabled && await this.safeParse("parseInteropBlock"), e.ifd1.enabled && await this.safeParse("parseThumbnailBlock"), this.createOutput() } safeParse(e) { let t = this[e](); return t.catch !== void 0 && (t = t.catch(this.handleError)), t } findIfd0Offset() { this.ifd0Offset === void 0 && (this.ifd0Offset = this.chunk.getUint32(4)) } findIfd1Offset() { if (this.ifd1Offset === void 0) { this.findIfd0Offset(); let e = this.chunk.getUint16(this.ifd0Offset), t = this.ifd0Offset + 2 + 12 * e; this.ifd1Offset = this.chunk.getUint32(t) } } parseBlock(e, t) { let r = new Map; return this[t] = r, this.parseTags(e, t, r), r } async parseIfd0Block() {
            if (this.ifd0) return; let { file: e } = this; this.findIfd0Offset(), this.ifd0Offset < 8 && ot("Malformed EXIF data"), !e.chunked && this.ifd0Offset > e.byteLength && ot(`IFD0 offset points to outside of file.
this.ifd0Offset: ${this.ifd0Offset}, file.byteLength: ${e.byteLength}`), e.tiff && await e.ensureChunk(this.ifd0Offset, pg(this.options)); let t = this.parseBlock(this.ifd0Offset, "ifd0"); return t.size !== 0 ? (this.exifOffset = t.get(34665), this.interopOffset = t.get(40965), this.gpsOffset = t.get(34853), this.xmp = t.get(700), this.iptc = t.get(33723), this.icc = t.get(34675), this.options.sanitize && (t.delete(34665), t.delete(40965), t.delete(34853), t.delete(700), t.delete(33723), t.delete(34675)), t) : void 0
        } async parseExifBlock() { if (this.exif || (this.ifd0 || await this.parseIfd0Block(), this.exifOffset === void 0)) return; this.file.tiff && await this.file.ensureChunk(this.exifOffset, pg(this.options)); let e = this.parseBlock(this.exifOffset, "exif"); return this.interopOffset || (this.interopOffset = e.get(40965)), this.makerNote = e.get(37500), this.userComment = e.get(37510), this.options.sanitize && (e.delete(40965), e.delete(37500), e.delete(37510)), this.unpack(e, 41728), this.unpack(e, 41729), e } unpack(e, t) { let r = e.get(t); r && r.length === 1 && e.set(t, r[0]) } async parseGpsBlock() { if (this.gps || (this.ifd0 || await this.parseIfd0Block(), this.gpsOffset === void 0)) return; let e = this.parseBlock(this.gpsOffset, "gps"); return e && e.has(2) && e.has(4) && (e.set("latitude", vg(...e.get(2), e.get(1))), e.set("longitude", vg(...e.get(4), e.get(3)))), e } async parseInteropBlock() { if (!this.interop && (this.ifd0 || await this.parseIfd0Block(), this.interopOffset !== void 0 || this.exif || await this.parseExifBlock(), this.interopOffset !== void 0)) return this.parseBlock(this.interopOffset, "interop") } async parseThumbnailBlock(e = !1) { if (!this.ifd1 && !this.ifd1Parsed && (!this.options.mergeOutput || e)) return this.findIfd1Offset(), this.ifd1Offset > 0 && (this.parseBlock(this.ifd1Offset, "ifd1"), this.ifd1Parsed = !0), this.ifd1 } async extractThumbnail() { if (this.headerParsed || this.parseHeader(), this.ifd1Parsed || await this.parseThumbnailBlock(!0), this.ifd1 === void 0) return; let e = this.ifd1.get(513), t = this.ifd1.get(514); return this.chunk.getUint8Array(e, t) } get image() { return this.ifd0 } get thumbnail() { return this.ifd1 } createOutput() { let e, t, r, s = {}; for (t of Ge) if (e = this[t], !_g(e)) if (r = this.canTranslate ? this.translateBlock(e, t) : Object.fromEntries(e), this.options.mergeOutput) { if (t === "ifd1") continue; Object.assign(s, r) } else s[t] = r; return this.makerNote && (s.makerNote = this.makerNote), this.userComment && (s.userComment = this.userComment), s } assignToOutput(e, t) { if (this.globalOptions.mergeOutput) Object.assign(e, t); else for (let [r, s] of Object.entries(t)) this.assignObjectToOutput(e, r, s) }
    }; n(Lo, "ie"); function vg(i, e, t, r) { var s = i + e / 60 + t / 3600; return r !== "S" && r !== "W" || (s *= -1), s } n(vg, "ne"); ge(Lo, "type", "tiff"), ge(Lo, "headerLength", 10), ti.set("tiff", Lo); var qC = Object.freeze({ __proto__: null, default: h2, Exifr: Es, fileParsers: mu, segmentParsers: ti, fileReaders: la, tagKeys: ua, tagValues: ah, tagRevivers: lh, createDictionary: Fg, extendDictionary: xg, fetchUrlAsArrayBuffer: pu, readBlobAsArrayBuffer: na, chunkedProps: Do, otherSegments: gu, segments: aa, tiffBlocks: Ge, segmentsAndBlocks: Io, tiffExtractables: No, inheritables: yu, allFormatters: Mo, Options: ts, parse: Og }), uh = { ifd0: !1, ifd1: !1, exif: !1, gps: !1, interop: !1, sanitize: !1, reviveValues: !0, translateKeys: !1, translateValues: !1, mergeOutput: !1 }, VC = Object.assign({}, uh, { firstChunkSize: 4e4, gps: [1, 2, 3, 4] }); var WC = Object.assign({}, uh, { tiff: !1, ifd1: !0, mergeOutput: !1 }); var g2 = Object.assign({}, uh, { firstChunkSize: 4e4, ifd0: [274] }); async function y2(i) { let e = new Es(g2); await e.read(i); let t = await e.parse(); if (t && t.ifd0) return t.ifd0[274] } n(y2, "ce"); var v2 = Object.freeze({ 1: { dimensionSwapped: !1, scaleX: 1, scaleY: 1, deg: 0, rad: 0 }, 2: { dimensionSwapped: !1, scaleX: -1, scaleY: 1, deg: 0, rad: 0 }, 3: { dimensionSwapped: !1, scaleX: 1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 4: { dimensionSwapped: !1, scaleX: -1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 5: { dimensionSwapped: !0, scaleX: 1, scaleY: -1, deg: 90, rad: 90 * Math.PI / 180 }, 6: { dimensionSwapped: !0, scaleX: 1, scaleY: 1, deg: 90, rad: 90 * Math.PI / 180 }, 7: { dimensionSwapped: !0, scaleX: 1, scaleY: -1, deg: 270, rad: 270 * Math.PI / 180 }, 8: { dimensionSwapped: !0, scaleX: 1, scaleY: 1, deg: 270, rad: 270 * Math.PI / 180 } }), ta = !0, ia = !0; if (typeof navigator == "object") { let i = navigator.userAgent; if (i.includes("iPad") || i.includes("iPhone")) { let e = i.match(/OS (\d+)_(\d+)/); if (e) { let [, t, r] = e; ta = Number(t) + .1 * Number(r) < 13.4, ia = !1 } } else if (i.includes("OS X 10")) { let [, e] = i.match(/OS X 10[_.](\d+)/); ta = ia = Number(e) < 15 } if (i.includes("Chrome/")) { let [, e] = i.match(/Chrome\/(\d+)/); ta = ia = Number(e) < 81 } else if (i.includes("Firefox/")) { let [, e] = i.match(/Firefox\/(\d+)/); ta = ia = Number(e) < 77 } } async function Eg(i) { let e = await y2(i); return Object.assign({ canvas: ta, css: ia }, v2[e]) } n(Eg, "ye"); var du = class extends qt { constructor(...e) { super(...e), ge(this, "ranges", new hu), this.byteLength !== 0 && this.ranges.add(0, this.byteLength) } _tryExtend(e, t, r) { if (e === 0 && this.byteLength === 0 && r) { let s = new DataView(r.buffer || r, r.byteOffset, r.byteLength); this._swapDataView(s) } else { let s = e + t; if (s > this.byteLength) { let { dataView: o } = this._extend(s); this._swapDataView(o) } } } _extend(e) { let t; t = Pg ? Sg.allocUnsafe(e) : new Uint8Array(e); let r = new DataView(t.buffer, t.byteOffset, t.byteLength); return t.set(new Uint8Array(this.buffer, this.byteOffset, this.byteLength), 0), { uintView: t, dataView: r } } subarray(e, t, r = !1) { return t = t || this._lengthToEnd(e), r && this._tryExtend(e, t), this.ranges.add(e, t), super.subarray(e, t) } set(e, t, r = !1) { r && this._tryExtend(t, e.byteLength, e); let s = super.set(e, t); return this.ranges.add(t, s.byteLength), s } async ensureChunk(e, t) { this.chunked && (this.ranges.available(e, t) || await this.readChunk(e, t)) } available(e, t) { return this.ranges.available(e, t) } }; n(du, "be"); var hu = class { constructor() { ge(this, "list", []) } get length() { return this.list.length } add(e, t, r = 0) { let s = e + t, o = this.list.filter(a => bg(e, a.offset, s) || bg(e, a.end, s)); if (o.length > 0) { e = Math.min(e, ...o.map(l => l.offset)), s = Math.max(s, ...o.map(l => l.end)), t = s - e; let a = o.shift(); a.offset = e, a.length = t, a.end = s, this.list = this.list.filter(l => !o.includes(l)) } else this.list.push({ offset: e, length: t, end: s }) } available(e, t) { let r = e + t; return this.list.some(s => s.offset <= e && r <= s.end) } }; n(hu, "we"); function bg(i, e, t) { return i <= e && e <= t } n(bg, "ke"); var cu = class extends du { constructor(e, t) { super(0), ge(this, "chunksRead", 0), this.input = e, this.options = t } async readWhole() { this.chunked = !1, await this.readChunk(this.nextChunkOffset) } async readChunked() { this.chunked = !0, await this.readChunk(0, this.options.firstChunkSize) } async readNextChunk(e = this.nextChunkOffset) { if (this.fullyRead) return this.chunksRead++, !1; let t = this.options.chunkSize, r = await this.readChunk(e, t); return !!r && r.byteLength === t } async readChunk(e, t) { if (this.chunksRead++, (t = this.safeWrapAddress(e, t)) !== 0) return this._readChunk(e, t) } safeWrapAddress(e, t) { return this.size !== void 0 && e + t > this.size ? Math.max(0, this.size - e) : t } get nextChunkOffset() { if (this.ranges.list.length !== 0) return this.ranges.list[0].length } get canReadNextChunk() { return this.chunksRead < this.options.chunkLimit } get fullyRead() { return this.size !== void 0 && this.nextChunkOffset === this.size } read() { return this.options.chunked ? this.readChunked() : this.readWhole() } close() { } }; n(cu, "Oe"); la.set("blob", class extends cu { async readWhole() { this.chunked = !1; let i = await na(this.input); this._swapArrayBuffer(i) } readChunked() { return this.chunked = !0, this.size = this.input.size, super.readChunked() } async _readChunk(i, e) { let t = e ? i + e : void 0, r = this.input.slice(i, t), s = await na(r); return this.set(s, i, !0) } }); var Cg = { strings: { generatingThumbnails: "Generating thumbnails..." } }; var b2 = { version: "3.0.5" }; function w2(i, e, t) { try { i.getContext("2d").getImageData(0, 0, 1, 1) } catch (r) { if (r.code === 18) return Promise.reject(new Error("cannot read image, probably an svg with external resources")) } return i.toBlob ? new Promise(r => { i.toBlob(r, e, t) }).then(r => { if (r === null) throw new Error("cannot read image, probably an svg with external resources"); return r }) : Promise.resolve().then(() => th(i.toDataURL(e, t), {})).then(r => { if (r === null) throw new Error("could not extract blob, probably an old browser"); return r }) } n(w2, "canvasToBlob"); function S2(i, e) { let t = i.width, r = i.height; (e.deg === 90 || e.deg === 270) && (t = i.height, r = i.width); let s = document.createElement("canvas"); s.width = t, s.height = r; let o = s.getContext("2d"); return o.translate(t / 2, r / 2), e.canvas && (o.rotate(e.rad), o.scale(e.scaleX, e.scaleY)), o.drawImage(i, -i.width / 2, -i.height / 2, i.width, i.height), s } n(S2, "rotateImage"); function P2(i) { let e = i.width / i.height, t = 5e6, r = 4096, s = Math.floor(Math.sqrt(t * e)), o = Math.floor(t / Math.sqrt(t * e)); if (s > r && (s = r, o = Math.round(s / e)), o > r && (o = r, s = Math.round(e * o)), i.width > s) { let a = document.createElement("canvas"); return a.width = s, a.height = o, a.getContext("2d").drawImage(i, 0, 0, s, o), a } return i } n(P2, "protect"); var Er = class extends Q { constructor(e, t) { super(e, t), this.onFileAdded = s => { !s.preview && s.data && To(s.type) && !s.isRemote && this.addToQueue(s.id) }, this.onCancelRequest = s => { let o = this.queue.indexOf(s.id); o !== -1 && this.queue.splice(o, 1) }, this.onFileRemoved = s => { let o = this.queue.indexOf(s.id); o !== -1 && this.queue.splice(o, 1), s.preview && au(s.preview) && URL.revokeObjectURL(s.preview) }, this.onRestored = () => { this.uppy.getFiles().filter(o => o.isRestored).forEach(o => { (!o.preview || au(o.preview)) && this.addToQueue(o.id) }) }, this.onAllFilesRemoved = () => { this.queue = [] }, this.waitUntilAllProcessed = s => { s.forEach(a => { let l = this.uppy.getFile(a); this.uppy.emit("preprocess-progress", l, { mode: "indeterminate", message: this.i18n("generatingThumbnails") }) }); let o = n(() => { s.forEach(a => { let l = this.uppy.getFile(a); this.uppy.emit("preprocess-complete", l) }) }, "emitPreprocessCompleteForAll"); return new Promise(a => { this.queueProcessing ? this.uppy.once("thumbnail:all-generated", () => { o(), a() }) : (o(), a()) }) }, this.type = "modifier", this.id = this.opts.id || "ThumbnailGenerator", this.title = "Thumbnail Generator", this.queue = [], this.queueProcessing = !1, this.defaultThumbnailDimension = 200, this.thumbnailType = this.opts.thumbnailType || "image/jpeg", this.defaultLocale = Cg; let r = { thumbnailWidth: null, thumbnailHeight: null, waitForThumbnailsBeforeUpload: !1, lazy: !1 }; if (this.opts = { ...r, ...t }, this.i18nInit(), this.opts.lazy && this.opts.waitForThumbnailsBeforeUpload) throw new Error("ThumbnailGenerator: The `lazy` and `waitForThumbnailsBeforeUpload` options are mutually exclusive. Please ensure at most one of them is set to `true`.") } createThumbnail(e, t, r) { let s = URL.createObjectURL(e.data), o = new Promise((l, d) => { let p = new Image; p.src = s, p.addEventListener("load", () => { URL.revokeObjectURL(s), l(p) }), p.addEventListener("error", h => { URL.revokeObjectURL(s), d(h.error || new Error("Could not create thumbnail")) }) }), a = Eg(e.data).catch(() => 1); return Promise.all([o, a]).then(l => { let [d, p] = l, h = this.getProportionalDimensions(d, t, r, p.deg), m = S2(d, p), y = this.resizeImage(m, h.width, h.height); return w2(y, this.thumbnailType, 80) }).then(l => URL.createObjectURL(l)) } getProportionalDimensions(e, t, r, s) { let o = e.width / e.height; return (s === 90 || s === 270) && (o = e.height / e.width), t != null ? { width: t, height: Math.round(t / o) } : r != null ? { width: Math.round(r * o), height: r } : { width: this.defaultThumbnailDimension, height: Math.round(this.defaultThumbnailDimension / o) } } resizeImage(e, t, r) { let s = P2(e), o = Math.ceil(Math.log2(s.width / t)); o < 1 && (o = 1); let a = t * 2 ** (o - 1), l = r * 2 ** (o - 1), d = 2; for (; o--;) { let p = document.createElement("canvas"); p.width = a, p.height = l, p.getContext("2d").drawImage(s, 0, 0, a, l), s = p, a = Math.round(a / d), l = Math.round(l / d) } return s } setPreviewURL(e, t) { this.uppy.setFileState(e, { preview: t }) } addToQueue(e) { this.queue.push(e), this.queueProcessing === !1 && this.processQueue() } processQueue() { if (this.queueProcessing = !0, this.queue.length > 0) { let e = this.uppy.getFile(this.queue.shift()); return e ? this.requestThumbnail(e).catch(() => { }).then(() => this.processQueue()) : (this.uppy.log("[ThumbnailGenerator] file was removed before a thumbnail could be generated, but not removed from the queue. This is probably a bug", "error"), Promise.resolve()) } return this.queueProcessing = !1, this.uppy.log("[ThumbnailGenerator] Emptied thumbnail queue"), this.uppy.emit("thumbnail:all-generated"), Promise.resolve() } requestThumbnail(e) { return To(e.type) && !e.isRemote ? this.createThumbnail(e, this.opts.thumbnailWidth, this.opts.thumbnailHeight).then(t => { this.setPreviewURL(e.id, t), this.uppy.log(`[ThumbnailGenerator] Generated thumbnail for ${e.id}`), this.uppy.emit("thumbnail:generated", this.uppy.getFile(e.id), t) }).catch(t => { this.uppy.log(`[ThumbnailGenerator] Failed thumbnail for ${e.id}:`, "warning"), this.uppy.log(t, "warning"), this.uppy.emit("thumbnail:error", this.uppy.getFile(e.id), t) }) : Promise.resolve() } install() { this.uppy.on("file-removed", this.onFileRemoved), this.uppy.on("cancel-all", this.onAllFilesRemoved), this.opts.lazy ? (this.uppy.on("thumbnail:request", this.onFileAdded), this.uppy.on("thumbnail:cancel", this.onCancelRequest)) : (this.uppy.on("file-added", this.onFileAdded), this.uppy.on("restored", this.onRestored)), this.opts.waitForThumbnailsBeforeUpload && this.uppy.addPreProcessor(this.waitUntilAllProcessed) } uninstall() { this.uppy.off("file-removed", this.onFileRemoved), this.uppy.off("cancel-all", this.onAllFilesRemoved), this.opts.lazy ? (this.uppy.off("thumbnail:request", this.onFileAdded), this.uppy.off("thumbnail:cancel", this.onCancelRequest)) : (this.uppy.off("file-added", this.onFileAdded), this.uppy.off("restored", this.onRestored)), this.opts.waitForThumbnailsBeforeUpload && this.uppy.removePreProcessor(this.waitUntilAllProcessed) } }; n(Er, "ThumbnailGenerator"); Er.VERSION = b2.version; function vu(i) { if (typeof i == "string") { let e = document.querySelectorAll(i); return e.length === 0 ? null : Array.from(e) } return typeof i == "object" && Fn(i) ? [i] : null } n(vu, "findAllDOMElements"); var Ke = Array.from; function bu(i, e, t, r) { let { onSuccess: s } = r; i.readEntries(o => { let a = [...e, ...o]; o.length ? queueMicrotask(() => { bu(i, a, t, { onSuccess: s }) }) : s(a) }, o => { t(o), s(e) }) } n(bu, "getFilesAndDirectoriesFromDirectory"); function Ag(i, e) { return i == null ? i : { kind: i.isFile ? "file" : i.isDirectory ? "directory" : void 0, name: i.name, getFile() { return new Promise((t, r) => i.file(t, r)) }, async*values() { let t = i.createReader(); yield* await new Promise(s => { bu(t, [], e, { onSuccess: o => s(o.map(a => Ag(a, e))) }) }) } } } n(Ag, "getAsFileSystemHandleFromEntry"); function Tg(i, e, t) { try { return t === void 0 && (t = void 0), async function* () { let r = n(() => `${e}/${i.name}`, "getNextRelativePath"); if (i.kind === "file") { let s = await i.getFile(); s != null ? (s.relativePath = e ? r() : null, yield s) : t != null && (yield t) } else if (i.kind === "directory") for await (let s of i.values()) yield* Tg(s, e ? r() : i.name); else t != null && (yield t) }() } catch (r) { return Promise.reject(r) } } n(Tg, "createPromiseToAddFileOrParseDirectory"); async function* dh(i, e) { let t = await Promise.all(Array.from(i.items, async r => { var s; let o, a = n(() => typeof r.getAsEntry == "function" ? r.getAsEntry() : r.webkitGetAsEntry(), "getAsEntry"); return (s = o) != null || (o = Ag(a(), e)), { fileSystemHandle: o, lastResortFile: r.getAsFile() } })); for (let { lastResortFile: r, fileSystemHandle: s } of t) if (s != null) try { yield* Tg(s, "", r) } catch (o) { r != null ? yield r : e(o) } else r != null && (yield r) } n(dh, "getFilesFromDataTransfer"); function hh(i) { let e = Ke(i.files); return Promise.resolve(e) } n(hh, "fallbackApi"); async function Cs(i, e) { let { logDropError: t = n(() => { }, "logDropError") } = e === void 0 ? {} : e; try { let r = []; for await (let s of dh(i, t)) r.push(s); return r } catch { return hh(i) } } n(Cs, "getDroppedFiles"); var Rg = Number.isNaN || n(function (e) { return typeof e == "number" && e !== e }, "ponyfill"); function _2(i, e) { return !!(i === e || Rg(i) && Rg(e)) } n(_2, "isEqual"); function F2(i, e) { if (i.length !== e.length) return !1; for (var t = 0; t < i.length; t++)if (!_2(i[t], e[t])) return !1; return !0 } n(F2, "areInputsEqual"); function ch(i, e) { e === void 0 && (e = F2); var t = null; function r() { for (var s = [], o = 0; o < arguments.length; o++)s[o] = arguments[o]; if (t && t.lastThis === this && e(s, t.lastArgs)) return t.lastResult; var a = i.apply(this, s); return t = { lastResult: a, lastArgs: s, lastThis: this }, a } return n(r, "memoized"), r.clear = n(function () { t = null }, "clear"), r } n(ch, "memoizeOne"); var wu = ['a[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'area[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', "input:not([disabled]):not([inert]):not([aria-hidden])", "select:not([disabled]):not([inert]):not([aria-hidden])", "textarea:not([disabled]):not([inert]):not([aria-hidden])", "button:not([disabled]):not([inert]):not([aria-hidden])", 'iframe:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'object:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'embed:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[contenteditable]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[tabindex]:not([tabindex^="-"]):not([inert]):not([aria-hidden])']; function da(i, e) { if (e) { let t = i.querySelector(`[data-uppy-paneltype="${e}"]`); if (t) return t } return i } n(da, "getActiveOverlayEl"); function Ug(i, e) { let t = e[0]; t && (t.focus(), i.preventDefault()) } n(Ug, "focusOnFirstNode"); function x2(i, e) { let t = e[e.length - 1]; t && (t.focus(), i.preventDefault()) } n(x2, "focusOnLastNode"); function O2(i) { return i.contains(document.activeElement) } n(O2, "isFocusInOverlay"); function ph(i, e, t) { let r = da(t, e), s = Ke(r.querySelectorAll(wu)), o = s.indexOf(document.activeElement); O2(r) ? i.shiftKey && o === 0 ? x2(i, s) : !i.shiftKey && o === s.length - 1 && Ug(i, s) : Ug(i, s) } n(ph, "trapFocus"); function kg(i, e, t) { e === null || ph(i, e, t) } n(kg, "forInline"); var Dg = de(cd(), 1); function fh() { let i = !1; return (0, Dg.default)(n((t, r) => { let s = da(t, r), o = s.contains(document.activeElement); if (o && i) return; let a = s.querySelector("[data-uppy-super-focusable]"); if (!(o && !a)) if (a) a.focus({ preventScroll: !0 }), i = !0; else { let l = s.querySelector(wu); l?.focus({ preventScroll: !0 }), i = !1 } }, "superFocus"), 260) } n(fh, "createSuperFocus"); var sy = de(Jt(), 1); function ha() { let i = document.body; return !(!("draggable" in i) || !("ondragstart" in i && "ondrop" in i) || !("FormData" in window) || !("FileReader" in window)) } n(ha, "isDragDropSupported"); var zg = de(Jt(), 1), Hg = de(Ng(), 1); function C2() { return u("svg", { "aria-hidden": "true", focusable: "false", width: "25", height: "25", viewBox: "0 0 25 25" }, u("g", { fill: "#686DE0", fillRule: "evenodd" }, u("path", { d: "M5 7v10h15V7H5zm0-1h15a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1z", fillRule: "nonzero" }), u("path", { d: "M6.35 17.172l4.994-5.026a.5.5 0 0 1 .707 0l2.16 2.16 3.505-3.505a.5.5 0 0 1 .707 0l2.336 2.31-.707.72-1.983-1.97-3.505 3.505a.5.5 0 0 1-.707 0l-2.16-2.159-3.938 3.939-1.409.026z", fillRule: "nonzero" }), u("circle", { cx: "7.5", cy: "9.5", r: "1.5" }))) } n(C2, "iconImage"); function A2() { return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "25", height: "25", viewBox: "0 0 25 25" }, u("path", { d: "M9.5 18.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V7.25a.5.5 0 0 1 .379-.485l9-2.25A.5.5 0 0 1 18.5 5v11.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V8.67l-8 2v7.97zm8-11v-2l-8 2v2l8-2zM7 19.64c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1zm9-2c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1z", fill: "#049BCF", fillRule: "nonzero" })) } n(A2, "iconAudio"); function T2() { return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "25", height: "25", viewBox: "0 0 25 25" }, u("path", { d: "M16 11.834l4.486-2.691A1 1 0 0 1 22 10v6a1 1 0 0 1-1.514.857L16 14.167V17a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2.834zM15 9H5v8h10V9zm1 4l5 3v-6l-5 3z", fill: "#19AF67", fillRule: "nonzero" })) } n(T2, "iconVideo"); function R2() { return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "25", height: "25", viewBox: "0 0 25 25" }, u("path", { d: "M9.766 8.295c-.691-1.843-.539-3.401.747-3.726 1.643-.414 2.505.938 2.39 3.299-.039.79-.194 1.662-.537 3.148.324.49.66.967 1.055 1.51.17.231.382.488.629.757 1.866-.128 3.653.114 4.918.655 1.487.635 2.192 1.685 1.614 2.84-.566 1.133-1.839 1.084-3.416.249-1.141-.604-2.457-1.634-3.51-2.707a13.467 13.467 0 0 0-2.238.426c-1.392 4.051-4.534 6.453-5.707 4.572-.986-1.58 1.38-4.206 4.914-5.375.097-.322.185-.656.264-1.001.08-.353.306-1.31.407-1.737-.678-1.059-1.2-2.031-1.53-2.91zm2.098 4.87c-.033.144-.068.287-.104.427l.033-.01-.012.038a14.065 14.065 0 0 1 1.02-.197l-.032-.033.052-.004a7.902 7.902 0 0 1-.208-.271c-.197-.27-.38-.526-.555-.775l-.006.028-.002-.003c-.076.323-.148.632-.186.8zm5.77 2.978c1.143.605 1.832.632 2.054.187.26-.519-.087-1.034-1.113-1.473-.911-.39-2.175-.608-3.55-.608.845.766 1.787 1.459 2.609 1.894zM6.559 18.789c.14.223.693.16 1.425-.413.827-.648 1.61-1.747 2.208-3.206-2.563 1.064-4.102 2.867-3.633 3.62zm5.345-10.97c.088-1.793-.351-2.48-1.146-2.28-.473.119-.564 1.05-.056 2.405.213.566.52 1.188.908 1.859.18-.858.268-1.453.294-1.984z", fill: "#E2514A", fillRule: "nonzero" })) } n(R2, "iconPDF"); function U2() { return u("svg", { "aria-hidden": "true", focusable: "false", width: "25", height: "25", viewBox: "0 0 25 25" }, u("path", { d: "M10.45 2.05h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V2.55a.5.5 0 0 1 .5-.5zm2.05 1.024h1.05a.5.5 0 0 1 .5.5V3.6a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5v-.001zM10.45 0h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 3.074h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 1.024h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm-2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-1.656 3.074l-.82 5.946c.52.302 1.174.458 1.976.458.803 0 1.455-.156 1.975-.458l-.82-5.946h-2.311zm0-1.025h2.312c.512 0 .946.378 1.015.885l.82 5.946c.056.412-.142.817-.501 1.026-.686.398-1.515.597-2.49.597-.974 0-1.804-.199-2.49-.597a1.025 1.025 0 0 1-.5-1.026l.819-5.946c.07-.507.503-.885 1.015-.885zm.545 6.6a.5.5 0 0 1-.397-.561l.143-.999a.5.5 0 0 1 .495-.429h.74a.5.5 0 0 1 .495.43l.143.998a.5.5 0 0 1-.397.561c-.404.08-.819.08-1.222 0z", fill: "#00C469", fillRule: "nonzero" })) } n(U2, "iconArchive"); function k2() { return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "25", height: "25", viewBox: "0 0 25 25" }, u("g", { fill: "#A7AFB7", fillRule: "nonzero" }, u("path", { d: "M5.5 22a.5.5 0 0 1-.5-.5v-18a.5.5 0 0 1 .5-.5h10.719a.5.5 0 0 1 .367.16l3.281 3.556a.5.5 0 0 1 .133.339V21.5a.5.5 0 0 1-.5.5h-14zm.5-1h13V7.25L16 4H6v17z" }), u("path", { d: "M15 4v3a1 1 0 0 0 1 1h3V7h-3V4h-1z" }))) } n(k2, "iconFile"); function D2() { return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "25", height: "25", viewBox: "0 0 25 25" }, u("path", { d: "M4.5 7h13a.5.5 0 1 1 0 1h-13a.5.5 0 0 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h10a.5.5 0 1 1 0 1h-10a.5.5 0 1 1 0-1z", fill: "#5A5E69", fillRule: "nonzero" })) } n(D2, "iconText"); function As(i) { let e = { color: "#838999", icon: k2() }; if (!i) return e; let t = i.split("/")[0], r = i.split("/")[1]; return t === "text" ? { color: "#5a5e69", icon: D2() } : t === "image" ? { color: "#686de0", icon: C2() } : t === "audio" ? { color: "#068dbb", icon: A2() } : t === "video" ? { color: "#19af67", icon: T2() } : t === "application" && r === "pdf" ? { color: "#e25149", icon: R2() } : t === "application" && ["zip", "x-7z-compressed", "x-rar-compressed", "x-tar", "x-gzip", "x-apple-diskimage"].indexOf(r) !== -1 ? { color: "#00C469", icon: U2() } : e } n(As, "getIconByMime"); function ca(i) { let { file: e } = i; if (e.preview) return u("img", { className: "uppy-Dashboard-Item-previewImg", alt: e.name, src: e.preview }); let { color: t, icon: r } = As(e.type); return u("div", { className: "uppy-Dashboard-Item-previewIconWrap" }, u("span", { className: "uppy-Dashboard-Item-previewIcon", style: { color: t } }, r), u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-Dashboard-Item-previewIconBg", width: "58", height: "76", viewBox: "0 0 58 76" }, u("rect", { fill: "#FFF", width: "58", height: "76", rx: "3", fillRule: "evenodd" }))) } n(ca, "FilePreview"); var I2 = n((i, e) => (typeof e == "function" ? e() : e).filter(s => s.id === i)[0].name, "metaFieldIdToName"); function pa(i) { let { file: e, toggleFileCard: t, i18n: r, metaFields: s } = i, { missingRequiredMetaFields: o } = e; if (!(o != null && o.length)) return null; let a = o.map(l => I2(l, s)).join(", "); return u("div", { className: "uppy-Dashboard-Item-errorMessage" }, r("missingRequiredMetaFields", { smart_count: o.length, fields: a }), " ", u("button", { type: "button", class: "uppy-u-reset uppy-Dashboard-Item-errorMessageBtn", onClick: () => t(!0, e.id) }, r("editFile"))) } n(pa, "renderMissingMetaFieldsError"); function mh(i) { let { file: e, i18n: t, toggleFileCard: r, metaFields: s, showLinkToFileUploadResult: o } = i, a = "rgba(255, 255, 255, 0.5)", l = e.preview ? a : As(i.file.type).color; return u("div", { className: "uppy-Dashboard-Item-previewInnerWrap", style: { backgroundColor: l } }, o && e.uploadURL && u("a", { className: "uppy-Dashboard-Item-previewLink", href: e.uploadURL, rel: "noreferrer noopener", target: "_blank", "aria-label": e.meta.name }, u("span", { hidden: !0 }, e.meta.name)), u(ca, { file: e }), u(pa, { file: e, i18n: t, toggleFileCard: r, metaFields: s })) } n(mh, "FilePreviewAndLink"); function N2(i) { if (!i.isUploaded) { if (i.error && !i.hideRetryButton) { i.uppy.retryUpload(i.file.id); return } i.resumableUploads && !i.hidePauseResumeButton ? i.uppy.pauseResume(i.file.id) : i.individualCancellation && !i.hideCancelButton && i.uppy.removeFile(i.file.id) } } n(N2, "onPauseResumeCancelRetry"); function Mg(i) { return i.isUploaded ? i.i18n("uploadComplete") : i.error ? i.i18n("retryUpload") : i.resumableUploads ? i.file.isPaused ? i.i18n("resumeUpload") : i.i18n("pauseUpload") : i.individualCancellation ? i.i18n("cancelUpload") : "" } n(Mg, "progressIndicatorTitle"); function gh(i) { return u("div", { className: "uppy-Dashboard-Item-progress" }, u("button", { className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-progressIndicator", type: "button", "aria-label": Mg(i), title: Mg(i), onClick: () => N2(i) }, i.children)) } n(gh, "ProgressIndicatorButton"); function Su(i) { let { children: e } = i; return u("svg", { "aria-hidden": "true", focusable: "false", width: "70", height: "70", viewBox: "0 0 36 36", className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--circle" }, e) } n(Su, "ProgressCircleContainer"); function yh(i) { let { progress: e } = i, t = 2 * Math.PI * 15; return u("g", null, u("circle", { className: "uppy-Dashboard-Item-progressIcon--bg", r: "15", cx: "18", cy: "18", "stroke-width": "2", fill: "none" }), u("circle", { className: "uppy-Dashboard-Item-progressIcon--progress", r: "15", cx: "18", cy: "18", transform: "rotate(-90, 18, 18)", fill: "none", "stroke-width": "2", "stroke-dasharray": t, "stroke-dashoffset": t - t / 100 * e })) } n(yh, "ProgressCircle"); function vh(i) { if (!i.file.progress.uploadStarted) return null; if (i.isUploaded) return u("div", { className: "uppy-Dashboard-Item-progress" }, u("div", { className: "uppy-Dashboard-Item-progressIndicator" }, u(Su, null, u("circle", { r: "15", cx: "18", cy: "18", fill: "#1bb240" }), u("polygon", { className: "uppy-Dashboard-Item-progressIcon--check", transform: "translate(2, 3)", points: "14 22.5 7 15.2457065 8.99985857 13.1732815 14 18.3547104 22.9729883 9 25 11.1005634" })))); if (!i.recoveredState) return i.error && !i.hideRetryButton ? u(gh, i, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--retry", width: "28", height: "31", viewBox: "0 0 16 19" }, u("path", { d: "M16 11a8 8 0 1 1-8-8v2a6 6 0 1 0 6 6h2z" }), u("path", { d: "M7.9 3H10v2H7.9z" }), u("path", { d: "M8.536.5l3.535 3.536-1.414 1.414L7.12 1.914z" }), u("path", { d: "M10.657 2.621l1.414 1.415L8.536 7.57 7.12 6.157z" }))) : i.resumableUploads && !i.hidePauseResumeButton ? u(gh, i, u(Su, null, u(yh, { progress: i.file.progress.percentage }), i.file.isPaused ? u("polygon", { className: "uppy-Dashboard-Item-progressIcon--play", transform: "translate(3, 3)", points: "12 20 12 10 20 15" }) : u("g", { className: "uppy-Dashboard-Item-progressIcon--pause", transform: "translate(14.5, 13)" }, u("rect", { x: "0", y: "0", width: "2", height: "10", rx: "0" }), u("rect", { x: "5", y: "0", width: "2", height: "10", rx: "0" })))) : !i.resumableUploads && i.individualCancellation && !i.hideCancelButton ? u(gh, i, u(Su, null, u(yh, { progress: i.file.progress.percentage }), u("polygon", { className: "cancel", transform: "translate(2, 2)", points: "19.8856516 11.0625 16 14.9481516 12.1019737 11.0625 11.0625 12.1143484 14.9481516 16 11.0625 19.8980263 12.1019737 20.9375 16 17.0518484 19.8856516 20.9375 20.9375 19.8980263 17.0518484 16 20.9375 12" }))) : u("div", { className: "uppy-Dashboard-Item-progress" }, u("div", { className: "uppy-Dashboard-Item-progressIndicator" }, u(Su, null, u(yh, { progress: i.file.progress.percentage })))) } n(vh, "FileProgress"); var jg = de(Lg(), 1); var bh = "..."; function Pu(i, e) { if (e === 0) return ""; if (i.length <= e) return i; if (e <= bh.length + 1) return `${i.slice(0, e - 1)}\u2026`; let t = e - bh.length, r = Math.ceil(t / 2), s = Math.floor(t / 2); return i.slice(0, r) + bh + i.slice(-s) } n(Pu, "truncateString"); var M2 = n(i => { let { author: e, name: t } = i.file.meta; function r() { return i.isSingleFile && i.containerHeight >= 350 ? 90 : i.containerWidth <= 352 ? 35 : i.containerWidth <= 576 ? 60 : e ? 20 : 30 } return n(r, "getMaxNameLength"), u("div", { className: "uppy-Dashboard-Item-name", title: t }, Pu(t, r())) }, "renderFileName"), B2 = n(i => { let { author: e } = i.file.meta, { providerName: t } = i.file.remote, r = "\xB7"; return e ? u("div", { className: "uppy-Dashboard-Item-author" }, u("a", { href: `${e.url}?utm_source=Companion&utm_medium=referral`, target: "_blank", rel: "noopener noreferrer" }, Pu(e.name, 13)), t ? u(Ht, null, ` ${r} `, t, ` ${r} `) : null) : null }, "renderAuthor"), L2 = n(i => i.file.size && u("div", { className: "uppy-Dashboard-Item-statusSize" }, (0, jg.default)(i.file.size)), "renderFileSize"), j2 = n(i => i.file.isGhost && u("span", null, " \u2022 ", u("button", { className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-reSelect", type: "button", onClick: i.toggleAddFilesPanel }, i.i18n("reSelect"))), "ReSelectButton"), z2 = n(i => { let { file: e, onClick: t } = i; return e.error ? u("button", { className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-errorDetails", "aria-label": e.error, "data-microtip-position": "bottom", "data-microtip-size": "medium", onClick: t, type: "button" }, "?") : null }, "ErrorButton"); function wh(i) { let { file: e } = i; return u("div", { className: "uppy-Dashboard-Item-fileInfo", "data-uppy-file-source": e.source }, u("div", { className: "uppy-Dashboard-Item-fileName" }, M2(i), u(z2, { file: i.file, onClick: () => alert(i.file.error) })), u("div", { className: "uppy-Dashboard-Item-status" }, B2(i), L2(i), j2(i)), u(pa, { file: i.file, i18n: i.i18n, toggleFileCard: i.toggleFileCard, metaFields: i.metaFields })) } n(wh, "FileInfo"); function Sh(i, e) { return e === void 0 && (e = "Copy the URL below"), new Promise(t => { let r = document.createElement("textarea"); r.setAttribute("style", { position: "fixed", top: 0, left: 0, width: "2em", height: "2em", padding: 0, border: "none", outline: "none", boxShadow: "none", background: "transparent" }), r.value = i, document.body.appendChild(r), r.select(); let s = n(() => { document.body.removeChild(r), window.prompt(e, i), t() }, "magicCopyFailed"); try { return document.execCommand("copy") ? (document.body.removeChild(r), t()) : s("copy command unavailable") } catch (o) { return document.body.removeChild(r), s(o) } }) } n(Sh, "copyToClipboard"); function H2(i) { let { file: e, uploadInProgressOrComplete: t, metaFields: r, canEditFile: s, i18n: o, onClick: a } = i; return !t && r && r.length > 0 || !t && s(e) ? u("button", { className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-action uppy-Dashboard-Item-action--edit", type: "button", "aria-label": o("editFileWithFilename", { file: e.meta.name }), title: o("editFileWithFilename", { file: e.meta.name }), onClick: () => a() }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "14", height: "14", viewBox: "0 0 14 14" }, u("g", { fillRule: "evenodd" }, u("path", { d: "M1.5 10.793h2.793A1 1 0 0 0 5 10.5L11.5 4a1 1 0 0 0 0-1.414L9.707.793a1 1 0 0 0-1.414 0l-6.5 6.5A1 1 0 0 0 1.5 8v2.793zm1-1V8L9 1.5l1.793 1.793-6.5 6.5H2.5z", fillRule: "nonzero" }), u("rect", { x: "1", y: "12.293", width: "11", height: "1", rx: ".5" }), u("path", { fillRule: "nonzero", d: "M6.793 2.5L9.5 5.207l.707-.707L7.5 1.793z" })))) : null } n(H2, "EditButton"); function $2(i) { let { i18n: e, onClick: t, file: r } = i; return u("button", { className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--remove", type: "button", "aria-label": e("removeFile", { file: r.meta.name }), title: e("removeFile", { file: r.meta.name }), onClick: () => t() }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "18", height: "18", viewBox: "0 0 18 18" }, u("path", { d: "M9 0C4.034 0 0 4.034 0 9s4.034 9 9 9 9-4.034 9-9-4.034-9-9-9z" }), u("path", { fill: "#FFF", d: "M13 12.222l-.778.778L9 9.778 5.778 13 5 12.222 8.222 9 5 5.778 5.778 5 9 8.222 12.222 5l.778.778L9.778 9z" }))) } n($2, "RemoveButton"); var q2 = n((i, e) => { Sh(e.file.uploadURL, e.i18n("copyLinkToClipboardFallback")).then(() => { e.uppy.log("Link copied to clipboard."), e.uppy.info(e.i18n("copyLinkToClipboardSuccess"), "info", 3e3) }).catch(e.uppy.log).then(() => i.target.focus({ preventScroll: !0 })) }, "copyLinkToClipboard"); function V2(i) { let { i18n: e } = i; return u("button", { className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--copyLink", type: "button", "aria-label": e("copyLink"), title: e("copyLink"), onClick: t => q2(t, i) }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "14", height: "14", viewBox: "0 0 14 12" }, u("path", { d: "M7.94 7.703a2.613 2.613 0 0 1-.626 2.681l-.852.851a2.597 2.597 0 0 1-1.849.766A2.616 2.616 0 0 1 2.764 7.54l.852-.852a2.596 2.596 0 0 1 2.69-.625L5.267 7.099a1.44 1.44 0 0 0-.833.407l-.852.851a1.458 1.458 0 0 0 1.03 2.486c.39 0 .755-.152 1.03-.426l.852-.852c.231-.231.363-.522.406-.824l1.04-1.038zm4.295-5.937A2.596 2.596 0 0 0 10.387 1c-.698 0-1.355.272-1.849.766l-.852.851a2.614 2.614 0 0 0-.624 2.688l1.036-1.036c.041-.304.173-.6.407-.833l.852-.852c.275-.275.64-.426 1.03-.426a1.458 1.458 0 0 1 1.03 2.486l-.852.851a1.442 1.442 0 0 1-.824.406l-1.04 1.04a2.596 2.596 0 0 0 2.683-.628l.851-.85a2.616 2.616 0 0 0 0-3.697zm-6.88 6.883a.577.577 0 0 0 .82 0l3.474-3.474a.579.579 0 1 0-.819-.82L5.355 7.83a.579.579 0 0 0 0 .819z" }))) } n(V2, "CopyLinkButton"); function Ph(i) { let { uppy: e, file: t, uploadInProgressOrComplete: r, canEditFile: s, metaFields: o, showLinkToFileUploadResult: a, showRemoveButton: l, i18n: d, toggleFileCard: p, openFileEditor: h } = i; return u("div", { className: "uppy-Dashboard-Item-actionWrapper" }, u(H2, { i18n: d, file: t, uploadInProgressOrComplete: r, canEditFile: s, metaFields: o, onClick: n(() => { o && o.length > 0 ? p(!0, t.id) : h(t) }, "editAction") }), a && t.uploadURL ? u(V2, { file: t, uppy: e, i18n: d }) : null, l ? u($2, { i18n: d, file: t, uppy: e, onClick: () => i.uppy.removeFile(t.id, "removed-by-user") }) : null) } n(Ph, "Buttons"); var jo = class extends ve { componentDidMount() { let { file: e } = this.props; e.preview || this.props.handleRequestThumbnail(e) } shouldComponentUpdate(e) { return !(0, Hg.default)(this.props, e) } componentDidUpdate() { let { file: e } = this.props; e.preview || this.props.handleRequestThumbnail(e) } componentWillUnmount() { let { file: e } = this.props; e.preview || this.props.handleCancelThumbnail(e) } render() { let { file: e } = this.props, t = e.progress.preprocess || e.progress.postprocess, r = e.progress.uploadComplete && !t && !e.error, s = e.progress.uploadStarted || t, o = e.progress.uploadStarted && !e.progress.uploadComplete || t, a = e.error || !1, { isGhost: l } = e, d = (this.props.individualCancellation || !o) && !r; r && this.props.showRemoveButtonAfterComplete && (d = !0); let p = (0, zg.default)({ "uppy-Dashboard-Item": !0, "is-inprogress": o && !this.props.recoveredState, "is-processing": t, "is-complete": r, "is-error": !!a, "is-resumable": this.props.resumableUploads, "is-noIndividualCancellation": !this.props.individualCancellation, "is-ghost": l }); return u("div", { className: p, id: `uppy_${e.id}`, role: this.props.role }, u("div", { className: "uppy-Dashboard-Item-preview" }, u(mh, { file: e, showLinkToFileUploadResult: this.props.showLinkToFileUploadResult, i18n: this.props.i18n, toggleFileCard: this.props.toggleFileCard, metaFields: this.props.metaFields }), u(vh, { uppy: this.props.uppy, file: e, error: a, isUploaded: r, hideRetryButton: this.props.hideRetryButton, hideCancelButton: this.props.hideCancelButton, hidePauseResumeButton: this.props.hidePauseResumeButton, recoveredState: this.props.recoveredState, showRemoveButtonAfterComplete: this.props.showRemoveButtonAfterComplete, resumableUploads: this.props.resumableUploads, individualCancellation: this.props.individualCancellation, i18n: this.props.i18n })), u("div", { className: "uppy-Dashboard-Item-fileInfoAndButtons" }, u(wh, { file: e, id: this.props.id, acquirers: this.props.acquirers, containerWidth: this.props.containerWidth, containerHeight: this.props.containerHeight, i18n: this.props.i18n, toggleAddFilesPanel: this.props.toggleAddFilesPanel, toggleFileCard: this.props.toggleFileCard, metaFields: this.props.metaFields, isSingleFile: this.props.isSingleFile }), u(Ph, { file: e, metaFields: this.props.metaFields, showLinkToFileUploadResult: this.props.showLinkToFileUploadResult, showRemoveButton: d, canEditFile: this.props.canEditFile, uploadInProgressOrComplete: s, toggleFileCard: this.props.toggleFileCard, openFileEditor: this.props.openFileEditor, uppy: this.props.uppy, i18n: this.props.i18n }))) } }; n(jo, "FileItem"); function W2(i, e) { let t = [], r = []; return i.forEach(s => { r.length < e ? r.push(s) : (t.push(r), r = [s]) }), r.length && t.push(r), t } n(W2, "chunks"); var $g = n(i => { let { id: e, error: t, i18n: r, uppy: s, files: o, acquirers: a, resumableUploads: l, hideRetryButton: d, hidePauseResumeButton: p, hideCancelButton: h, showLinkToFileUploadResult: m, showRemoveButtonAfterComplete: y, isWide: b, metaFields: S, isSingleFile: O, toggleFileCard: F, handleRequestThumbnail: x, handleCancelThumbnail: U, recoveredState: H, individualCancellation: W, itemsPerRow: J, openFileEditor: L, canEditFile: G, toggleAddFilesPanel: ee, containerWidth: be, containerHeight: yt } = i, nt = J === 1 ? 71 : 200, jt = Ao(() => { let Me = n(($e, ki) => o[ki].isGhost - o[$e].isGhost, "sortByGhostComesFirst"), bt = Object.keys(o); return H && bt.sort(Me), W2(bt, J) }, [o, J, H]), vt = n(Me => u("div", { class: "uppy-Dashboard-filesInner", role: "presentation", key: Me[0] }, Me.map(bt => u(jo, { key: bt, uppy: s, id: e, error: t, i18n: r, acquirers: a, resumableUploads: l, individualCancellation: W, hideRetryButton: d, hidePauseResumeButton: p, hideCancelButton: h, showLinkToFileUploadResult: m, showRemoveButtonAfterComplete: y, isWide: b, metaFields: S, recoveredState: H, isSingleFile: O, containerWidth: be, containerHeight: yt, toggleFileCard: F, handleRequestThumbnail: x, handleCancelThumbnail: U, role: "listitem", openFileEditor: L, canEditFile: G, toggleAddFilesPanel: ee, file: o[bt] }))), "renderRow"); return O ? u("div", { class: "uppy-Dashboard-files" }, vt(jt[0])) : u(iu, { class: "uppy-Dashboard-files", role: "list", data: jt, renderRow: vt, rowHeight: nt }) }, "default"); var qg; qg = Symbol.for("uppy test: disable unused locale key warning"); var _u = class extends ve { constructor() { super(...arguments), this.triggerFileInputClick = () => { this.fileInput.click() }, this.triggerFolderInputClick = () => { this.folderInput.click() }, this.triggerVideoCameraInputClick = () => { this.mobileVideoFileInput.click() }, this.triggerPhotoCameraInputClick = () => { this.mobilePhotoFileInput.click() }, this.onFileInputChange = e => { this.props.handleInputChange(e), e.target.value = null }, this.renderHiddenInput = (e, t) => u("input", { className: "uppy-Dashboard-input", hidden: !0, "aria-hidden": "true", tabIndex: -1, webkitdirectory: e, type: "file", name: "files[]", multiple: this.props.maxNumberOfFiles !== 1, onChange: this.onFileInputChange, accept: this.props.allowedFileTypes, ref: t }), this.renderHiddenCameraInput = (e, t, r) => { let o = { photo: "image/*", video: "video/*" }[e]; return u("input", { className: "uppy-Dashboard-input", hidden: !0, "aria-hidden": "true", tabIndex: -1, type: "file", name: `camera-${e}`, onChange: this.onFileInputChange, capture: t, accept: o, ref: r }) }, this.renderMyDeviceAcquirer = () => u("div", { className: "uppy-DashboardTab", role: "presentation", "data-uppy-acquirer-id": "MyDevice" }, u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn", role: "tab", tabIndex: 0, "data-uppy-super-focusable": !0, onClick: this.triggerFileInputClick }, u("div", { className: "uppy-DashboardTab-inner" }, u("svg", { className: "uppy-DashboardTab-iconMyDevice", "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("path", { d: "M8.45 22.087l-1.305-6.674h17.678l-1.572 6.674H8.45zm4.975-12.412l1.083 1.765a.823.823 0 00.715.386h7.951V13.5H8.587V9.675h4.838zM26.043 13.5h-1.195v-2.598c0-.463-.336-.75-.798-.75h-8.356l-1.082-1.766A.823.823 0 0013.897 8H7.728c-.462 0-.815.256-.815.718V13.5h-.956a.97.97 0 00-.746.37.972.972 0 00-.19.81l1.724 8.565c.095.44.484.755.933.755H24c.44 0 .824-.3.929-.727l2.043-8.568a.972.972 0 00-.176-.825.967.967 0 00-.753-.38z", fill: "currentcolor", "fill-rule": "evenodd" }))), u("div", { className: "uppy-DashboardTab-name" }, this.props.i18n("myDevice")))), this.renderPhotoCamera = () => u("div", { className: "uppy-DashboardTab", role: "presentation", "data-uppy-acquirer-id": "MobilePhotoCamera" }, u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn", role: "tab", tabIndex: 0, "data-uppy-super-focusable": !0, onClick: this.triggerPhotoCameraInputClick }, u("div", { className: "uppy-DashboardTab-inner" }, u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("path", { d: "M23.5 9.5c1.417 0 2.5 1.083 2.5 2.5v9.167c0 1.416-1.083 2.5-2.5 2.5h-15c-1.417 0-2.5-1.084-2.5-2.5V12c0-1.417 1.083-2.5 2.5-2.5h2.917l1.416-2.167C13 7.167 13.25 7 13.5 7h5c.25 0 .5.167.667.333L20.583 9.5H23.5zM16 11.417a4.706 4.706 0 00-4.75 4.75 4.704 4.704 0 004.75 4.75 4.703 4.703 0 004.75-4.75c0-2.663-2.09-4.75-4.75-4.75zm0 7.825c-1.744 0-3.076-1.332-3.076-3.074 0-1.745 1.333-3.077 3.076-3.077 1.744 0 3.074 1.333 3.074 3.076s-1.33 3.075-3.074 3.075z", fill: "#02B383", "fill-rule": "nonzero" }))), u("div", { className: "uppy-DashboardTab-name" }, this.props.i18n("takePictureBtn")))), this.renderVideoCamera = () => u("div", { className: "uppy-DashboardTab", role: "presentation", "data-uppy-acquirer-id": "MobileVideoCamera" }, u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn", role: "tab", tabIndex: 0, "data-uppy-super-focusable": !0, onClick: this.triggerVideoCameraInputClick }, u("div", { className: "uppy-DashboardTab-inner" }, u("svg", { "aria-hidden": "true", width: "32", height: "32", viewBox: "0 0 32 32" }, u("path", { fill: "#FF675E", fillRule: "nonzero", d: "m21.254 14.277 2.941-2.588c.797-.313 1.243.818 1.09 1.554-.01 2.094.02 4.189-.017 6.282-.126.915-1.145 1.08-1.58.34l-2.434-2.142c-.192.287-.504 1.305-.738.468-.104-1.293-.028-2.596-.05-3.894.047-.312.381.823.426 1.069.063-.384.206-.744.362-1.09zm-12.939-3.73c3.858.013 7.717-.025 11.574.02.912.129 1.492 1.237 1.351 2.217-.019 2.412.04 4.83-.03 7.239-.17 1.025-1.166 1.59-2.029 1.429-3.705-.012-7.41.025-11.114-.019-.913-.129-1.492-1.237-1.352-2.217.018-2.404-.036-4.813.029-7.214.136-.82.83-1.473 1.571-1.454z " }))), u("div", { className: "uppy-DashboardTab-name" }, this.props.i18n("recordVideoBtn")))), this.renderBrowseButton = (e, t) => { let r = this.props.acquirers.length; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-Dashboard-browse", onClick: t, "data-uppy-super-focusable": r === 0 }, e) }, this.renderDropPasteBrowseTagline = e => { let t = this.renderBrowseButton(this.props.i18n("browseFiles"), this.triggerFileInputClick), r = this.renderBrowseButton(this.props.i18n("browseFolders"), this.triggerFolderInputClick), s = this.props.fileManagerSelectionType, o = s.charAt(0).toUpperCase() + s.slice(1); return u("div", { class: "uppy-Dashboard-AddFiles-title" }, this.props.disableLocalFiles ? this.props.i18n("importFiles") : e > 0 ? this.props.i18nArray(`dropPasteImport${o}`, { browseFiles: t, browseFolders: r, browse: t }) : this.props.i18nArray(`dropPaste${o}`, { browseFiles: t, browseFolders: r, browse: t })) }, this.renderAcquirer = e => u("div", { className: "uppy-DashboardTab", role: "presentation", "data-uppy-acquirer-id": e.id }, u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn", role: "tab", tabIndex: 0, "data-cy": e.id, "aria-controls": `uppy-DashboardContent-panel--${e.id}`, "aria-selected": this.props.activePickerPanel.id === e.id, "data-uppy-super-focusable": !0, onClick: () => this.props.showPanel(e.id) }, u("div", { className: "uppy-DashboardTab-inner" }, e.icon()), u("div", { className: "uppy-DashboardTab-name" }, e.name))), this.renderAcquirers = e => { let t = [...e], r = t.splice(e.length - 2, e.length); return u(Ht, null, t.map(s => this.renderAcquirer(s)), u("span", { role: "presentation", style: { "white-space": "nowrap" } }, r.map(s => this.renderAcquirer(s)))) }, this.renderSourcesList = (e, t) => { let { showNativePhotoCameraButton: r, showNativeVideoCameraButton: s } = this.props, o = [], a = "myDevice"; t || (o.push({ key: a, elements: this.renderMyDeviceAcquirer() }), r && o.push({ key: "nativePhotoCameraButton", elements: this.renderPhotoCamera() }), s && o.push({ key: "nativePhotoCameraButton", elements: this.renderVideoCamera() })), o.push(...e.map(m => ({ key: m.id, elements: this.renderAcquirer(m) }))), o.length === 1 && o[0].key === a && (o = []); let d = [...o], p = d.splice(o.length - 2, o.length), h = n(m => m.map(y => { let { key: b, elements: S } = y; return u(Ht, { key: b }, S) }), "renderList"); return u(Ht, null, this.renderDropPasteBrowseTagline(o.length), u("div", { className: "uppy-Dashboard-AddFiles-list", role: "tablist" }, h(d), u("span", { role: "presentation", style: { "white-space": "nowrap" } }, h(p)))) } } [qg]() { this.props.i18nArray("dropPasteBoth"), this.props.i18nArray("dropPasteFiles"), this.props.i18nArray("dropPasteFolders"), this.props.i18nArray("dropPasteImportBoth"), this.props.i18nArray("dropPasteImportFiles"), this.props.i18nArray("dropPasteImportFolders") } renderPoweredByUppy() { let { i18nArray: e } = this.props, t = u("span", null, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon uppy-Dashboard-poweredByIcon", width: "11", height: "11", viewBox: "0 0 11 11" }, u("path", { d: "M7.365 10.5l-.01-4.045h2.612L5.5.806l-4.467 5.65h2.604l.01 4.044h3.718z", fillRule: "evenodd" })), u("span", { className: "uppy-Dashboard-poweredByUppy" }, "Uppy")), r = e("poweredBy", { uppy: t }); return u("a", { tabIndex: "-1", href: "https://uppy.io", rel: "noreferrer noopener", target: "_blank", className: "uppy-Dashboard-poweredBy" }, r) } render() { let { showNativePhotoCameraButton: e, showNativeVideoCameraButton: t, nativeCameraFacingMode: r } = this.props; return u("div", { className: "uppy-Dashboard-AddFiles" }, this.renderHiddenInput(!1, s => { this.fileInput = s }), this.renderHiddenInput(!0, s => { this.folderInput = s }), e && this.renderHiddenCameraInput("photo", r, s => { this.mobilePhotoFileInput = s }), t && this.renderHiddenCameraInput("video", r, s => { this.mobileVideoFileInput = s }), this.renderSourcesList(this.props.acquirers, this.props.disableLocalFiles), u("div", { className: "uppy-Dashboard-AddFiles-info" }, this.props.note && u("div", { className: "uppy-Dashboard-note" }, this.props.note), this.props.proudlyDisplayPoweredByUppy && this.renderPoweredByUppy(this.props))) } }; n(_u, "AddFiles"); var Fu = _u; var Vg = de(Jt(), 1); var G2 = n(i => u("div", { className: (0, Vg.default)("uppy-Dashboard-AddFilesPanel", i.className), "data-uppy-panelType": "AddFiles", "aria-hidden": !i.showAddFilesPanel }, u("div", { className: "uppy-DashboardContent-bar" }, u("div", { className: "uppy-DashboardContent-title", role: "heading", "aria-level": "1" }, i.i18n("addingMoreFiles")), u("button", { className: "uppy-DashboardContent-back", type: "button", onClick: () => i.toggleAddFilesPanel(!1) }, i.i18n("back"))), u(Fu, i)), "AddFilesPanel"), Wg = G2; var Gg = de(Jt(), 1); function K2(i) { let { tagName: e } = i.target; if (e === "INPUT" || e === "TEXTAREA") { i.stopPropagation(); return } i.preventDefault(), i.stopPropagation() } n(K2, "ignoreEvent"); var Hi = K2; function X2(i) { let { activePickerPanel: e, className: t, hideAllPanels: r, i18n: s, state: o, uppy: a } = i; return u("div", { className: (0, Gg.default)("uppy-DashboardContent-panel", t), role: "tabpanel", "data-uppy-panelType": "PickerPanel", id: `uppy-DashboardContent-panel--${e.id}`, onDragOver: Hi, onDragLeave: Hi, onDrop: Hi, onPaste: Hi }, u("div", { className: "uppy-DashboardContent-bar" }, u("div", { className: "uppy-DashboardContent-title", role: "heading", "aria-level": "1" }, s("importFrom", { name: e.name })), u("button", { className: "uppy-DashboardContent-back", type: "button", onClick: r }, s("cancel"))), u("div", { className: "uppy-DashboardContent-panelBody" }, a.getPlugin(e.id).render(o))) } n(X2, "PickerPanelContent"); var Kg = X2; var Xg = de(Jt(), 1); function Y2(i) { let e = i.files[i.fileCardFor], t = n(() => { i.uppy.emit("file-editor:cancel", e), i.hideAllPanels() }, "handleCancel"); return u("div", { className: (0, Xg.default)("uppy-DashboardContent-panel", i.className), role: "tabpanel", "data-uppy-panelType": "FileEditor", id: "uppy-DashboardContent-panel--editor" }, u("div", { className: "uppy-DashboardContent-bar" }, u("div", { className: "uppy-DashboardContent-title", role: "heading", "aria-level": "1" }, i.i18nArray("editing", { file: u("span", { className: "uppy-DashboardContent-titleFile" }, e.meta ? e.meta.name : e.name) })), u("button", { className: "uppy-DashboardContent-back", type: "button", onClick: t }, i.i18n("cancel")), u("button", { className: "uppy-DashboardContent-save", type: "button", onClick: i.saveFileEditor }, i.i18n("save"))), u("div", { className: "uppy-DashboardContent-panelBody" }, i.editors.map(r => i.uppy.getPlugin(r.id).render(i.state)))) } n(Y2, "EditorPanel"); var Yg = Y2; var $i = { STATE_ERROR: "error", STATE_WAITING: "waiting", STATE_PREPROCESSING: "preprocessing", STATE_UPLOADING: "uploading", STATE_POSTPROCESSING: "postprocessing", STATE_COMPLETE: "complete", STATE_PAUSED: "paused" }; function Q2(i, e, t, r) { if (r === void 0 && (r = {}), i) return $i.STATE_ERROR; if (e) return $i.STATE_COMPLETE; if (t) return $i.STATE_PAUSED; let s = $i.STATE_WAITING, o = Object.keys(r); for (let a = 0; a < o.length; a++) { let { progress: l } = r[o[a]]; if (l.uploadStarted && !l.uploadComplete) return $i.STATE_UPLOADING; l.preprocess && s !== $i.STATE_UPLOADING && (s = $i.STATE_PREPROCESSING), l.postprocess && s !== $i.STATE_UPLOADING && s !== $i.STATE_PREPROCESSING && (s = $i.STATE_POSTPROCESSING) } return s } n(Q2, "getUploadingState"); function J2(i) { let { files: e, i18n: t, isAllComplete: r, isAllErrored: s, isAllPaused: o, inProgressNotPausedFiles: a, newFiles: l, processingFiles: d } = i; switch (Q2(s, r, o, e)) { case "uploading": return t("uploadingXFiles", { smart_count: a.length }); case "preprocessing": case "postprocessing": return t("processingXFiles", { smart_count: d.length }); case "paused": return t("uploadPaused"); case "waiting": return t("xFilesSelected", { smart_count: l.length }); case "complete": return t("uploadComplete"); case "error": return t("error"); default: } } n(J2, "UploadStatus"); function Z2(i) { let { i18n: e, isAllComplete: t, hideCancelButton: r, maxNumberOfFiles: s, toggleAddFilesPanel: o, uppy: a } = i, { allowNewUpload: l } = i; return l && s && (l = i.totalFileCount < i.maxNumberOfFiles), u("div", { className: "uppy-DashboardContent-bar" }, !t && !r ? u("button", { className: "uppy-DashboardContent-back", type: "button", onClick: () => a.cancelAll() }, e("cancel")) : u("div", null), u("div", { className: "uppy-DashboardContent-title", role: "heading", "aria-level": "1" }, u(J2, i)), l ? u("button", { className: "uppy-DashboardContent-addMore", type: "button", "aria-label": e("addMoreFiles"), title: e("addMoreFiles"), onClick: () => o(!0) }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "15", height: "15", viewBox: "0 0 15 15" }, u("path", { d: "M8 6.5h6a.5.5 0 0 1 .5.5v.5a.5.5 0 0 1-.5.5H8v6a.5.5 0 0 1-.5.5H7a.5.5 0 0 1-.5-.5V8h-6a.5.5 0 0 1-.5-.5V7a.5.5 0 0 1 .5-.5h6v-6A.5.5 0 0 1 7 0h.5a.5.5 0 0 1 .5.5v6z" })), u("span", { className: "uppy-DashboardContent-addMoreCaption" }, e("addMore"))) : u("div", null)) } n(Z2, "PanelTopBar"); var Qg = Z2; var Jg = de(Jt(), 1); function _h(i) { let { computedMetaFields: e, requiredMetaFields: t, updateMeta: r, form: s, formState: o } = i, a = { text: "uppy-u-reset uppy-c-textInput uppy-Dashboard-FileCard-input" }; return e.map(l => { let d = `uppy-Dashboard-FileCard-input-${l.id}`, p = t.includes(l.id); return u("fieldset", { key: l.id, className: "uppy-Dashboard-FileCard-fieldset" }, u("label", { className: "uppy-Dashboard-FileCard-label", htmlFor: d }, l.name), l.render !== void 0 ? l.render({ value: o[l.id], onChange: h => r(h, l.id), fieldCSSClasses: a, required: p, form: s.id }, u) : u("input", { className: a.text, id: d, form: s.id, type: l.type || "text", required: p, value: o[l.id], placeholder: l.placeholder, onInput: h => r(h.target.value, l.id), "data-uppy-super-focusable": !0 })) }) } n(_h, "RenderMetaFields"); function Fh(i) { var e; let { files: t, fileCardFor: r, toggleFileCard: s, saveFileCard: o, metaFields: a, requiredMetaFields: l, openFileEditor: d, i18n: p, i18nArray: h, className: m, canEditFile: y } = i, b = n(() => typeof a == "function" ? a(t[r]) : a, "getMetaFields"), S = t[r], O = (e = b()) != null ? e : [], F = y(S), x = {}; O.forEach(ee => { var be; x[ee.id] = (be = S.meta[ee.id]) != null ? be : "" }); let [U, H] = Co(x), W = zn(ee => { ee.preventDefault(), o(U, r) }, [o, U, r]), J = n((ee, be) => { H({ ...U, [be]: ee }) }, "updateMeta"), L = n(() => { s(!1) }, "handleCancel"), [G] = Co(() => { let ee = document.createElement("form"); return ee.setAttribute("tabindex", "-1"), ee.id = St(), ee }); return xs(() => (document.body.appendChild(G), G.addEventListener("submit", W), () => { G.removeEventListener("submit", W), document.body.removeChild(G) }), [G, W]), u("div", { className: (0, Jg.default)("uppy-Dashboard-FileCard", m), "data-uppy-panelType": "FileCard", onDragOver: Hi, onDragLeave: Hi, onDrop: Hi, onPaste: Hi }, u("div", { className: "uppy-DashboardContent-bar" }, u("div", { className: "uppy-DashboardContent-title", role: "heading", "aria-level": "1" }, h("editing", { file: u("span", { className: "uppy-DashboardContent-titleFile" }, S.meta ? S.meta.name : S.name) })), u("button", { className: "uppy-DashboardContent-back", type: "button", form: G.id, title: p("finishEditingFile"), onClick: L }, p("cancel"))), u("div", { className: "uppy-Dashboard-FileCard-inner" }, u("div", { className: "uppy-Dashboard-FileCard-preview", style: { backgroundColor: As(S.type).color } }, u(ca, { file: S }), F && u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-Dashboard-FileCard-edit", onClick: ee => { W(ee), d(S) } }, p("editFile"))), u("div", { className: "uppy-Dashboard-FileCard-info" }, u(_h, { computedMetaFields: O, requiredMetaFields: l, updateMeta: J, form: G, formState: U })), u("div", { className: "uppy-Dashboard-FileCard-actions" }, u("button", { className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Dashboard-FileCard-actionsBtn", type: "submit", form: G.id }, p("saveChanges")), u("button", { className: "uppy-u-reset uppy-c-btn uppy-c-btn-link uppy-Dashboard-FileCard-actionsBtn", type: "button", onClick: L, form: G.id }, p("cancel"))))) } n(Fh, "FileCard"); var ey = de(Jt(), 1); var zo = "uppy-transition-slideDownUp", Zg = 250, xu = class extends ve { constructor(e) { super(e), this.state = { cachedChildren: null, className: "" } } componentWillUpdate(e) { let { cachedChildren: t } = this.state, r = ci(e.children)[0]; if (t === r) return null; let s = { cachedChildren: r }; r && !t && (s.className = `${zo}-enter`, cancelAnimationFrame(this.animationFrame), clearTimeout(this.leaveTimeout), this.leaveTimeout = void 0, this.animationFrame = requestAnimationFrame(() => { this.setState({ className: `${zo}-enter ${zo}-enter-active` }), this.enterTimeout = setTimeout(() => { this.setState({ className: "" }) }, Zg) })), t && !r && this.leaveTimeout === void 0 && (s.cachedChildren = t, s.className = `${zo}-leave`, cancelAnimationFrame(this.animationFrame), clearTimeout(this.enterTimeout), this.enterTimeout = void 0, this.animationFrame = requestAnimationFrame(() => { this.setState({ className: `${zo}-leave ${zo}-leave-active` }), this.leaveTimeout = setTimeout(() => { this.setState({ cachedChildren: null, className: "" }) }, Zg) })), this.setState(s) } render() { let { cachedChildren: e, className: t } = this.state; return e ? Ml(e, { className: (0, ey.default)(t, e.props.className) }) : null } }; n(xu, "Slide"); var fa = xu; function Ts() { return Ts = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, Ts.apply(this, arguments) } n(Ts, "_extends"); var ty = 900, iy = 700, xh = 576, ry = 330; function Oh(i) { let e = i.totalFileCount === 0, t = i.totalFileCount === 1, r = i.containerWidth > xh, s = i.containerHeight > ry, o = (0, sy.default)({ "uppy-Dashboard": !0, "uppy-Dashboard--isDisabled": i.disabled, "uppy-Dashboard--animateOpenClose": i.animateOpenClose, "uppy-Dashboard--isClosing": i.isClosing, "uppy-Dashboard--isDraggingOver": i.isDraggingOver, "uppy-Dashboard--modal": !i.inline, "uppy-size--md": i.containerWidth > xh, "uppy-size--lg": i.containerWidth > iy, "uppy-size--xl": i.containerWidth > ty, "uppy-size--height-md": i.containerHeight > ry, "uppy-Dashboard--isAddFilesPanelVisible": i.showAddFilesPanel, "uppy-Dashboard--isInnerWrapVisible": i.areInsidesReadyToBeVisible, "uppy-Dashboard--singleFile": i.singleFileFullScreen && t && s }), a = 1; i.containerWidth > ty ? a = 5 : i.containerWidth > iy ? a = 4 : i.containerWidth > xh && (a = 3); let l = i.showSelectedFiles && !e, d = i.recoveredState ? Object.keys(i.recoveredState.files).length : null, p = i.files ? Object.keys(i.files).filter(y => i.files[y].isGhost).length : null, h = n(() => p > 0 ? i.i18n("recoveredXFiles", { smart_count: p }) : i.i18n("recoveredAllFiles"), "renderRestoredText"); return u("div", { className: o, "data-uppy-theme": i.theme, "data-uppy-num-acquirers": i.acquirers.length, "data-uppy-drag-drop-supported": !i.disableLocalFiles && ha(), "aria-hidden": i.inline ? "false" : i.isHidden, "aria-disabled": i.disabled, "aria-label": i.inline ? i.i18n("dashboardTitle") : i.i18n("dashboardWindowTitle"), onPaste: i.handlePaste, onDragOver: i.handleDragOver, onDragLeave: i.handleDragLeave, onDrop: i.handleDrop }, u("div", { "aria-hidden": "true", className: "uppy-Dashboard-overlay", tabIndex: -1, onClick: i.handleClickOutside }), u("div", { className: "uppy-Dashboard-inner", "aria-modal": !i.inline && "true", role: !i.inline && "dialog", style: { width: i.inline && i.width ? i.width : "", height: i.inline && i.height ? i.height : "" } }, i.inline ? null : u("button", { className: "uppy-u-reset uppy-Dashboard-close", type: "button", "aria-label": i.i18n("closeModal"), title: i.i18n("closeModal"), onClick: i.closeModal }, u("span", { "aria-hidden": "true" }, "\xD7")), u("div", { className: "uppy-Dashboard-innerWrap" }, u("div", { className: "uppy-Dashboard-dropFilesHereHint" }, i.i18n("dropHint")), l && u(Qg, i), d && u("div", { className: "uppy-Dashboard-serviceMsg" }, u("svg", { className: "uppy-Dashboard-serviceMsg-icon", "aria-hidden": "true", focusable: "false", width: "21", height: "16", viewBox: "0 0 24 19" }, u("g", { transform: "translate(0 -1)", fill: "none", fillRule: "evenodd" }, u("path", { d: "M12.857 1.43l10.234 17.056A1 1 0 0122.234 20H1.766a1 1 0 01-.857-1.514L11.143 1.429a1 1 0 011.714 0z", fill: "#FFD300" }), u("path", { fill: "#000", d: "M11 6h2l-.3 8h-1.4z" }), u("circle", { fill: "#000", cx: "12", cy: "17", r: "1" }))), u("strong", { className: "uppy-Dashboard-serviceMsg-title" }, i.i18n("sessionRestored")), u("div", { className: "uppy-Dashboard-serviceMsg-text" }, h())), l ? u($g, { id: i.id, error: i.error, i18n: i.i18n, uppy: i.uppy, files: i.files, acquirers: i.acquirers, resumableUploads: i.resumableUploads, hideRetryButton: i.hideRetryButton, hidePauseResumeButton: i.hidePauseResumeButton, hideCancelButton: i.hideCancelButton, showLinkToFileUploadResult: i.showLinkToFileUploadResult, showRemoveButtonAfterComplete: i.showRemoveButtonAfterComplete, isWide: i.isWide, metaFields: i.metaFields, toggleFileCard: i.toggleFileCard, handleRequestThumbnail: i.handleRequestThumbnail, handleCancelThumbnail: i.handleCancelThumbnail, recoveredState: i.recoveredState, individualCancellation: i.individualCancellation, openFileEditor: i.openFileEditor, canEditFile: i.canEditFile, toggleAddFilesPanel: i.toggleAddFilesPanel, isSingleFile: t, itemsPerRow: a }) : u(Fu, Ts({}, i, { isSizeMD: r })), u(fa, null, i.showAddFilesPanel ? u(Wg, Ts({ key: "AddFiles" }, i, { isSizeMD: r })) : null), u(fa, null, i.fileCardFor ? u(Fh, Ts({ key: "FileCard" }, i)) : null), u(fa, null, i.activePickerPanel ? u(Kg, Ts({ key: "Picker" }, i)) : null), u(fa, null, i.showFileEditor ? u(Yg, Ts({ key: "Editor" }, i)) : null), u("div", { className: "uppy-Dashboard-progressindicators" }, i.progressindicators.map(y => i.uppy.getPlugin(y.id).render(i.state)))))) } n(Oh, "Dashboard"); var oy = { strings: { closeModal: "Close Modal", addMoreFiles: "Add more files", addingMoreFiles: "Adding more files", importFrom: "Import from %{name}", dashboardWindowTitle: "Uppy Dashboard Window (Press escape to close)", dashboardTitle: "Uppy Dashboard", copyLinkToClipboardSuccess: "Link copied to clipboard.", copyLinkToClipboardFallback: "Copy the URL below", copyLink: "Copy link", back: "Back", removeFile: "Remove file", editFile: "Edit file", editing: "Editing %{file}", error: "Error", finishEditingFile: "Finish editing file", saveChanges: "Save changes", myDevice: "My Device", dropHint: "Drop your files here", uploadComplete: "Upload complete", uploadPaused: "Upload paused", resumeUpload: "Resume upload", pauseUpload: "Pause upload", retryUpload: "Retry upload", cancelUpload: "Cancel upload", xFilesSelected: { 0: "%{smart_count} file selected", 1: "%{smart_count} files selected" }, uploadingXFiles: { 0: "Uploading %{smart_count} file", 1: "Uploading %{smart_count} files" }, processingXFiles: { 0: "Processing %{smart_count} file", 1: "Processing %{smart_count} files" }, poweredBy: "Powered by %{uppy}", addMore: "Add more", editFileWithFilename: "Edit file %{file}", save: "Save", cancel: "Cancel", dropPasteFiles: "Drop files here or %{browseFiles}", dropPasteFolders: "Drop files here or %{browseFolders}", dropPasteBoth: "Drop files here, %{browseFiles} or %{browseFolders}", dropPasteImportFiles: "Drop files here, %{browseFiles} or import from:", dropPasteImportFolders: "Drop files here, %{browseFolders} or import from:", dropPasteImportBoth: "Drop files here, %{browseFiles}, %{browseFolders} or import from:", importFiles: "Import files from:", browseFiles: "browse files", browseFolders: "browse folders", recoveredXFiles: { 0: "We could not fully recover 1 file. Please re-select it and resume the upload.", 1: "We could not fully recover %{smart_count} files. Please re-select them and resume the upload." }, recoveredAllFiles: "We restored all files. You can now resume the upload.", sessionRestored: "Session restored", reSelect: "Re-select", missingRequiredMetaFields: { 0: "Missing required meta field: %{fields}.", 1: "Missing required meta fields: %{fields}." }, takePictureBtn: "Take Picture", recordVideoBtn: "Record Video" } }; function Je(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Je, "_classPrivateFieldLooseBase"); var eS = 0; function is(i) { return "__private_" + eS++ + "_" + i } n(is, "_classPrivateFieldLooseKey"); var tS = { version: "3.5.4" }, Eh = ch.default || ch, ny = 9, iS = 27; function ay() { let i = {}; return i.promise = new Promise((e, t) => { i.resolve = e, i.reject = t }), i } n(ay, "createPromise"); var Rs = is("disabledNodes"), Cr = is("generateLargeThumbnailIfSingleFile"), ma = is("openFileEditorWhenFilesAdded"), Us = is("attachRenderFunctionToTarget"), Ch = is("isTargetSupported"), Ah = is("getAcquirers"), Th = is("getProgressIndicators"), Ar = is("getEditors"), qi = class extends Q { constructor(e, t) { var r; super(e, t), r = this, Object.defineProperty(this, Rs, { writable: !0, value: null }), this.removeTarget = o => { let l = this.getPluginState().targets.filter(d => d.id !== o.id); this.setPluginState({ targets: l }) }, this.addTarget = o => { let a = o.id || o.constructor.name, l = o.title || a, d = o.type; if (d !== "acquirer" && d !== "progressindicator" && d !== "editor") { let y = "Dashboard: can only be targeted by plugins of types: acquirer, progressindicator, editor"; this.uppy.log(y, "error"); return } let p = { id: a, name: l, type: d }, m = this.getPluginState().targets.slice(); return m.push(p), this.setPluginState({ targets: m }), this.el }, this.hideAllPanels = () => { let o = this.getPluginState(), a = { activePickerPanel: !1, showAddFilesPanel: !1, activeOverlayType: null, fileCardFor: null, showFileEditor: !1 }; o.activePickerPanel === a.activePickerPanel && o.showAddFilesPanel === a.showAddFilesPanel && o.showFileEditor === a.showFileEditor && o.activeOverlayType === a.activeOverlayType || (this.setPluginState(a), this.uppy.emit("dashboard:close-panel", o.activePickerPanel.id)) }, this.showPanel = o => { let { targets: a } = this.getPluginState(), l = a.filter(d => d.type === "acquirer" && d.id === o)[0]; this.setPluginState({ activePickerPanel: l, activeOverlayType: "PickerPanel" }), this.uppy.emit("dashboard:show-panel", o) }, this.canEditFile = o => { let { targets: a } = this.getPluginState(); return Je(this, Ar)[Ar](a).some(d => this.uppy.getPlugin(d.id).canEditFile(o)) }, this.openFileEditor = o => { let { targets: a } = this.getPluginState(), l = Je(this, Ar)[Ar](a); this.setPluginState({ showFileEditor: !0, fileCardFor: o.id || null, activeOverlayType: "FileEditor" }), l.forEach(d => { this.uppy.getPlugin(d.id).selectFile(o) }) }, this.saveFileEditor = () => { let { targets: o } = this.getPluginState(); Je(this, Ar)[Ar](o).forEach(l => { this.uppy.getPlugin(l.id).save() }), this.hideAllPanels() }, this.openModal = () => { let { promise: o, resolve: a } = ay(); if (this.savedScrollPosition = window.pageYOffset, this.savedActiveElement = document.activeElement, this.opts.disablePageScrollWhenModalOpen && document.body.classList.add("uppy-Dashboard-isFixed"), this.opts.animateOpenClose && this.getPluginState().isClosing) { let l = n(() => { this.setPluginState({ isHidden: !1 }), this.el.removeEventListener("animationend", l, !1), a() }, "handler"); this.el.addEventListener("animationend", l, !1) } else this.setPluginState({ isHidden: !1 }), a(); return this.opts.browserBackButtonClose && this.updateBrowserHistory(), document.addEventListener("keydown", this.handleKeyDownInModal), this.uppy.emit("dashboard:modal-open"), o }, this.closeModal = function (o) { o === void 0 && (o = {}); let { manualClose: a = !0 } = o, { isHidden: l, isClosing: d } = r.getPluginState(); if (l || d) return; let { promise: p, resolve: h } = ay(); if (r.opts.disablePageScrollWhenModalOpen && document.body.classList.remove("uppy-Dashboard-isFixed"), r.opts.animateOpenClose) { r.setPluginState({ isClosing: !0 }); let y = n(() => { r.setPluginState({ isHidden: !0, isClosing: !1 }), r.superFocus.cancel(), r.savedActiveElement.focus(), r.el.removeEventListener("animationend", y, !1), h() }, "handler"); r.el.addEventListener("animationend", y, !1) } else r.setPluginState({ isHidden: !0 }), r.superFocus.cancel(), r.savedActiveElement.focus(), h(); if (document.removeEventListener("keydown", r.handleKeyDownInModal), a && r.opts.browserBackButtonClose) { var m; (m = history.state) != null && m[r.modalName] && history.back() } return r.uppy.emit("dashboard:modal-closed"), p }, this.isModalOpen = () => !this.getPluginState().isHidden || !1, this.requestCloseModal = () => this.opts.onRequestCloseModal ? this.opts.onRequestCloseModal() : this.closeModal(), this.setDarkModeCapability = o => { let { capabilities: a } = this.uppy.getState(); this.uppy.setState({ capabilities: { ...a, darkMode: o } }) }, this.handleSystemDarkModeChange = o => { let a = o.matches; this.uppy.log(`[Dashboard] Dark mode is ${a ? "on" : "off"}`), this.setDarkModeCapability(a) }, this.toggleFileCard = (o, a) => { let l = this.uppy.getFile(a); o ? this.uppy.emit("dashboard:file-edit-start", l) : this.uppy.emit("dashboard:file-edit-complete", l), this.setPluginState({ fileCardFor: o ? a : null, activeOverlayType: o ? "FileCard" : null }) }, this.toggleAddFilesPanel = o => { this.setPluginState({ showAddFilesPanel: o, activeOverlayType: o ? "AddFiles" : null }) }, this.addFiles = o => { let a = o.map(l => ({ source: this.id, name: l.name, type: l.type, data: l, meta: { relativePath: l.relativePath || l.webkitRelativePath || null } })); try { this.uppy.addFiles(a) } catch (l) { this.uppy.log(l) } }, this.startListeningToResize = () => { this.resizeObserver = new ResizeObserver(o => { let a = o[0], { width: l, height: d } = a.contentRect; this.setPluginState({ containerWidth: l, containerHeight: d, areInsidesReadyToBeVisible: !0 }) }), this.resizeObserver.observe(this.el.querySelector(".uppy-Dashboard-inner")), this.makeDashboardInsidesVisibleAnywayTimeout = setTimeout(() => { let o = this.getPluginState(), a = !this.opts.inline && o.isHidden; !o.areInsidesReadyToBeVisible && !a && (this.uppy.log("[Dashboard] resize event didn\u2019t fire on time: defaulted to mobile layout", "warning"), this.setPluginState({ areInsidesReadyToBeVisible: !0 })) }, 1e3) }, this.stopListeningToResize = () => { this.resizeObserver.disconnect(), clearTimeout(this.makeDashboardInsidesVisibleAnywayTimeout) }, this.recordIfFocusedOnUppyRecently = o => { this.el.contains(o.target) ? this.ifFocusedOnUppyRecently = !0 : (this.ifFocusedOnUppyRecently = !1, this.superFocus.cancel()) }, this.disableInteractiveElements = o => { var a; let l = ["a[href]", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", '[role="button"]:not([disabled])'], d = (a = Je(this, Rs)[Rs]) != null ? a : Ke(this.el.querySelectorAll(l)).filter(p => !p.classList.contains("uppy-Dashboard-close")); for (let p of d) p.tagName === "A" ? p.setAttribute("aria-disabled", o) : p.disabled = o; o ? Je(this, Rs)[Rs] = d : Je(this, Rs)[Rs] = null, this.dashboardIsDisabled = o }, this.updateBrowserHistory = () => { var o; (o = history.state) != null && o[this.modalName] || history.pushState({ ...history.state, [this.modalName]: !0 }, ""), window.addEventListener("popstate", this.handlePopState, !1) }, this.handlePopState = o => { var a; this.isModalOpen() && (!o.state || !o.state[this.modalName]) && this.closeModal({ manualClose: !1 }), !this.isModalOpen() && (a = o.state) != null && a[this.modalName] && history.back() }, this.handleKeyDownInModal = o => { o.keyCode === iS && this.requestCloseModal(o), o.keyCode === ny && ph(o, this.getPluginState().activeOverlayType, this.el) }, this.handleClickOutside = () => { this.opts.closeModalOnClickOutside && this.requestCloseModal() }, this.handlePaste = o => { this.uppy.iteratePlugins(l => { l.type === "acquirer" && (l.handleRootPaste == null || l.handleRootPaste(o)) }); let a = Ke(o.clipboardData.files); a.length > 0 && (this.uppy.log("[Dashboard] Files pasted"), this.addFiles(a)) }, this.handleInputChange = o => { o.preventDefault(); let a = Ke(o.target.files); a.length > 0 && (this.uppy.log("[Dashboard] Files selected through input"), this.addFiles(a)) }, this.handleDragOver = o => { var a, l; o.preventDefault(), o.stopPropagation(); let d = n(() => { let y = !0; return this.uppy.iteratePlugins(b => { b.canHandleRootDrop != null && b.canHandleRootDrop(o) && (y = !0) }), y }, "canSomePluginHandleRootDrop"), p = n(() => { let { types: y } = o.dataTransfer; return y.some(b => b === "Files") }, "doesEventHaveFiles"), h = d(o), m = p(o); if (!h && !m || this.opts.disabled || this.opts.disableLocalFiles && (m || !h) || !this.uppy.getState().allowNewUpload) { o.dataTransfer.dropEffect = "none", clearTimeout(this.removeDragOverClassTimeout); return } o.dataTransfer.dropEffect = "copy", clearTimeout(this.removeDragOverClassTimeout), this.setPluginState({ isDraggingOver: !0 }), (a = (l = this.opts).onDragOver) == null || a.call(l, o) }, this.handleDragLeave = o => { var a, l; o.preventDefault(), o.stopPropagation(), clearTimeout(this.removeDragOverClassTimeout), this.removeDragOverClassTimeout = setTimeout(() => { this.setPluginState({ isDraggingOver: !1 }) }, 50), (a = (l = this.opts).onDragLeave) == null || a.call(l, o) }, this.handleDrop = async o => { var a, l; o.preventDefault(), o.stopPropagation(), clearTimeout(this.removeDragOverClassTimeout), this.setPluginState({ isDraggingOver: !1 }), this.uppy.iteratePlugins(m => { m.type === "acquirer" && (m.handleRootDrop == null || m.handleRootDrop(o)) }); let d = !1, p = n(m => { this.uppy.log(m, "error"), d || (this.uppy.info(m.message, "error"), d = !0) }, "logDropError"); this.uppy.log("[Dashboard] Processing dropped files"); let h = await Cs(o.dataTransfer, { logDropError: p }); h.length > 0 && (this.uppy.log("[Dashboard] Files dropped"), this.addFiles(h)), (a = (l = this.opts).onDrop) == null || a.call(l, o) }, this.handleRequestThumbnail = o => { this.opts.waitForThumbnailsBeforeUpload || this.uppy.emit("thumbnail:request", o) }, this.handleCancelThumbnail = o => { this.opts.waitForThumbnailsBeforeUpload || this.uppy.emit("thumbnail:cancel", o) }, this.handleKeyDownInInline = o => { o.keyCode === ny && kg(o, this.getPluginState().activeOverlayType, this.el) }, this.handlePasteOnBody = o => { this.el.contains(document.activeElement) && this.handlePaste(o) }, this.handleComplete = o => { let { failed: a } = o; this.opts.closeAfterFinish && a.length === 0 && this.requestCloseModal() }, this.handleCancelRestore = () => { this.uppy.emit("restore-canceled") }, Object.defineProperty(this, Cr, { writable: !0, value: () => { if (this.opts.disableThumbnailGenerator) return; let o = 600, a = this.uppy.getFiles(); if (a.length === 1) { let l = this.uppy.getPlugin(`${this.id}:ThumbnailGenerator`); l?.setOptions({ thumbnailWidth: o }); let d = { ...a[0], preview: void 0 }; l.requestThumbnail(d).then(() => { l?.setOptions({ thumbnailWidth: this.opts.thumbnailWidth }) }) } } }), Object.defineProperty(this, ma, { writable: !0, value: o => { let a = o[0]; this.canEditFile(a) && this.openFileEditor(a) } }), this.initEvents = () => { if (this.opts.trigger && !this.opts.inline) { let o = vu(this.opts.trigger); o ? o.forEach(a => a.addEventListener("click", this.openModal)) : this.uppy.log("Dashboard modal trigger not found. Make sure `trigger` is set in Dashboard options, unless you are planning to call `dashboard.openModal()` method yourself", "warning") } this.startListeningToResize(), document.addEventListener("paste", this.handlePasteOnBody), this.uppy.on("plugin-remove", this.removeTarget), this.uppy.on("file-added", this.hideAllPanels), this.uppy.on("dashboard:modal-closed", this.hideAllPanels), this.uppy.on("file-editor:complete", this.hideAllPanels), this.uppy.on("complete", this.handleComplete), this.uppy.on("files-added", Je(this, Cr)[Cr]), this.uppy.on("file-removed", Je(this, Cr)[Cr]), document.addEventListener("focus", this.recordIfFocusedOnUppyRecently, !0), document.addEventListener("click", this.recordIfFocusedOnUppyRecently, !0), this.opts.inline && this.el.addEventListener("keydown", this.handleKeyDownInInline), this.opts.autoOpenFileEditor && this.uppy.on("files-added", Je(this, ma)[ma]) }, this.removeEvents = () => { let o = vu(this.opts.trigger); !this.opts.inline && o && o.forEach(a => a.removeEventListener("click", this.openModal)), this.stopListeningToResize(), document.removeEventListener("paste", this.handlePasteOnBody), window.removeEventListener("popstate", this.handlePopState, !1), this.uppy.off("plugin-remove", this.removeTarget), this.uppy.off("file-added", this.hideAllPanels), this.uppy.off("dashboard:modal-closed", this.hideAllPanels), this.uppy.off("file-editor:complete", this.hideAllPanels), this.uppy.off("complete", this.handleComplete), this.uppy.off("files-added", Je(this, Cr)[Cr]), this.uppy.off("file-removed", Je(this, Cr)[Cr]), document.removeEventListener("focus", this.recordIfFocusedOnUppyRecently), document.removeEventListener("click", this.recordIfFocusedOnUppyRecently), this.opts.inline && this.el.removeEventListener("keydown", this.handleKeyDownInInline), this.opts.autoOpenFileEditor && this.uppy.off("files-added", Je(this, ma)[ma]) }, this.superFocusOnEachUpdate = () => { let o = this.el.contains(document.activeElement), a = document.activeElement === document.body || document.activeElement === null, l = this.uppy.getState().info.length === 0, d = !this.opts.inline; l && (d || o || a && this.ifFocusedOnUppyRecently) ? this.superFocus(this.el, this.getPluginState().activeOverlayType) : this.superFocus.cancel() }, this.afterUpdate = () => { if (this.opts.disabled && !this.dashboardIsDisabled) { this.disableInteractiveElements(!0); return } !this.opts.disabled && this.dashboardIsDisabled && this.disableInteractiveElements(!1), this.superFocusOnEachUpdate() }, this.saveFileCard = (o, a) => { this.uppy.setFileMeta(a, o), this.toggleFileCard(!1, a) }, Object.defineProperty(this, Us, { writable: !0, value: o => { let a = this.uppy.getPlugin(o.id); return { ...o, icon: a.icon || this.opts.defaultPickerIcon, render: a.render } } }), Object.defineProperty(this, Ch, { writable: !0, value: o => { let a = this.uppy.getPlugin(o.id); return typeof a.isSupported != "function" ? !0 : a.isSupported() } }), Object.defineProperty(this, Ah, { writable: !0, value: Eh(o => o.filter(a => a.type === "acquirer" && Je(this, Ch)[Ch](a)).map(Je(this, Us)[Us])) }), Object.defineProperty(this, Th, { writable: !0, value: Eh(o => o.filter(a => a.type === "progressindicator").map(Je(this, Us)[Us])) }), Object.defineProperty(this, Ar, { writable: !0, value: Eh(o => o.filter(a => a.type === "editor").map(Je(this, Us)[Us])) }), this.render = o => { let a = this.getPluginState(), { files: l, capabilities: d, allowNewUpload: p } = o, { newFiles: h, uploadStartedFiles: m, completeFiles: y, erroredFiles: b, inProgressFiles: S, inProgressNotPausedFiles: O, processingFiles: F, isUploadStarted: x, isAllComplete: U, isAllErrored: H, isAllPaused: W } = this.uppy.getObjectOfFilesPerState(), J = Je(this, Ah)[Ah](a.targets), L = Je(this, Th)[Th](a.targets), G = Je(this, Ar)[Ar](a.targets), ee; return this.opts.theme === "auto" ? ee = d.darkMode ? "dark" : "light" : ee = this.opts.theme, ["files", "folders", "both"].indexOf(this.opts.fileManagerSelectionType) < 0 && (this.opts.fileManagerSelectionType = "files", console.warn(`Unsupported option for "fileManagerSelectionType". Using default of "${this.opts.fileManagerSelectionType}".`)), Oh({ state: o, isHidden: a.isHidden, files: l, newFiles: h, uploadStartedFiles: m, completeFiles: y, erroredFiles: b, inProgressFiles: S, inProgressNotPausedFiles: O, processingFiles: F, isUploadStarted: x, isAllComplete: U, isAllErrored: H, isAllPaused: W, totalFileCount: Object.keys(l).length, totalProgress: o.totalProgress, allowNewUpload: p, acquirers: J, theme: ee, disabled: this.opts.disabled, disableLocalFiles: this.opts.disableLocalFiles, direction: this.opts.direction, activePickerPanel: a.activePickerPanel, showFileEditor: a.showFileEditor, saveFileEditor: this.saveFileEditor, disableInteractiveElements: this.disableInteractiveElements, animateOpenClose: this.opts.animateOpenClose, isClosing: a.isClosing, progressindicators: L, editors: G, autoProceed: this.uppy.opts.autoProceed, id: this.id, closeModal: this.requestCloseModal, handleClickOutside: this.handleClickOutside, handleInputChange: this.handleInputChange, handlePaste: this.handlePaste, inline: this.opts.inline, showPanel: this.showPanel, hideAllPanels: this.hideAllPanels, i18n: this.i18n, i18nArray: this.i18nArray, uppy: this.uppy, note: this.opts.note, recoveredState: o.recoveredState, metaFields: a.metaFields, resumableUploads: d.resumableUploads || !1, individualCancellation: d.individualCancellation, isMobileDevice: d.isMobileDevice, fileCardFor: a.fileCardFor, toggleFileCard: this.toggleFileCard, toggleAddFilesPanel: this.toggleAddFilesPanel, showAddFilesPanel: a.showAddFilesPanel, saveFileCard: this.saveFileCard, openFileEditor: this.openFileEditor, canEditFile: this.canEditFile, width: this.opts.width, height: this.opts.height, showLinkToFileUploadResult: this.opts.showLinkToFileUploadResult, fileManagerSelectionType: this.opts.fileManagerSelectionType, proudlyDisplayPoweredByUppy: this.opts.proudlyDisplayPoweredByUppy, hideCancelButton: this.opts.hideCancelButton, hideRetryButton: this.opts.hideRetryButton, hidePauseResumeButton: this.opts.hidePauseResumeButton, showRemoveButtonAfterComplete: this.opts.showRemoveButtonAfterComplete, containerWidth: a.containerWidth, containerHeight: a.containerHeight, areInsidesReadyToBeVisible: a.areInsidesReadyToBeVisible, isTargetDOMEl: this.isTargetDOMEl, parentElement: this.el, allowedFileTypes: this.uppy.opts.restrictions.allowedFileTypes, maxNumberOfFiles: this.uppy.opts.restrictions.maxNumberOfFiles, requiredMetaFields: this.uppy.opts.restrictions.requiredMetaFields, showSelectedFiles: this.opts.showSelectedFiles, showNativePhotoCameraButton: this.opts.showNativePhotoCameraButton, showNativeVideoCameraButton: this.opts.showNativeVideoCameraButton, nativeCameraFacingMode: this.opts.nativeCameraFacingMode, singleFileFullScreen: this.opts.singleFileFullScreen, handleCancelRestore: this.handleCancelRestore, handleRequestThumbnail: this.handleRequestThumbnail, handleCancelThumbnail: this.handleCancelThumbnail, isDraggingOver: a.isDraggingOver, handleDragOver: this.handleDragOver, handleDragLeave: this.handleDragLeave, handleDrop: this.handleDrop }) }, this.discoverProviderPlugins = () => { this.uppy.iteratePlugins(o => { o && !o.target && o.opts && o.opts.target === this.constructor && this.addTarget(o) }) }, this.install = () => { this.setPluginState({ isHidden: !0, fileCardFor: null, activeOverlayType: null, showAddFilesPanel: !1, activePickerPanel: !1, showFileEditor: !1, metaFields: this.opts.metaFields, targets: [], areInsidesReadyToBeVisible: !1, isDraggingOver: !1 }); let { inline: o, closeAfterFinish: a } = this.opts; if (o && a) throw new Error("[Dashboard] `closeAfterFinish: true` cannot be used on an inline Dashboard, because an inline Dashboard cannot be closed at all. Either set `inline: false`, or disable the `closeAfterFinish` option."); let { allowMultipleUploads: l, allowMultipleUploadBatches: d } = this.uppy.opts; (l || d) && a && this.uppy.log("[Dashboard] When using `closeAfterFinish`, we recommended setting the `allowMultipleUploadBatches` option to `false` in the Uppy constructor. See https://uppy.io/docs/uppy/#allowMultipleUploads-true", "warning"); let { target: p } = this.opts; p && this.mount(p, this), (this.opts.plugins || []).forEach(y => { let b = this.uppy.getPlugin(y); b && b.mount(this, b) }), this.opts.disableStatusBar || this.uppy.use(ji, { id: `${this.id}:StatusBar`, target: this, hideUploadButton: this.opts.hideUploadButton, hideRetryButton: this.opts.hideRetryButton, hidePauseResumeButton: this.opts.hidePauseResumeButton, hideCancelButton: this.opts.hideCancelButton, showProgressDetails: this.opts.showProgressDetails, hideAfterFinish: this.opts.hideProgressAfterFinish, locale: this.opts.locale, doneButtonHandler: this.opts.doneButtonHandler }), this.opts.disableInformer || this.uppy.use(zi, { id: `${this.id}:Informer`, target: this }), this.opts.disableThumbnailGenerator || this.uppy.use(Er, { id: `${this.id}:ThumbnailGenerator`, thumbnailWidth: this.opts.thumbnailWidth, thumbnailHeight: this.opts.thumbnailHeight, thumbnailType: this.opts.thumbnailType, waitForThumbnailsBeforeUpload: this.opts.waitForThumbnailsBeforeUpload, lazy: !this.opts.waitForThumbnailsBeforeUpload }), this.darkModeMediaQuery = typeof window < "u" && window.matchMedia ? window.matchMedia("(prefers-color-scheme: dark)") : null; let m = this.darkModeMediaQuery ? this.darkModeMediaQuery.matches : !1; this.uppy.log(`[Dashboard] Dark mode is ${m ? "on" : "off"}`), this.setDarkModeCapability(m), this.opts.theme === "auto" && this.darkModeMediaQuery.addListener(this.handleSystemDarkModeChange), this.discoverProviderPlugins(), this.initEvents() }, this.uninstall = () => { if (!this.opts.disableInformer) { let a = this.uppy.getPlugin(`${this.id}:Informer`); a && this.uppy.removePlugin(a) } if (!this.opts.disableStatusBar) { let a = this.uppy.getPlugin(`${this.id}:StatusBar`); a && this.uppy.removePlugin(a) } if (!this.opts.disableThumbnailGenerator) { let a = this.uppy.getPlugin(`${this.id}:ThumbnailGenerator`); a && this.uppy.removePlugin(a) } (this.opts.plugins || []).forEach(a => { let l = this.uppy.getPlugin(a); l && l.unmount() }), this.opts.theme === "auto" && this.darkModeMediaQuery.removeListener(this.handleSystemDarkModeChange), this.unmount(), this.removeEvents() }, this.id = this.opts.id || "Dashboard", this.title = "Dashboard", this.type = "orchestrator", this.modalName = `uppy-Dashboard-${St()}`, this.defaultLocale = oy; let s = { target: "body", metaFields: [], trigger: null, inline: !1, width: 750, height: 550, thumbnailWidth: 280, thumbnailType: "image/jpeg", waitForThumbnailsBeforeUpload: !1, defaultPickerIcon: Ro, showLinkToFileUploadResult: !1, showProgressDetails: !1, hideUploadButton: !1, hideCancelButton: !1, hideRetryButton: !1, hidePauseResumeButton: !1, hideProgressAfterFinish: !1, doneButtonHandler: () => { this.uppy.cancelAll(), this.requestCloseModal() }, note: null, closeModalOnClickOutside: !1, closeAfterFinish: !1, singleFileFullScreen: !0, disableStatusBar: !1, disableInformer: !1, disableThumbnailGenerator: !1, disablePageScrollWhenModalOpen: !0, animateOpenClose: !0, fileManagerSelectionType: "files", proudlyDisplayPoweredByUppy: !0, onRequestCloseModal: () => this.closeModal(), showSelectedFiles: !0, showRemoveButtonAfterComplete: !1, browserBackButtonClose: !1, showNativePhotoCameraButton: !1, showNativeVideoCameraButton: !1, theme: "light", autoOpenFileEditor: !1, disabled: !1, disableLocalFiles: !1 }; this.opts = { ...s, ...t }, this.i18nInit(), this.superFocus = fh(), this.ifFocusedOnUppyRecently = !1, this.makeDashboardInsidesVisibleAnywayTimeout = null, this.removeDragOverClassTimeout = null } }; n(qi, "Dashboard"); qi.VERSION = tS.version; var ly = { strings: { dropHereOr: "Drop here or %{browse}", browse: "browse" } }; var rS = { version: "3.0.3" }, Vi = class extends Q {
        constructor(e, t) { super(e, t), this.handleDrop = async s => { var o, a; s.preventDefault(), s.stopPropagation(), clearTimeout(this.removeDragOverClassTimeout), this.setPluginState({ isDraggingOver: !1 }); let l = n(p => { this.uppy.log(p, "error") }, "logDropError"), d = await Cs(s.dataTransfer, { logDropError: l }); d.length > 0 && (this.uppy.log("[DragDrop] Files dropped"), this.addFiles(d)), (o = (a = this.opts).onDrop) == null || o.call(a, s) }, this.type = "acquirer", this.id = this.opts.id || "DragDrop", this.title = "Drag & Drop", this.defaultLocale = ly; let r = { target: null, inputName: "files[]", width: "100%", height: "100%", note: null }; this.opts = { ...r, ...t }, this.i18nInit(), this.isDragDropSupported = ha(), this.removeDragOverClassTimeout = null, this.onInputChange = this.onInputChange.bind(this), this.handleDragOver = this.handleDragOver.bind(this), this.handleDragLeave = this.handleDragLeave.bind(this), this.handleDrop = this.handleDrop.bind(this), this.addFiles = this.addFiles.bind(this), this.render = this.render.bind(this) } addFiles(e) { let t = e.map(r => ({ source: this.id, name: r.name, type: r.type, data: r, meta: { relativePath: r.relativePath || null } })); try { this.uppy.addFiles(t) } catch (r) { this.uppy.log(r) } } onInputChange(e) { let t = Ke(e.target.files); t.length > 0 && (this.uppy.log("[DragDrop] Files selected through input"), this.addFiles(t)), e.target.value = null } handleDragOver(e) { var t, r; e.preventDefault(), e.stopPropagation(); let { types: s } = e.dataTransfer, o = s.some(l => l === "Files"), { allowNewUpload: a } = this.uppy.getState(); if (!o || !a) { e.dataTransfer.dropEffect = "none", clearTimeout(this.removeDragOverClassTimeout); return } e.dataTransfer.dropEffect = "copy", clearTimeout(this.removeDragOverClassTimeout), this.setPluginState({ isDraggingOver: !0 }), (t = (r = this.opts).onDragOver) == null || t.call(r, e) } handleDragLeave(e) { var t, r; e.preventDefault(), e.stopPropagation(), clearTimeout(this.removeDragOverClassTimeout), this.removeDragOverClassTimeout = setTimeout(() => { this.setPluginState({ isDraggingOver: !1 }) }, 50), (t = (r = this.opts).onDragLeave) == null || t.call(r, e) } renderHiddenFileInput() { let { restrictions: e } = this.uppy.opts; return u("input", { className: "uppy-DragDrop-input", type: "file", hidden: !0, ref: t => { this.fileInputRef = t }, name: this.opts.inputName, multiple: e.maxNumberOfFiles !== 1, accept: e.allowedFileTypes, onChange: this.onInputChange }) } static renderArrowSvg() { return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon uppy-DragDrop-arrow", width: "16", height: "16", viewBox: "0 0 16 16" }, u("path", { d: "M11 10V0H5v10H2l6 6 6-6h-3zm0 0", fillRule: "evenodd" })) } renderLabel() { return u("div", { className: "uppy-DragDrop-label" }, this.i18nArray("dropHereOr", { browse: u("span", { className: "uppy-DragDrop-browse" }, this.i18n("browse")) })) } renderNote() { return u("span", { className: "uppy-DragDrop-note" }, this.opts.note) } render() {
            let e = `uppy-u-reset
      uppy-DragDrop-container
      ${this.isDragDropSupported ? "uppy-DragDrop--isDragDropSupported" : ""}
      ${this.getPluginState().isDraggingOver ? "uppy-DragDrop--isDraggingOver" : ""}
    `, t = { width: this.opts.width, height: this.opts.height }; return u("button", { type: "button", className: e, style: t, onClick: () => this.fileInputRef.click(), onDragOver: this.handleDragOver, onDragLeave: this.handleDragLeave, onDrop: this.handleDrop }, this.renderHiddenFileInput(), u("div", { className: "uppy-DragDrop-inner" }, Vi.renderArrowSvg(), this.renderLabel(), this.renderNote()))
        } install() { let { target: e } = this.opts; this.setPluginState({ isDraggingOver: !1 }), e && this.mount(e, this) } uninstall() { this.unmount() }
    }; n(Vi, "DragDrop"); Vi.VERSION = rS.version; var sS = { version: "2.0.1" }; function Rh(i) { var e, t; return (e = (t = i.dataTransfer.types) == null ? void 0 : t.some(r => r === "Files")) != null ? e : !1 } n(Rh, "isFileTransfer"); var ks = class extends Se { constructor(e, t) { super(e, t), this.addFiles = s => { let o = s.map(a => ({ source: this.id, name: a.name, type: a.type, data: a, meta: { relativePath: a.relativePath || null } })); try { this.uppy.addFiles(o) } catch (a) { this.uppy.log(a) } }, this.handleDrop = async s => { var o, a; if (!Rh(s)) return; s.preventDefault(), s.stopPropagation(), clearTimeout(this.removeDragOverClassTimeout), s.currentTarget.classList.remove("uppy-is-drag-over"), this.setPluginState({ isDraggingOver: !1 }), this.uppy.iteratePlugins(h => { h.type === "acquirer" && (h.handleRootDrop == null || h.handleRootDrop(s)) }); let l = !1, d = n(h => { this.uppy.log(h, "error"), l || (this.uppy.info(h.message, "error"), l = !0) }, "logDropError"), p = await Cs(s.dataTransfer, { logDropError: d }); p.length > 0 && (this.uppy.log("[DropTarget] Files were dropped"), this.addFiles(p)), (o = (a = this.opts).onDrop) == null || o.call(a, s) }, this.handleDragOver = s => { var o, a; Rh(s) && (s.preventDefault(), s.stopPropagation(), s.dataTransfer.dropEffect = "copy", clearTimeout(this.removeDragOverClassTimeout), s.currentTarget.classList.add("uppy-is-drag-over"), this.setPluginState({ isDraggingOver: !0 }), (o = (a = this.opts).onDragOver) == null || o.call(a, s)) }, this.handleDragLeave = s => { var o, a; if (!Rh(s)) return; s.preventDefault(), s.stopPropagation(); let { currentTarget: l } = s; clearTimeout(this.removeDragOverClassTimeout), this.removeDragOverClassTimeout = setTimeout(() => { l.classList.remove("uppy-is-drag-over"), this.setPluginState({ isDraggingOver: !1 }) }, 50), (o = (a = this.opts).onDragLeave) == null || o.call(a, s) }, this.addListeners = () => { let { target: s } = this.opts; if (s instanceof Element ? this.nodes = [s] : typeof s == "string" && (this.nodes = Ke(document.querySelectorAll(s))), !this.nodes && !this.nodes.length > 0) throw new Error(`"${s}" does not match any HTML elements`); this.nodes.forEach(o => { o.addEventListener("dragover", this.handleDragOver, !1), o.addEventListener("dragleave", this.handleDragLeave, !1), o.addEventListener("drop", this.handleDrop, !1) }) }, this.removeListeners = () => { this.nodes && this.nodes.forEach(s => { s.removeEventListener("dragover", this.handleDragOver, !1), s.removeEventListener("dragleave", this.handleDragLeave, !1), s.removeEventListener("drop", this.handleDrop, !1) }) }, this.type = "acquirer", this.id = this.opts.id || "DropTarget", this.title = "Drop Target"; let r = { target: null }; this.opts = { ...r, ...t }, this.removeDragOverClassTimeout = null } install() { this.setPluginState({ isDraggingOver: !1 }), this.addListeners() } uninstall() { this.removeListeners() } }; n(ks, "DropTarget"); ks.VERSION = sS.version; var uy = { strings: { chooseFiles: "Choose files" } }; var oS = { version: "3.0.3" }, rs = class extends Q { constructor(e, t) { super(e, t), this.id = this.opts.id || "FileInput", this.title = "File Input", this.type = "acquirer", this.defaultLocale = uy; let r = { target: null, pretty: !0, inputName: "files[]" }; this.opts = { ...r, ...t }, this.i18nInit(), this.render = this.render.bind(this), this.handleInputChange = this.handleInputChange.bind(this), this.handleClick = this.handleClick.bind(this) } addFiles(e) { let t = e.map(r => ({ source: this.id, name: r.name, type: r.type, data: r })); try { this.uppy.addFiles(t) } catch (r) { this.uppy.log(r) } } handleInputChange(e) { this.uppy.log("[FileInput] Something selected through input..."); let t = Ke(e.target.files); this.addFiles(t), e.target.value = null } handleClick() { this.input.click() } render() { let e = { width: "0.1px", height: "0.1px", opacity: 0, overflow: "hidden", position: "absolute", zIndex: -1 }, { restrictions: t } = this.uppy.opts, r = t.allowedFileTypes ? t.allowedFileTypes.join(",") : null; return u("div", { className: "uppy-FileInput-container" }, u("input", { className: "uppy-FileInput-input", style: this.opts.pretty && e, type: "file", name: this.opts.inputName, onChange: this.handleInputChange, multiple: t.maxNumberOfFiles !== 1, accept: r, ref: s => { this.input = s } }), this.opts.pretty && u("button", { className: "uppy-FileInput-btn", type: "button", onClick: this.handleClick }, this.i18n("chooseFiles"))) } install() { let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.unmount() } }; n(rs, "FileInput"); rs.VERSION = oS.version; var py = de(dy(), 1); function nS(i, e) { let t = i.width / e.width, r = i.height / e.height, s = Math.min(t, r), o = e.width * s, a = e.height * s, l = (i.width - o) / 2, d = (i.height - a) / 2; return { width: o, height: a, left: l, top: d } } n(nS, "getCanvasDataThatFitsPerfectlyIntoContainer"); var hy = nS; function aS(i) { return i * (Math.PI / 180) } n(aS, "toRadians"); function lS(i, e) { let t = Math.abs(aS(e)), r = i.width, s = i.height; return Math.max((Math.sin(t) * r + Math.cos(t) * s) / s, (Math.sin(t) * s + Math.cos(t) * r) / r) } n(lS, "getScaleFactorThatRemovesDarkCorners"); var cy = lS; var Ho = class extends ve { constructor(e) { super(e), this.onRotate90Deg = () => { let { angle90Deg: t } = this.state, r = t - 90; this.setState({ angle90Deg: r, angleGranular: 0 }), this.cropper.scale(1), this.cropper.rotateTo(r); let s = this.cropper.getCanvasData(), o = this.cropper.getContainerData(), a = hy(o, s); this.cropper.setCanvasData(a), this.cropper.setCropBoxData(a) }, this.onRotateGranular = t => { let r = Number(t.target.value); this.setState({ angleGranular: r }); let { angle90Deg: s } = this.state, o = s + r; this.cropper.rotateTo(o); let a = this.cropper.getCropBoxData(), l = cy(a, r), d = this.cropper.getImageData().scaleX < 0 ? -l : l; this.cropper.scale(d, l) }, this.state = { angle90Deg: 0, angleGranular: 0 } } componentDidMount() { let { opts: e, storeCropperInstance: t } = this.props; this.cropper = new py.default(this.imgElement, e.cropperOptions), t(this.cropper) } componentWillUnmount() { this.cropper.destroy() } renderGranularRotate() { let { i18n: e } = this.props, { angleGranular: t } = this.state; return u("label", { "data-microtip-position": "top", role: "tooltip", "aria-label": `${t}\xBA`, className: "uppy-ImageCropper-rangeWrapper uppy-u-reset" }, u("input", { className: "uppy-ImageCropper-range uppy-u-reset", type: "range", onInput: this.onRotateGranular, onChange: this.onRotateGranular, value: t, min: "-45", max: "44", "aria-label": e("rotate") })) } renderRevert() { let { i18n: e } = this.props; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", "aria-label": e("revert"), "data-microtip-position": "top", onClick: () => { this.cropper.reset(), this.cropper.setAspectRatio(0), this.setState({ angle90Deg: 0, angleGranular: 0 }) } }, u("svg", { "aria-hidden": "true", className: "uppy-c-icon", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M0 0h24v24H0z", fill: "none" }), u("path", { d: "M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z" }))) } renderRotate() { let { i18n: e } = this.props; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", onClick: this.onRotate90Deg, "aria-label": e("rotate"), "data-microtip-position": "top" }, u("svg", { "aria-hidden": "true", className: "uppy-c-icon", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M0 0h24v24H0V0zm0 0h24v24H0V0z", fill: "none" }), u("path", { d: "M14 10a2 2 0 012 2v7a2 2 0 01-2 2H6a2 2 0 01-2-2v-7a2 2 0 012-2h8zm0 1.75H6a.25.25 0 00-.243.193L5.75 12v7a.25.25 0 00.193.243L6 19.25h8a.25.25 0 00.243-.193L14.25 19v-7a.25.25 0 00-.193-.243L14 11.75zM12 .76V4c2.3 0 4.61.88 6.36 2.64a8.95 8.95 0 012.634 6.025L21 13a1 1 0 01-1.993.117L19 13h-.003a6.979 6.979 0 00-2.047-4.95 6.97 6.97 0 00-4.652-2.044L12 6v3.24L7.76 5 12 .76z" }))) } renderFlip() { let { i18n: e } = this.props; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", "aria-label": e("flipHorizontal"), "data-microtip-position": "top", onClick: () => this.cropper.scaleX(-this.cropper.getData().scaleX || -1) }, u("svg", { "aria-hidden": "true", className: "uppy-c-icon", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M0 0h24v24H0z", fill: "none" }), u("path", { d: "M15 21h2v-2h-2v2zm4-12h2V7h-2v2zM3 5v14c0 1.1.9 2 2 2h4v-2H5V5h4V3H5c-1.1 0-2 .9-2 2zm16-2v2h2c0-1.1-.9-2-2-2zm-8 20h2V1h-2v22zm8-6h2v-2h-2v2zM15 5h2V3h-2v2zm4 8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2z" }))) } renderZoomIn() { let { i18n: e } = this.props; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", "aria-label": e("zoomIn"), "data-microtip-position": "top", onClick: () => this.cropper.zoom(.1) }, u("svg", { "aria-hidden": "true", className: "uppy-c-icon", height: "24", viewBox: "0 0 24 24", width: "24" }, u("path", { d: "M0 0h24v24H0V0z", fill: "none" }), u("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }), u("path", { d: "M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z" }))) } renderZoomOut() { let { i18n: e } = this.props; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", "aria-label": e("zoomOut"), "data-microtip-position": "top", onClick: () => this.cropper.zoom(-.1) }, u("svg", { "aria-hidden": "true", className: "uppy-c-icon", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M0 0h24v24H0V0z", fill: "none" }), u("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z" }))) } renderCropSquare() { let { i18n: e } = this.props; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", "aria-label": e("aspectRatioSquare"), "data-microtip-position": "top", onClick: () => this.cropper.setAspectRatio(1) }, u("svg", { "aria-hidden": "true", className: "uppy-c-icon", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M0 0h24v24H0z", fill: "none" }), u("path", { d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z" }))) } renderCropWidescreen() { let { i18n: e } = this.props; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", "aria-label": e("aspectRatioLandscape"), "data-microtip-position": "top", onClick: () => this.cropper.setAspectRatio(16 / 9) }, u("svg", { "aria-hidden": "true", className: "uppy-c-icon", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M 19,4.9999992 V 17.000001 H 4.9999998 V 6.9999992 H 19 m 0,-2 H 4.9999998 c -1.0999999,0 -1.9999999,0.9000001 -1.9999999,2 V 17.000001 c 0,1.1 0.9,2 1.9999999,2 H 19 c 1.1,0 2,-0.9 2,-2 V 6.9999992 c 0,-1.0999999 -0.9,-2 -2,-2 z" }), u("path", { fill: "none", d: "M0 0h24v24H0z" }))) } renderCropWidescreenVertical() { let { i18n: e } = this.props; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", "aria-label": e("aspectRatioPortrait"), "data-microtip-position": "top", onClick: () => this.cropper.setAspectRatio(9 / 16) }, u("svg", { "aria-hidden": "true", className: "uppy-c-icon", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M 19.000001,19 H 6.999999 V 5 h 10.000002 v 14 m 2,0 V 5 c 0,-1.0999999 -0.9,-1.9999999 -2,-1.9999999 H 6.999999 c -1.1,0 -2,0.9 -2,1.9999999 v 14 c 0,1.1 0.9,2 2,2 h 10.000002 c 1.1,0 2,-0.9 2,-2 z" }), u("path", { d: "M0 0h24v24H0z", fill: "none" }))) } render() { let { currentImage: e, opts: t } = this.props, { actions: r } = t, s = URL.createObjectURL(e.data); return u("div", { className: "uppy-ImageCropper" }, u("div", { className: "uppy-ImageCropper-container" }, u("img", { className: "uppy-ImageCropper-image", alt: e.name, src: s, ref: o => { this.imgElement = o } })), u("div", { className: "uppy-ImageCropper-controls" }, r.revert && this.renderRevert(), r.rotate && this.renderRotate(), r.granularRotate && this.renderGranularRotate(), r.flip && this.renderFlip(), r.zoomIn && this.renderZoomIn(), r.zoomOut && this.renderZoomOut(), r.cropSquare && this.renderCropSquare(), r.cropWidescreen && this.renderCropWidescreen(), r.cropWidescreenVertical && this.renderCropWidescreenVertical())) } }; n(Ho, "Editor"); var fy = { strings: { revert: "Revert", rotate: "Rotate", zoomIn: "Zoom in", zoomOut: "Zoom out", flipHorizontal: "Flip horizontal", aspectRatioSquare: "Crop square", aspectRatioLandscape: "Crop landscape (16:9)", aspectRatioPortrait: "Crop portrait (9:16)" } }; var uS = { version: "2.2.1" }, ss = class extends Q { constructor(e, t) { super(e, t), this.save = () => { let a = n(p => { let { currentImage: h } = this.getPluginState(); this.uppy.setFileState(h.id, { data: p, size: p.size, preview: null }); let m = this.uppy.getFile(h.id); this.uppy.emit("thumbnail:request", m), this.setPluginState({ currentImage: m }), this.uppy.emit("file-editor:complete", m) }, "saveBlobCallback"), { currentImage: l } = this.getPluginState(), d = this.cropper.getCroppedCanvas({}); d.width % 2 !== 0 && this.cropper.setData({ width: d.width - 1 }), d.height % 2 !== 0 && this.cropper.setData({ height: d.height - 1 }), this.cropper.getCroppedCanvas(this.opts.cropperOptions.croppedCanvasOptions).toBlob(a, l.type, this.opts.quality) }, this.storeCropperInstance = a => { this.cropper = a }, this.selectFile = a => { this.uppy.emit("file-editor:start", a), this.setPluginState({ currentImage: a }) }, this.id = this.opts.id || "ImageEditor", this.title = "Image Editor", this.type = "editor", this.defaultLocale = fy; let r = { viewMode: 0, background: !1, autoCropArea: 1, responsive: !0, croppedCanvasOptions: {} }, s = { revert: !0, rotate: !0, granularRotate: !0, flip: !0, zoomIn: !0, zoomOut: !0, cropSquare: !0, cropWidescreen: !0, cropWidescreenVertical: !0 }, o = { quality: .8 }; this.opts = { ...o, ...t, actions: { ...s, ...t.actions }, cropperOptions: { ...r, ...t.cropperOptions } }, this.i18nInit() } canEditFile(e) { if (!e.type || e.isRemote) return !1; let t = e.type.split("/")[1]; return !!/^(jpe?g|gif|png|bmp|webp)$/.test(t) } install() { this.setPluginState({ currentImage: null }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { let { currentImage: e } = this.getPluginState(); if (e) { let t = this.uppy.getFile(e.id); this.uppy.emit("file-editor:cancel", t) } this.unmount() } render() { let { currentImage: e } = this.getPluginState(); return e === null || e.isRemote ? null : u(Ho, { currentImage: e, storeCropperInstance: this.storeCropperInstance, save: this.save, opts: this.opts, i18n: this.i18n }) } }; n(ss, "ImageEditor"); ss.VERSION = uS.version; var dS = { version: "3.0.3" }, os = class extends Q { constructor(e, t) { super(e, t), this.id = this.opts.id || "ProgressBar", this.title = "Progress Bar", this.type = "progressindicator"; let r = { target: "body", fixed: !1, hideAfterFinish: !0 }; this.opts = { ...r, ...t }, this.render = this.render.bind(this) } render(e) { let t = e.totalProgress || 0, r = (t === 0 || t === 100) && this.opts.hideAfterFinish; return u("div", { className: "uppy uppy-ProgressBar", style: { position: this.opts.fixed ? "fixed" : "initial" }, "aria-hidden": r }, u("div", { className: "uppy-ProgressBar-inner", style: { width: `${t}%` } }), u("div", { className: "uppy-ProgressBar-percentage" }, t)) } install() { let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.unmount() } }; n(os, "ProgressBar"); os.VERSION = dS.version; var hS = { "audio/mp3": "mp3", "audio/mp4": "mp4", "audio/ogg": "ogg", "audio/webm": "webm", "image/gif": "gif", "image/heic": "heic", "image/heif": "heif", "image/jpeg": "jpg", "image/png": "png", "image/svg+xml": "svg", "video/mp4": "mp4", "video/ogg": "ogv", "video/quicktime": "mov", "video/webm": "webm", "video/x-matroska": "mkv", "video/x-msvideo": "avi" }; function Wi(i) { return [i] = i.split(";", 1), hS[i] || null } n(Wi, "getFileTypeExtension"); function Dh() { var i; return typeof MediaRecorder == "function" && typeof ((i = MediaRecorder.prototype) == null ? void 0 : i.start) == "function" } n(Dh, "supportsMediaRecorder"); function Ih(i) { let { recording: e, onStartRecording: t, onStopRecording: r, i18n: s } = i; return e ? u("button", { className: "uppy-u-reset uppy-c-btn uppy-Audio-button", type: "button", title: s("stopAudioRecording"), "aria-label": s("stopAudioRecording"), onClick: r, "data-uppy-super-focusable": !0 }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "100", height: "100", viewBox: "0 0 100 100" }, u("rect", { x: "15", y: "15", width: "70", height: "70" }))) : u("button", { className: "uppy-u-reset uppy-c-btn uppy-Audio-button", type: "button", title: s("startAudioRecording"), "aria-label": s("startAudioRecording"), onClick: t, "data-uppy-super-focusable": !0 }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "14px", height: "20px", viewBox: "0 0 14 20" }, u("path", { d: "M7 14c2.21 0 4-1.71 4-3.818V3.818C11 1.71 9.21 0 7 0S3 1.71 3 3.818v6.364C3 12.29 4.79 14 7 14zm6.364-7h-.637a.643.643 0 0 0-.636.65V9.6c0 3.039-2.565 5.477-5.6 5.175-2.645-.264-4.582-2.692-4.582-5.407V7.65c0-.36-.285-.65-.636-.65H.636A.643.643 0 0 0 0 7.65v1.631c0 3.642 2.544 6.888 6.045 7.382v1.387H3.818a.643.643 0 0 0-.636.65v.65c0 .36.285.65.636.65h6.364c.351 0 .636-.29.636-.65v-.65c0-.36-.285-.65-.636-.65H7.955v-1.372C11.363 16.2 14 13.212 14 9.6V7.65c0-.36-.285-.65-.636-.65z", fill: "#FFF", "fill-rule": "nonzero" }))) } n(Ih, "RecordButton"); function Nh(i) { return `${Math.floor(i / 60)}:${String(i % 60).padStart(2, 0)}` } n(Nh, "formatSeconds"); function Mh(i) { let { recordingLengthSeconds: e, i18n: t } = i, r = Nh(e); return u("span", { "aria-label": t("recordingLength", { recording_length: r }) }, r) } n(Mh, "RecordingLength"); var my = n(i => { let { currentDeviceId: e, audioSources: t, onChangeSource: r } = i; return u("div", { className: "uppy-Audio-videoSource" }, u("select", { className: "uppy-u-reset uppy-Audio-audioSource-select", onChange: s => { r(s.target.value) } }, t.map(s => u("option", { key: s.deviceId, value: s.deviceId, selected: s.deviceId === e }, s.label)))) }, "default"); function cS(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(cS, "_classPrivateFieldLooseBase"); var pS = 0; function fS(i) { return "__private_" + pS++ + "_" + i } n(fS, "_classPrivateFieldLooseKey"); function gy(i) { return typeof i == "function" } n(gy, "isFunction"); function ga(i) { return gy(i) ? i() : i } n(ga, "result"); var Bh = fS("draw"), $o = class { constructor(e, t) { t === void 0 && (t = {}), Object.defineProperty(this, Bh, { writable: !0, value: () => this.draw() }); let r = t.canvas || {}, s = t.canvasContext || {}; this.analyser = null, this.bufferLength = 0, this.dataArray = [], this.canvas = e, this.width = ga(r.width) || this.canvas.width, this.height = ga(r.height) || this.canvas.height, this.canvas.width = this.width, this.canvas.height = this.height, this.canvasContext = this.canvas.getContext("2d"), this.canvasContext.fillStyle = ga(s.fillStyle) || "rgb(255, 255, 255)", this.canvasContext.strokeStyle = ga(s.strokeStyle) || "rgb(0, 0, 0)", this.canvasContext.lineWidth = ga(s.lineWidth) || 1, this.onDrawFrame = gy(t.onDrawFrame) ? t.onDrawFrame : () => { } } addSource(e) { this.streamSource = e, this.audioContext = this.streamSource.context, this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = 2048, this.bufferLength = this.analyser.frequencyBinCount, this.source = this.audioContext.createBufferSource(), this.dataArray = new Uint8Array(this.bufferLength), this.analyser.getByteTimeDomainData(this.dataArray), this.streamSource.connect(this.analyser) } draw() { let { analyser: e, dataArray: t, bufferLength: r } = this, s = this.canvasContext, o = this.width, a = this.height; e && e.getByteTimeDomainData(t), s.fillRect(0, 0, o, a), s.beginPath(); let l = o * 1 / r, d = 0; r || s.moveTo(0, this.height / 2); for (let p = 0; p < r; p++) { let m = t[p] / 128 * (a / 2); p === 0 ? s.moveTo(d, m) : s.lineTo(d, m), d += l } s.lineTo(o, a / 2), s.stroke(), this.onDrawFrame(this), requestAnimationFrame(cS(this, Bh)[Bh]) } }; n($o, "AudioOscilloscope"); function mS(i) { let { onSubmit: e, i18n: t } = i; return u("button", { className: "uppy-u-reset uppy-c-btn uppy-Audio-button uppy-Audio-button--submit", type: "button", title: t("submitRecordedFile"), "aria-label": t("submitRecordedFile"), onClick: e, "data-uppy-super-focusable": !0 }, u("svg", { width: "12", height: "9", viewBox: "0 0 12 9", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", focusable: "false", className: "uppy-c-icon" }, u("path", { fill: "#fff", fillRule: "nonzero", d: "M10.66 0L12 1.31 4.136 9 0 4.956l1.34-1.31L4.136 6.38z" }))) } n(mS, "SubmitButton"); var yy = mS; function gS(i) { let { onDiscard: e, i18n: t } = i; return u("button", { className: "uppy-u-reset uppy-c-btn uppy-Audio-button", type: "button", title: t("discardRecordedFile"), "aria-label": t("discardRecordedFile"), onClick: e, "data-uppy-super-focusable": !0 }, u("svg", { width: "13", height: "13", viewBox: "0 0 13 13", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", className: "uppy-c-icon" }, u("g", { fill: "#FFF", fillRule: "evenodd" }, u("path", { d: "M.496 11.367L11.103.76l1.414 1.414L1.911 12.781z" }), u("path", { d: "M11.104 12.782L.497 2.175 1.911.76l10.607 10.606z" })))) } n(gS, "DiscardButton"); var vy = gS; function Lh(i) { let { stream: e, recordedAudio: t, onStop: r, recording: s, supportsRecording: o, audioSources: a, showAudioSourceDropdown: l, onSubmit: d, i18n: p, onStartRecording: h, onStopRecording: m, onDiscardRecordedAudio: y, recordingLengthSeconds: b } = i, S = Bd(null), O = Bd(null); xs(() => () => { O.current = null, r() }, [r]), xs(() => { if (!t && (O.current = new $o(S.current, { canvas: { width: 600, height: 600 }, canvasContext: { lineWidth: 2, fillStyle: "rgb(0,0,0)", strokeStyle: "green" } }), O.current.draw(), e)) { let W = new AudioContext().createMediaStreamSource(e); O.current.addSource(W) } }, [t, e]); let F = t != null, x = !F && o, U = l && !F && a && a.length > 1; return u("div", { className: "uppy-Audio-container" }, u("div", { className: "uppy-Audio-audioContainer" }, F ? u("audio", { className: "uppy-Audio-player", controls: !0, src: t }) : u("canvas", { ref: S, className: "uppy-Audio-canvas" })), u("div", { className: "uppy-Audio-footer" }, u("div", { className: "uppy-Audio-audioSourceContainer" }, U ? my(i) : null), u("div", { className: "uppy-Audio-buttonContainer" }, x && u(Ih, { recording: s, onStartRecording: h, onStopRecording: m, i18n: p }), F && u(yy, { onSubmit: d, i18n: p }), F && u(vy, { onDiscard: y, i18n: p })), u("div", { className: "uppy-Audio-recordingLength" }, !F && u(Mh, { recordingLengthSeconds: b, i18n: p })))) } n(Lh, "RecordingScreen"); var by = n(i => { let { icon: e, hasAudio: t, i18n: r } = i; return u("div", { className: "uppy-Audio-permissons" }, u("div", { className: "uppy-Audio-permissonsIcon" }, e()), u("h1", { className: "uppy-Audio-title" }, r(t ? "allowAudioAccessTitle" : "noAudioTitle")), u("p", null, r(t ? "allowAudioAccessDescription" : "noAudioDescription"))) }, "default"); var wy = { strings: { pluginNameAudio: "Audio", startAudioRecording: "Begin audio recording", stopAudioRecording: "Stop audio recording", allowAudioAccessTitle: "Please allow access to your microphone", allowAudioAccessDescription: "In order to record audio, please allow microphone access for this site.", noAudioTitle: "Microphone Not Available", noAudioDescription: "In order to record audio, please connect a microphone or another audio input device", recordingStoppedMaxSize: "Recording stopped because the file size is about to exceed the limit", recordingLength: "Recording length %{recording_length}", submitRecordedFile: "Submit recorded file", discardRecordedFile: "Discard recorded file" } }; function Wh() { return Wh = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, Wh.apply(this, arguments) } n(Wh, "_extends"); function j(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(j, "_classPrivateFieldLooseBase"); var yS = 0; function dt(i) { return "__private_" + yS++ + "_" + i } n(dt, "_classPrivateFieldLooseKey"); var vS = { version: "1.1.3" }, lt = dt("stream"), Tr = dt("audioActive"), ke = dt("recordingChunks"), Ue = dt("recorder"), Rr = dt("capturedMediaFile"), ut = dt("mediaDevices"), ya = dt("supportsUserMedia"), jh = dt("hasAudioCheck"), Ds = dt("start"), zh = dt("startRecording"), va = dt("stopRecording"), Hh = dt("discardRecordedAudio"), $h = dt("submit"), Ur = dt("stop"), qh = dt("getAudio"), Vh = dt("changeSource"), Is = dt("updateSources"), ns = class extends Q { constructor(e, t) { var r; super(e, t), r = this, Object.defineProperty(this, qh, { value: wS }), Object.defineProperty(this, jh, { value: bS }), Object.defineProperty(this, lt, { writable: !0, value: null }), Object.defineProperty(this, Tr, { writable: !0, value: !1 }), Object.defineProperty(this, ke, { writable: !0, value: null }), Object.defineProperty(this, Ue, { writable: !0, value: null }), Object.defineProperty(this, Rr, { writable: !0, value: null }), Object.defineProperty(this, ut, { writable: !0, value: null }), Object.defineProperty(this, ya, { writable: !0, value: null }), Object.defineProperty(this, Ds, { writable: !0, value: function (s) { if (s === void 0 && (s = null), !j(r, ya)[ya]) return Promise.reject(new Error("Microphone access not supported")); j(r, Tr)[Tr] = !0, j(r, jh)[jh]().then(o => (r.setPluginState({ hasAudio: o }), j(r, ut)[ut].getUserMedia({ audio: !0 }).then(a => { j(r, lt)[lt] = a; let l = null, d = a.getAudioTracks(); !s || !s.deviceId ? l = d[0].getSettings().deviceId : d.forEach(p => { p.getSettings().deviceId === s.deviceId && (l = p.getSettings().deviceId) }), j(r, Is)[Is](), r.setPluginState({ currentDeviceId: l, audioReady: !0 }) }).catch(a => { r.setPluginState({ audioReady: !1, cameraError: a }), r.uppy.info(a.message, "error") }))) } }), Object.defineProperty(this, zh, { writable: !0, value: () => { j(this, Ue)[Ue] = new MediaRecorder(j(this, lt)[lt]), j(this, ke)[ke] = []; let s = !1; j(this, Ue)[Ue].addEventListener("dataavailable", o => { j(this, ke)[ke].push(o.data); let { restrictions: a } = this.uppy.opts; if (j(this, ke)[ke].length > 1 && a.maxFileSize != null && !s) { let l = j(this, ke)[ke].reduce((m, y) => m + y.size, 0), p = (l - j(this, ke)[ke][0].size) / (j(this, ke)[ke].length - 1) * 3, h = Math.max(0, a.maxFileSize - p); l > h && (s = !0, this.uppy.info(this.i18n("recordingStoppedMaxSize"), "warning", 4e3), j(this, va)[va]()) } }), j(this, Ue)[Ue].start(500), this.recordingLengthTimer = setInterval(() => { let o = this.getPluginState().recordingLengthSeconds; this.setPluginState({ recordingLengthSeconds: o + 1 }) }, 1e3), this.setPluginState({ isRecording: !0 }) } }), Object.defineProperty(this, va, { writable: !0, value: () => new Promise(o => { j(this, Ue)[Ue].addEventListener("stop", () => { o() }), j(this, Ue)[Ue].stop(), clearInterval(this.recordingLengthTimer), this.setPluginState({ recordingLengthSeconds: 0 }) }).then(() => (this.setPluginState({ isRecording: !1 }), j(this, qh)[qh]())).then(o => { try { j(this, Rr)[Rr] = o, this.setPluginState({ recordedAudio: URL.createObjectURL(o.data) }) } catch (a) { a.isRestriction || this.uppy.log(a) } }).then(() => { j(this, ke)[ke] = null, j(this, Ue)[Ue] = null }, o => { throw j(this, ke)[ke] = null, j(this, Ue)[Ue] = null, o }) }), Object.defineProperty(this, Hh, { writable: !0, value: () => { this.setPluginState({ recordedAudio: null }), j(this, Rr)[Rr] = null } }), Object.defineProperty(this, $h, { writable: !0, value: () => { try { j(this, Rr)[Rr] && this.uppy.addFile(j(this, Rr)[Rr]) } catch (s) { s.isRestriction || this.uppy.log(s, "warning") } } }), Object.defineProperty(this, Ur, { writable: !0, value: async () => { j(this, lt)[lt] && j(this, lt)[lt].getAudioTracks().forEach(o => o.stop()), j(this, Ue)[Ue] && await new Promise(s => { j(this, Ue)[Ue].addEventListener("stop", s, { once: !0 }), j(this, Ue)[Ue].stop(), clearInterval(this.recordingLengthTimer) }), j(this, ke)[ke] = null, j(this, Ue)[Ue] = null, j(this, Tr)[Tr] = !1, j(this, lt)[lt] = null, this.setPluginState({ recordedAudio: null, isRecording: !1, recordingLengthSeconds: 0 }) } }), Object.defineProperty(this, Vh, { writable: !0, value: s => { j(this, Ur)[Ur](), j(this, Ds)[Ds]({ deviceId: s }) } }), Object.defineProperty(this, Is, { writable: !0, value: () => { j(this, ut)[ut].enumerateDevices().then(s => { this.setPluginState({ audioSources: s.filter(o => o.kind === "audioinput") }) }) } }), j(this, ut)[ut] = navigator.mediaDevices, j(this, ya)[ya] = j(this, ut)[ut] != null, this.id = this.opts.id || "Audio", this.type = "acquirer", this.icon = () => u("svg", { className: "uppy-DashboardTab-iconAudio", "aria-hidden": "true", focusable: "false", width: "32px", height: "32px", viewBox: "0 0 32 32" }, u("path", { d: "M21.143 12.297c.473 0 .857.383.857.857v2.572c0 3.016-2.24 5.513-5.143 5.931v2.64h2.572a.857.857 0 110 1.714H12.57a.857.857 0 110-1.714h2.572v-2.64C12.24 21.24 10 18.742 10 15.726v-2.572a.857.857 0 111.714 0v2.572A4.29 4.29 0 0016 20.01a4.29 4.29 0 004.286-4.285v-2.572c0-.474.384-.857.857-.857zM16 6.5a3 3 0 013 3v6a3 3 0 01-6 0v-6a3 3 0 013-3z", fill: "currentcolor", "fill-rule": "nonzero" })), this.defaultLocale = wy, this.opts = { ...t }, this.i18nInit(), this.title = this.i18n("pluginNameAudio"), this.setPluginState({ hasAudio: !1, audioReady: !1, cameraError: null, recordingLengthSeconds: 0, audioSources: [], currentDeviceId: null }) } render() { j(this, Tr)[Tr] || j(this, Ds)[Ds](); let e = this.getPluginState(); return !e.audioReady || !e.hasAudio ? u(by, { icon: this.icon, i18n: this.i18n, hasAudio: e.hasAudio }) : u(Lh, Wh({}, e, { audioActive: j(this, Tr)[Tr], onChangeSource: j(this, Vh)[Vh], onStartRecording: j(this, zh)[zh], onStopRecording: j(this, va)[va], onDiscardRecordedAudio: j(this, Hh)[Hh], onSubmit: j(this, $h)[$h], onStop: j(this, Ur)[Ur], i18n: this.i18n, showAudioSourceDropdown: this.opts.showAudioSourceDropdown, supportsRecording: Dh(), recording: e.isRecording, stream: j(this, lt)[lt] })) } install() { this.setPluginState({ audioReady: !1, recordingLengthSeconds: 0 }); let { target: e } = this.opts; e && this.mount(e, this), j(this, ut)[ut] && (j(this, Is)[Is](), j(this, ut)[ut].ondevicechange = () => { if (j(this, Is)[Is](), j(this, lt)[lt]) { let t = !0, { audioSources: r, currentDeviceId: s } = this.getPluginState(); r.forEach(o => { s === o.deviceId && (t = !1) }), t && (j(this, Ur)[Ur](), j(this, Ds)[Ds]()) } }) } uninstall() { j(this, lt)[lt] && j(this, Ur)[Ur](), this.unmount() } }; n(ns, "Audio"); function bS() { return j(this, ut)[ut] ? j(this, ut)[ut].enumerateDevices().then(i => i.some(e => e.kind === "audioinput")) : Promise.resolve(!1) } n(bS, "_hasAudioCheck2"); function wS() { let i = j(this, ke)[ke].find(o => { var a; return ((a = o.type) == null ? void 0 : a.length) > 0 }).type, e = Wi(i); if (!e) return Promise.reject(new Error(`Could not retrieve recording: Unsupported media type "${i}"`)); let t = `audio-${Date.now()}.${e}`, r = new Blob(j(this, ke)[ke], { type: i }), s = { source: this.id, name: t, data: new Blob([r], { type: i }), type: i }; return Promise.resolve(s) } n(wS, "_getAudio2"); ns.VERSION = vS.version; var Sy = { strings: { pluginNameBox: "Box" } }; var SS = { version: "2.1.3" }, Gi = class extends Q { constructor(e, t) { super(e, t), this.id = this.opts.id || "Box", ne.initPlugin(this, t), this.title = this.opts.title || "Box", this.icon = () => u("svg", { className: "uppy-DashboardTab-iconBox", "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("g", { fill: "currentcolor", fillRule: "nonzero" }, u("path", { d: "m16.4 13.5c-1.6 0-3 0.9-3.7 2.2-0.7-1.3-2.1-2.2-3.7-2.2-1 0-1.8 0.3-2.5 0.8v-3.6c-0.1-0.3-0.5-0.7-1-0.7s-0.8 0.4-0.8 0.8v7c0 2.3 1.9 4.2 4.2 4.2 1.6 0 3-0.9 3.7-2.2 0.7 1.3 2.1 2.2 3.7 2.2 2.3 0 4.2-1.9 4.2-4.2 0.1-2.4-1.8-4.3-4.1-4.3m-7.5 6.8c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5m7.5 0c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5" }), u("path", { d: "m27.2 20.6l-2.3-2.8 2.3-2.8c0.3-0.4 0.2-0.9-0.2-1.2s-1-0.2-1.3 0.2l-2 2.4-2-2.4c-0.3-0.4-0.9-0.4-1.3-0.2-0.4 0.3-0.5 0.8-0.2 1.2l2.3 2.8-2.3 2.8c-0.3 0.4-0.2 0.9 0.2 1.2s1 0.2 1.3-0.2l2-2.4 2 2.4c0.3 0.4 0.9 0.4 1.3 0.2 0.4-0.3 0.4-0.8 0.2-1.2" }))), this.provider = new ne(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionKeysParams: this.opts.companionKeysParams, companionCookiesRule: this.opts.companionCookiesRule, provider: "box", pluginId: this.id }), this.defaultLocale = Sy, this.i18nInit(), this.title = this.i18n("pluginNameBox"), this.onFirstRender = this.onFirstRender.bind(this), this.render = this.render.bind(this) } install() { this.view = new Ce(this, { provider: this.provider, loadAllFiles: !0 }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.view.tearDown(), this.unmount() } onFirstRender() { return this.view.getFolder() } render(e) { return this.view.render(e) } }; n(Gi, "Box"); Gi.VERSION = SS.version; var Py = { strings: { pluginNameDropbox: "Dropbox" } }; var PS = { version: "3.1.3" }, Ki = class extends Q { constructor(e, t) { super(e, t), this.id = this.opts.id || "Dropbox", ne.initPlugin(this, t), this.title = this.opts.title || "Dropbox", this.icon = () => u("svg", { className: "uppy-DashboardTab-iconDropbox", "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("path", { d: "M10.5 7.5L5 10.955l5.5 3.454 5.5-3.454 5.5 3.454 5.5-3.454L21.5 7.5 16 10.955zM10.5 21.319L5 17.864l5.5-3.455 5.5 3.455zM16 17.864l5.5-3.455 5.5 3.455-5.5 3.455zM16 25.925l-5.5-3.455 5.5-3.454 5.5 3.454z", fill: "currentcolor", fillRule: "nonzero" })), this.provider = new ne(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionKeysParams: this.opts.companionKeysParams, companionCookiesRule: this.opts.companionCookiesRule, provider: "dropbox", pluginId: this.id }), this.defaultLocale = Py, this.i18nInit(), this.title = this.i18n("pluginNameDropbox"), this.onFirstRender = this.onFirstRender.bind(this), this.render = this.render.bind(this) } install() { this.view = new Ce(this, { provider: this.provider, loadAllFiles: !0 }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.view.tearDown(), this.unmount() } onFirstRender() { return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]) } render(e) { return this.view.render(e) } }; n(Ki, "Dropbox"); Ki.VERSION = PS.version; var _y = { strings: { pluginNameFacebook: "Facebook" } }; var _S = { version: "3.1.2" }, Xi = class extends Q { constructor(e, t) { super(e, t), this.id = this.opts.id || "Facebook", ne.initPlugin(this, t), this.title = this.opts.title || "Facebook", this.icon = () => u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("g", { fill: "none", fillRule: "evenodd" }, u("path", { d: "M27 16c0-6.075-4.925-11-11-11S5 9.925 5 16c0 5.49 4.023 10.041 9.281 10.866V19.18h-2.793V16h2.793v-2.423c0-2.757 1.642-4.28 4.155-4.28 1.204 0 2.462.215 2.462.215v2.707h-1.387c-1.366 0-1.792.848-1.792 1.718V16h3.05l-.487 3.18h-2.563v7.686C22.977 26.041 27 21.49 27 16", fill: "#1777F2" }), u("path", { d: "M20.282 19.18L20.77 16h-3.051v-2.063c0-.87.426-1.718 1.792-1.718h1.387V9.512s-1.258-.215-2.462-.215c-2.513 0-4.155 1.523-4.155 4.28V16h-2.793v3.18h2.793v7.686a11.082 11.082 0 003.438 0V19.18h2.563", fill: "#FFFFFE" }))), this.provider = new ne(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionKeysParams: this.opts.companionKeysParams, companionCookiesRule: this.opts.companionCookiesRule, provider: "facebook", pluginId: this.id }), this.defaultLocale = _y, this.i18nInit(), this.title = this.i18n("pluginNameFacebook"), this.onFirstRender = this.onFirstRender.bind(this), this.render = this.render.bind(this) } install() { this.view = new Ce(this, { provider: this.provider }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.view.tearDown(), this.unmount() } onFirstRender() { return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]) } render(e) { let t = {}; return this.getPluginState().files.length && !this.getPluginState().folders.length && (t.viewType = "grid", t.showFilter = !1, t.showTitles = !1), this.view.render(e, t) } }; n(Xi, "Facebook"); Xi.VERSION = _S.version; var qo = class extends Ce { toggleCheckbox(e, t) { e.stopPropagation(), e.preventDefault(), t.custom.isSharedDrive || super.toggleCheckbox(e, t) } }; n(qo, "DriveProviderViews"); var Fy = { strings: { pluginNameGoogleDrive: "Google Drive" } }; var FS = { version: "3.2.1" }, Yi = class extends Q { constructor(e, t) { super(e, t), this.id = this.opts.id || "GoogleDrive", this.title = this.opts.title || "Google Drive", ne.initPlugin(this, t), this.title = this.opts.title || "Google Drive", this.icon = () => u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("g", { fillRule: "nonzero", fill: "none" }, u("path", { d: "M6.663 22.284l.97 1.62c.202.34.492.609.832.804l3.465-5.798H5c0 .378.1.755.302 1.096l1.361 2.278z", fill: "#0066DA" }), u("path", { d: "M16 12.09l-3.465-5.798c-.34.195-.63.463-.832.804l-6.4 10.718A2.15 2.15 0 005 18.91h6.93L16 12.09z", fill: "#00AC47" }), u("path", { d: "M23.535 24.708c.34-.195.63-.463.832-.804l.403-.67 1.928-3.228c.201-.34.302-.718.302-1.096h-6.93l1.474 2.802 1.991 2.996z", fill: "#EA4335" }), u("path", { d: "M16 12.09l3.465-5.798A2.274 2.274 0 0018.331 6h-4.662c-.403 0-.794.11-1.134.292L16 12.09z", fill: "#00832D" }), u("path", { d: "M20.07 18.91h-8.14l-3.465 5.798c.34.195.73.292 1.134.292h12.802c.403 0 .794-.11 1.134-.292L20.07 18.91z", fill: "#2684FC" }), u("path", { d: "M23.497 12.455l-3.2-5.359a2.252 2.252 0 00-.832-.804L16 12.09l4.07 6.82h6.917c0-.377-.1-.755-.302-1.096l-3.188-5.359z", fill: "#FFBA00" }))), this.provider = new ne(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionKeysParams: this.opts.companionKeysParams, companionCookiesRule: this.opts.companionCookiesRule, provider: "drive", pluginId: this.id }), this.defaultLocale = Fy, this.i18nInit(), this.title = this.i18n("pluginNameGoogleDrive"), this.onFirstRender = this.onFirstRender.bind(this), this.render = this.render.bind(this) } install() { this.view = new qo(this, { provider: this.provider, loadAllFiles: !0 }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.view.tearDown(), this.unmount() } onFirstRender() { return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder("root")]) } render(e) { return this.view.render(e) } }; n(Yi, "GoogleDrive"); Yi.VERSION = FS.version; var xy = { strings: { pluginNameInstagram: "Instagram" } }; var xS = { version: "3.1.2" }, Qi = class extends Q { constructor(e, t) { super(e, t), this.id = this.opts.id || "Instagram", ne.initPlugin(this, t), this.icon = () => u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("defs", null, u("path", { d: "M16.825 5l.483-.001.799.002c1.168.005 1.598.021 2.407.057 1.17.05 1.97.235 2.67.506.725.28 1.34.655 1.951 1.265.613.61.99 1.223 1.273 1.946.273.7.46 1.498.516 2.67l.025.552.008.205c.029.748.037 1.51.042 3.777l.001.846v.703l-.001.398a50.82 50.82 0 01-.058 2.588c-.05 1.17-.235 1.97-.506 2.67a5.394 5.394 0 01-1.265 1.951c-.61.613-1.222.99-1.946 1.273-.699.273-1.498.46-2.668.516-.243.012-.451.022-.656.03l-.204.007c-.719.026-1.512.034-3.676.038l-.847.001h-1.1a50.279 50.279 0 01-2.587-.059c-1.171-.05-1.971-.235-2.671-.506a5.394 5.394 0 01-1.951-1.265 5.385 5.385 0 01-1.272-1.946c-.274-.699-.46-1.498-.517-2.668a88.15 88.15 0 01-.03-.656l-.007-.205c-.026-.718-.034-1.512-.038-3.674v-2.129c.006-1.168.022-1.597.058-2.406.051-1.171.235-1.971.506-2.672a5.39 5.39 0 011.265-1.95 5.381 5.381 0 011.946-1.272c.699-.274 1.498-.462 2.669-.517l.656-.03.204-.007c.718-.026 1.511-.034 3.674-.038zm.678 1.981h-1.226l-.295.001c-2.307.005-3.016.013-3.777.043l-.21.009-.457.02c-1.072.052-1.654.232-2.042.383-.513.2-.879.44-1.263.825a3.413 3.413 0 00-.82 1.267c-.15.388-.33.97-.375 2.043a48.89 48.89 0 00-.056 2.482v.398 1.565c.006 2.937.018 3.285.073 4.444.05 1.073.231 1.654.382 2.043.2.512.44.878.825 1.263.386.383.753.621 1.267.82.388.15.97.328 2.043.374.207.01.388.017.563.024l.208.007a63.28 63.28 0 002.109.026h1.564c2.938-.006 3.286-.019 4.446-.073 1.071-.051 1.654-.232 2.04-.383.514-.2.88-.44 1.264-.825.384-.386.622-.753.82-1.266.15-.389.328-.971.375-2.044.039-.88.054-1.292.057-2.723v-1.15-.572c-.006-2.936-.019-3.284-.074-4.445-.05-1.071-.23-1.654-.382-2.04-.2-.515-.44-.88-.825-1.264a3.405 3.405 0 00-1.267-.82c-.388-.15-.97-.328-2.042-.375a48.987 48.987 0 00-2.535-.056zm-1.515 3.37a5.65 5.65 0 11.021 11.299 5.65 5.65 0 01-.02-11.3zm.004 1.982a3.667 3.667 0 10.015 7.334 3.667 3.667 0 00-.015-7.334zm5.865-3.536a1.32 1.32 0 11.005 2.64 1.32 1.32 0 01-.005-2.64z", id: "a" })), u("g", { fill: "none", "fill-rule": "evenodd" }, u("mask", { id: "b", fill: "#fff" }, u("use", { xlinkHref: "#a" })), u("image", { mask: "url(#b)", x: "4", y: "4", width: "24", height: "24", xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAALKADAAQAAAABAAAALAAAAAD8buejAAALZklEQVRYCVWZC2LbNhAFCRKykvP0bD1506SxRKIzbwHJoU3jv5h9WICU3P7+6zlG2zZvr8s/rW1tN7U0rMll8aDYufdzbLfc1JHmpv3jpPy8tsO+3O2s/O6YMSjTl/qdCds4mIIG60m8vdq2Z+phm2V4vAb9+o7BbZeuoM0NyYazvTvbvlN1MGjHUAesZ/IWWOsCeF0BOwAK4ITR0WYd/QKHEPv2DEymmorZtiubjOHEMYEzXmC9GMxu+95Kz+kuwxjDBKb8iUoCAdqZoAeyALreW6ZNx9Y4Jz8cLwjTZOEoR+HU05k2RzgP2iafGgfZiEdZbEr94zpX/xkPtDtGAxF+LRcgTsp9CAZg0rnEnXmPqFshY5vLnVWxLXO/bah2sZQgBZppGSe8NbjNPN5kc/WbIYEn8U+jXCOezT4zfgS1eoVEhceVeK74Fe4N6CoYEoLWykzHsd+GMAUqdTTVvvqT1uWqB3lVCLb12/ORAe8/5Zu9mp7lqoEFUCAFDIxqz7i1bq2AY1U9jqq2QK/7DYl+1AeZlAFcEc+U/jkRUqsvCHQ/nyGvjrOl6EuZWRWVGCKUMCkntQ5o+u2AZ3OxakbTcoBZnY0xhgGCUM4Kp1xtBTnBnXM5ASRms/Fs7d9OpX8bXN45pibQY/ML1MmA5G9CINBuCpdftexr6i2c5qd9J441LNJm3zk1GVusJ7v6mPJ7HPxJR0Li/vg9O1XHTEgvsQoSgExU0NnlLF0paK+6d06aOMKE2nCKV0ofNw4WsWmLsWrv6lPLnhGpr9E137QkHOMB/jh/T8MOqOadXarR44zPBW5NvDccnBxVmdK81+7RQ5p6qnQoRDZPh9+xWj0N2XpqxX1HzMty9UlFnKya/h3gulziAsyxwkSmpTIPB8vagKLyktRdDuBEHNGZMm4oCFWgjq31WPHpaC93gGNqpOpP4Ez4spa+nMNvhTWcuPKAJ79fqIxVoUvdjEG9qSy2WhpQlz61yG/gnKEA25IrIOYK6DIsQs2EE9LR/sTKq38Nd1y/X//FXG0QDHkEqSz3EYVV2dhb00rgLPSDcqmrScs55NNOD2zVqKmYnYTFnkACp520dkW5vBxK99BVzr792/iZ+VVo92UkKU2oG5WFTb6mNiA1H2C8KC0E44qaQleR3EQvQNwLrECOVAiSwM5gpF7nvDND0lZvYuQ9JbZfqdTrqCgwMcVrRS0z9QkLu9NWmkgEHb8p2zDRylj9VWA3lXD2vObEdWpT3w5MiFqQ1W/lteG4eipastxv2w+TeTBP0ypK84HiOW9fUzLcjRDwCW2b2VxmnGSKTX6uRSwMnC9YX4l05Mh2uwI+QVWdWUOSTWd5Xjjf7/tPYk2stSh053XTGN5RJMCMSajMcS8Trn3j/E1ajthlxCkmJXVi47PSUsyyq+jyexsayQNuv5GVYJaszprNsQD3RkgYiy49kFl2JlJJxlf8Uu/lpkq7+aWqzEzjr5cTVpFaJvSVr8AKRtiTlVPFk5t1nO30W+o6jrbAk76kxFa/tX+dom4C1wDPk03gqCw8HTBSxx4FHxIA+mh2pM3rKu5SNqBAuOSZnHzsB9JwW7DV/ge8dlVsOh375PvH8YO8EALU1HuecIC6qQgXifNuSx9XAoLaoGIYDjkWFrawX1U1XrknuMFw7QBSPtg79XovmBvwqnDICrhClEO6wgKFj9vPqJWlthUvdgH1DOA8+wFMexzQc5BUS1d1IsdBSjEv4Fe1LgBO1CpFPTpV1JuPSFNt4y/trzbtaUfwBWwM3/6JsrL6MSQYwLKXAm9YJBxsM8992MblZ63Gami0+rnwOMyPykVpQsyl9eYNOfVC6kRBkwaop//LgcAKWivkHF791g0JK5kMmCgKPas2QRkUFQsuTvm6R1946Wg95k764ZRLW59yO5UVGsawwELupCfAbdCuAwvcz5Xk18rIVEdgSRBRgO77R206QdXHuA2goaGiCQ0GmUfN1JlmFayjv0IcKGkfYt4HAj0yuQBRGDjzuS/rTmAf29Gov1S+FF7QBayNcpoBOEsMt3vFcIUC7VxOnE+pxmkgqEzduzwsPykrjBszCusgdarsRIAL6CM/KqsqcAf1vj8P1TXFyN6e5G8ao48fjKfDQJYizIdIfb+Xwp6Z2fE2C7mUfUEzMKqSBp4VUV1A49Sz1M2LzVzahEfyHUAcQNltR0nADYkBvHXDZQo8H9dQvHF7qhjPtSolBJ0A/vaLwdRz5YFFGoWBy8E/4aKcjqimaUBXXnjBpzOZnMlIVXsTVEBBUa+dD0BR0xVopgAD70psY0KjMHpmHB2kApea9o23NS83mpsref5OZet4U/0CMhSEDpwnxB9lVKSfk5djllXRFPizQmKcqMpnyZ3ycPntf96Ym9ChzU8vCQnhgWZ2UuySArw+cVBG4gqNCS6YoSEEziRWVStKUpe4FfCd91V0XA/qgOJuF7FpGjjyQgsFoNDtibp8cm+cyXxbB6zh4pMUO4H06yzsv4E/A6rg/uRJRnMRmrhMDIhyOjABX9CMDFhBFxx19KujjqWeim5PwVFU6IBiewfyk7IPETcg52kjXN7nsbaoEykKf/cjUgVxpTZZVtnqFMgv4FHa8oSOisawinMLHfUBzJcK1j8BeqquedKDtgcgnA4bym4P6gBWYVM3W/pn41ku5L4RElFWtlk5SXHEThhOWDiIyVROlQNM+wyHimlgATI/PPIm4BB8qfqwHnhgL89gzs+Ww1xQb4821SZ/4IwOJiRqH/X9u7Hj08JLSZfawOQcpRzwgk1oBNzzcgLn1FBNHspMENik9OG4awIDaUjw9rKNT1KXPl9neua6sSbkgqfs/CNfBdNfDDhQuL4AKXEXeOgZID91eOiRUnEFOIA5rnTkBU0/IT05gByoq5KBJF4Hym4Pxh3UcxZ7HjdhEhKWURbhavNR9rjLBwk3ryDcrGzfvk9I69b1yhMGWQ4bqMwv/RMSplQkjjVKXzZX8wESVcuB7QG0YUCMjk/aOmWgc/vC4oMCVYfghIGP6MT1zpeUhM1rQzOnGxmFKwTCir1Xaj5vN7T7nDZvnbDGHbCKnwji2zofNsOvbold3zlUtKGosBun3PbJSrrReHEaCQVCIDEMaCCBs+P+AbybkbIhmbNecGwF+E5/L2ECuPKCWsUESQkKnyyJ93TGACk7OrAY9P8XG//fGCoM7DAEUGnj5Mw7aQfelySWOm9iPuFyvrL8rKQR6mM6qdCUDQsfNPVu4yv/HaPOT1e/yDaviMKmTkg/I/F7MUG9OlrmDrBLRVd3c8KBJlPEKoVRcIJuhoQAmZDUkPC00W5OI1dOpQ1F61kFNqr9SmFcaHdBheOaDHF6QZMOP6QyiZ804oj98wLiAMIgcWw4UDYkDAWfR+4d5s0zP2GgUZX04i+NeSgYGokvbDhIZYUWHgd9K8zZzir264NxZUFbsfM1jdqpV2naA48tx6hsvBSabE4IMtlcOGgq8PqCjoly2rw2soqy4RJWQtPZl6PUCU14ZUWENuZV2Honn3f+k6R6wrkqgTStyQ0bFY+XAaafMRFgUlVeXxXFUcpLEYfZz3FrVUzZrOOJK+4B/wnIZ8TGRvb9OB8EUM0w8uNYj/oa9iK9AMoy6gA72o02srMxpAPUD+EDnVEF7P5xw896VyAbFk8MgnpVpR3gfLnt/wECq3rYFvYLcKCpqvcI+/hVl8AumXDeApklDRRKJSS+KOaq1Rgg4igOYtiQK1hJy46TBtDjznDp3iqJff5j0/LfSZbYVdauqXccJ9W+czupp0sU9gMlqkQ52lU1E6tUwoDUukAD6YRpAwqDrAErzA8QCRvXm98KEep0xIdY1CN1ye27IP0IHvvYIW18qGz8S7VWUZuMkUOb3P8DHTl67ur/i1UAAAAASUVORK5CYII=" }))), this.defaultLocale = xy, this.i18nInit(), this.title = this.i18n("pluginNameInstagram"), this.provider = new ne(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionKeysParams: this.opts.companionKeysParams, companionCookiesRule: this.opts.companionCookiesRule, provider: "instagram", pluginId: this.id }), this.onFirstRender = this.onFirstRender.bind(this), this.render = this.render.bind(this) } install() { this.view = new Ce(this, { provider: this.provider, viewType: "grid", showTitles: !1, showFilter: !1, showBreadcrumbs: !1 }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.view.tearDown(), this.unmount() } onFirstRender() { return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder("recent")]) } render(e) { return this.view.render(e) } }; n(Qi, "Instagram"); Qi.VERSION = xS.version; var Oy = { strings: { pluginNameOneDrive: "OneDrive" } }; var OS = { version: "3.1.3" }, Ji = class extends Q { constructor(e, t) { super(e, t), this.id = this.opts.id || "OneDrive", ne.initPlugin(this, t), this.title = this.opts.title || "OneDrive", this.icon = () => u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("g", { fill: "none", fillRule: "nonzero" }, u("path", { d: "M13.39 12.888l4.618 2.747 2.752-1.15a4.478 4.478 0 012.073-.352 6.858 6.858 0 00-5.527-5.04 6.895 6.895 0 00-6.876 2.982l.07-.002a5.5 5.5 0 012.89.815z", fill: "#0364B8" }), u("path", { d: "M13.39 12.887v.001a5.5 5.5 0 00-2.89-.815l-.07.002a5.502 5.502 0 00-4.822 2.964 5.43 5.43 0 00.38 5.62l4.073-1.702 1.81-.757 4.032-1.685 2.105-.88-4.619-2.748z", fill: "#0078D4" }), u("path", { d: "M22.833 14.133a4.479 4.479 0 00-2.073.352l-2.752 1.15.798.475 2.616 1.556 1.141.68 3.902 2.321a4.413 4.413 0 00-.022-4.25 4.471 4.471 0 00-3.61-2.284z", fill: "#1490DF" }), u("path", { d: "M22.563 18.346l-1.141-.68-2.616-1.556-.798-.475-2.105.88L11.87 18.2l-1.81.757-4.073 1.702A5.503 5.503 0 0010.5 23h12.031a4.472 4.472 0 003.934-2.333l-3.902-2.321z", fill: "#28A8EA" }))), this.provider = new ne(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionCookiesRule: this.opts.companionCookiesRule, provider: "onedrive", pluginId: this.id }), this.defaultLocale = Oy, this.i18nInit(), this.title = this.i18n("pluginNameOneDrive"), this.onFirstRender = this.onFirstRender.bind(this), this.render = this.render.bind(this) } install() { this.view = new Ce(this, { provider: this.provider, loadAllFiles: !0 }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.view.tearDown(), this.unmount() } onFirstRender() { return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]) } render(e) { return this.view.render(e) } }; n(Ji, "OneDrive"); Ji.VERSION = OS.version; var ES = { version: "3.2.2" }, Zi = class extends Q { constructor(e, t) { if (super(e, t), this.id = this.opts.id || "Unsplash", this.title = this.opts.title || "Unsplash", ne.initPlugin(this, t, {}), this.icon = () => u("svg", { className: "uppy-DashboardTab-iconUnsplash", viewBox: "0 0 32 32", height: "32", width: "32", "aria-hidden": "true" }, u("g", { fill: "currentcolor" }, u("path", { d: "M46.575 10.883v-9h12v9zm12 5h10v18h-32v-18h10v9h12z" }), u("path", { d: "M13 12.5V8h6v4.5zm6 2.5h5v9H8v-9h5v4.5h6z" }))), !this.opts.companionUrl) throw new Error("Companion hostname is required, please consult https://uppy.io/docs/companion"); this.hostname = this.opts.companionUrl, this.provider = new Yr(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionCookiesRule: this.opts.companionCookiesRule, provider: "unsplash", pluginId: this.id }) } install() { this.view = new Bi(this, { provider: this.provider, viewType: "unsplash", showFilter: !0 }); let { target: e } = this.opts; e && this.mount(e, this) } onFirstRender() { } render(e) { return this.view.render(e) } uninstall() { this.unmount() } }; n(Zi, "Unsplash"); Zi.VERSION = ES.version; function Ey(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Ey, "_classPrivateFieldLooseBase"); var CS = 0; function AS(i) { return "__private_" + CS++ + "_" + i } n(AS, "_classPrivateFieldLooseKey"); var ba = AS("handleSubmit"), Ou = class extends ve { constructor(e) { super(e), this.form = document.createElement("form"), Object.defineProperty(this, ba, { writable: !0, value: t => { t.preventDefault(); let { addFile: r } = this.props, s = this.input.value.trim(); r(s) } }), this.form.id = St() } componentDidMount() { this.input.value = "", this.form.addEventListener("submit", Ey(this, ba)[ba]), document.body.appendChild(this.form) } componentWillUnmount() { this.form.removeEventListener("submit", Ey(this, ba)[ba]), document.body.removeChild(this.form) } render() { let { i18n: e } = this.props; return u("div", { className: "uppy-Url" }, u("input", { className: "uppy-u-reset uppy-c-textInput uppy-Url-input", type: "text", "aria-label": e("enterUrlToImport"), placeholder: e("enterUrlToImport"), ref: t => { this.input = t }, "data-uppy-super-focusable": !0, form: this.form.id }), u("button", { className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Url-importButton", type: "submit", form: this.form.id }, e("import"))) } }; n(Ou, "UrlUI"); var Cy = Ou; function Eu(i, e, t) { let r = Ke(i.items), s; switch (e) { case "paste": { if (r.some(a => a.kind === "file")) return; s = r.filter(a => a.kind === "string" && a.type === "text/plain"); break } case "drop": { s = r.filter(o => o.kind === "string" && o.type === "text/uri-list"); break } default: throw new Error(`isDropOrPaste must be either 'drop' or 'paste', but it's ${e}`) }s.forEach(o => { o.getAsString(a => t(a)) }) } n(Eu, "forEachDroppedOrPastedUrl"); var Ay = { strings: { import: "Import", enterUrlToImport: "Enter URL to import a file", failedToFetch: "Companion failed to fetch this URL, please make sure it\u2019s correct", enterCorrectUrl: "Incorrect URL: Please make sure you are entering a direct link to a file" } }; var TS = { version: "3.3.3" }; function RS() { return u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("path", { d: "M23.637 15.312l-2.474 2.464a3.582 3.582 0 01-.577.491c-.907.657-1.897.986-2.968.986a4.925 4.925 0 01-3.959-1.971c-.248-.329-.164-.902.165-1.149.33-.247.907-.164 1.155.164 1.072 1.478 3.133 1.724 4.618.656a.642.642 0 00.33-.328l2.473-2.463c1.238-1.313 1.238-3.366-.082-4.597a3.348 3.348 0 00-4.618 0l-1.402 1.395a.799.799 0 01-1.154 0 .79.79 0 010-1.15l1.402-1.394a4.843 4.843 0 016.843 0c2.062 1.805 2.144 5.007.248 6.896zm-8.081 5.664l-1.402 1.395a3.348 3.348 0 01-4.618 0c-1.319-1.23-1.319-3.365-.082-4.596l2.475-2.464.328-.328c.743-.492 1.567-.739 2.475-.657.906.165 1.648.574 2.143 1.314.248.329.825.411 1.155.165.33-.248.412-.822.165-1.15-.825-1.068-1.98-1.724-3.216-1.888-1.238-.247-2.556.082-3.628.902l-.495.493-2.474 2.464c-1.897 1.969-1.814 5.09.083 6.977.99.904 2.226 1.396 3.463 1.396s2.473-.492 3.463-1.395l1.402-1.396a.79.79 0 000-1.15c-.33-.328-.908-.41-1.237-.082z", fill: "#FF753E", "fill-rule": "nonzero" })) } n(RS, "UrlIcon"); function US(i) { let e = /^[a-z0-9]+:\/\//, t = "http://"; return e.test(i) ? i : t + i } n(US, "addProtocolToURL"); function kS(i) { return Ke(i.dataTransfer.items).filter(r => r.kind === "string" && r.type === "text/uri-list").length > 0 } n(kS, "canHandleRootDrop"); function DS(i) { if (!i) return !1; let e = i.match(/^([a-z0-9]+):\/\//)[1]; return !(e !== "http" && e !== "https") } n(DS, "checkIfCorrectURL"); function IS(i) { let { pathname: e } = new URL(i); return e.substring(e.lastIndexOf("/") + 1) } n(IS, "getFileNameFromUrl"); var Oi = class extends Q { constructor(e, t) { super(e, t), this.id = this.opts.id || "Url", this.title = this.opts.title || "Link", this.type = "acquirer", this.icon = () => u(RS, null), this.defaultLocale = Ay; let r = {}; if (this.opts = { ...r, ...t }, this.i18nInit(), this.hostname = this.opts.companionUrl, !this.hostname) throw new Error("Companion hostname is required, please consult https://uppy.io/docs/companion"); this.getMeta = this.getMeta.bind(this), this.addFile = this.addFile.bind(this), this.handleRootDrop = this.handleRootDrop.bind(this), this.handleRootPaste = this.handleRootPaste.bind(this), this.client = new xe(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionCookiesRule: this.opts.companionCookiesRule }) } getMeta(e) { return this.client.post("url/meta", { url: e }).then(t => { if (t.error) throw this.uppy.log("[URL] Error:"), this.uppy.log(t.error), new Error("Failed to fetch the file"); return t }) } async addFile(e, t) { t === void 0 && (t = void 0); let r = US(e); if (!DS(r)) { this.uppy.log(`[URL] Incorrect URL entered: ${r}`), this.uppy.info(this.i18n("enterCorrectUrl"), "error", 4e3); return } try { let s = await this.getMeta(r), o = { meta: t, source: this.id, name: s.name || IS(r), type: s.type, data: { size: s.size }, isRemote: !0, body: { url: r }, remote: { companionUrl: this.opts.companionUrl, url: `${this.hostname}/url/get`, body: { fileId: r, url: r }, providerOptions: this.client.opts } }; this.uppy.log("[Url] Adding remote file"); try { return this.uppy.addFile(o) } catch (a) { return a.isRestriction || this.uppy.log(a), a } } catch (s) { return this.uppy.log(s), this.uppy.info({ message: this.i18n("failedToFetch"), details: s }, "error", 4e3), s } } handleRootDrop(e) { Eu(e.dataTransfer, "drop", t => { this.uppy.log(`[URL] Adding file from dropped url: ${t}`), this.addFile(t) }) } handleRootPaste(e) { Eu(e.clipboardData, "paste", t => { this.uppy.log(`[URL] Adding file from pasted url: ${t}`), this.addFile(t) }) } render() { return u(Cy, { i18n: this.i18n, addFile: this.addFile }) } install() { let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.unmount() } }; n(Oi, "Url"); Oi.VERSION = TS.version; Oi.prototype.canHandleRootDrop = kS; var Ty = { strings: { pluginNameZoom: "Zoom" } }; var NS = { version: "2.1.2" }, er = class extends Q { constructor(e, t) { super(e, t), this.id = this.opts.id || "Zoom", ne.initPlugin(this, t), this.title = this.opts.title || "Zoom", this.icon = () => u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("path", { d: "M24.5 11.125l-2.75 2.063c-.473.353-.75.91-.75 1.5v3.124c0 .59.277 1.147.75 1.5l2.75 2.063a.938.938 0 001.5-.75v-8.75a.938.938 0 00-1.5-.75zm-4.75 9.5c0 1.035-.84 1.875-1.875 1.875H9.75A3.75 3.75 0 016 18.75v-6.875C6 10.84 6.84 10 7.875 10H16a3.75 3.75 0 013.75 3.75v6.875z", fill: "#2E8CFF", "fill-rule": "evenodd" })), this.provider = new ne(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionKeysParams: this.opts.companionKeysParams, companionCookiesRule: this.opts.companionCookiesRule, provider: "zoom", pluginId: this.id }), this.defaultLocale = Ty, this.i18nInit(), this.title = this.i18n("pluginNameZoom"), this.onFirstRender = this.onFirstRender.bind(this), this.render = this.render.bind(this) } install() { this.view = new Ce(this, { provider: this.provider }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.view.tearDown(), this.unmount() } onFirstRender() { return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]) } render(e) { return this.view.render(e) } }; n(er, "Zoom"); er.VERSION = NS.version; function Gh(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Gh, "_classPrivateFieldLooseBase"); var MS = 0; function BS(i) { return "__private_" + MS++ + "_" + i } n(BS, "_classPrivateFieldLooseKey"); var LS = { version: "1.0.4" }, Kh = { __proto__: null, Box: Gi, Dropbox: Ki, Facebook: Xi, GoogleDrive: Yi, Instagram: Qi, OneDrive: Ji, Unsplash: Zi, Url: Oi, Zoom: er }, Ns = BS("installedPlugins"), Ms = class extends Se { constructor(e, t) { super(e, t), Object.defineProperty(this, Ns, { writable: !0, value: new Set }), this.id = this.opts.id || "RemoteSources", this.type = "acquirer"; let r = { sources: Object.keys(Kh), target: qi }; if (this.opts = { ...r, ...t }, this.opts.companionUrl == null) throw new Error("Please specify companionUrl for RemoteSources to work, see https://uppy.io/docs/remote-sources#companionUrl") } setOptions(e) { this.uninstall(), super.setOptions(e), this.install() } install() { this.opts.sources.forEach(e => { let t = { ...this.opts, sources: void 0 }, r = Kh[e]; if (r == null) { let s = Object.keys(Kh), o = new Intl.ListFormat("en", { style: "long", type: "disjunction" }); throw new Error(`Invalid plugin: "${e}" is not one of: ${o.format(s)}.`) } this.uppy.use(r, t), Gh(this, Ns)[Ns].add(this.uppy.getPlugin(e)) }) } uninstall() { for (let e of Gh(this, Ns)[Ns]) this.uppy.removePlugin(e); Gh(this, Ns)[Ns].clear() } }; n(Ms, "RemoteSources"); Ms.VERSION = LS.version; var Ry = n(() => u("svg", { className: "uppy-DashboardTab-iconScreenRec", "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("g", { fill: "currentcolor", fillRule: "evenodd" }, u("path", { d: "M24.182 9H7.818C6.81 9 6 9.742 6 10.667v10c0 .916.81 1.666 1.818 1.666h4.546V24h7.272v-1.667h4.546c1 0 1.809-.75 1.809-1.666l.009-10C26 9.742 25.182 9 24.182 9zM24 21H8V11h16v10z" }), u("circle", { cx: "16", cy: "16", r: "2" }))), "default"); function Xh(i) { let { recording: e, onStartRecording: t, onStopRecording: r, i18n: s } = i; return e ? u("button", { className: "uppy-u-reset uppy-c-btn uppy-ScreenCapture-button uppy-ScreenCapture-button--video uppy-ScreenCapture-button--stop-rec", type: "button", title: s("stopCapturing"), "aria-label": s("stopCapturing"), onClick: r, "data-uppy-super-focusable": !0 }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "100", height: "100", viewBox: "0 0 100 100" }, u("rect", { x: "15", y: "15", width: "70", height: "70" }))) : u("button", { className: "uppy-u-reset uppy-c-btn uppy-ScreenCapture-button uppy-ScreenCapture-button--video", type: "button", title: s("startCapturing"), "aria-label": s("startCapturing"), onClick: t, "data-uppy-super-focusable": !0 }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "100", height: "100", viewBox: "0 0 100 100" }, u("circle", { cx: "50", cy: "50", r: "40" }))) } n(Xh, "RecordButton"); function Yh(i) { let { recording: e, recordedVideo: t, onSubmit: r, i18n: s } = i; return t && !e ? u("button", { className: "uppy-u-reset uppy-c-btn uppy-ScreenCapture-button uppy-ScreenCapture-button--submit", type: "button", title: s("submitRecordedFile"), "aria-label": s("submitRecordedFile"), onClick: r, "data-uppy-super-focusable": !0 }, u("svg", { width: "12", height: "9", viewBox: "0 0 12 9", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", focusable: "false", className: "uppy-c-icon" }, u("path", { fill: "#fff", fillRule: "nonzero", d: "M10.66 0L12 1.31 4.136 9 0 4.956l1.34-1.31L4.136 6.38z" }))) : null } n(Yh, "SubmitButton"); var Cu = class extends ve { constructor(e) { super(e), this.state = { elapsedTime: 0 }, this.wrapperStyle = { width: "100%", height: "100%", display: "flex" }, this.overlayStyle = { position: "absolute", width: "100%", height: "100%", background: "black", opacity: .7 }, this.infoContainerStyle = { marginLeft: "auto", marginRight: "auto", marginTop: "auto", marginBottom: "auto", zIndex: 1, color: "white" }, this.infotextStyle = { marginLeft: "auto", marginRight: "auto", marginBottom: "1rem", fontSize: "1.5rem" }, this.timeStyle = { display: "block", fontWeight: "bold", marginLeft: "auto", marginRight: "auto", fontSize: "3rem", fontFamily: "Courier New" } } startTimer() { this.timerTick(), this.timerRunning = !0 } resetTimer() { clearTimeout(this.timer), this.setState({ elapsedTime: 0 }), this.timerRunning = !1 } timerTick() { this.timer = setTimeout(() => { this.setState(e => ({ elapsedTime: e.elapsedTime + 1 })), this.timerTick() }, 1e3) } fmtMSS(e) { return (e - (e %= 60)) / 60 + (e > 9 ? ":" : ":0") + e } render() { let { recording: e, i18n: t } = { ...this.props }, { elapsedTime: r } = this.state, s = this.fmtMSS(r); return e && !this.timerRunning && this.startTimer(), !e && this.timerRunning && this.resetTimer(), e ? u("div", { style: this.wrapperStyle }, u("div", { style: this.overlayStyle }), u("div", { style: this.infoContainerStyle }, u("div", { style: this.infotextStyle }, t("recording")), u("div", { style: this.timeStyle }, s))) : null } }; n(Cu, "StopWatch"); var Uy = Cu; var ky = n(i => { let { streamActive: e, i18n: t } = i; return e ? u("div", { title: t("streamActive"), "aria-label": t("streamActive"), className: "uppy-ScreenCapture-icon--stream uppy-ScreenCapture-icon--streamActive" }, u("svg", { "aria-hidden": "true", focusable: "false", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M0 0h24v24H0z", opacity: ".1", fill: "none" }), u("path", { d: "M0 0h24v24H0z", fill: "none" }), u("path", { d: "M1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm18-7H5v1.63c3.96 1.28 7.09 4.41 8.37 8.37H19V7zM1 10v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11zm20-7H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z" }))) : u("div", { title: t("streamPassive"), "aria-label": t("streamPassive"), className: "uppy-ScreenCapture-icon--stream" }, u("svg", { "aria-hidden": "true", focusable: "false", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M0 0h24v24H0z", opacity: ".1", fill: "none" }), u("path", { d: "M0 0h24v24H0z", fill: "none" }), u("path", { d: "M21 3H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm0-4v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11z" }))) }, "default"); function Qh() { return Qh = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, Qh.apply(this, arguments) } n(Qh, "_extends"); var Au = class extends ve { componentWillUnmount() { let { onStop: e } = this.props; e() } render() { let { recording: e, stream: t, recordedVideo: r } = this.props, s = { playsinline: !0 }; return (e || !r && !e) && (s.muted = !0, s.autoplay = !0, s.srcObject = t), r && !e && (s.muted = !1, s.controls = !0, s.src = r, this.videoElement && (this.videoElement.srcObject = void 0)), u("div", { className: "uppy uppy-ScreenCapture-container" }, u("div", { className: "uppy-ScreenCapture-videoContainer" }, u(ky, this.props), u("video", Qh({ ref: o => { this.videoElement = o }, className: "uppy-ScreenCapture-video" }, s)), u(Uy, this.props)), u("div", { className: "uppy-ScreenCapture-buttonContainer" }, u(Xh, this.props), u(Yh, this.props))) } }; n(Au, "RecorderScreen"); var Dy = Au; var Iy = { strings: { startCapturing: "Begin screen capturing", stopCapturing: "Stop screen capturing", submitRecordedFile: "Submit recorded file", streamActive: "Stream active", streamPassive: "Stream passive", micDisabled: "Microphone access denied by user", recording: "Recording" } }; function Jh() { return Jh = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, Jh.apply(this, arguments) } n(Jh, "_extends"); var jS = { version: "3.1.2" }; function zS() { var i; return window.MediaRecorder && ((i = navigator.mediaDevices) == null ? void 0 : i.getDisplayMedia) } n(zS, "isScreenRecordingSupported"); function HS() { return window.MediaRecorder && navigator.mediaDevices } n(HS, "getMediaDevices"); var as = class extends Q { constructor(e, t) { super(e, t), this.mediaDevices = HS(), this.protocol = location.protocol === "https:" ? "https" : "http", this.id = this.opts.id || "ScreenCapture", this.title = this.opts.title || "Screencast", this.type = "acquirer", this.icon = Ry, this.defaultLocale = Iy; let r = { displayMediaConstraints: { video: { width: 1280, height: 720, frameRate: { ideal: 3, max: 5 }, cursor: "motion", displaySurface: "monitor" } }, userMediaConstraints: { audio: !0 }, preferredVideoMimeType: "video/webm" }; this.opts = { ...r, ...t }, this.i18nInit(), this.install = this.install.bind(this), this.setPluginState = this.setPluginState.bind(this), this.render = this.render.bind(this), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this.startRecording = this.startRecording.bind(this), this.stopRecording = this.stopRecording.bind(this), this.submit = this.submit.bind(this), this.streamInterrupted = this.streamInactivated.bind(this), this.captureActive = !1, this.capturedMediaFile = null } install() { if (!zS()) return this.uppy.log("Screen recorder access is not supported", "warning"), null; this.setPluginState({ streamActive: !1, audioStreamActive: !1 }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.videoStream && this.stop(), this.unmount() } start() { return this.mediaDevices ? (this.captureActive = !0, this.selectAudioStreamSource(), this.selectVideoStreamSource().then(e => { e === !1 && this.parent && this.parent.hideAllPanels && (this.parent.hideAllPanels(), this.captureActive = !1) })) : Promise.reject(new Error("Screen recorder access not supported")) } selectVideoStreamSource() { return this.videoStream ? new Promise(e => e(this.videoStream)) : this.mediaDevices.getDisplayMedia(this.opts.displayMediaConstraints).then(e => (this.videoStream = e, this.videoStream.addEventListener("inactive", () => { this.streamInactivated() }), this.setPluginState({ streamActive: !0 }), e)).catch(e => (this.setPluginState({ screenRecError: e }), this.userDenied = !0, setTimeout(() => { this.userDenied = !1 }, 1e3), !1)) } selectAudioStreamSource() { return this.audioStream ? new Promise(e => e(this.audioStream)) : this.mediaDevices.getUserMedia(this.opts.userMediaConstraints).then(e => (this.audioStream = e, this.setPluginState({ audioStreamActive: !0 }), e)).catch(e => (e.name === "NotAllowedError" && (this.uppy.info(this.i18n("micDisabled"), "error", 5e3), this.uppy.log(this.i18n("micDisabled"), "warning")), !1)) } startRecording() { let e = {}; this.capturedMediaFile = null, this.recordingChunks = []; let { preferredVideoMimeType: t } = this.opts; this.selectVideoStreamSource().then(r => { t && MediaRecorder.isTypeSupported(t) && Wi(t) && (e.mimeType = t); let s = [r.getVideoTracks()[0]]; this.audioStream && s.push(this.audioStream.getAudioTracks()[0]), this.outputStream = new MediaStream(s), this.recorder = new MediaRecorder(this.outputStream, e), this.recorder.addEventListener("dataavailable", o => { this.recordingChunks.push(o.data) }), this.recorder.start(), this.setPluginState({ recording: !0 }) }).catch(r => { this.uppy.log(r, "error") }) } streamInactivated() { let { recordedVideo: e, recording: t } = { ...this.getPluginState() }; !e && !t ? this.parent && this.parent.hideAllPanels && this.parent.hideAllPanels() : t && (this.uppy.log("Capture stream inactive \u2014 stop recording"), this.stopRecording()), this.videoStream = null, this.audioStream = null, this.setPluginState({ streamActive: !1, audioStreamActive: !1 }) } stopRecording() { return new Promise(t => { this.recorder.addEventListener("stop", () => { t() }), this.recorder.stop() }).then(() => (this.setPluginState({ recording: !1 }), this.getVideo())).then(t => { this.capturedMediaFile = t, this.setPluginState({ recordedVideo: URL.createObjectURL(t.data) }) }).then(() => { this.recordingChunks = null, this.recorder = null }, t => { throw this.recordingChunks = null, this.recorder = null, t }) } submit() { try { this.capturedMediaFile && this.uppy.addFile(this.capturedMediaFile) } catch (e) { e.isRestriction || this.uppy.log(e, "warning") } } stop() { this.videoStream && (this.videoStream.getVideoTracks().forEach(e => { e.stop() }), this.videoStream.getAudioTracks().forEach(e => { e.stop() }), this.videoStream = null), this.audioStream && (this.audioStream.getAudioTracks().forEach(e => { e.stop() }), this.audioStream.getVideoTracks().forEach(e => { e.stop() }), this.audioStream = null), this.outputStream && (this.outputStream.getAudioTracks().forEach(e => { e.stop() }), this.outputStream.getVideoTracks().forEach(e => { e.stop() }), this.outputStream = null), this.setPluginState({ recordedVideo: null }), this.captureActive = !1 } getVideo() { let e = this.recordingChunks[0].type, t = Wi(e); if (!t) return Promise.reject(new Error(`Could not retrieve recording: Unsupported media type "${e}"`)); let r = `screencap-${Date.now()}.${t}`, s = new Blob(this.recordingChunks, { type: e }), o = { source: this.id, name: r, data: new Blob([s], { type: e }), type: e }; return Promise.resolve(o) } render() { let e = this.getPluginState(); return !e.streamActive && !this.captureActive && !this.userDenied && this.start(), u(Dy, Jh({}, e, { onStartRecording: this.startRecording, onStopRecording: this.stopRecording, onStop: this.stop, onSubmit: this.submit, i18n: this.i18n, stream: this.videoStream })) } }; n(as, "ScreenCapture"); as.VERSION = jS.version; var Vy = de(Ny(), 1); function ec(i, e, t) { return new Promise(r => { i.toBlob(r, e, t) }) } n(ec, "canvasToBlob"); function tc() { return typeof MediaRecorder == "function" && !!MediaRecorder.prototype && typeof MediaRecorder.prototype.start == "function" } n(tc, "supportsMediaRecorder"); var Ru = n(() => u("svg", { "aria-hidden": "true", focusable: "false", fill: "#0097DC", width: "66", height: "55", viewBox: "0 0 66 55" }, u("path", { d: "M57.3 8.433c4.59 0 8.1 3.51 8.1 8.1v29.7c0 4.59-3.51 8.1-8.1 8.1H8.7c-4.59 0-8.1-3.51-8.1-8.1v-29.7c0-4.59 3.51-8.1 8.1-8.1h9.45l4.59-7.02c.54-.54 1.35-1.08 2.16-1.08h16.2c.81 0 1.62.54 2.16 1.08l4.59 7.02h9.45zM33 14.64c-8.62 0-15.393 6.773-15.393 15.393 0 8.62 6.773 15.393 15.393 15.393 8.62 0 15.393-6.773 15.393-15.393 0-8.62-6.773-15.393-15.393-15.393zM33 40c-5.648 0-9.966-4.319-9.966-9.967 0-5.647 4.318-9.966 9.966-9.966s9.966 4.319 9.966 9.966C42.966 35.681 38.648 40 33 40z", fillRule: "evenodd" })), "default"); var My = n(i => { let { onSnapshot: e, i18n: t } = i; return u("button", { className: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--picture", type: "button", title: t("takePicture"), "aria-label": t("takePicture"), onClick: e, "data-uppy-super-focusable": !0 }, Ru()) }, "default"); function ic(i) { let { recording: e, onStartRecording: t, onStopRecording: r, i18n: s } = i; return e ? u("button", { className: "uppy-u-reset uppy-c-btn uppy-Webcam-button", type: "button", title: s("stopRecording"), "aria-label": s("stopRecording"), onClick: r, "data-uppy-super-focusable": !0 }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "100", height: "100", viewBox: "0 0 100 100" }, u("rect", { x: "15", y: "15", width: "70", height: "70" }))) : u("button", { className: "uppy-u-reset uppy-c-btn uppy-Webcam-button", type: "button", title: s("startRecording"), "aria-label": s("startRecording"), onClick: t, "data-uppy-super-focusable": !0 }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "100", height: "100", viewBox: "0 0 100 100" }, u("circle", { cx: "50", cy: "50", r: "40" }))) } n(ic, "RecordButton"); function rc(i) { return `${Math.floor(i / 60)}:${String(i % 60).padStart(2, 0)}` } n(rc, "formatSeconds"); function sc(i) { let { recordingLengthSeconds: e, i18n: t } = i, r = rc(e); return u("span", { "aria-label": t("recordingLength", { recording_length: r }) }, r) } n(sc, "RecordingLength"); var By = n(i => { let { currentDeviceId: e, videoSources: t, onChangeVideoSource: r } = i; return u("div", { className: "uppy-Webcam-videoSource" }, u("select", { className: "uppy-u-reset uppy-Webcam-videoSource-select", onChange: s => { r(s.target.value) } }, t.map(s => u("option", { key: s.deviceId, value: s.deviceId, selected: s.deviceId === e }, s.label)))) }, "default"); function WS(i) { let { onSubmit: e, i18n: t } = i; return u("button", { className: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--submit", type: "button", title: t("submitRecordedFile"), "aria-label": t("submitRecordedFile"), onClick: e, "data-uppy-super-focusable": !0 }, u("svg", { width: "12", height: "9", viewBox: "0 0 12 9", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", focusable: "false", className: "uppy-c-icon" }, u("path", { fill: "#fff", fillRule: "nonzero", d: "M10.66 0L12 1.31 4.136 9 0 4.956l1.34-1.31L4.136 6.38z" }))) } n(WS, "SubmitButton"); var Ly = WS; function GS(i) { let { onDiscard: e, i18n: t } = i; return u("button", { className: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--discard", type: "button", title: t("discardRecordedFile"), "aria-label": t("discardRecordedFile"), onClick: e, "data-uppy-super-focusable": !0 }, u("svg", { width: "13", height: "13", viewBox: "0 0 13 13", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", focusable: "false", className: "uppy-c-icon" }, u("g", { fill: "#FFF", fillRule: "evenodd" }, u("path", { d: "M.496 11.367L11.103.76l1.414 1.414L1.911 12.781z" }), u("path", { d: "M11.104 12.782L.497 2.175 1.911.76l10.607 10.606z" })))) } n(GS, "DiscardButton"); var jy = GS; function oc() { return oc = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, oc.apply(this, arguments) } n(oc, "_extends"); function Uu(i, e) { return i.includes(e) } n(Uu, "isModeAvailable"); var ku = class extends ve { componentDidMount() { let { onFocus: e } = this.props; e() } componentWillUnmount() { let { onStop: e } = this.props; e() } render() { let { src: e, recordedVideo: t, recording: r, modes: s, supportsRecording: o, videoSources: a, showVideoSourceDropdown: l, showRecordingLength: d, onSubmit: p, i18n: h, mirror: m, onSnapshot: y, onStartRecording: b, onStopRecording: S, onDiscardRecordedVideo: O, recordingLengthSeconds: F } = this.props, x = !!t, U = !x && o && (Uu(s, "video-only") || Uu(s, "audio-only") || Uu(s, "video-audio")), H = !x && Uu(s, "picture"), W = o && d && !x, J = l && a && a.length > 1, L = { playsinline: !0 }; return t ? (L.muted = !1, L.controls = !0, L.src = t, this.videoElement && (this.videoElement.srcObject = void 0)) : (L.muted = !0, L.autoplay = !0, L.srcObject = e), u("div", { className: "uppy uppy-Webcam-container" }, u("div", { className: "uppy-Webcam-videoContainer" }, u("video", oc({ ref: G => this.videoElement = G, className: `uppy-Webcam-video  ${m ? "uppy-Webcam-video--mirrored" : ""}` }, L))), u("div", { className: "uppy-Webcam-footer" }, u("div", { className: "uppy-Webcam-videoSourceContainer" }, J ? By(this.props) : null), u("div", { className: "uppy-Webcam-buttonContainer" }, H && u(My, { onSnapshot: y, i18n: h }), U && u(ic, { recording: r, onStartRecording: b, onStopRecording: S, i18n: h }), x && u(Ly, { onSubmit: p, i18n: h }), x && u(jy, { onDiscard: O, i18n: h })), u("div", { className: "uppy-Webcam-recordingLength" }, W && u(sc, { recordingLengthSeconds: F, i18n: h })))) } }; n(ku, "CameraScreen"); var zy = ku; var Hy = n(i => { let { icon: e, i18n: t, hasCamera: r } = i; return u("div", { className: "uppy-Webcam-permissons" }, u("div", { className: "uppy-Webcam-permissonsIcon" }, e()), u("h1", { className: "uppy-Webcam-title" }, t(r ? "allowAccessTitle" : "noCameraTitle")), u("p", null, t(r ? "allowAccessDescription" : "noCameraDescription"))) }, "default"); var $y = { strings: { pluginNameCamera: "Camera", noCameraTitle: "Camera Not Available", noCameraDescription: "In order to take pictures or record video, please connect a camera device", recordingStoppedMaxSize: "Recording stopped because the file size is about to exceed the limit", submitRecordedFile: "Submit recorded file", discardRecordedFile: "Discard recorded file", smile: "Smile!", takePicture: "Take a picture", startRecording: "Begin video recording", stopRecording: "Stop video recording", recordingLength: "Recording length %{recording_length}", allowAccessTitle: "Please allow access to your camera", allowAccessDescription: "In order to take pictures or record video with your camera, please allow camera access for this site." } }; function ac() { return ac = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, ac.apply(this, arguments) } n(ac, "_extends"); function wa(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(wa, "_classPrivateFieldLooseBase"); var KS = 0; function XS(i) { return "__private_" + KS++ + "_" + i } n(XS, "_classPrivateFieldLooseKey"); var YS = { version: "3.3.3" }; function qy(i) { return i[0] === "." ? cn[i.slice(1)] : i } n(qy, "toMimeType"); function QS(i) { return /^video\/[^*]+$/.test(i) } n(QS, "isVideoMimeType"); function JS(i) { return /^image\/[^*]+$/.test(i) } n(JS, "isImageMimeType"); function ZS() { return navigator.mediaDevices } n(ZS, "getMediaDevices"); function nc(i, e) { return i.includes(e) } n(nc, "isModeAvailable"); var Ei = XS("enableMirror"), ls = class extends Q { constructor(e, t) { super(e, t), Object.defineProperty(this, Ei, { writable: !0, value: void 0 }), this.mediaDevices = ZS(), this.supportsUserMedia = !!this.mediaDevices, this.protocol = location.protocol.match(/https/i) ? "https" : "http", this.id = this.opts.id || "Webcam", this.type = "acquirer", this.capturedMediaFile = null, this.icon = () => u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("path", { d: "M23.5 9.5c1.417 0 2.5 1.083 2.5 2.5v9.167c0 1.416-1.083 2.5-2.5 2.5h-15c-1.417 0-2.5-1.084-2.5-2.5V12c0-1.417 1.083-2.5 2.5-2.5h2.917l1.416-2.167C13 7.167 13.25 7 13.5 7h5c.25 0 .5.167.667.333L20.583 9.5H23.5zM16 11.417a4.706 4.706 0 00-4.75 4.75 4.704 4.704 0 004.75 4.75 4.703 4.703 0 004.75-4.75c0-2.663-2.09-4.75-4.75-4.75zm0 7.825c-1.744 0-3.076-1.332-3.076-3.074 0-1.745 1.333-3.077 3.076-3.077 1.744 0 3.074 1.333 3.074 3.076s-1.33 3.075-3.074 3.075z", fill: "#02B383", fillRule: "nonzero" })), this.defaultLocale = $y; let r = { onBeforeSnapshot: () => Promise.resolve(), countdown: !1, modes: ["video-audio", "video-only", "audio-only", "picture"], mirror: !0, showVideoSourceDropdown: !1, facingMode: "user", videoConstraints: void 0, preferredImageMimeType: null, preferredVideoMimeType: null, showRecordingLength: !1, mobileNativeCamera: (0, Vy.default)({ tablet: !0 }) }; this.opts = { ...r, ...t }, this.i18nInit(), this.title = this.i18n("pluginNameCamera"), wa(this, Ei)[Ei] = this.opts.mirror, this.install = this.install.bind(this), this.setPluginState = this.setPluginState.bind(this), this.render = this.render.bind(this), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this.takeSnapshot = this.takeSnapshot.bind(this), this.startRecording = this.startRecording.bind(this), this.stopRecording = this.stopRecording.bind(this), this.discardRecordedVideo = this.discardRecordedVideo.bind(this), this.submit = this.submit.bind(this), this.oneTwoThreeSmile = this.oneTwoThreeSmile.bind(this), this.focus = this.focus.bind(this), this.changeVideoSource = this.changeVideoSource.bind(this), this.webcamActive = !1, this.opts.countdown && (this.opts.onBeforeSnapshot = this.oneTwoThreeSmile), this.setPluginState({ hasCamera: !1, cameraReady: !1, cameraError: null, recordingLengthSeconds: 0, videoSources: [], currentDeviceId: null }) } setOptions(e) { super.setOptions({ ...e, videoConstraints: { ...this.opts.videoConstraints, ...e?.videoConstraints } }) } hasCameraCheck() { return this.mediaDevices ? this.mediaDevices.enumerateDevices().then(e => e.some(t => t.kind === "videoinput")) : Promise.resolve(!1) } isAudioOnly() { return this.opts.modes.length === 1 && this.opts.modes[0] === "audio-only" } getConstraints(e) { e === void 0 && (e = null); let t = this.opts.modes.indexOf("video-audio") !== -1 || this.opts.modes.indexOf("audio-only") !== -1, r = !this.isAudioOnly() && (this.opts.modes.indexOf("video-audio") !== -1 || this.opts.modes.indexOf("video-only") !== -1 || this.opts.modes.indexOf("picture") !== -1), s = { ...this.opts.videoConstraints || { facingMode: this.opts.facingMode }, ...e ? { deviceId: e, facingMode: null } : {} }; return { audio: t, video: r ? s : !1 } } start(e) { if (e === void 0 && (e = null), !this.supportsUserMedia) return Promise.reject(new Error("Webcam access not supported")); this.webcamActive = !0, this.opts.mirror && (wa(this, Ei)[Ei] = !0); let t = this.getConstraints(e && e.deviceId ? e.deviceId : null); this.hasCameraCheck().then(r => (this.setPluginState({ hasCamera: r }), this.mediaDevices.getUserMedia(t).then(s => { this.stream = s; let o = null, a = this.isAudioOnly() ? s.getAudioTracks() : s.getVideoTracks(); !e || !e.deviceId ? o = a[0].getSettings().deviceId : a.forEach(l => { l.getSettings().deviceId === e.deviceId && (o = l.getSettings().deviceId) }), this.updateVideoSources(), this.setPluginState({ currentDeviceId: o, cameraReady: !0 }) }).catch(s => { this.setPluginState({ cameraReady: !1, cameraError: s }), this.uppy.info(s.message, "error") }))) } getMediaRecorderOptions() { let e = {}; if (MediaRecorder.isTypeSupported) { let { restrictions: t } = this.uppy.opts, r = []; this.opts.preferredVideoMimeType ? r = [this.opts.preferredVideoMimeType] : t.allowedFileTypes && (r = t.allowedFileTypes.map(qy).filter(QS)); let s = n(a => MediaRecorder.isTypeSupported(a) && Wi(a), "filterSupportedTypes"), o = r.filter(s); o.length > 0 && (e.mimeType = o[0]) } return e } startRecording() { this.recorder = new MediaRecorder(this.stream, this.getMediaRecorderOptions()), this.recordingChunks = []; let e = !1; this.recorder.addEventListener("dataavailable", t => { this.recordingChunks.push(t.data); let { restrictions: r } = this.uppy.opts; if (this.recordingChunks.length > 1 && r.maxFileSize != null && !e) { let s = this.recordingChunks.reduce((d, p) => d + p.size, 0), a = (s - this.recordingChunks[0].size) / (this.recordingChunks.length - 1) * 3, l = Math.max(0, r.maxFileSize - a); s > l && (e = !0, this.uppy.info(this.i18n("recordingStoppedMaxSize"), "warning", 4e3), this.stopRecording()) } }), this.recorder.start(500), this.opts.showRecordingLength && (this.recordingLengthTimer = setInterval(() => { let t = this.getPluginState().recordingLengthSeconds; this.setPluginState({ recordingLengthSeconds: t + 1 }) }, 1e3)), this.setPluginState({ isRecording: !0 }) } stopRecording() { return new Promise(t => { this.recorder.addEventListener("stop", () => { t() }), this.recorder.stop(), this.opts.showRecordingLength && (clearInterval(this.recordingLengthTimer), this.setPluginState({ recordingLengthSeconds: 0 })) }).then(() => (this.setPluginState({ isRecording: !1 }), this.getVideo())).then(t => { try { this.capturedMediaFile = t, this.setPluginState({ recordedVideo: URL.createObjectURL(t.data) }), wa(this, Ei)[Ei] = !1 } catch (r) { r.isRestriction || this.uppy.log(r) } }).then(() => { this.recordingChunks = null, this.recorder = null }, t => { throw this.recordingChunks = null, this.recorder = null, t }) } discardRecordedVideo() { this.setPluginState({ recordedVideo: null }), this.opts.mirror && (wa(this, Ei)[Ei] = !0), this.capturedMediaFile = null } submit() { try { this.capturedMediaFile && this.uppy.addFile(this.capturedMediaFile) } catch (e) { e.isRestriction || this.uppy.log(e, "error") } } async stop() { if (this.stream) { let e = this.stream.getAudioTracks(), t = this.stream.getVideoTracks(); e.concat(t).forEach(r => r.stop()) } this.recorder && await new Promise(e => { this.recorder.addEventListener("stop", e, { once: !0 }), this.recorder.stop(), this.opts.showRecordingLength && clearInterval(this.recordingLengthTimer) }), this.recordingChunks = null, this.recorder = null, this.webcamActive = !1, this.stream = null, this.setPluginState({ recordedVideo: null, isRecording: !1, recordingLengthSeconds: 0 }) } getVideoElement() { return this.el.querySelector(".uppy-Webcam-video") } oneTwoThreeSmile() { return new Promise((e, t) => { let r = this.opts.countdown, s = setInterval(() => { if (!this.webcamActive) return clearInterval(s), this.captureInProgress = !1, t(new Error("Webcam is not active")); r > 0 ? (this.uppy.info(`${r}...`, "warning", 800), r--) : (clearInterval(s), this.uppy.info(this.i18n("smile"), "success", 1500), setTimeout(() => e(), 1500)) }, 1e3) }) } takeSnapshot() { this.captureInProgress || (this.captureInProgress = !0, this.opts.onBeforeSnapshot().catch(e => { let t = typeof e == "object" ? e.message : e; return this.uppy.info(t, "error", 5e3), Promise.reject(new Error(`onBeforeSnapshot: ${t}`)) }).then(() => this.getImage()).then(e => { this.captureInProgress = !1; try { this.uppy.addFile(e) } catch (t) { t.isRestriction || this.uppy.log(t) } }, e => { throw this.captureInProgress = !1, e })) } getImage() { let e = this.getVideoElement(); if (!e) return Promise.reject(new Error("No video element found, likely due to the Webcam tab being closed.")); let t = e.videoWidth, r = e.videoHeight, s = document.createElement("canvas"); s.width = t, s.height = r, s.getContext("2d").drawImage(e, 0, 0); let { restrictions: a } = this.uppy.opts, l = []; this.opts.preferredImageMimeType ? l = [this.opts.preferredImageMimeType] : a.allowedFileTypes && (l = a.allowedFileTypes.map(qy).filter(JS)); let d = l[0] || "image/jpeg", p = Wi(d) || "jpg", h = `cam-${Date.now()}.${p}`; return ec(s, d).then(m => ({ source: this.id, name: h, data: new Blob([m], { type: d }), type: d })) } getVideo() { let e = this.recordingChunks.find(a => { var l; return ((l = a.type) == null ? void 0 : l.length) > 0 }).type, t = Wi(e); if (!t) return Promise.reject(new Error(`Could not retrieve recording: Unsupported media type "${e}"`)); let r = `webcam-${Date.now()}.${t}`, s = new Blob(this.recordingChunks, { type: e }), o = { source: this.id, name: r, data: new Blob([s], { type: e }), type: e }; return Promise.resolve(o) } focus() { this.opts.countdown && setTimeout(() => { this.uppy.info(this.i18n("smile"), "success", 1500) }, 1e3) } changeVideoSource(e) { this.stop(), this.start({ deviceId: e }) } updateVideoSources() { this.mediaDevices.enumerateDevices().then(e => { this.setPluginState({ videoSources: e.filter(t => t.kind === "videoinput") }) }) } render() { this.webcamActive || this.start(); let e = this.getPluginState(); return !e.cameraReady || !e.hasCamera ? u(Hy, { icon: Ru, i18n: this.i18n, hasCamera: e.hasCamera }) : u(zy, ac({}, e, { onChangeVideoSource: this.changeVideoSource, onSnapshot: this.takeSnapshot, onStartRecording: this.startRecording, onStopRecording: this.stopRecording, onDiscardRecordedVideo: this.discardRecordedVideo, onSubmit: this.submit, onFocus: this.focus, onStop: this.stop, i18n: this.i18n, modes: this.opts.modes, showRecordingLength: this.opts.showRecordingLength, showVideoSourceDropdown: this.opts.showVideoSourceDropdown, supportsRecording: tc(), recording: e.isRecording, mirror: wa(this, Ei)[Ei], src: this.stream })) } install() { let { mobileNativeCamera: e, modes: t, facingMode: r, videoConstraints: s } = this.opts, { target: o } = this.opts; if (e && o) { var a; (a = this.getTargetPlugin(o)) == null || a.setOptions({ showNativeVideoCameraButton: nc(t, "video-only") || nc(t, "video-audio"), showNativePhotoCameraButton: nc(t, "picture"), nativeCameraFacingMode: s?.facingMode || r }); return } this.setPluginState({ cameraReady: !1, recordingLengthSeconds: 0 }), o && this.mount(o, this), this.mediaDevices && (this.updateVideoSources(), this.mediaDevices.ondevicechange = () => { if (this.updateVideoSources(), this.stream) { let l = !0, { videoSources: d, currentDeviceId: p } = this.getPluginState(); d.forEach(h => { p === h.deviceId && (l = !1) }), l && (this.stop(), this.start()) } }) } uninstall() { this.stop(), this.unmount() } onUnmount() { this.stop() } }; n(ls, "Webcam"); ls.VERSION = YS.version; function X(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(X, "_classPrivateFieldLooseBase"); var eP = 0; function Vt(i) { return "__private_" + eP++ + "_" + i } n(Vt, "_classPrivateFieldLooseKey"); function tP(i) { return new Error("Cancelled", { cause: i }) } n(tP, "createCancelError"); function Wy(i) { if (i != null) { var e; let t = n(() => this.abort(i.reason), "abortPromise"); i.addEventListener("abort", t, { once: !0 }); let r = n(() => { i.removeEventListener("abort", t) }, "removeAbortListener"); (e = this.then) == null || e.call(this, r, r) } return this } n(Wy, "abortOn"); var ri = Vt("activeRequests"), It = Vt("queuedHandlers"), ii = Vt("paused"), Bs = Vt("pauseTimer"), Dt = Vt("downLimit"), Ls = Vt("upperLimit"), kr = Vt("rateLimitingTimer"), Sa = Vt("call"), Dr = Vt("queueNext"), dc = Vt("next"), lc = Vt("queue"), hc = Vt("dequeue"), uc = Vt("resume"), js = Vt("increaseLimit"), Nt = class { constructor(e) { Object.defineProperty(this, hc, { value: nP }), Object.defineProperty(this, lc, { value: oP }), Object.defineProperty(this, dc, { value: sP }), Object.defineProperty(this, Dr, { value: rP }), Object.defineProperty(this, Sa, { value: iP }), Object.defineProperty(this, ri, { writable: !0, value: 0 }), Object.defineProperty(this, It, { writable: !0, value: [] }), Object.defineProperty(this, ii, { writable: !0, value: !1 }), Object.defineProperty(this, Bs, { writable: !0, value: void 0 }), Object.defineProperty(this, Dt, { writable: !0, value: 1 }), Object.defineProperty(this, Ls, { writable: !0, value: void 0 }), Object.defineProperty(this, kr, { writable: !0, value: void 0 }), Object.defineProperty(this, uc, { writable: !0, value: () => this.resume() }), Object.defineProperty(this, js, { writable: !0, value: () => { if (X(this, ii)[ii]) { X(this, kr)[kr] = setTimeout(X(this, js)[js], 0); return } X(this, Dt)[Dt] = this.limit, this.limit = Math.ceil((X(this, Ls)[Ls] + X(this, Dt)[Dt]) / 2); for (let t = X(this, Dt)[Dt]; t <= this.limit; t++)X(this, Dr)[Dr](); X(this, Ls)[Ls] - X(this, Dt)[Dt] > 3 ? X(this, kr)[kr] = setTimeout(X(this, js)[js], 2e3) : X(this, Dt)[Dt] = Math.floor(X(this, Dt)[Dt] / 2) } }), typeof e != "number" || e === 0 ? this.limit = 1 / 0 : this.limit = e } run(e, t) { return !X(this, ii)[ii] && X(this, ri)[ri] < this.limit ? X(this, Sa)[Sa](e) : X(this, lc)[lc](e, t) } wrapSyncFunction(e, t) { var r = this; return function () { for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++)o[a] = arguments[a]; let l = r.run(() => (e(...o), queueMicrotask(() => l.done()), () => { }), t); return { abortOn: Wy, abort() { l.abort() } } } } wrapPromiseFunction(e, t) { var r = this; return function () { for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++)o[a] = arguments[a]; let l, d = new Promise((p, h) => { l = r.run(() => { let m, y; try { y = Promise.resolve(e(...o)) } catch (b) { y = Promise.reject(b) } return y.then(b => { m ? h(m) : (l.done(), p(b)) }, b => { m ? h(m) : (l.done(), h(b)) }), b => { m = tP(b) } }, t) }); return d.abort = p => { l.abort(p) }, d.abortOn = Wy, d } } resume() { X(this, ii)[ii] = !1, clearTimeout(X(this, Bs)[Bs]); for (let e = 0; e < this.limit; e++)X(this, Dr)[Dr]() } pause(e) { e === void 0 && (e = null), X(this, ii)[ii] = !0, clearTimeout(X(this, Bs)[Bs]), e != null && (X(this, Bs)[Bs] = setTimeout(X(this, uc)[uc], e)) } rateLimit(e) { clearTimeout(X(this, kr)[kr]), this.pause(e), this.limit > 1 && Number.isFinite(this.limit) && (X(this, Ls)[Ls] = this.limit - 1, this.limit = X(this, Dt)[Dt], X(this, kr)[kr] = setTimeout(X(this, js)[js], e)) } get isPaused() { return X(this, ii)[ii] } }; n(Nt, "RateLimitedQueue"); function iP(i) { X(this, ri)[ri] += 1; let e = !1, t; try { t = i() } catch (r) { throw X(this, ri)[ri] -= 1, r } return { abort: r => { e || (e = !0, X(this, ri)[ri] -= 1, t(r), X(this, Dr)[Dr]()) }, done: () => { e || (e = !0, X(this, ri)[ri] -= 1, X(this, Dr)[Dr]()) } } } n(iP, "_call2"); function rP() { queueMicrotask(() => X(this, dc)[dc]()) } n(rP, "_queueNext2"); function sP() { if (X(this, ii)[ii] || X(this, ri)[ri] >= this.limit || X(this, It)[It].length === 0) return; let i = X(this, It)[It].shift(), e = X(this, Sa)[Sa](i.fn); i.abort = e.abort, i.done = e.done } n(sP, "_next2"); function oP(i, e) { e === void 0 && (e = {}); let t = { fn: i, priority: e.priority || 0, abort: () => { X(this, hc)[hc](t) }, done: () => { throw new Error("Cannot mark a queued request as done: this indicates a bug") } }, r = X(this, It)[It].findIndex(s => t.priority > s.priority); return r === -1 ? X(this, It)[It].push(t) : X(this, It)[It].splice(r, 0, t), t } n(oP, "_queue2"); function nP(i) { let e = X(this, It)[It].indexOf(i); e !== -1 && X(this, It)[It].splice(e, 1) } n(nP, "_dequeue2"); var us = Symbol("__queue"); function ds(i) { let e = n(t => "error" in t && t.error, "hasError"); return i.filter(t => !e(t)) } n(ds, "filterNonFailedFiles"); function hs(i) { return i.filter(e => !e.progress.uploadStarted || !e.isRestored) } n(hs, "filterFilesToEmitUploadStarted"); var { AbortController: Du } = globalThis, { AbortSignal: OD } = globalThis, cc = n(function (i, e) { i === void 0 && (i = "Aborted"); let t = new DOMException(i, "AbortError"); return e != null && Et(e, "cause") && Object.defineProperty(t, "cause", { __proto__: null, configurable: !0, writable: !0, value: e.cause }), t }, "createAbortError"); function z(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(z, "_classPrivateFieldLooseBase"); var aP = 0; function et(i) { return "__private_" + aP++ + "_" + i } n(et, "_classPrivateFieldLooseKey"); var lP = 1024 * 1024, Gy = { getChunkSize(i) { return Math.ceil(i.size / 1e4) }, onProgress() { }, onPartComplete() { }, onSuccess() { }, onError(i) { throw i } }; function uP(i) { if (typeof i == "string") return parseInt(i, 10); if (typeof i == "number") return i; throw new TypeError("Expected a number") } n(uP, "ensureInt"); var Ea = Symbol("pausing upload, not an actual error"), ht = et("abortController"), Ze = et("chunks"), Mt = et("chunkState"), si = et("data"), oi = et("file"), Ca = et("uploadHasStarted"), Pa = et("onError"), $s = et("onSuccess"), Ir = et("shouldUseMultipart"), Hs = et("isRestoring"), Aa = et("onReject"), zs = et("maxMultipartParts"), Fa = et("minPartSize"), pc = et("initChunks"), fc = et("createUpload"), _a = et("resumeUpload"), xa = et("onPartProgress"), Oa = et("onPartComplete"), mc = et("abortUpload"), Iu = class { constructor(e, t) { var r, s; Object.defineProperty(this, mc, { value: pP }), Object.defineProperty(this, _a, { value: cP }), Object.defineProperty(this, fc, { value: hP }), Object.defineProperty(this, pc, { value: dP }), Object.defineProperty(this, ht, { writable: !0, value: new Du }), Object.defineProperty(this, Ze, { writable: !0, value: void 0 }), Object.defineProperty(this, Mt, { writable: !0, value: void 0 }), Object.defineProperty(this, si, { writable: !0, value: void 0 }), Object.defineProperty(this, oi, { writable: !0, value: void 0 }), Object.defineProperty(this, Ca, { writable: !0, value: !1 }), Object.defineProperty(this, Pa, { writable: !0, value: void 0 }), Object.defineProperty(this, $s, { writable: !0, value: void 0 }), Object.defineProperty(this, Ir, { writable: !0, value: void 0 }), Object.defineProperty(this, Hs, { writable: !0, value: void 0 }), Object.defineProperty(this, Aa, { writable: !0, value: o => o?.cause === Ea ? null : z(this, Pa)[Pa](o) }), Object.defineProperty(this, zs, { writable: !0, value: 1e4 }), Object.defineProperty(this, Fa, { writable: !0, value: 5 * lP }), Object.defineProperty(this, xa, { writable: !0, value: o => a => { if (!a.lengthComputable) return; z(this, Mt)[Mt][o].uploaded = uP(a.loaded); let l = z(this, Mt)[Mt].reduce((d, p) => d + p.uploaded, 0); this.options.onProgress(l, z(this, si)[si].size) } }), Object.defineProperty(this, Oa, { writable: !0, value: o => a => { z(this, Ze)[Ze][o] = null, z(this, Mt)[Mt][o].etag = a, z(this, Mt)[Mt][o].done = !0; let l = { PartNumber: o + 1, ETag: a }; this.options.onPartComplete(l) } }), this.options = { ...Gy, ...t }, (s = (r = this.options).getChunkSize) != null || (r.getChunkSize = Gy.getChunkSize), z(this, si)[si] = e, z(this, oi)[oi] = t.file, z(this, $s)[$s] = this.options.onSuccess, z(this, Pa)[Pa] = this.options.onError, z(this, Ir)[Ir] = this.options.shouldUseMultipart, z(this, Hs)[Hs] = t.uploadId && t.key, z(this, pc)[pc]() } start() { z(this, Ca)[Ca] ? (z(this, ht)[ht].signal.aborted || z(this, ht)[ht].abort(Ea), z(this, ht)[ht] = new Du, z(this, _a)[_a]()) : z(this, Hs)[Hs] ? (this.options.companionComm.restoreUploadFile(z(this, oi)[oi], { uploadId: this.options.uploadId, key: this.options.key }), z(this, _a)[_a]()) : z(this, fc)[fc]() } pause() { z(this, ht)[ht].abort(Ea), z(this, ht)[ht] = new Du } abort(e) { var t; e === void 0 && (e = void 0), (t = e) != null && t.really ? z(this, mc)[mc]() : this.pause() } get chunkState() { return z(this, Mt)[Mt] } }; n(Iu, "MultipartUploader"); function dP() { let i = z(this, si)[si].size, e = typeof z(this, Ir)[Ir] == "function" ? z(this, Ir)[Ir](z(this, oi)[oi]) : !!z(this, Ir)[Ir]; if (e && i > z(this, Fa)[Fa]) { let t = Math.max(this.options.getChunkSize(z(this, si)[si]), z(this, Fa)[Fa]), r = Math.floor(i / t); r > z(this, zs)[zs] && (r = z(this, zs)[zs], t = i / z(this, zs)[zs]), z(this, Ze)[Ze] = Array(r); for (let s = 0, o = 0; s < i; s += t, o++) { let a = Math.min(i, s + t), l = n(() => { let d = s; return z(this, si)[si].slice(d, a) }, "getData"); if (z(this, Ze)[Ze][o] = { getData: l, onProgress: z(this, xa)[xa](o), onComplete: z(this, Oa)[Oa](o), shouldUseMultipart: e }, z(this, Hs)[Hs]) { let d = s + t > i ? i - s : t; z(this, Ze)[Ze][o].setAsUploaded = () => { z(this, Ze)[Ze][o] = null, z(this, Mt)[Mt][o].uploaded = d } } } } else z(this, Ze)[Ze] = [{ getData: () => z(this, si)[si], onProgress: z(this, xa)[xa](0), onComplete: z(this, Oa)[Oa](0), shouldUseMultipart: e }]; z(this, Mt)[Mt] = z(this, Ze)[Ze].map(() => ({ uploaded: 0 })) } n(dP, "_initChunks2"); function hP() { this.options.companionComm.uploadFile(z(this, oi)[oi], z(this, Ze)[Ze], z(this, ht)[ht].signal).then(z(this, $s)[$s], z(this, Aa)[Aa]), z(this, Ca)[Ca] = !0 } n(hP, "_createUpload2"); function cP() { this.options.companionComm.resumeUploadFile(z(this, oi)[oi], z(this, Ze)[Ze], z(this, ht)[ht].signal).then(z(this, $s)[$s], z(this, Aa)[Aa]) } n(cP, "_resumeUpload2"); function pP() { z(this, ht)[ht].abort(), this.options.companionComm.abortFileUpload(z(this, oi)[oi]).catch(i => this.options.log(i)) } n(pP, "_abortUpload2"); var Ky = Iu; function fP(i) {
        let { method: e = "PUT", CanonicalUri: t = "/", CanonicalQueryString: r = "", SignedHeaders: s, HashedPayload: o } = i, a = Object.keys(s).map(l => l.toLowerCase()).sort(); return [e, t, r, ...a.map(l => `${l}:${s[l]}`), "", a.join(";"), o].join(`
`)
    } n(fP, "createCanonicalRequest"); var gc = new TextEncoder, yc = { name: "HMAC", hash: "SHA-256" }; async function mP(i) { let { subtle: e } = globalThis.crypto; return e.digest(yc.hash, gc.encode(i)) } n(mP, "digest"); async function gP(i) { let { subtle: e } = globalThis.crypto; return e.importKey("raw", typeof i == "string" ? gc.encode(i) : i, yc, !1, ["sign"]) } n(gP, "generateHmacKey"); function Xy(i) { let e = new Uint8Array(i), t = ""; for (let r = 0; r < e.length; r++)t += e[r].toString(16).padStart(2, "0"); return t } n(Xy, "arrayBufferToHexString"); async function Ta(i, e) { let { subtle: t } = globalThis.crypto; return t.sign(yc, await gP(i), gc.encode(e)) } n(Ta, "hash"); async function vc(i) {
        let { accountKey: e, accountSecret: t, sessionToken: r, bucketName: s, Key: o, Region: a, expires: l, uploadId: d, partNumber: p } = i, h = "s3", m = `${s}.${h}.${a}.amazonaws.com`, y = `/${encodeURI(o)}`, b = "UNSIGNED-PAYLOAD", S = new Date().toISOString().replace(/[-:]|\.\d+/g, ""), O = S.slice(0, 8), F = `${O}/${a}/${h}/aws4_request`, x = new URL(`https://${m}${y}`); x.searchParams.set("X-Amz-Algorithm", "AWS4-HMAC-SHA256"), x.searchParams.set("X-Amz-Content-Sha256", b), x.searchParams.set("X-Amz-Credential", `${e}/${F}`), x.searchParams.set("X-Amz-Date", S), x.searchParams.set("X-Amz-Expires", l), x.searchParams.set("X-Amz-Security-Token", r), x.searchParams.set("X-Amz-SignedHeaders", "host"), p && x.searchParams.set("partNumber", p), d && x.searchParams.set("uploadId", d), x.searchParams.set("x-id", p && d ? "UploadPart" : "PutObject"); let U = fP({ CanonicalUri: y, CanonicalQueryString: x.search.slice(1), SignedHeaders: { host: m }, HashedPayload: b }), H = Xy(await mP(U)), W = ["AWS4-HMAC-SHA256", S, F, H].join(`
`), J = await Ta(`AWS4${t}`, O), L = await Ta(J, a), G = await Ta(L, h), ee = await Ta(G, "aws4_request"), be = Xy(await Ta(ee, W)); return x.searchParams.set("X-Amz-Signature", be), x
    } n(vc, "createSignedURL"); var Qy; function N(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(N, "_classPrivateFieldLooseBase"); var yP = 0; function Pe(i) { return "__private_" + yP++ + "_" + i } n(Pe, "_classPrivateFieldLooseKey"); var vP = { version: "3.7.0" }; function Vo(i) { if (i && i.error) { let e = new Error(i.message); throw Object.assign(e, i.error), e } return i } n(Vo, "assertServerError"); function Jy(i) { let e = i.Expiration; if (e) { let t = Math.floor((new Date(e) - Date.now()) / 1e3); if (t > 9) return t } } n(Jy, "getExpiry"); function Yy(i) { let { meta: e, allowedMetaFields: t, querify: r = !1 } = i, s = t ?? Object.keys(e); return e ? Object.fromEntries(s.filter(o => e[o] != null).map(o => { let a = r ? `metadata[${o}]` : o, l = String(e[o]); return [a, l] })) : {} } n(Yy, "getAllowedMetadata"); function _t(i) { if (i != null && i.aborted) throw cc("The operation was aborted", { cause: i.reason }) } n(_t, "throwIfAborted"); var Ra = Pe("abortMultipartUpload"), ct = Pe("cache"), Ua = Pe("createMultipartUpload"), ka = Pe("fetchSignature"), Ba = Pe("getUploadParameters"), Da = Pe("listParts"), Ks = Pe("previousRetryDelay"), Xs = Pe("requests"), qs = Pe("retryDelays"), Vs = Pe("sendCompletionRequest"), Ws = Pe("setS3MultipartState"), Ys = Pe("uploadPartBytes"), ft = Pe("getFile"), bc = Pe("shouldRetry"), Ia = Pe("nonMultipartUpload"), Nu = class { constructor(e, t, r, s) { Object.defineProperty(this, Ia, { value: wP }), Object.defineProperty(this, bc, { value: bP }), Object.defineProperty(this, Ra, { writable: !0, value: void 0 }), Object.defineProperty(this, ct, { writable: !0, value: new WeakMap }), Object.defineProperty(this, Ua, { writable: !0, value: void 0 }), Object.defineProperty(this, ka, { writable: !0, value: void 0 }), Object.defineProperty(this, Ba, { writable: !0, value: void 0 }), Object.defineProperty(this, Da, { writable: !0, value: void 0 }), Object.defineProperty(this, Ks, { writable: !0, value: void 0 }), Object.defineProperty(this, Xs, { writable: !0, value: void 0 }), Object.defineProperty(this, qs, { writable: !0, value: void 0 }), Object.defineProperty(this, Vs, { writable: !0, value: void 0 }), Object.defineProperty(this, Ws, { writable: !0, value: void 0 }), Object.defineProperty(this, Ys, { writable: !0, value: void 0 }), Object.defineProperty(this, ft, { writable: !0, value: void 0 }), N(this, Xs)[Xs] = e, N(this, Ws)[Ws] = r, N(this, ft)[ft] = s, this.setOptions(t) } setOptions(e) { let t = N(this, Xs)[Xs]; if ("abortMultipartUpload" in e && (N(this, Ra)[Ra] = t.wrapPromiseFunction(e.abortMultipartUpload, { priority: 1 })), "createMultipartUpload" in e && (N(this, Ua)[Ua] = t.wrapPromiseFunction(e.createMultipartUpload, { priority: -1 })), "signPart" in e && (N(this, ka)[ka] = t.wrapPromiseFunction(e.signPart)), "listParts" in e && (N(this, Da)[Da] = t.wrapPromiseFunction(e.listParts)), "completeMultipartUpload" in e && (N(this, Vs)[Vs] = t.wrapPromiseFunction(e.completeMultipartUpload, { priority: 1 })), "retryDelays" in e) { var r; N(this, qs)[qs] = (r = e.retryDelays) != null ? r : [] } "uploadPartBytes" in e && (N(this, Ys)[Ys] = t.wrapPromiseFunction(e.uploadPartBytes, { priority: 1 / 0 })), "getUploadParameters" in e && (N(this, Ba)[Ba] = t.wrapPromiseFunction(e.getUploadParameters)) } async getUploadId(e, t) { let r; for (; (r = N(this, ct)[ct].get(e.data)) != null;)try { return await r } catch { } let s = N(this, Ua)[Ua](N(this, ft)[ft](e), t), o = n(() => { s.abort(t.reason), N(this, ct)[ct].delete(e.data) }, "abortPromise"); return t.addEventListener("abort", o, { once: !0 }), N(this, ct)[ct].set(e.data, s), s.then(async a => { t.removeEventListener("abort", o), N(this, Ws)[Ws](e, a), N(this, ct)[ct].set(e.data, a) }, () => { t.removeEventListener("abort", o), N(this, ct)[ct].delete(e.data) }), s } async abortFileUpload(e) { let t = N(this, ct)[ct].get(e.data); if (t == null) return; N(this, ct)[ct].delete(e.data), N(this, Ws)[Ws](e, Object.create(null)); let r; try { r = await t } catch { return } await N(this, Ra)[Ra](N(this, ft)[ft](e), r) } async uploadFile(e, t, r) { if (_t(r), t.length === 1 && !t[0].shouldUseMultipart) return N(this, Ia)[Ia](e, t[0], r); let { uploadId: s, key: o } = await this.getUploadId(e, r); _t(r); try { let a = await Promise.all(t.map((l, d) => this.uploadChunk(e, d + 1, l, r))); return _t(r), await N(this, Vs)[Vs](N(this, ft)[ft](e), { key: o, uploadId: s, parts: a, signal: r }).abortOn(r) } catch (a) { throw a?.cause !== Ea && a?.name !== "AbortError" && this.abortFileUpload(e), a } } restoreUploadFile(e, t) { N(this, ct)[ct].set(e.data, t) } async resumeUploadFile(e, t, r) { if (_t(r), t.length === 1 && !t[0].shouldUseMultipart) return N(this, Ia)[Ia](e, t[0], r); let { uploadId: s, key: o } = await this.getUploadId(e, r); _t(r); let a = await N(this, Da)[Da](N(this, ft)[ft](e), { uploadId: s, key: o, signal: r }).abortOn(r); _t(r); let l = await Promise.all(t.map((d, p) => { let h = p + 1, m = a.find(y => { let { PartNumber: b } = y; return b === h }); return m == null ? this.uploadChunk(e, h, d, r) : (d == null || d.setAsUploaded == null || d.setAsUploaded(), { PartNumber: h, ETag: m.ETag }) })); return _t(r), N(this, Vs)[Vs](N(this, ft)[ft](e), { key: o, uploadId: s, parts: l, signal: r }).abortOn(r) } async uploadChunk(e, t, r, s) { _t(s); let { uploadId: o, key: a } = await this.getUploadId(e, s), l = N(this, qs)[qs].values(), d = N(this, qs)[qs].values(), p = n(() => { let h = l.next(); return h == null || h.done ? null : h.value }, "shouldRetrySignature"); for (; ;) { _t(s); let h = r.getData(), { onProgress: m, onComplete: y } = r, b; try { b = await N(this, ka)[ka](N(this, ft)[ft](e), { uploadId: o, key: a, partNumber: t, body: h, signal: s }).abortOn(s) } catch (S) { let O = p(); if (O == null || s.aborted) throw S; await new Promise(F => setTimeout(F, O)); continue } _t(s); try { return { PartNumber: t, ...await N(this, Ys)[Ys]({ signature: b, body: h, size: h.size, onProgress: m, onComplete: y, signal: s }).abortOn(s) } } catch (S) { if (!await N(this, bc)[bc](S, d)) throw S } } } }; n(Nu, "HTTPCommunicationQueue"); async function bP(i, e) { var t; let r = N(this, Xs)[Xs], s = i == null || (t = i.source) == null ? void 0 : t.status; if (s == null) return !1; if (s === 403 && i.message === "Request has expired") { if (!r.isPaused) { if (r.limit === 1 || N(this, Ks)[Ks] == null) { let o = e.next(); if (o == null || o.done) return !1; N(this, Ks)[Ks] = o.value } r.rateLimit(0), await new Promise(o => setTimeout(o, N(this, Ks)[Ks])) } } else if (s === 429) { if (!r.isPaused) { let o = e.next(); if (o == null || o.done) return !1; r.rateLimit(o.value) } } else { if (s > 400 && s < 500 && s !== 409) return !1; if (typeof navigator < "u" && navigator.onLine === !1) r.isPaused || (r.pause(), window.addEventListener("online", () => { r.resume() }, { once: !0 })); else { let o = e.next(); if (o == null || o.done) return !1; await new Promise(a => setTimeout(a, o.value)) } } return !0 } n(bP, "_shouldRetry2"); async function wP(i, e, t) { let { method: r = "POST", url: s, fields: o, headers: a } = await N(this, Ba)[Ba](N(this, ft)[ft](i), { signal: t }).abortOn(t), l, d = e.getData(); if (r.toUpperCase() === "POST") { let m = new FormData; Object.entries(o).forEach(y => { let [b, S] = y; return m.set(b, S) }), m.set("file", d), l = m } else l = d; let { onProgress: p, onComplete: h } = e; return N(this, Ys)[Ys]({ signature: { url: s, headers: a, method: r }, body: l, size: d.size, onProgress: p, onComplete: h, signal: t }).abortOn(t) } n(wP, "_nonMultipartUpload2"); var Qs = Pe("companionCommunicationQueue"), je = Pe("client"), pt = Pe("cachedTemporaryCredentials"), wc = Pe("getTemporarySecurityCredentials"), Sc = Pe("setS3MultipartState"), Js = Pe("getFile"), Pc = Pe("uploadLocalFile"), _c = Pe("getCompanionClientArgs"), Na = Pe("upload"), Gs = Pe("setCompanionHeaders"), Nr = Pe("setResumableUploadsCapability"), Ma = Pe("resetResumableCapability"); Qy = Symbol.for("uppy test: getClient"); var Ci = class extends Se { constructor(e, t) { var r; super(e, t), Object.defineProperty(this, _c, { value: _P }), Object.defineProperty(this, Pc, { value: PP }), Object.defineProperty(this, wc, { value: SP }), Object.defineProperty(this, Qs, { writable: !0, value: void 0 }), Object.defineProperty(this, je, { writable: !0, value: void 0 }), Object.defineProperty(this, pt, { writable: !0, value: void 0 }), Object.defineProperty(this, Sc, { writable: !0, value: (o, a) => { let { key: l, uploadId: d } = a, p = this.uppy.getFile(o.id); p != null && this.uppy.setFileState(o.id, { s3Multipart: { ...p.s3Multipart, key: l, uploadId: d } }) } }), Object.defineProperty(this, Js, { writable: !0, value: o => this.uppy.getFile(o.id) || o }), Object.defineProperty(this, Na, { writable: !0, value: async o => { if (o.length === 0) return; let a = this.uppy.getFilesByIds(o), l = ds(a), d = hs(l); this.uppy.emit("upload-start", d); let p = l.map(m => { if (m.isRemote) { let y = m.remote.providerOptions.provider ? ne : xe, b = n(() => this.requests, "getQueue"), S = new y(this.uppy, m.remote.providerOptions, b); N(this, Nr)[Nr](!1); let O = new AbortController, F = n(U => { U.id === m.id && O.abort() }, "removedHandler"); this.uppy.on("file-removed", F); let x = S.uploadRemoteFile(m, N(this, _c)[_c](m), { signal: O.signal }); return this.requests.wrapSyncFunction(() => { this.uppy.off("file-removed", F) }, { priority: -1 })(), x } return N(this, Pc)[Pc](m) }), h = await Promise.all(p); return N(this, Nr)[Nr](!0), h } }), Object.defineProperty(this, Gs, { writable: !0, value: () => { N(this, je)[je].setCompanionHeaders(this.opts.companionHeaders) } }), Object.defineProperty(this, Nr, { writable: !0, value: o => { let { capabilities: a } = this.uppy.getState(); this.uppy.setState({ capabilities: { ...a, resumableUploads: o } }) } }), Object.defineProperty(this, Ma, { writable: !0, value: () => { N(this, Nr)[Nr](!0) } }), this.type = "uploader", this.id = this.opts.id || "AwsS3Multipart", this.title = "AWS S3 Multipart", N(this, je)[je] = new xe(e, t); let s = { allowedMetaFields: null, limit: 6, shouldUseMultipart: o => o.size !== 0, retryDelays: [0, 1e3, 3e3, 5e3], createMultipartUpload: this.createMultipartUpload.bind(this), listParts: this.listParts.bind(this), abortMultipartUpload: this.abortMultipartUpload.bind(this), completeMultipartUpload: this.completeMultipartUpload.bind(this), getTemporarySecurityCredentials: !1, signPart: t != null && t.getTemporarySecurityCredentials ? this.createSignedURL.bind(this) : this.signPart.bind(this), uploadPartBytes: Ci.uploadPartBytes, getUploadParameters: t != null && t.getTemporarySecurityCredentials ? this.createSignedURL.bind(this) : this.getUploadParameters.bind(this), companionHeaders: {} }; this.opts = { ...s, ...t }, t?.prepareUploadParts != null && t.signPart == null && (this.opts.signPart = async (o, a) => { let { uploadId: l, key: d, partNumber: p, body: h, signal: m } = a, { presignedUrls: y, headers: b } = await t.prepareUploadParts(o, { uploadId: l, key: d, parts: [{ number: p, chunk: h }], signal: m }); return { url: y?.[p], headers: b?.[p] } }), this.requests = (r = this.opts.rateLimitedQueue) != null ? r : new Nt(this.opts.limit), N(this, Qs)[Qs] = new Nu(this.requests, this.opts, N(this, Sc)[Sc], N(this, Js)[Js]), this.uploaders = Object.create(null), this.uploaderEvents = Object.create(null), this.uploaderSockets = Object.create(null) } [Qy]() { return N(this, je)[je] } setOptions(e) { N(this, Qs)[Qs].setOptions(e), super.setOptions(e), N(this, Gs)[Gs]() } resetUploaderReferences(e, t) { t === void 0 && (t = {}), this.uploaders[e] && (this.uploaders[e].abort({ really: t.abort || !1 }), this.uploaders[e] = null), this.uploaderEvents[e] && (this.uploaderEvents[e].remove(), this.uploaderEvents[e] = null), this.uploaderSockets[e] && (this.uploaderSockets[e].close(), this.uploaderSockets[e] = null) } assertHost(e) { if (!this.opts.companionUrl) throw new Error(`Expected a \`companionUrl\` option containing a Companion address, or if you are not using Companion, a custom \`${e}\` implementation.`) } createMultipartUpload(e, t) { this.assertHost("createMultipartUpload"), _t(t); let r = Yy({ meta: e.meta, allowedMetaFields: this.opts.allowedMetaFields }); return N(this, je)[je].post("s3/multipart", { filename: e.name, type: e.type, metadata: r }, { signal: t }).then(Vo) } listParts(e, t, r) { let { key: s, uploadId: o } = t; this.assertHost("listParts"), _t(r); let a = encodeURIComponent(s); return N(this, je)[je].get(`s3/multipart/${o}?key=${a}`, { signal: r }).then(Vo) } completeMultipartUpload(e, t, r) { let { key: s, uploadId: o, parts: a } = t; this.assertHost("completeMultipartUpload"), _t(r); let l = encodeURIComponent(s), d = encodeURIComponent(o); return N(this, je)[je].post(`s3/multipart/${d}/complete?key=${l}`, { parts: a }, { signal: r }).then(Vo) } async createSignedURL(e, t) { let r = await N(this, wc)[wc](t), s = Jy(r.credentials) || 604800, { uploadId: o, key: a, partNumber: l, signal: d } = t; return { method: "PUT", expires: s, fields: {}, url: `${await vc({ accountKey: r.credentials.AccessKeyId, accountSecret: r.credentials.SecretAccessKey, sessionToken: r.credentials.SessionToken, expires: s, bucketName: r.bucket, Region: r.region, Key: a ?? `${crypto.randomUUID()}-${e.name}`, uploadId: o, partNumber: l, signal: d })}`, headers: { "Content-Type": e.type } } } signPart(e, t) { let { uploadId: r, key: s, partNumber: o, signal: a } = t; if (this.assertHost("signPart"), _t(a), r == null || s == null || o == null) throw new Error("Cannot sign without a key, an uploadId, and a partNumber"); let l = encodeURIComponent(s); return N(this, je)[je].get(`s3/multipart/${r}/${o}?key=${l}`, { signal: a }).then(Vo) } abortMultipartUpload(e, t, r) { let { key: s, uploadId: o } = t; this.assertHost("abortMultipartUpload"); let a = encodeURIComponent(s), l = encodeURIComponent(o); return N(this, je)[je].delete(`s3/multipart/${l}?key=${a}`, void 0, { signal: r }).then(Vo) } getUploadParameters(e, t) { let { meta: r } = e, { type: s, name: o } = r, a = Yy({ meta: r, allowedMetaFields: this.opts.allowedMetaFields, querify: !0 }), l = new URLSearchParams({ filename: o, type: s, ...a }); return N(this, je)[je].get(`s3/params?${l}`, t) } static async uploadPartBytes(e) { let { signature: { url: t, expires: r, headers: s, method: o = "PUT" }, body: a, size: l = a.size, onProgress: d, onComplete: p, signal: h } = e; if (_t(h), t == null) throw new Error("Cannot upload to an undefined URL"); return new Promise((m, y) => { let b = new XMLHttpRequest; b.open(o, t, !0), s && Object.keys(s).forEach(F => { b.setRequestHeader(F, s[F]) }), b.responseType = "text", typeof r == "number" && (b.timeout = r * 1e3); function S() { b.abort() } n(S, "onabort"); function O() { h.removeEventListener("abort", S) } n(O, "cleanup"), h.addEventListener("abort", S), b.upload.addEventListener("progress", F => { d(F) }), b.addEventListener("abort", () => { O(), y(cc()) }), b.addEventListener("timeout", () => { O(); let F = new Error("Request has expired"); F.source = { status: 403 }, y(F) }), b.addEventListener("load", F => { if (O(), F.target.status === 403 && F.target.responseText.includes("<Message>Request has expired</Message>")) { let H = new Error("Request has expired"); H.source = F.target, y(H); return } if (F.target.status < 200 || F.target.status >= 300) { let H = new Error("Non 2xx"); H.source = F.target, y(H); return } d?.({ loaded: l, lengthComputable: !0 }); let x = F.target.getResponseHeader("ETag"), U = F.target.getResponseHeader("Location"); if (o.toUpperCase() === "POST" && U === null && console.warn("AwsS3/Multipart: Could not read the Location header. This likely means CORS is not configured correctly on the S3 Bucket. See https://uppy.io/docs/aws-s3-multipart#S3-Bucket-Configuration for instructions."), x === null) { y(new Error("AwsS3/Multipart: Could not read the ETag header. This likely means CORS is not configured correctly on the S3 Bucket. See https://uppy.io/docs/aws-s3-multipart#S3-Bucket-Configuration for instructions.")); return } p?.(x), m({ ETag: x, ...U ? { location: U } : void 0 }) }), b.addEventListener("error", F => { O(); let x = new Error("Unknown error"); x.source = F.target, y(x) }), b.send(a) }) } install() { N(this, Nr)[Nr](!0), this.uppy.addPreProcessor(N(this, Gs)[Gs]), this.uppy.addUploader(N(this, Na)[Na]), this.uppy.on("cancel-all", N(this, Ma)[Ma]) } uninstall() { this.uppy.removePreProcessor(N(this, Gs)[Gs]), this.uppy.removeUploader(N(this, Na)[Na]), this.uppy.off("cancel-all", N(this, Ma)[Ma]) } }; n(Ci, "AwsS3Multipart"); async function SP(i) { return _t(i?.signal), N(this, pt)[pt] == null && (this.opts.getTemporarySecurityCredentials === !0 ? (this.assertHost("getTemporarySecurityCredentials"), N(this, pt)[pt] = N(this, je)[je].get("s3/sts", null, i).then(Vo)) : N(this, pt)[pt] = this.opts.getTemporarySecurityCredentials(i), N(this, pt)[pt] = await N(this, pt)[pt], setTimeout(() => { N(this, pt)[pt] = null }, (Jy(N(this, pt)[pt].credentials) || 0) * 500)), N(this, pt)[pt] } n(SP, "_getTemporarySecurityCredentials2"); function PP(i) { var e = this; return new Promise((t, r) => { let s = n((h, m) => { this.uppy.emit("upload-progress", i, { uploader: this, bytesUploaded: h, bytesTotal: m }) }, "onProgress"), o = n(h => { this.uppy.log(h), this.uppy.emit("upload-error", i, h), this.resetUploaderReferences(i.id), r(h) }, "onError"), a = n(h => { let m = { body: { ...h }, uploadURL: h.location }; this.resetUploaderReferences(i.id), this.uppy.emit("upload-success", N(this, Js)[Js](i), m), h.location && this.uppy.log(`Download ${i.name} from ${h.location}`), t() }, "onSuccess"), l = n(h => { this.uppy.emit("s3-multipart:part-uploaded", N(this, Js)[Js](i), h) }, "onPartComplete"), d = new Ky(i.data, { companionComm: N(this, Qs)[Qs], log: function () { return e.uppy.log(...arguments) }, getChunkSize: this.opts.getChunkSize ? this.opts.getChunkSize.bind(this) : null, onProgress: s, onError: o, onSuccess: a, onPartComplete: l, file: i, shouldUseMultipart: this.opts.shouldUseMultipart, ...i.s3Multipart }); this.uploaders[i.id] = d; let p = new $t(this.uppy); this.uploaderEvents[i.id] = p, p.onFileRemove(i.id, h => { d.abort(), this.resetUploaderReferences(i.id, { abort: !0 }), t(`upload ${h.id} was removed`) }), p.onCancelAll(i.id, function (h) { let { reason: m } = h === void 0 ? {} : h; m === "user" && (d.abort(), e.resetUploaderReferences(i.id, { abort: !0 })), t(`upload ${i.id} was canceled`) }), p.onFilePause(i.id, h => { h ? d.pause() : d.start() }), p.onPauseAll(i.id, () => { d.pause() }), p.onResumeAll(i.id, () => { d.start() }), d.start() }) } n(PP, "_uploadLocalFile2"); function _P(i) { return { ...i.remote.body, protocol: "s3-multipart", size: i.data.size, metadata: i.meta } } n(_P, "_getCompanionClientArgs2"); Ci.VERSION = vP.version; function fi(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(fi, "_classPrivateFieldLooseBase"); var FP = 0; function Bu(i) { return "__private_" + FP++ + "_" + i } n(Bu, "_classPrivateFieldLooseKey"); var Mr = Bu("aliveTimer"), Zs = Bu("isDone"), La = Bu("onTimedOut"), eo = Bu("timeout"), Mu = class { constructor(e, t) { Object.defineProperty(this, Mr, { writable: !0, value: void 0 }), Object.defineProperty(this, Zs, { writable: !0, value: !1 }), Object.defineProperty(this, La, { writable: !0, value: void 0 }), Object.defineProperty(this, eo, { writable: !0, value: void 0 }), fi(this, eo)[eo] = e, fi(this, La)[La] = t } progress() { fi(this, Zs)[Zs] || fi(this, eo)[eo] > 0 && (clearTimeout(fi(this, Mr)[Mr]), fi(this, Mr)[Mr] = setTimeout(fi(this, La)[La], fi(this, eo)[eo])) } done() { fi(this, Zs)[Zs] || (clearTimeout(fi(this, Mr)[Mr]), fi(this, Mr)[Mr] = null, fi(this, Zs)[Zs] = !0) } }; n(Mu, "ProgressTimeout"); var ja = Mu; function xP(i) { return i ? i.readyState !== 0 && i.readyState !== 4 || i.status === 0 : !1 } n(xP, "isNetworkError"); var to = xP; function Zy(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Zy, "_classPrivateFieldLooseBase"); var OP = 0; function tv(i) { return "__private_" + OP++ + "_" + i } n(tv, "_classPrivateFieldLooseKey"); function ev(i, e) { if (to(i)) return new wi(e, i); let t = new gr("Upload error", { cause: e }); return t.request = i, t } n(ev, "buildResponseError"); function EP(i) { return i.data.slice(0, i.data.size, i.meta.type) } n(EP, "setTypeInBlob"); function CP(i, e, t) { (Array.isArray(t.allowedMetaFields) ? t.allowedMetaFields : Object.keys(e)).forEach(s => { i.append(s, e[s]) }) } n(CP, "addMetadata"); function AP(i, e) { let t = new FormData; CP(t, i.meta, e); let r = EP(i); return i.name ? t.append(e.fieldName, r, i.meta.name) : t.append(e.fieldName, r), t } n(AP, "createFormDataUpload"); var TP = n(i => i.data, "createBareUpload"), Fc = tv("addEventHandlerForFile"), xc = tv("addEventHandlerIfFileStillExists"), Wo = class { constructor(e, t) { Object.defineProperty(this, xc, { value: UP }), Object.defineProperty(this, Fc, { value: RP }), this.uppy = e, this.opts = { validateStatus(r) { return r >= 200 && r < 300 }, ...t }, this.requests = t[us], this.uploaderEvents = Object.create(null), this.i18n = t.i18n } getOptions(e) { var t; let { uppy: r } = this, s = r.getState().xhrUpload; return { ...this.opts, ...s || {}, ...e.xhrUpload || {}, headers: { ...this.opts.headers, ...s?.headers, ...(t = e.xhrUpload) == null ? void 0 : t.headers } } } uploadLocalFile(e) { let t = this.getOptions(e); return new Promise((r, s) => { let o = t.formData ? AP(e, t) : TP(e, t), a = new XMLHttpRequest; this.uploaderEvents[e.id] = new $t(this.uppy); let l = new ja(t.timeout, () => { a.abort(), p.done(); let h = new Error(this.i18n("timedOut", { seconds: Math.ceil(t.timeout / 1e3) })); this.uppy.emit("upload-error", e, h), s(h) }), d = St(); a.upload.addEventListener("loadstart", () => { this.uppy.log(`[AwsS3/XHRUpload] ${d} started`) }), a.upload.addEventListener("progress", h => { this.uppy.log(`[AwsS3/XHRUpload] ${d} progress: ${h.loaded} / ${h.total}`), l.progress(), h.lengthComputable && this.uppy.emit("upload-progress", e, { uploader: this, bytesUploaded: h.loaded, bytesTotal: h.total }) }), a.addEventListener("load", h => { if (this.uppy.log(`[AwsS3/XHRUpload] ${d} finished`), l.done(), p.done(), this.uploaderEvents[e.id] && (this.uploaderEvents[e.id].remove(), this.uploaderEvents[e.id] = null), t.validateStatus(h.target.status, a.responseText, a)) { let S = t.getResponseData(a.responseText, a), O = S[t.responseUrlFieldName], F = { status: h.target.status, body: S, uploadURL: O }; return this.uppy.emit("upload-success", e, F), O && this.uppy.log(`Download ${e.name} from ${O}`), r(e) } let m = t.getResponseData(a.responseText, a), y = ev(a, t.getResponseError(a.responseText, a)), b = { status: h.target.status, body: m }; return this.uppy.emit("upload-error", e, y, b), s(y) }), a.addEventListener("error", () => { this.uppy.log(`[AwsS3/XHRUpload] ${d} errored`), l.done(), p.done(), this.uploaderEvents[e.id] && (this.uploaderEvents[e.id].remove(), this.uploaderEvents[e.id] = null); let h = ev(a, t.getResponseError(a.responseText, a)); return this.uppy.emit("upload-error", e, h), s(h) }), a.open(t.method.toUpperCase(), t.endpoint, !0), a.withCredentials = !!t.withCredentials, t.responseType !== "" && (a.responseType = t.responseType), Object.keys(t.headers).forEach(h => { a.setRequestHeader(h, t.headers[h]) }); let p = this.requests.run(() => (a.send(o), () => { l.done(), a.abort() }), { priority: 1 }); Zy(this, Fc)[Fc]("file-removed", e.id, () => { p.abort(), s(new Error("File removed")) }), Zy(this, xc)[xc]("cancel-all", e.id, function (h) { let { reason: m } = h === void 0 ? {} : h; m === "user" && p.abort(), s(new Error("Upload cancelled")) }) }) } }; n(Wo, "MiniXHRUpload"); function RP(i, e, t) { this.uploaderEvents[e].on(i, r => { var s; let o = (s = r?.id) != null ? s : r; e === o && t() }) } n(RP, "_addEventHandlerForFile2"); function UP(i, e, t) { var r = this; this.uploaderEvents[e].on(i, function () { r.uppy.getFile(e) && t(...arguments) }) } n(UP, "_addEventHandlerIfFileStillExists2"); function kP(i) { return i.replace(/;.*$/, "") } n(kP, "removeMimeParameters"); function DP(i, e) { let t = e.headers ? e.headers["content-type"] : e.getResponseHeader("Content-Type"); if (typeof t == "string") { let r = kP(t).toLowerCase(); if (r === "application/xml" || r === "text/xml" || r === "text/html" && /^<\?xml /.test(i)) return !0 } return !1 } n(DP, "isXml"); var Oc = DP; var iv = { strings: { timedOut: "Upload stalled for %{seconds} seconds, aborting." } }; var sv; function tt(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(tt, "_classPrivateFieldLooseBase"); var IP = 0; function Go(i) { return "__private_" + IP++ + "_" + i } n(Go, "_classPrivateFieldLooseKey"); var NP = { version: "3.3.1" }; function MP(i, e) { return !i && !e.startsWith("https://") && !e.startsWith("http://") && (e = `https://${e}`), new URL(e, i || void 0).toString() } n(MP, "resolveUrl"); function $a(i, e) { let t = i.indexOf(`<${e}>`), r = i.indexOf(`</${e}>`, t); return t !== -1 && r !== -1 ? i.slice(t + e.length + 2, r) : "" } n($a, "getXmlValue"); function BP(i) { if (i && i.error) { let e = new Error(i.message); throw Object.assign(e, i.error), e } return i } n(BP, "assertServerError"); function LP(i, e) {
        if (!(e != null && typeof e.url == "string" && (typeof e.fields == "object" || e.fields == null))) throw new TypeError(`AwsS3: got incorrect result from 'getUploadParameters()' for file '${i.name}', expected an object '{ url, method, fields, headers }' but got '${JSON.stringify(e)}' instead.
See https://uppy.io/docs/aws-s3/#getUploadParameters-file for more on the expected format.`); if (!(e.method == null || /^p(u|os)t$/i.test(e.method))) throw new TypeError(`AwsS3: got incorrect method from 'getUploadParameters()' for file '${i.name}', expected  'PUT' or 'POST' but got '${e.method}' instead.
See https://uppy.io/docs/aws-s3/#getUploadParameters-file for more on the expected format.`)
    } n(LP, "validateParameters"); function jP(i, e) { if (!Oc(i, e)) return; let t = $a(i, "Message"); return new Error(t) } n(jP, "defaultGetResponseError"); var rv = !1, ni = Go("client"), Ai = Go("requests"), io = Go("uploader"), za = Go("handleUpload"), Ha = Go("setCompanionHeaders"), Ec = Go("getCompanionClientArgs"); sv = Symbol.for("uppy test: getClient"); var ro = class extends Se { constructor(e, t) { if (t?.shouldUseMultipart != null) return new Ci(e, t); super(e, t), Object.defineProperty(this, ni, { writable: !0, value: void 0 }), Object.defineProperty(this, Ai, { writable: !0, value: void 0 }), Object.defineProperty(this, io, { writable: !0, value: void 0 }), Object.defineProperty(this, za, { writable: !0, value: async s => { let o = Object.create(null); function a(y) { var b; let { id: S } = y; (b = o[S]) == null || b.abort() } n(a, "onremove"), this.uppy.on("file-removed", a); let l = this.uppy.getFilesByIds(s), d = ds(l), p = hs(d); this.uppy.emit("upload-start", p); let h = tt(this, Ai)[Ai].wrapPromiseFunction(y => this.opts.getUploadParameters(y)), m = s.length; return Promise.allSettled(s.map((y, b) => (o[y] = h(this.uppy.getFile(y)), o[y].then(S => { delete o[y]; let O = this.uppy.getFile(y); LP(O, S); let { method: F = "POST", url: x, fields: U, headers: H } = S, W = { method: F, formData: F.toUpperCase() === "POST", endpoint: x, allowedMetaFields: U ? Object.keys(U) : [] }; return H && (W.headers = H), this.uppy.setFileState(O.id, { meta: { ...O.meta, ...U }, xhrUpload: W }), this.uploadFile(O.id, b, m) }).catch(S => { delete o[y]; let O = this.uppy.getFile(y); return this.uppy.emit("upload-error", O, S), Promise.reject(S) })))).finally(() => { this.uppy.off("file-removed", a) }) } }), Object.defineProperty(this, Ha, { writable: !0, value: () => (tt(this, ni)[ni].setCompanionHeaders(this.opts.companionHeaders), Promise.resolve()) }), Object.defineProperty(this, Ec, { writable: !0, value: s => { let o = tt(this, io)[io].getOptions(s), a = Array.isArray(o.allowedMetaFields) ? o.allowedMetaFields : Object.keys(s.meta); return { ...s.remote.body, protocol: "multipart", endpoint: o.endpoint, size: s.data.size, fieldname: o.fieldName, metadata: Object.fromEntries(a.map(l => [l, s.meta[l]])), httpMethod: o.method, useFormData: o.formData, headers: typeof o.headers == "function" ? o.headers(s) : o.headers } } }), this.type = "uploader", this.id = this.opts.id || "AwsS3", this.title = "AWS S3", this.defaultLocale = iv; let r = { timeout: 30 * 1e3, limit: 0, allowedMetaFields: [], getUploadParameters: this.getUploadParameters.bind(this), shouldUseMultipart: !1, companionHeaders: {} }; if (this.opts = { ...r, ...t }, t?.allowedMetaFields === void 0 && "metaFields" in this.opts) throw new Error("The `metaFields` option has been renamed to `allowedMetaFields`."); this.i18nInit(), tt(this, ni)[ni] = new xe(e, t), tt(this, Ai)[Ai] = new Nt(this.opts.limit) } [sv]() { return tt(this, ni)[ni] } get client() { return tt(this, ni)[ni] } set client(e) { tt(this, ni)[ni] = e } getUploadParameters(e) { if (!this.opts.companionUrl) throw new Error("Expected a `companionUrl` option containing a Companion address."); let t = e.meta.name, { type: r } = e.meta, s = Object.fromEntries(this.opts.allowedMetaFields.filter(a => e.meta[a] != null).map(a => [`metadata[${a}]`, e.meta[a].toString()])), o = new URLSearchParams({ filename: t, type: r, ...s }); return tt(this, ni)[ni].get(`s3/params?${o}`).then(BP) } uploadFile(e, t, r) { let s = this.uppy.getFile(e); if (this.uppy.log(`uploading ${t} of ${r}`), s.error) throw new Error(s.error); if (s.isRemote) { let o = s.remote.providerOptions.provider ? ne : xe, a = n(() => tt(this, Ai)[Ai], "getQueue"), l = new o(this.uppy, s.remote.providerOptions, a), d = new AbortController, p = n(m => { m.id === s.id && d.abort() }, "removedHandler"); this.uppy.on("file-removed", p); let h = l.uploadRemoteFile(s, tt(this, Ec)[Ec](s), { signal: d.signal }); return tt(this, Ai)[Ai].wrapSyncFunction(() => { this.uppy.off("file-removed", p) }, { priority: -1 })(), h } return tt(this, io)[io].uploadLocalFile(s, t, r) } install() { let { uppy: e } = this; e.addPreProcessor(tt(this, Ha)[Ha]), e.addUploader(tt(this, za)[za]); function t(s, o) { let a = this; return Oc(s, o) ? { location: MP(o.responseURL, $a(s, "Location")), bucket: $a(s, "Bucket"), key: $a(s, "Key"), etag: $a(s, "ETag") } : a.method.toUpperCase() === "POST" ? (rv || (e.log("[AwsS3] No response data found, make sure to set the success_action_status AWS SDK option to 201. See https://uppy.io/docs/aws-s3/#POST-Uploads", "warning"), rv = !0), { location: null }) : o.responseURL ? { location: o.responseURL.replace(/\?.*$/, "") } : { location: null } } n(t, "defaultGetResponseData"); let r = { fieldName: "file", responseUrlFieldName: "location", timeout: this.opts.timeout, [us]: tt(this, Ai)[Ai], responseType: "text", getResponseData: this.opts.getResponseData || t, getResponseError: jP }; r.i18n = this.i18n, tt(this, io)[io] = new Wo(e, r) } uninstall() { this.uppy.removePreProcessor(tt(this, Ha)[Ha]), this.uppy.removeUploader(tt(this, za)[za]) } }; n(ro, "AwsS3"); ro.VERSION = NP.version; var dv = "3.7.2", zP = dv, HP = typeof atob == "function", $P = typeof btoa == "function", Xo = typeof Buffer == "function", ov = typeof TextDecoder == "function" ? new TextDecoder : void 0, nv = typeof TextEncoder == "function" ? new TextEncoder : void 0, qP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", qa = Array.prototype.slice.call(qP), Lu = (i => { let e = {}; return i.forEach((t, r) => e[t] = r), e })(qa), VP = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, mt = String.fromCharCode.bind(String), av = typeof Uint8Array.from == "function" ? Uint8Array.from.bind(Uint8Array) : (i, e = t => t) => new Uint8Array(Array.prototype.slice.call(i, 0).map(e)), hv = n(i => i.replace(/=/g, "").replace(/[+\/]/g, e => e == "+" ? "-" : "_"), "_mkUriSafe"), cv = n(i => i.replace(/[^A-Za-z0-9\+\/]/g, ""), "_tidyB64"), pv = n(i => { let e, t, r, s, o = "", a = i.length % 3; for (let l = 0; l < i.length;) { if ((t = i.charCodeAt(l++)) > 255 || (r = i.charCodeAt(l++)) > 255 || (s = i.charCodeAt(l++)) > 255) throw new TypeError("invalid character found"); e = t << 16 | r << 8 | s, o += qa[e >> 18 & 63] + qa[e >> 12 & 63] + qa[e >> 6 & 63] + qa[e & 63] } return a ? o.slice(0, a - 3) + "===".substring(a) : o }, "btoaPolyfill"), Tc = $P ? i => btoa(i) : Xo ? i => Buffer.from(i, "binary").toString("base64") : pv, Cc = Xo ? i => Buffer.from(i).toString("base64") : i => { let t = []; for (let r = 0, s = i.length; r < s; r += 4096)t.push(mt.apply(null, i.subarray(r, r + 4096))); return Tc(t.join("")) }, ju = n((i, e = !1) => e ? hv(Cc(i)) : Cc(i), "fromUint8Array"), WP = n(i => { if (i.length < 2) { var e = i.charCodeAt(0); return e < 128 ? i : e < 2048 ? mt(192 | e >>> 6) + mt(128 | e & 63) : mt(224 | e >>> 12 & 15) + mt(128 | e >>> 6 & 63) + mt(128 | e & 63) } else { var e = 65536 + (i.charCodeAt(0) - 55296) * 1024 + (i.charCodeAt(1) - 56320); return mt(240 | e >>> 18 & 7) + mt(128 | e >>> 12 & 63) + mt(128 | e >>> 6 & 63) + mt(128 | e & 63) } }, "cb_utob"), GP = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, fv = n(i => i.replace(GP, WP), "utob"), lv = Xo ? i => Buffer.from(i, "utf8").toString("base64") : nv ? i => Cc(nv.encode(i)) : i => Tc(fv(i)), Ko = n((i, e = !1) => e ? hv(lv(i)) : lv(i), "encode"), uv = n(i => Ko(i, !0), "encodeURI"), KP = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, XP = n(i => { switch (i.length) { case 4: var e = (7 & i.charCodeAt(0)) << 18 | (63 & i.charCodeAt(1)) << 12 | (63 & i.charCodeAt(2)) << 6 | 63 & i.charCodeAt(3), t = e - 65536; return mt((t >>> 10) + 55296) + mt((t & 1023) + 56320); case 3: return mt((15 & i.charCodeAt(0)) << 12 | (63 & i.charCodeAt(1)) << 6 | 63 & i.charCodeAt(2)); default: return mt((31 & i.charCodeAt(0)) << 6 | 63 & i.charCodeAt(1)) } }, "cb_btou"), mv = n(i => i.replace(KP, XP), "btou"), gv = n(i => { if (i = i.replace(/\s+/g, ""), !VP.test(i)) throw new TypeError("malformed base64."); i += "==".slice(2 - (i.length & 3)); let e, t = "", r, s; for (let o = 0; o < i.length;)e = Lu[i.charAt(o++)] << 18 | Lu[i.charAt(o++)] << 12 | (r = Lu[i.charAt(o++)]) << 6 | (s = Lu[i.charAt(o++)]), t += r === 64 ? mt(e >> 16 & 255) : s === 64 ? mt(e >> 16 & 255, e >> 8 & 255) : mt(e >> 16 & 255, e >> 8 & 255, e & 255); return t }, "atobPolyfill"), Rc = HP ? i => atob(cv(i)) : Xo ? i => Buffer.from(i, "base64").toString("binary") : gv, yv = Xo ? i => av(Buffer.from(i, "base64")) : i => av(Rc(i), e => e.charCodeAt(0)), vv = n(i => yv(bv(i)), "toUint8Array"), YP = Xo ? i => Buffer.from(i, "base64").toString("utf8") : ov ? i => ov.decode(yv(i)) : i => mv(Rc(i)), bv = n(i => cv(i.replace(/[-_]/g, e => e == "-" ? "+" : "/")), "_unURI"), Ac = n(i => YP(bv(i)), "decode"), QP = n(i => { if (typeof i != "string") return !1; let e = i.replace(/\s+/g, "").replace(/={0,2}$/, ""); return !/[^\s0-9a-zA-Z\+/]/.test(e) || !/[^\s0-9a-zA-Z\-_]/.test(e) }, "isValid"), wv = n(i => ({ value: i, enumerable: !1, writable: !0, configurable: !0 }), "_noEnum"), Sv = n(function () { let i = n((e, t) => Object.defineProperty(String.prototype, e, wv(t)), "_add"); i("fromBase64", function () { return Ac(this) }), i("toBase64", function (e) { return Ko(this, e) }), i("toBase64URI", function () { return Ko(this, !0) }), i("toBase64URL", function () { return Ko(this, !0) }), i("toUint8Array", function () { return vv(this) }) }, "extendString"), Pv = n(function () { let i = n((e, t) => Object.defineProperty(Uint8Array.prototype, e, wv(t)), "_add"); i("toBase64", function (e) { return ju(this, e) }), i("toBase64URI", function () { return ju(this, !0) }), i("toBase64URL", function () { return ju(this, !0) }) }, "extendUint8Array"), JP = n(() => { Sv(), Pv() }, "extendBuiltins"), _v = { version: dv, VERSION: zP, atob: Rc, atobPolyfill: gv, btoa: Tc, btoaPolyfill: pv, fromBase64: Ac, toBase64: Ko, encode: Ko, encodeURI: uv, encodeURL: uv, utob: fv, btou: mv, decode: Ac, isValid: QP, fromUint8Array: ju, toUint8Array: vv, extendString: Sv, extendUint8Array: Pv, extendBuiltins: JP }; var Kv = de(Nv()); function Ic(i) { "@babel/helpers - typeof"; return Ic = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Ic(i) } n(Ic, "_typeof"); function Mv(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(Mv, "_defineProperties"); function d_(i, e, t) { return e && Mv(i.prototype, e), t && Mv(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(d_, "_createClass"); function h_(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(h_, "_classCallCheck"); function c_(i, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); i.prototype = Object.create(e && e.prototype, { constructor: { value: i, writable: !0, configurable: !0 } }), Object.defineProperty(i, "prototype", { writable: !1 }), e && Va(i, e) } n(c_, "_inherits"); function p_(i) { var e = Bv(); return n(function () { var r = Wa(i), s; if (e) { var o = Wa(this).constructor; s = Reflect.construct(r, arguments, o) } else s = r.apply(this, arguments); return f_(this, s) }, "_createSuperInternal") } n(p_, "_createSuper"); function f_(i, e) { if (e && (Ic(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return m_(i) } n(f_, "_possibleConstructorReturn"); function m_(i) { if (i === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return i } n(m_, "_assertThisInitialized"); function Nc(i) { var e = typeof Map == "function" ? new Map : void 0; return Nc = n(function (r) { if (r === null || !g_(r)) return r; if (typeof r != "function") throw new TypeError("Super expression must either be null or a function"); if (typeof e < "u") { if (e.has(r)) return e.get(r); e.set(r, s) } function s() { return Hu(r, arguments, Wa(this).constructor) } return n(s, "Wrapper"), s.prototype = Object.create(r.prototype, { constructor: { value: s, enumerable: !1, writable: !0, configurable: !0 } }), Va(s, r) }, "_wrapNativeSuper"), Nc(i) } n(Nc, "_wrapNativeSuper"); function Hu(i, e, t) { return Bv() ? Hu = Reflect.construct.bind() : Hu = n(function (s, o, a) { var l = [null]; l.push.apply(l, o); var d = Function.bind.apply(s, l), p = new d; return a && Va(p, a.prototype), p }, "_construct"), Hu.apply(null, arguments) } n(Hu, "_construct"); function Bv() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch { return !1 } } n(Bv, "_isNativeReflectConstruct"); function g_(i) { return Function.toString.call(i).indexOf("[native code]") !== -1 } n(g_, "_isNativeFunction"); function Va(i, e) { return Va = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : n(function (r, s) { return r.__proto__ = s, r }, "_setPrototypeOf"), Va(i, e) } n(Va, "_setPrototypeOf"); function Wa(i) { return Wa = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : n(function (t) { return t.__proto__ || Object.getPrototypeOf(t) }, "_getPrototypeOf"), Wa(i) } n(Wa, "_getPrototypeOf"); var y_ = function (i) { c_(t, i); var e = p_(t); function t(r) { var s, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null; if (h_(this, t), s = e.call(this, r), s.originalRequest = a, s.originalResponse = l, s.causingError = o, o != null && (r += ", caused by ".concat(o.toString())), a != null) { var d = a.getHeader("X-Request-ID") || "n/a", p = a.getMethod(), h = a.getURL(), m = l ? l.getStatus() : "n/a", y = l ? l.getBody() || "" : "n/a"; r += ", originated from request (method: ".concat(p, ", url: ").concat(h, ", response code: ").concat(m, ", response text: ").concat(y, ", request id: ").concat(d, ")") } return s.message = r, s } return n(t, "DetailedError"), d_(t) }(Nc(Error)), Yo = y_; var v_ = !1; function cs(i) { v_ && console.log(i) } n(cs, "log"); function Mc() { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (i) { var e = Math.random() * 16 | 0, t = i === "x" ? e : e & 3 | 8; return t.toString(16) }) } n(Mc, "uuid"); function Gv(i, e) { return P_(i) || S_(i, e) || w_(i, e) || b_() } n(Gv, "_slicedToArray"); function b_() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    } n(b_, "_nonIterableRest"); function w_(i, e) { if (i) { if (typeof i == "string") return Lv(i, e); var t = Object.prototype.toString.call(i).slice(8, -1); if (t === "Object" && i.constructor && (t = i.constructor.name), t === "Map" || t === "Set") return Array.from(i); if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return Lv(i, e) } } n(w_, "_unsupportedIterableToArray"); function Lv(i, e) { (e == null || e > i.length) && (e = i.length); for (var t = 0, r = new Array(e); t < e; t++)r[t] = i[t]; return r } n(Lv, "_arrayLikeToArray"); function S_(i, e) { var t = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"]; if (t != null) { var r = [], s = !0, o = !1, a, l; try { for (t = t.call(i); !(s = (a = t.next()).done) && (r.push(a.value), !(e && r.length === e)); s = !0); } catch (d) { o = !0, l = d } finally { try { !s && t.return != null && t.return() } finally { if (o) throw l } } return r } } n(S_, "_iterableToArrayLimit"); function P_(i) { if (Array.isArray(i)) return i } n(P_, "_arrayWithHoles"); function jv(i, e) { var t = Object.keys(i); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(i); e && (r = r.filter(function (s) { return Object.getOwnPropertyDescriptor(i, s).enumerable })), t.push.apply(t, r) } return t } n(jv, "ownKeys"); function Qo(i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? jv(Object(t), !0).forEach(function (r) { __(i, r, t[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t)) : jv(Object(t)).forEach(function (r) { Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(t, r)) }) } return i } n(Qo, "_objectSpread"); function __(i, e, t) { return e in i ? Object.defineProperty(i, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = t, i } n(__, "_defineProperty"); function F_(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(F_, "_classCallCheck"); function zv(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(zv, "_defineProperties"); function x_(i, e, t) { return e && zv(i.prototype, e), t && zv(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(x_, "_createClass"); var O_ = { endpoint: null, uploadUrl: null, metadata: {}, fingerprint: null, uploadSize: null, onProgress: null, onChunkComplete: null, onSuccess: null, onError: null, _onUploadUrlAvailable: null, overridePatchMethod: !1, headers: {}, addRequestId: !1, onBeforeRequest: null, onAfterResponse: null, onShouldRetry: null, chunkSize: 1 / 0, retryDelays: [0, 1e3, 3e3, 5e3], parallelUploads: 1, parallelUploadBoundaries: null, storeFingerprintForResuming: !0, removeFingerprintOnSuccess: !1, uploadLengthDeferred: !1, uploadDataDuringCreation: !1, urlStorage: null, fileReader: null, httpStack: null }, Xv = function () { function i(e, t) { F_(this, i), "resume" in t && console.log("tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead."), this.options = t, this.options.chunkSize = Number(this.options.chunkSize), this._urlStorage = this.options.urlStorage, this.file = e, this.url = null, this._req = null, this._fingerprint = null, this._urlStorageKey = null, this._offset = null, this._aborted = !1, this._size = null, this._source = null, this._retryAttempt = 0, this._retryTimeout = null, this._offsetBeforeRetry = 0, this._parallelUploads = null, this._parallelUploadUrls = null } return n(i, "BaseUpload"), x_(i, [{ key: "findPreviousUploads", value: n(function () { var t = this; return this.options.fingerprint(this.file, this.options).then(function (r) { return t._urlStorage.findUploadsByFingerprint(r) }) }, "findPreviousUploads") }, { key: "resumeFromPreviousUpload", value: n(function (t) { this.url = t.uploadUrl || null, this._parallelUploadUrls = t.parallelUploadUrls || null, this._urlStorageKey = t.urlStorageKey }, "resumeFromPreviousUpload") }, { key: "start", value: n(function () { var t = this, r = this.file; if (!r) { this._emitError(new Error("tus: no file or stream to upload provided")); return } if (!this.options.endpoint && !this.options.uploadUrl && !this.url) { this._emitError(new Error("tus: neither an endpoint or an upload URL is provided")); return } var s = this.options.retryDelays; if (s != null && Object.prototype.toString.call(s) !== "[object Array]") { this._emitError(new Error("tus: the `retryDelays` option must either be an array or null")); return } if (this.options.parallelUploads > 1) for (var o = 0, a = ["uploadUrl", "uploadSize", "uploadLengthDeferred"]; o < a.length; o++) { var l = a[o]; if (this.options[l]) { this._emitError(new Error("tus: cannot use the ".concat(l, " option when parallelUploads is enabled"))); return } } if (this.options.parallelUploadBoundaries) { if (this.options.parallelUploads <= 1) { this._emitError(new Error("tus: cannot use the `parallelUploadBoundaries` option when `parallelUploads` is disabled")); return } if (this.options.parallelUploads !== this.options.parallelUploadBoundaries.length) { this._emitError(new Error("tus: the `parallelUploadBoundaries` must have the same length as the value of `parallelUploads`")); return } } this.options.fingerprint(r, this.options).then(function (d) { return d == null ? cs("No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.") : cs("Calculated fingerprint: ".concat(d)), t._fingerprint = d, t._source ? t._source : t.options.fileReader.openFile(r, t.options.chunkSize) }).then(function (d) { if (t._source = d, t.options.uploadLengthDeferred) t._size = null; else if (t.options.uploadSize != null) { if (t._size = Number(t.options.uploadSize), Number.isNaN(t._size)) { t._emitError(new Error("tus: cannot convert `uploadSize` option into a number")); return } } else if (t._size = t._source.size, t._size == null) { t._emitError(new Error("tus: cannot automatically derive upload's size from input. Specify it manually using the `uploadSize` option or use the `uploadLengthDeferred` option")); return } t.options.parallelUploads > 1 || t._parallelUploadUrls != null ? t._startParallelUpload() : t._startSingleUpload() }).catch(function (d) { t._emitError(d) }) }, "start") }, { key: "_startParallelUpload", value: n(function () { var t, r = this, s = this._size, o = 0; this._parallelUploads = []; var a = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads, l = (t = this.options.parallelUploadBoundaries) !== null && t !== void 0 ? t : C_(this._source.size, a); this._parallelUploadUrls && l.forEach(function (h, m) { h.uploadUrl = r._parallelUploadUrls[m] || null }), this._parallelUploadUrls = new Array(l.length); var d = l.map(function (h, m) { var y = 0; return r._source.slice(h.start, h.end).then(function (b) { var S = b.value; return new Promise(function (O, F) { var x = Qo(Qo({}, r.options), {}, { uploadUrl: h.uploadUrl || null, storeFingerprintForResuming: !1, removeFingerprintOnSuccess: !1, parallelUploads: 1, parallelUploadBoundaries: null, metadata: {}, headers: Qo(Qo({}, r.options.headers), {}, { "Upload-Concat": "partial" }), onSuccess: O, onError: F, onProgress: n(function (W) { o = o - y + W, y = W, r._emitProgress(o, s) }, "onProgress"), _onUploadUrlAvailable: n(function () { r._parallelUploadUrls[m] = U.url, r._parallelUploadUrls.filter(function (W) { return !!W }).length === l.length && r._saveUploadInUrlStorage() }, "_onUploadUrlAvailable") }), U = new i(S, x); U.start(), r._parallelUploads.push(U) }) }) }), p; Promise.all(d).then(function () { p = r._openRequest("POST", r.options.endpoint), p.setHeader("Upload-Concat", "final;".concat(r._parallelUploadUrls.join(" "))); var h = Hv(r.options.metadata); return h !== "" && p.setHeader("Upload-Metadata", h), r._sendRequest(p, null) }).then(function (h) { if (!Jo(h.getStatus(), 200)) { r._emitHttpError(p, h, "tus: unexpected response while creating upload"); return } var m = h.getHeader("Location"); if (m == null) { r._emitHttpError(p, h, "tus: invalid or missing Location header"); return } r.url = Wv(r.options.endpoint, m), cs("Created upload at ".concat(r.url)), r._emitSuccess() }).catch(function (h) { r._emitError(h) }) }, "_startParallelUpload") }, { key: "_startSingleUpload", value: n(function () { if (this._aborted = !1, this.url != null) { cs("Resuming upload from previous URL: ".concat(this.url)), this._resumeUpload(); return } if (this.options.uploadUrl != null) { cs("Resuming upload from provided URL: ".concat(this.options.uploadUrl)), this.url = this.options.uploadUrl, this._resumeUpload(); return } cs("Creating a new upload"), this._createUpload() }, "_startSingleUpload") }, { key: "abort", value: n(function (t) { var r = this; return this._parallelUploads != null && this._parallelUploads.forEach(function (s) { s.abort(t) }), this._req !== null && this._req.abort(), this._aborted = !0, this._retryTimeout != null && (clearTimeout(this._retryTimeout), this._retryTimeout = null), !t || this.url == null ? Promise.resolve() : i.terminate(this.url, this.options).then(function () { return r._removeFromUrlStorage() }) }, "abort") }, { key: "_emitHttpError", value: n(function (t, r, s, o) { this._emitError(new Yo(s, o, t, r)) }, "_emitHttpError") }, { key: "_emitError", value: n(function (t) { var r = this; if (!this._aborted) { if (this.options.retryDelays != null) { var s = this._offset != null && this._offset > this._offsetBeforeRetry; if (s && (this._retryAttempt = 0), Vv(t, this._retryAttempt, this.options)) { var o = this.options.retryDelays[this._retryAttempt++]; this._offsetBeforeRetry = this._offset, this._retryTimeout = setTimeout(function () { r.start() }, o); return } } if (typeof this.options.onError == "function") this.options.onError(t); else throw t } }, "_emitError") }, { key: "_emitSuccess", value: n(function () { this.options.removeFingerprintOnSuccess && this._removeFromUrlStorage(), typeof this.options.onSuccess == "function" && this.options.onSuccess() }, "_emitSuccess") }, { key: "_emitProgress", value: n(function (t, r) { typeof this.options.onProgress == "function" && this.options.onProgress(t, r) }, "_emitProgress") }, { key: "_emitChunkComplete", value: n(function (t, r, s) { typeof this.options.onChunkComplete == "function" && this.options.onChunkComplete(t, r, s) }, "_emitChunkComplete") }, { key: "_createUpload", value: n(function () { var t = this; if (!this.options.endpoint) { this._emitError(new Error("tus: unable to create upload because no endpoint is provided")); return } var r = this._openRequest("POST", this.options.endpoint); this.options.uploadLengthDeferred ? r.setHeader("Upload-Defer-Length", 1) : r.setHeader("Upload-Length", this._size); var s = Hv(this.options.metadata); s !== "" && r.setHeader("Upload-Metadata", s); var o; this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred ? (this._offset = 0, o = this._addChunkToRequest(r)) : o = this._sendRequest(r, null), o.then(function (a) { if (!Jo(a.getStatus(), 200)) { t._emitHttpError(r, a, "tus: unexpected response while creating upload"); return } var l = a.getHeader("Location"); if (l == null) { t._emitHttpError(r, a, "tus: invalid or missing Location header"); return } if (t.url = Wv(t.options.endpoint, l), cs("Created upload at ".concat(t.url)), typeof t.options._onUploadUrlAvailable == "function" && t.options._onUploadUrlAvailable(), t._size === 0) { t._emitSuccess(), t._source.close(); return } t._saveUploadInUrlStorage().then(function () { t.options.uploadDataDuringCreation ? t._handleUploadResponse(r, a) : (t._offset = 0, t._performUpload()) }) }).catch(function (a) { t._emitHttpError(r, null, "tus: failed to create upload", a) }) }, "_createUpload") }, { key: "_resumeUpload", value: n(function () { var t = this, r = this._openRequest("HEAD", this.url), s = this._sendRequest(r, null); s.then(function (o) { var a = o.getStatus(); if (!Jo(a, 200)) { if (a === 423) { t._emitHttpError(r, o, "tus: upload is currently locked; retry later"); return } if (Jo(a, 400) && t._removeFromUrlStorage(), !t.options.endpoint) { t._emitHttpError(r, o, "tus: unable to resume upload (new upload cannot be created without an endpoint)"); return } t.url = null, t._createUpload(); return } var l = parseInt(o.getHeader("Upload-Offset"), 10); if (Number.isNaN(l)) { t._emitHttpError(r, o, "tus: invalid or missing offset value"); return } var d = parseInt(o.getHeader("Upload-Length"), 10); if (Number.isNaN(d) && !t.options.uploadLengthDeferred) { t._emitHttpError(r, o, "tus: invalid or missing length value"); return } typeof t.options._onUploadUrlAvailable == "function" && t.options._onUploadUrlAvailable(), t._saveUploadInUrlStorage().then(function () { if (l === d) { t._emitProgress(d, d), t._emitSuccess(); return } t._offset = l, t._performUpload() }) }).catch(function (o) { t._emitHttpError(r, null, "tus: failed to resume upload", o) }) }, "_resumeUpload") }, { key: "_performUpload", value: n(function () { var t = this; if (!this._aborted) { var r; this.options.overridePatchMethod ? (r = this._openRequest("POST", this.url), r.setHeader("X-HTTP-Method-Override", "PATCH")) : r = this._openRequest("PATCH", this.url), r.setHeader("Upload-Offset", this._offset); var s = this._addChunkToRequest(r); s.then(function (o) { if (!Jo(o.getStatus(), 200)) { t._emitHttpError(r, o, "tus: unexpected response while uploading chunk"); return } t._handleUploadResponse(r, o) }).catch(function (o) { t._aborted || t._emitHttpError(r, null, "tus: failed to upload chunk at offset ".concat(t._offset), o) }) } }, "_performUpload") }, { key: "_addChunkToRequest", value: n(function (t) { var r = this, s = this._offset, o = this._offset + this.options.chunkSize; return t.setProgressHandler(function (a) { r._emitProgress(s + a, r._size) }), t.setHeader("Content-Type", "application/offset+octet-stream"), (o === 1 / 0 || o > this._size) && !this.options.uploadLengthDeferred && (o = this._size), this._source.slice(s, o).then(function (a) { var l = a.value, d = a.done; return r.options.uploadLengthDeferred && d && (r._size = r._offset + (l && l.size ? l.size : 0), t.setHeader("Upload-Length", r._size)), l === null ? r._sendRequest(t) : (r._emitProgress(r._offset, r._size), r._sendRequest(t, l)) }) }, "_addChunkToRequest") }, { key: "_handleUploadResponse", value: n(function (t, r) { var s = parseInt(r.getHeader("Upload-Offset"), 10); if (Number.isNaN(s)) { this._emitHttpError(t, r, "tus: invalid or missing offset value"); return } if (this._emitProgress(s, this._size), this._emitChunkComplete(s - this._offset, s, this._size), this._offset = s, s === this._size) { this._emitSuccess(), this._source.close(); return } this._performUpload() }, "_handleUploadResponse") }, { key: "_openRequest", value: n(function (t, r) { var s = $v(t, r, this.options); return this._req = s, s }, "_openRequest") }, { key: "_removeFromUrlStorage", value: n(function () { var t = this; this._urlStorageKey && (this._urlStorage.removeUpload(this._urlStorageKey).catch(function (r) { t._emitError(r) }), this._urlStorageKey = null) }, "_removeFromUrlStorage") }, { key: "_saveUploadInUrlStorage", value: n(function () { var t = this; if (!this.options.storeFingerprintForResuming || !this._fingerprint || this._urlStorageKey !== null) return Promise.resolve(); var r = { size: this._size, metadata: this.options.metadata, creationTime: new Date().toString() }; return this._parallelUploads ? r.parallelUploadUrls = this._parallelUploadUrls : r.uploadUrl = this.url, this._urlStorage.addUpload(this._fingerprint, r).then(function (s) { t._urlStorageKey = s }) }, "_saveUploadInUrlStorage") }, { key: "_sendRequest", value: n(function (t) { var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null; return qv(t, r, this.options) }, "_sendRequest") }], [{ key: "terminate", value: n(function (t) { var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = $v("DELETE", t, r); return qv(s, null, r).then(function (o) { if (o.getStatus() !== 204) throw new Yo("tus: unexpected response while terminating upload", null, s, o) }).catch(function (o) { if (o instanceof Yo || (o = new Yo("tus: failed to terminate upload", o, s, null)), !Vv(o, 0, r)) throw o; var a = r.retryDelays[0], l = r.retryDelays.slice(1), d = Qo(Qo({}, r), {}, { retryDelays: l }); return new Promise(function (p) { return setTimeout(p, a) }).then(function () { return i.terminate(t, d) }) }) }, "terminate") }]), i }(); function Hv(i) { return Object.entries(i).map(function (e) { var t = Gv(e, 2), r = t[0], s = t[1]; return "".concat(r, " ").concat(_v.encode(String(s))) }).join(",") } n(Hv, "encodeMetadata"); function Jo(i, e) { return i >= e && i < e + 100 } n(Jo, "inStatusCategory"); function $v(i, e, t) { var r = t.httpStack.createRequest(i, e); r.setHeader("Tus-Resumable", "1.0.0"); var s = t.headers || {}; if (Object.entries(s).forEach(function (a) { var l = Gv(a, 2), d = l[0], p = l[1]; r.setHeader(d, p) }), t.addRequestId) { var o = Mc(); r.setHeader("X-Request-ID", o) } return r } n($v, "openRequest"); function qv(i, e, t) { var r = typeof t.onBeforeRequest == "function" ? Promise.resolve(t.onBeforeRequest(i)) : Promise.resolve(); return r.then(function () { return i.send(e).then(function (s) { var o = typeof t.onAfterResponse == "function" ? Promise.resolve(t.onAfterResponse(i, s)) : Promise.resolve(); return o.then(function () { return s }) }) }) } n(qv, "sendRequest"); function E_() { var i = !0; return typeof window < "u" && "navigator" in window && window.navigator.onLine === !1 && (i = !1), i } n(E_, "isOnline"); function Vv(i, e, t) { if (t.retryDelays == null || e >= t.retryDelays.length || i.originalRequest == null) return !1; if (t && typeof t.onShouldRetry == "function") return t.onShouldRetry(i, e, t); var r = i.originalResponse ? i.originalResponse.getStatus() : 0; return (!Jo(r, 400) || r === 409 || r === 423) && E_() } n(Vv, "shouldRetry"); function Wv(i, e) { return new Kv.default(e, i).toString() } n(Wv, "resolveUrl"); function C_(i, e) { for (var t = Math.floor(i / e), r = [], s = 0; s < e; s++)r.push({ start: t * s, end: t * (s + 1) }); return r[e - 1].end = i, r } n(C_, "splitSizeIntoParts"); Xv.defaultOptions = O_; var $u = Xv; function A_(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(A_, "_classCallCheck"); function Yv(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(Yv, "_defineProperties"); function T_(i, e, t) { return e && Yv(i.prototype, e), t && Yv(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(T_, "_createClass"); var Qv = function () { function i() { A_(this, i) } return n(i, "NoopUrlStorage"), T_(i, [{ key: "listAllUploads", value: n(function () { return Promise.resolve([]) }, "listAllUploads") }, { key: "findUploadsByFingerprint", value: n(function (t) { return Promise.resolve([]) }, "findUploadsByFingerprint") }, { key: "removeUpload", value: n(function (t) { return Promise.resolve() }, "removeUpload") }, { key: "addUpload", value: n(function (t, r) { return Promise.resolve(null) }, "addUpload") }]), i }(); function R_(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(R_, "_classCallCheck"); function Jv(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(Jv, "_defineProperties"); function U_(i, e, t) { return e && Jv(i.prototype, e), t && Jv(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(U_, "_createClass"); var Lc = !1; try { Lc = "localStorage" in window, Bc = "tusSupport", localStorage.setItem(Bc, localStorage.getItem(Bc)) } catch (i) { if (i.code === i.SECURITY_ERR || i.code === i.QUOTA_EXCEEDED_ERR) Lc = !1; else throw i } var Bc, Zv = Lc, e0 = function () { function i() { R_(this, i) } return n(i, "WebStorageUrlStorage"), U_(i, [{ key: "findAllUploads", value: n(function () { var t = this._findEntries("tus::"); return Promise.resolve(t) }, "findAllUploads") }, { key: "findUploadsByFingerprint", value: n(function (t) { var r = this._findEntries("tus::".concat(t, "::")); return Promise.resolve(r) }, "findUploadsByFingerprint") }, { key: "removeUpload", value: n(function (t) { return localStorage.removeItem(t), Promise.resolve() }, "removeUpload") }, { key: "addUpload", value: n(function (t, r) { var s = Math.round(Math.random() * 1e12), o = "tus::".concat(t, "::").concat(s); return localStorage.setItem(o, JSON.stringify(r)), Promise.resolve(o) }, "addUpload") }, { key: "_findEntries", value: n(function (t) { for (var r = [], s = 0; s < localStorage.length; s++) { var o = localStorage.key(s); if (o.indexOf(t) === 0) try { var a = JSON.parse(localStorage.getItem(o)); a.urlStorageKey = o, r.push(a) } catch { } } return r }, "_findEntries") }]), i }(); function jc(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(jc, "_classCallCheck"); function t0(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(t0, "_defineProperties"); function zc(i, e, t) { return e && t0(i.prototype, e), t && t0(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(zc, "_createClass"); var i0 = function () { function i() { jc(this, i) } return n(i, "XHRHttpStack"), zc(i, [{ key: "createRequest", value: n(function (t, r) { return new k_(t, r) }, "createRequest") }, { key: "getName", value: n(function () { return "XHRHttpStack" }, "getName") }]), i }(); var k_ = function () { function i(e, t) { jc(this, i), this._xhr = new XMLHttpRequest, this._xhr.open(e, t, !0), this._method = e, this._url = t, this._headers = {} } return n(i, "Request"), zc(i, [{ key: "getMethod", value: n(function () { return this._method }, "getMethod") }, { key: "getURL", value: n(function () { return this._url }, "getURL") }, { key: "setHeader", value: n(function (t, r) { this._xhr.setRequestHeader(t, r), this._headers[t] = r }, "setHeader") }, { key: "getHeader", value: n(function (t) { return this._headers[t] }, "getHeader") }, { key: "setProgressHandler", value: n(function (t) { "upload" in this._xhr && (this._xhr.upload.onprogress = function (r) { r.lengthComputable && t(r.loaded) }) }, "setProgressHandler") }, { key: "send", value: n(function () { var t = this, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null; return new Promise(function (s, o) { t._xhr.onload = function () { s(new D_(t._xhr)) }, t._xhr.onerror = function (a) { o(a) }, t._xhr.send(r) }) }, "send") }, { key: "abort", value: n(function () { return this._xhr.abort(), Promise.resolve() }, "abort") }, { key: "getUnderlyingObject", value: n(function () { return this._xhr }, "getUnderlyingObject") }]), i }(), D_ = function () { function i(e) { jc(this, i), this._xhr = e } return n(i, "Response"), zc(i, [{ key: "getStatus", value: n(function () { return this._xhr.status }, "getStatus") }, { key: "getHeader", value: n(function (t) { return this._xhr.getResponseHeader(t) }, "getHeader") }, { key: "getBody", value: n(function () { return this._xhr.responseText }, "getBody") }, { key: "getUnderlyingObject", value: n(function () { return this._xhr }, "getUnderlyingObject") }]), i }(); var I_ = n(function () { return typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative" }, "isReactNative"), qu = I_; function Hc(i) { return new Promise(function (e, t) { var r = new XMLHttpRequest; r.responseType = "blob", r.onload = function () { var s = r.response; e(s) }, r.onerror = function (s) { t(s) }, r.open("GET", i), r.send() }) } n(Hc, "uriToBlob"); var N_ = n(function () { return typeof window < "u" && (typeof window.PhoneGap < "u" || typeof window.Cordova < "u" || typeof window.cordova < "u") }, "isCordova"), r0 = N_; function $c(i) { return new Promise(function (e, t) { var r = new FileReader; r.onload = function () { var s = new Uint8Array(r.result); e({ value: s }) }, r.onerror = function (s) { t(s) }, r.readAsArrayBuffer(i) }) } n($c, "readAsByteArray"); function M_(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(M_, "_classCallCheck"); function s0(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(s0, "_defineProperties"); function B_(i, e, t) { return e && s0(i.prototype, e), t && s0(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(B_, "_createClass"); var qc = function () { function i(e) { M_(this, i), this._file = e, this.size = e.size } return n(i, "FileSource"), B_(i, [{ key: "slice", value: n(function (t, r) { if (r0()) return $c(this._file.slice(t, r)); var s = this._file.slice(t, r); return Promise.resolve({ value: s }) }, "slice") }, { key: "close", value: n(function () { }, "close") }]), i }(); function L_(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(L_, "_classCallCheck"); function o0(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(o0, "_defineProperties"); function j_(i, e, t) { return e && o0(i.prototype, e), t && o0(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(j_, "_createClass"); function n0(i) { return i === void 0 ? 0 : i.size !== void 0 ? i.size : i.length } n(n0, "len"); function z_(i, e) { if (i.concat) return i.concat(e); if (i instanceof Blob) return new Blob([i, e], { type: i.type }); if (i.set) { var t = new i.constructor(i.length + e.length); return t.set(i), t.set(e, i.length), t } throw new Error("Unknown data type") } n(z_, "concat"); var a0 = function () { function i(e) { L_(this, i), this._buffer = void 0, this._bufferOffset = 0, this._reader = e, this._done = !1 } return n(i, "StreamSource"), j_(i, [{ key: "slice", value: n(function (t, r) { return t < this._bufferOffset ? Promise.reject(new Error("Requested data is before the reader's current offset")) : this._readUntilEnoughDataOrDone(t, r) }, "slice") }, { key: "_readUntilEnoughDataOrDone", value: n(function (t, r) { var s = this, o = r <= this._bufferOffset + n0(this._buffer); if (this._done || o) { var a = this._getDataFromBuffer(t, r), l = a == null ? this._done : !1; return Promise.resolve({ value: a, done: l }) } return this._reader.read().then(function (d) { var p = d.value, h = d.done; return h ? s._done = !0 : s._buffer === void 0 ? s._buffer = p : s._buffer = z_(s._buffer, p), s._readUntilEnoughDataOrDone(t, r) }) }, "_readUntilEnoughDataOrDone") }, { key: "_getDataFromBuffer", value: n(function (t, r) { t > this._bufferOffset && (this._buffer = this._buffer.slice(t - this._bufferOffset), this._bufferOffset = t); var s = n0(this._buffer) === 0; return this._done && s ? null : this._buffer.slice(0, r - t) }, "_getDataFromBuffer") }, { key: "close", value: n(function () { this._reader.cancel && this._reader.cancel() }, "close") }]), i }(); function H_(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(H_, "_classCallCheck"); function l0(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(l0, "_defineProperties"); function $_(i, e, t) { return e && l0(i.prototype, e), t && l0(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n($_, "_createClass"); var u0 = function () { function i() { H_(this, i) } return n(i, "FileReader"), $_(i, [{ key: "openFile", value: n(function (t, r) { return qu() && t && typeof t.uri < "u" ? Hc(t.uri).then(function (s) { return new qc(s) }).catch(function (s) { throw new Error("tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. ".concat(s)) }) : typeof t.slice == "function" && typeof t.size < "u" ? Promise.resolve(new qc(t)) : typeof t.read == "function" ? (r = Number(r), Number.isFinite(r) ? Promise.resolve(new a0(t, r)) : Promise.reject(new Error("cannot create source for stream without a finite value for the `chunkSize` option"))) : Promise.reject(new Error("source object may only be an instance of File, Blob, or Reader in this environment")) }, "openFile") }]), i }(); function Vc(i, e) { return qu() ? Promise.resolve(q_(i, e)) : Promise.resolve(["tus-br", i.name, i.type, i.size, i.lastModified, e.endpoint].join("-")) } n(Vc, "fingerprint"); function q_(i, e) { var t = i.exif ? V_(JSON.stringify(i.exif)) : "noexif"; return ["tus-rn", i.name || "noname", i.size || "nosize", t, e.endpoint].join("/") } n(q_, "reactNativeFingerprint"); function V_(i) { var e = 0; if (i.length === 0) return e; for (var t = 0; t < i.length; t++) { var r = i.charCodeAt(t); e = (e << 5) - e + r, e &= e } return e } n(V_, "hashCode"); function Wc(i) { "@babel/helpers - typeof"; return Wc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Wc(i) } n(Wc, "_typeof"); function W_(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(W_, "_classCallCheck"); function d0(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(d0, "_defineProperties"); function G_(i, e, t) { return e && d0(i.prototype, e), t && d0(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(G_, "_createClass"); function K_(i, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); i.prototype = Object.create(e && e.prototype, { constructor: { value: i, writable: !0, configurable: !0 } }), Object.defineProperty(i, "prototype", { writable: !1 }), e && Gc(i, e) } n(K_, "_inherits"); function Gc(i, e) { return Gc = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : n(function (r, s) { return r.__proto__ = s, r }, "_setPrototypeOf"), Gc(i, e) } n(Gc, "_setPrototypeOf"); function X_(i) { var e = J_(); return n(function () { var r = Vu(i), s; if (e) { var o = Vu(this).constructor; s = Reflect.construct(r, arguments, o) } else s = r.apply(this, arguments); return Y_(this, s) }, "_createSuperInternal") } n(X_, "_createSuper"); function Y_(i, e) { if (e && (Wc(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return Q_(i) } n(Y_, "_possibleConstructorReturn"); function Q_(i) { if (i === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return i } n(Q_, "_assertThisInitialized"); function J_() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch { return !1 } } n(J_, "_isNativeReflectConstruct"); function Vu(i) { return Vu = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : n(function (t) { return t.__proto__ || Object.getPrototypeOf(t) }, "_getPrototypeOf"), Vu(i) } n(Vu, "_getPrototypeOf"); function h0(i, e) { var t = Object.keys(i); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(i); e && (r = r.filter(function (s) { return Object.getOwnPropertyDescriptor(i, s).enumerable })), t.push.apply(t, r) } return t } n(h0, "ownKeys"); function Zo(i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? h0(Object(t), !0).forEach(function (r) { Z_(i, r, t[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t)) : h0(Object(t)).forEach(function (r) { Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(t, r)) }) } return i } n(Zo, "_objectSpread"); function Z_(i, e, t) { return e in i ? Object.defineProperty(i, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = t, i } n(Z_, "_defineProperty"); var Wu = Zo(Zo({}, $u.defaultOptions), {}, { httpStack: new i0, fileReader: new u0, urlStorage: Zv ? new e0 : new Qv, fingerprint: Vc }), p0 = function (i) { K_(t, i); var e = X_(t); function t() { var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; return W_(this, t), s = Zo(Zo({}, Wu), s), e.call(this, r, s) } return n(t, "Upload"), G_(t, null, [{ key: "terminate", value: n(function (s, o, a) { return o = Zo(Zo({}, Wu), o), $u.terminate(s, o, a) }, "terminate") }]), t }($u), f0 = window, e5 = f0.XMLHttpRequest, c0 = f0.Blob, w9 = e5 && c0 && typeof c0.prototype.slice == "function"; function t5() { return typeof window < "u" && (typeof window.PhoneGap < "u" || typeof window.Cordova < "u" || typeof window.cordova < "u") } n(t5, "isCordova"); function i5() { return typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative" } n(i5, "isReactNative"); function Kc(i) { return (e, t) => { if (t5() || i5()) return Wu.fingerprint(e, t); let r = ["tus", i.id, t.endpoint].join("-"); return Promise.resolve(r) } } n(Kc, "getFingerprint"); function so(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(so, "_classPrivateFieldLooseBase"); var r5 = 0; function Xa(i) { return "__private_" + r5++ + "_" + i } n(Xa, "_classPrivateFieldLooseKey"); var s5 = { version: "3.3.1" }, g0 = { endpoint: "", uploadUrl: null, metadata: {}, uploadSize: null, onProgress: null, onChunkComplete: null, onSuccess: null, onError: null, overridePatchMethod: !1, headers: {}, addRequestId: !1, chunkSize: 1 / 0, retryDelays: [100, 1e3, 3e3, 5e3], parallelUploads: 1, removeFingerprintOnSuccess: !1, uploadLengthDeferred: !1, uploadDataDuringCreation: !1 }, Ka = Xa("retryDelayIterator"), Yc = Xa("uploadLocalFile"), Qc = Xa("getCompanionClientArgs"), Xc = Xa("uploadFiles"), Ga = Xa("handleUpload"), rr = class extends Se { constructor(e, t) { var r, s; super(e, t), Object.defineProperty(this, Xc, { value: a5 }), Object.defineProperty(this, Qc, { value: n5 }), Object.defineProperty(this, Yc, { value: o5 }), Object.defineProperty(this, Ka, { writable: !0, value: void 0 }), Object.defineProperty(this, Ga, { writable: !0, value: async a => { if (a.length === 0) { this.uppy.log("[Tus] No files to upload"); return } this.opts.limit === 0 && this.uppy.log("[Tus] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/tus/#limit-0", "warning"), this.uppy.log("[Tus] Uploading..."); let l = this.uppy.getFilesByIds(a); await so(this, Xc)[Xc](l) } }), this.type = "uploader", this.id = this.opts.id || "Tus", this.title = "Tus"; let o = { useFastRemoteRetry: !0, limit: 20, retryDelays: g0.retryDelays, withCredentials: !1 }; if (this.opts = { ...o, ...t }, t?.allowedMetaFields === void 0 && "metaFields" in this.opts) throw new Error("The `metaFields` option has been renamed to `allowedMetaFields`."); if ("autoRetry" in t) throw new Error("The `autoRetry` option was deprecated and has been removed."); this.requests = (r = this.opts.rateLimitedQueue) != null ? r : new Nt(this.opts.limit), so(this, Ka)[Ka] = (s = this.opts.retryDelays) == null ? void 0 : s.values(), this.uploaders = Object.create(null), this.uploaderEvents = Object.create(null), this.handleResetProgress = this.handleResetProgress.bind(this) } handleResetProgress() { let e = { ...this.uppy.getState().files }; Object.keys(e).forEach(t => { if (e[t].tus && e[t].tus.uploadUrl) { let r = { ...e[t].tus }; delete r.uploadUrl, e[t] = { ...e[t], tus: r } } }), this.uppy.setState({ files: e }) } resetUploaderReferences(e, t) { if (t === void 0 && (t = {}), this.uploaders[e]) { let r = this.uploaders[e]; r.abort(), t.abort && r.abort(!0), this.uploaders[e] = null } this.uploaderEvents[e] && (this.uploaderEvents[e].remove(), this.uploaderEvents[e] = null) } onReceiveUploadUrl(e, t) { let r = this.uppy.getFile(e.id); r && (!r.tus || r.tus.uploadUrl !== t) && (this.uppy.log("[Tus] Storing upload url"), this.uppy.setFileState(r.id, { tus: { ...r.tus, uploadUrl: t } })) } install() { this.uppy.setState({ capabilities: { ...this.uppy.getState().capabilities, resumableUploads: !0 } }), this.uppy.addUploader(so(this, Ga)[Ga]), this.uppy.on("reset-progress", this.handleResetProgress) } uninstall() { this.uppy.setState({ capabilities: { ...this.uppy.getState().capabilities, resumableUploads: !1 } }), this.uppy.removeUploader(so(this, Ga)[Ga]) } }; n(rr, "Tus"); function o5(i) { var e = this; return this.resetUploaderReferences(i.id), new Promise((t, r) => { let s, o, a, l = { ...this.opts, ...i.tus || {} }; typeof l.headers == "function" && (l.headers = l.headers(i)); let d = { ...g0, ...l }; d.fingerprint = Kc(i), d.onBeforeRequest = S => { let O = S.getUnderlyingObject(); O.withCredentials = !!l.withCredentials; let F; if (typeof l.onBeforeRequest == "function" && (F = l.onBeforeRequest(S, i)), Et(s, "shouldBeRequeued")) { if (!s.shouldBeRequeued) return Promise.reject(); let x, U = new Promise(H => { x = H }); return s = this.requests.run(() => (i.isPaused && s.abort(), x(), () => { })), Promise.all([U, F]) } return F }, d.onError = S => { var O; this.uppy.log(S); let F = S.originalRequest ? S.originalRequest.getUnderlyingObject() : null; to(F) && (S = new wi(S, F)), this.resetUploaderReferences(i.id), (O = s) == null || O.abort(), this.uppy.emit("upload-error", i, S), typeof l.onError == "function" && l.onError(S), r(S) }, d.onProgress = (S, O) => { this.onReceiveUploadUrl(i, a.url), typeof l.onProgress == "function" && l.onProgress(S, O), this.uppy.emit("upload-progress", i, { uploader: this, bytesUploaded: S, bytesTotal: O }) }, d.onSuccess = () => { let S = { uploadURL: a.url }; this.resetUploaderReferences(i.id), s.done(), this.uppy.emit("upload-success", i, S), a.url && this.uppy.log(`Download ${a.file.name} from ${a.url}`), typeof l.onSuccess == "function" && l.onSuccess(), t(a) }; let p = n(S => { var O; let F = S == null || (O = S.originalResponse) == null ? void 0 : O.getStatus(); if (F === 429) { if (!this.requests.isPaused) { var x; let U = (x = so(this, Ka)[Ka]) == null ? void 0 : x.next(); if (U == null || U.done) return !1; this.requests.rateLimit(U.value) } } else { if (F > 400 && F < 500 && F !== 409 && F !== 423) return !1; typeof navigator < "u" && navigator.onLine === !1 && (this.requests.isPaused || (this.requests.pause(), window.addEventListener("online", () => { this.requests.resume() }, { once: !0 }))) } return s.abort(), s = { shouldBeRequeued: !0, abort() { this.shouldBeRequeued = !1 }, done() { throw new Error("Cannot mark a queued request as done: this indicates a bug") }, fn() { throw new Error("Cannot run a queued request: this indicates a bug") } }, !0 }, "defaultOnShouldRetry"); l.onShouldRetry != null ? d.onShouldRetry = function () { for (var S = arguments.length, O = new Array(S), F = 0; F < S; F++)O[F] = arguments[F]; return l.onShouldRetry(...O, p) } : d.onShouldRetry = p; let h = n((S, O, F) => { Et(S, O) && !Et(S, F) && (S[F] = S[O]) }, "copyProp"), m = {}; (Array.isArray(l.allowedMetaFields) ? l.allowedMetaFields : Object.keys(i.meta)).forEach(S => { m[S] = i.meta[S] }), h(m, "type", "filetype"), h(m, "name", "filename"), d.metadata = m, a = new p0(i.data, d), this.uploaders[i.id] = a; let b = new $t(this.uppy); this.uploaderEvents[i.id] = b, o = n(() => (i.isPaused || a.start(), () => { }), "qRequest"), a.findPreviousUploads().then(S => { let O = S[0]; O && (this.uppy.log(`[Tus] Resuming upload of ${i.id} started at ${O.creationTime}`), a.resumeFromPreviousUpload(O)) }), s = this.requests.run(o), b.onFileRemove(i.id, S => { s.abort(), this.resetUploaderReferences(i.id, { abort: !!a.url }), t(`upload ${S} was removed`) }), b.onPause(i.id, S => { s.abort(), S ? a.abort() : s = this.requests.run(o) }), b.onPauseAll(i.id, () => { s.abort(), a.abort() }), b.onCancelAll(i.id, function (S) { let { reason: O } = S === void 0 ? {} : S; O === "user" && (s.abort(), e.resetUploaderReferences(i.id, { abort: !!a.url })), t(`upload ${i.id} was canceled`) }), b.onResumeAll(i.id, () => { s.abort(), i.error && a.abort(), s = this.requests.run(o) }) }).catch(t => { throw this.uppy.emit("upload-error", i, t), t }) } n(o5, "_uploadLocalFile2"); function n5(i) { let e = { ...this.opts }; return i.tus && Object.assign(e, i.tus), { ...i.remote.body, endpoint: e.endpoint, uploadUrl: e.uploadUrl, protocol: "tus", size: i.data.size, headers: e.headers, metadata: i.meta } } n(n5, "_getCompanionClientArgs2"); async function a5(i) { let e = ds(i), t = hs(e); this.uppy.emit("upload-start", t), await Promise.allSettled(e.map((r, s) => { let o = s + 1, a = i.length; if (r.isRemote) { let l = r.remote.providerOptions.provider ? ne : xe, d = n(() => this.requests, "getQueue"), p = new l(this.uppy, r.remote.providerOptions, d), h = new AbortController, m = n(b => { b.id === r.id && h.abort() }, "removedHandler"); this.uppy.on("file-removed", m); let y = p.uploadRemoteFile(r, so(this, Qc)[Qc](r), { signal: h.signal }); return this.requests.wrapSyncFunction(() => { this.uppy.off("file-removed", m) }, { priority: -1 })(), y } return so(this, Yc)[Yc](r, o, a) })) } n(a5, "_uploadFiles2"); rr.VERSION = s5.version; var v0 = de(Zc(), 1); function he(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(he, "_classPrivateFieldLooseBase"); var u5 = 0; function sr(i) { return "__private_" + u5++ + "_" + i } n(sr, "_classPrivateFieldLooseKey"); var d5 = "ASSEMBLY_UPLOADING", rp = "ASSEMBLY_EXECUTING", sp = "ASSEMBLY_COMPLETED", y0 = [d5, rp, sp]; function Gu(i, e) { return y0.indexOf(i) >= y0.indexOf(e) } n(Gu, "isStatus"); var no = sr("rateLimitedQueue"), Ya = sr("fetchWithNetworkError"), oo = sr("previousFetchStatusStillPending"), ze = sr("sse"), op = sr("onFinished"), ep = sr("connectServerSentEvents"), Ti = sr("onError"), tp = sr("beginPolling"), Br = sr("fetchStatus"), ip = sr("diffStatus"), Ku = class extends v0.default { constructor(e, t) { super(), Object.defineProperty(this, ip, { value: g5 }), Object.defineProperty(this, Br, { value: m5 }), Object.defineProperty(this, tp, { value: f5 }), Object.defineProperty(this, Ti, { value: p5 }), Object.defineProperty(this, ep, { value: c5 }), Object.defineProperty(this, op, { value: h5 }), Object.defineProperty(this, no, { writable: !0, value: void 0 }), Object.defineProperty(this, Ya, { writable: !0, value: void 0 }), Object.defineProperty(this, oo, { writable: !0, value: !1 }), Object.defineProperty(this, ze, { writable: !0, value: void 0 }), this.status = e, this.pollInterval = null, this.closed = !1, he(this, no)[no] = t, he(this, Ya)[Ya] = t.wrapPromiseFunction(Ss) } connect() { he(this, ep)[ep](), he(this, tp)[tp]() } update() { return he(this, Br)[Br]({ diff: !0 }) } updateStatus(e) { he(this, ip)[ip](this.status, e), this.status = e } close() { this.closed = !0, he(this, ze)[ze] && (he(this, ze)[ze].close(), he(this, ze)[ze] = null), clearInterval(this.pollInterval), this.pollInterval = null } }; n(Ku, "TransloaditAssembly"); function h5() { this.emit("finished"), this.close() } n(h5, "_onFinished2"); function c5() { he(this, ze)[ze] = new EventSource(`${this.status.websocket_url}?assembly=${this.status.assembly_id}`), he(this, ze)[ze].addEventListener("open", () => { this.socket && (this.socket.disconnect(), this.socket = null), clearInterval(this.pollInterval), this.pollInterval = null }), he(this, ze)[ze].addEventListener("message", i => { i.data === "assembly_finished" && he(this, op)[op](), i.data === "assembly_uploading_finished" && this.emit("executing"), i.data === "assembly_upload_meta_data_extracted" && (this.emit("metadata"), he(this, Br)[Br]({ diff: !1 })) }), he(this, ze)[ze].addEventListener("assembly_upload_finished", i => { let e = JSON.parse(i.data); this.emit("upload", e), this.status.uploads.push(e) }), he(this, ze)[ze].addEventListener("assembly_result_finished", i => { var e, t; let [r, s] = JSON.parse(i.data); this.emit("result", r, s), ((t = (e = this.status.results)[r]) != null ? t : e[r] = []).push(s) }), he(this, ze)[ze].addEventListener("assembly_execution_progress", i => { let e = JSON.parse(i.data); this.emit("execution-progress", e) }), he(this, ze)[ze].addEventListener("assembly_error", i => { try { he(this, Ti)[Ti](JSON.parse(i.data)) } catch { he(this, Ti)[Ti]({ msg: i.data }) } he(this, Br)[Br]({ diff: !1 }) }) } n(c5, "_connectServerSentEvents2"); function p5(i) { this.emit("error", Object.assign(new Error(i.msg), i)), this.close() } n(p5, "_onError2"); function f5() { this.pollInterval = setInterval(() => { he(this, Br)[Br]() }, 2e3) } n(f5, "_beginPolling2"); async function m5(i) { let { diff: e = !0 } = i === void 0 ? {} : i; if (!(this.closed || he(this, no)[no].isPaused || he(this, oo)[oo])) try { he(this, oo)[oo] = !0; let t = await he(this, Ya)[Ya](this.status.assembly_ssl_url); if (he(this, oo)[oo] = !1, this.closed) return; if (t.status === 429) { he(this, no)[no].rateLimit(2e3); return } if (!t.ok) { he(this, Ti)[Ti](new wi(t.statusText)); return } let r = await t.json(); if (this.closed) return; this.emit("status", r), e ? this.updateStatus(r) : this.status = r } catch (t) { he(this, Ti)[Ti](t) } } n(m5, "_fetchStatus2"); function g5(i, e) { let t = i.ok, r = e.ok; if (e.error && !i.error) return he(this, Ti)[Ti](e); let s = Gu(r, rp) && !Gu(t, rp); s && this.emit("executing"), Object.keys(e.uploads).filter(o => !Et(i.uploads, o)).forEach(o => { this.emit("upload", e.uploads[o]) }), s && this.emit("metadata"), Object.keys(e.results).forEach(o => { let a = e.results[o], l = i.results[o]; a.filter(d => !l || !l.some(p => p.id === d.id)).forEach(d => { this.emit("result", o, d) }) }), Gu(r, sp) && !Gu(t, sp) && this.emit("finished") } n(g5, "_diffStatus2"); var np = Ku; function De(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(De, "_classPrivateFieldLooseBase"); var y5 = 0; function Xu(i) { return "__private_" + y5++ + "_" + i } n(Xu, "_classPrivateFieldLooseKey"); var b0 = "/assemblies", Bt = Xu("headers"), Qa = Xu("fetchWithNetworkError"), gt = Xu("fetchJSON"), li = Xu("reportError"), en = class { constructor(e) { e === void 0 && (e = {}), Object.defineProperty(this, gt, { value: v5 }), Object.defineProperty(this, Bt, { writable: !0, value: {} }), Object.defineProperty(this, Qa, { writable: !0, value: void 0 }), Object.defineProperty(this, li, { writable: !0, value: (t, r) => { if (this.opts.errorReporting === !1) throw t; let s = { type: r.type }; throw r.assembly && (s.assembly = r.assembly.assembly_id, s.instance = r.assembly.instance), r.url && (s.endpoint = r.url), this.submitError(t, s).catch(() => { }), t } }), this.opts = e, this.opts.client != null && (De(this, Bt)[Bt]["Transloadit-Client"] = this.opts.client), De(this, Qa)[Qa] = this.opts.rateLimitedQueue.wrapPromiseFunction(Ss) } createAssembly(e) { let { params: t, fields: r, signature: s, expectedFiles: o } = e, a = new FormData; a.append("params", typeof t == "string" ? t : JSON.stringify(t)), s && a.append("signature", s), Object.keys(r).forEach(d => { a.append(d, r[d]) }), a.append("num_expected_upload_files", o); let l = new URL(b0, `${this.opts.service}`).href; return De(this, gt)[gt](l, { method: "POST", headers: De(this, Bt)[Bt], body: a }).catch(d => De(this, li)[li](d, { url: l, type: "API_ERROR" })) } reserveFile(e, t) { let r = encodeURIComponent(t.size), s = `${e.assembly_ssl_url}/reserve_file?size=${r}`; return De(this, gt)[gt](s, { method: "POST", headers: De(this, Bt)[Bt] }).catch(o => De(this, li)[li](o, { assembly: e, file: t, url: s, type: "API_ERROR" })) } addFile(e, t) { if (!t.uploadURL) return Promise.reject(new Error("File does not have an `uploadURL`.")); let r = encodeURIComponent(t.size), s = encodeURIComponent(t.uploadURL), o = encodeURIComponent(t.name), l = `size=${r}&filename=${o}&fieldname=file&s3Url=${s}`, d = `${e.assembly_ssl_url}/add_file?${l}`; return De(this, gt)[gt](d, { method: "POST", headers: De(this, Bt)[Bt] }).catch(p => De(this, li)[li](p, { assembly: e, file: t, url: d, type: "API_ERROR" })) } updateNumberOfFilesInAssembly(e, t) { let r = new URL(e.assembly_ssl_url); r.pathname = "/update_assemblies"; let s = JSON.stringify({ assembly_updates: [{ assembly_id: e.assembly_id, num_expected_upload_files: t }] }); return De(this, gt)[gt](r, { method: "POST", headers: De(this, Bt)[Bt], body: s }).catch(o => De(this, li)[li](o, { url: r, type: "API_ERROR" })) } cancelAssembly(e) { let t = e.assembly_ssl_url; return De(this, gt)[gt](t, { method: "DELETE", headers: De(this, Bt)[Bt] }).catch(r => De(this, li)[li](r, { url: t, type: "API_ERROR" })) } getAssemblyStatus(e) { return De(this, gt)[gt](e, { headers: De(this, Bt)[Bt] }).catch(t => De(this, li)[li](t, { url: e, type: "STATUS_ERROR" })) } submitError(e, t) { let { endpoint: r, instance: s, assembly: o } = t === void 0 ? {} : t, a = e.details ? `${e.message} (${e.details})` : e.message; return De(this, gt)[gt]("https://transloaditstatus.com/client_error", { method: "POST", body: JSON.stringify({ endpoint: r, instance: s, assembly_id: o, agent: typeof navigator < "u" ? navigator.userAgent : "", client: this.opts.client, error: a }) }) } }; n(en, "Client"); function v5() { for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)e[t] = arguments[t]; return De(this, Qa)[Qa](...e).then(r => { if (r.status === 429) return this.opts.rateLimitedQueue.rateLimit(2e3), De(this, gt)[gt](...e); if (!r.ok) { let s = new Error(r.statusText); return s.statusCode = r.status, `${e[0]}`.endsWith(b0) ? r.json().then(o => { if (!o.error) throw s; let a = new Error(o.error); throw a.details = o.message, a.assembly = o, o.assembly_id && (a.details += ` Assembly ID: ${o.assembly_id}`), a }, o => { throw o.cause = s, o }) : Promise.reject(s) } return r.json() }) } n(v5, "_fetchJSON2"); function ap(i) { if (i == null) throw new Error("Transloadit: The `params` option is required."); if (typeof i == "string") try { i = JSON.parse(i) } catch (e) { throw new gr("Transloadit: The `params` option is a malformed JSON string.", { cause: e }) } if (!i.auth || !i.auth.key) throw new Error("Transloadit: The `params.auth.key` option is required. You can find your Transloadit API key at https://transloadit.com/c/template-credentials") } n(ap, "validateParams"); function b5(i) { let e = Object.create(null); for (let { fileIDs: t, options: r } of i.filter(Boolean)) { let s = JSON.stringify(r); s in e ? e[s].fileIDArrays.push(t) : e[s] = { options: r, fileIDArrays: [t] } } return Object.values(e).map(t => { let { options: r, fileIDArrays: s } = t; return { options: r, fileIDs: s.flat(1) } }) } n(b5, "dedupe"); async function w0(i, e) { let t = typeof e.assemblyOptions == "function" ? await e.assemblyOptions(i, e) : e.assemblyOptions; ap(t.params); let { fields: r } = t; return Array.isArray(r) ? t.fields = i == null ? {} : Object.fromEntries(r.map(s => [s, i.meta[s]])) : r == null && (t.fields = {}), t } n(w0, "getAssemblyOptions"); var Yu = class { constructor(e, t) { this.files = e, this.opts = t } async build() { let e = this.opts; if (this.files.length > 0) return Promise.all(this.files.map(async t => { if (t == null) return; let r = await w0(t, e); if (t != null) return { fileIDs: [t.id], options: r } })).then(b5); if (e.alwaysRunAssembly) { let t = await w0(null, e); return [{ fileIDs: [], options: t }] } return [] } }; n(Yu, "AssemblyOptions"); var S0 = Yu; var P0 = de(Zc(), 1); function se(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(se, "_classPrivateFieldLooseBase"); var w5 = 0; function ui(i) { return "__private_" + w5++ + "_" + i } n(ui, "_classPrivateFieldLooseKey"); var Ja = ui("assemblyIDs"), lp = ui("reject"), lo = ui("remaining"), Za = ui("resolve"), Oe = ui("uppy"), Lr = ui("watching"), el = ui("onAssemblyComplete"), tl = ui("onAssemblyCancel"), uo = ui("onAssemblyError"), il = ui("onImportError"), ao = ui("checkAllComplete"), dp = ui("removeListeners"), up = ui("addListeners"), Qu = class extends P0.default { constructor(e, t) { super(), Object.defineProperty(this, up, { value: F5 }), Object.defineProperty(this, dp, { value: _5 }), Object.defineProperty(this, ao, { value: P5 }), Object.defineProperty(this, Lr, { value: S5 }), Object.defineProperty(this, Ja, { writable: !0, value: void 0 }), Object.defineProperty(this, lp, { writable: !0, value: void 0 }), Object.defineProperty(this, lo, { writable: !0, value: void 0 }), Object.defineProperty(this, Za, { writable: !0, value: void 0 }), Object.defineProperty(this, Oe, { writable: !0, value: void 0 }), Object.defineProperty(this, el, { writable: !0, value: r => { se(this, Lr)[Lr](r.assembly_id) && (se(this, Oe)[Oe].log(`[Transloadit] AssemblyWatcher: Got Assembly finish ${r.assembly_id}`), this.emit("assembly-complete", r.assembly_id), se(this, ao)[ao]()) } }), Object.defineProperty(this, tl, { writable: !0, value: r => { se(this, Lr)[Lr](r.assembly_id) && se(this, ao)[ao]() } }), Object.defineProperty(this, uo, { writable: !0, value: (r, s) => { se(this, Lr)[Lr](r.assembly_id) && (se(this, Oe)[Oe].log(`[Transloadit] AssemblyWatcher: Got Assembly error ${r.assembly_id}`), se(this, Oe)[Oe].log(s), this.emit("assembly-error", r.assembly_id, s), se(this, ao)[ao]()) } }), Object.defineProperty(this, il, { writable: !0, value: (r, s, o) => { se(this, Lr)[Lr](r.assembly_id) && se(this, uo)[uo](r, o) } }), se(this, Oe)[Oe] = e, se(this, Ja)[Ja] = t, se(this, lo)[lo] = t.length, this.promise = new Promise((r, s) => { se(this, Za)[Za] = r, se(this, lp)[lp] = s }), se(this, up)[up]() } }; n(Qu, "TransloaditAssemblyWatcher"); function S5(i) { return se(this, Ja)[Ja].indexOf(i) !== -1 } n(S5, "_watching2"); function P5() { se(this, lo)[lo] -= 1, se(this, lo)[lo] === 0 && (se(this, dp)[dp](), se(this, Za)[Za]()) } n(P5, "_checkAllComplete2"); function _5() { se(this, Oe)[Oe].off("transloadit:complete", se(this, el)[el]), se(this, Oe)[Oe].off("transloadit:assembly-cancel", se(this, tl)[tl]), se(this, Oe)[Oe].off("transloadit:assembly-error", se(this, uo)[uo]), se(this, Oe)[Oe].off("transloadit:import-error", se(this, il)[il]) } n(_5, "_removeListeners2"); function F5() { se(this, Oe)[Oe].on("transloadit:complete", se(this, el)[el]), se(this, Oe)[Oe].on("transloadit:assembly-cancel", se(this, tl)[tl]), se(this, Oe)[Oe].on("transloadit:assembly-error", se(this, uo)[uo]), se(this, Oe)[Oe].on("transloadit:import-error", se(this, il)[il]) } n(F5, "_addListeners2"); var _0 = Qu; var F0 = { strings: { creatingAssembly: "Preparing upload...", creatingAssemblyFailed: "Transloadit: Could not create Assembly", encoding: "Encoding..." } }; function ae(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(ae, "_classPrivateFieldLooseBase"); var x5 = 0; function Ne(i) { return "__private_" + x5++ + "_" + i } n(Ne, "_classPrivateFieldLooseKey"); var O5 = { version: "3.3.1" }, x0 = n(i => e => { let t = new gr("Failed to send error to the client", { cause: e }); console.error(t, i) }, "sendErrorToConsole"), Pp = "https://api2.transloadit.com/companion", _p = /\.transloadit\.com$/, E5 = /https?:\/\/api2(?:-\w+)?\.transloadit\.com\/companion/, Ri = Ne("rateLimitedQueue"), hp = Ne("getClientVersion"), bp = Ne("attachAssemblyMetadata"), cp = Ne("createAssembly"), rl = Ne("createAssemblyWatcher"), pp = Ne("shouldWaitAfterUpload"), fp = Ne("reserveFiles"), sl = Ne("onFileUploadURLAvailable"), dl = Ne("findFile"), wp = Ne("onFileUploadComplete"), Sp = Ne("onResult"), ul = Ne("onAssemblyFinished"), hl = Ne("cancelAssembly"), mp = Ne("onCancelAll"), gp = Ne("getPersistentData"), yp = Ne("onRestored"), ol = Ne("connectAssembly"), nl = Ne("prepareUpload"), ho = Ne("afterUpload"), al = Ne("closeAssemblyIfExists"), ll = Ne("onError"), vp = Ne("onTusError"), mi = class extends Se { constructor(e, t) { var r, s, o, a; super(e, t), r = this, Object.defineProperty(this, ol, { value: L5 }), Object.defineProperty(this, hl, { value: B5 }), Object.defineProperty(this, ul, { value: M5 }), Object.defineProperty(this, Sp, { value: N5 }), Object.defineProperty(this, wp, { value: I5 }), Object.defineProperty(this, dl, { value: D5 }), Object.defineProperty(this, fp, { value: k5 }), Object.defineProperty(this, pp, { value: U5 }), Object.defineProperty(this, rl, { value: R5 }), Object.defineProperty(this, cp, { value: T5 }), Object.defineProperty(this, bp, { value: A5 }), Object.defineProperty(this, hp, { value: C5 }), Object.defineProperty(this, Ri, { writable: !0, value: void 0 }), Object.defineProperty(this, sl, { writable: !0, value: d => { var p; let h = this.uppy.getFile(d.id); if (!(h != null && (p = h.transloadit) != null && p.assembly)) return; let { assemblies: m } = this.getPluginState(), y = m[h.transloadit.assembly]; this.client.addFile(y, h).catch(b => { this.uppy.log(b), this.uppy.emit("transloadit:import-error", y, h.id, b) }) } }), Object.defineProperty(this, mp, { writable: !0, value: async function (d) { let { reason: p } = d === void 0 ? {} : d; try { if (p !== "user") return; let { uploadsAssemblies: h } = r.getPluginState(), y = Object.values(h).flat(1).map(b => r.getAssembly(b)); await Promise.all(y.map(b => ae(r, hl)[hl](b))) } catch (h) { r.uppy.log(h) } } }), Object.defineProperty(this, gp, { writable: !0, value: d => { let { assemblies: p, uploadsAssemblies: h } = this.getPluginState(); d({ [this.id]: { assemblies: p, uploadsAssemblies: h } }) } }), Object.defineProperty(this, yp, { writable: !0, value: d => { let p = d && d[this.id] ? d[this.id] : {}, h = p.assemblies || {}, m = p.uploadsAssemblies || {}; if (Object.keys(m).length === 0) return; let y = n(O => { let F = {}, x = []; for (let [U, H] of Object.entries(O)) { H.uploads.forEach(J => { let L = ae(this, dl)[dl](J); F[J.id] = { id: L.id, assembly: U, uploadedFile: J } }); let W = this.getPluginState(); Object.keys(H.results).forEach(J => { for (let L of H.results[J]) { let G = W.files[L.original_id]; L.localId = G ? G.id : null, x.push({ id: L.id, result: L, stepName: J, assembly: U }) } }) } this.setPluginState({ assemblies: O, files: F, results: x, uploadsAssemblies: m }) }, "restoreState"), b = n(() => { let { assemblies: O, uploadsAssemblies: F } = this.getPluginState(); Object.keys(F).forEach(U => { let H = F[U]; ae(this, rl)[rl](H, U) }), Object.keys(O).forEach(U => { let H = new np(O[U], ae(this, Ri)[Ri]); ae(this, ol)[ol](H) }) }, "restoreAssemblies"), S = n(() => { let { assemblies: O } = this.getPluginState(); return Promise.all(Object.keys(O).map(F => this.activeAssemblies[F].update())) }, "updateAssemblies"); this.restored = Promise.resolve().then(() => (y(h), b(), S())), this.restored.then(() => { this.restored = null }) } }), Object.defineProperty(this, nl, { writable: !0, value: (d, p) => { let m = d.map(O => this.uppy.getFile(O)).filter(O => O.error ? !1 : (this.uppy.emit("preprocess-progress", O, { mode: "indeterminate", message: this.i18n("creatingAssembly") }), !0)), y = n(async O => { let { fileIDs: F, options: x } = O; try { let U = await ae(this, cp)[cp](F, p, x); return this.opts.importFromUploadURLs && await ae(this, fp)[fp](U, F), F.forEach(H => { let W = this.uppy.getFile(H); this.uppy.emit("preprocess-complete", W) }), U } catch (U) { throw F.forEach(H => { let W = this.uppy.getFile(H); this.uppy.emit("preprocess-complete", W), this.uppy.emit("upload-error", W, U) }), U } }, "createAssembly"), { uploadsAssemblies: b } = this.getPluginState(); return this.setPluginState({ uploadsAssemblies: { ...b, [p]: [] } }), new S0(m, this.opts).build().then(O => Promise.all(O.map(y))).then(O => { let F = O.filter(Boolean), x = F.map(U => U.status.assembly_id); return ae(this, rl)[rl](x, p), Promise.all(F.map(U => ae(this, ol)[ol](U))) }).catch(O => { throw m.forEach(F => { this.uppy.emit("preprocess-complete", F), this.uppy.emit("upload-error", F, O) }), O }) } }), Object.defineProperty(this, ho, { writable: !0, value: (d, p) => { let h = d.map(x => this.uppy.getFile(x)), m = h.filter(x => !x.error).map(x => x.id), y = this.getPluginState(); if (this.restored) return this.restored.then(() => ae(this, ho)[ho](m, p)); let b = y.uploadsAssemblies[p], S = n(() => { b.forEach(x => { this.activeAssemblies[x].close(), delete this.activeAssemblies[x] }) }, "closeSocketConnections"); if (!ae(this, pp)[pp]()) { S(); let x = b.map(U => this.getAssembly(U)); return this.uppy.addResultData(p, { transloadit: x }), Promise.resolve() } return b.length === 0 ? (this.uppy.addResultData(p, { transloadit: [] }), Promise.resolve()) : (h.filter(x => !Et(this.completedFiles, x.id)).forEach(x => { this.uppy.emit("postprocess-progress", x, { mode: "indeterminate", message: this.i18n("encoding") }) }), this.assemblyWatchers[p].promise.then(() => { S(); let x = b.map(H => this.getAssembly(H)), U = { ...this.getPluginState().uploadsAssemblies }; delete U[p], this.setPluginState({ uploadsAssemblies: U }), this.uppy.addResultData(p, { transloadit: x }) })) } }), Object.defineProperty(this, al, { writable: !0, value: d => { var p; (p = this.activeAssemblies[d]) == null || p.close() } }), Object.defineProperty(this, ll, { writable: !0, value: function (d, p) { d === void 0 && (d = null); let m = r.getPluginState().uploadsAssemblies[p]; m?.forEach(ae(r, al)[al]), r.client.submitError(d).catch(x0(d)) } }), Object.defineProperty(this, vp, { writable: !0, value: (d, p) => { var h, m; if (ae(this, al)[al](d == null || (h = d.transloadit) == null ? void 0 : h.assembly), p != null && (m = p.message) != null && m.startsWith("tus: ")) { var y; let b = (y = p.originalRequest) == null || (y = y.getUnderlyingObject()) == null ? void 0 : y.responseURL; this.client.submitError(p, { endpoint: b, type: "TUS_ERROR" }).catch(x0(p)) } } }), this.type = "uploader", this.id = this.opts.id || "Transloadit", this.title = "Transloadit", this.defaultLocale = F0; let l = { service: "https://api2.transloadit.com", errorReporting: !0, waitForEncoding: !1, waitForMetadata: !1, alwaysRunAssembly: !1, importFromUploadURLs: !1, signature: null, params: null, fields: null, getAssemblyOptions: null, limit: 20, retryDelays: [7e3, 1e4, 15e3, 2e4] }; this.opts = { ...l, ...t }, (o = (s = this.opts).assemblyOptions) != null || (s.assemblyOptions = (a = this.opts.getAssemblyOptions) != null ? a : { params: this.opts.params, signature: this.opts.signature, fields: this.opts.fields }), t?.params != null && t.getAssemblyOptions == null && t.assemblyOptions == null && ap(this.opts.assemblyOptions.params), ae(this, Ri)[Ri] = new Nt(this.opts.limit), this.i18nInit(), this.client = new en({ service: this.opts.service, client: ae(this, hp)[hp](), errorReporting: this.opts.errorReporting, rateLimitedQueue: ae(this, Ri)[Ri] }), this.activeAssemblies = {}, this.assemblyWatchers = {}, this.completedFiles = Object.create(null) } install() { this.uppy.addPreProcessor(ae(this, nl)[nl]), this.uppy.addPostProcessor(ae(this, ho)[ho]), this.uppy.on("error", ae(this, ll)[ll]), this.uppy.on("cancel-all", ae(this, mp)[mp]), this.uppy.on("upload-error", ae(this, vp)[vp]), this.opts.importFromUploadURLs ? this.uppy.on("upload-success", ae(this, sl)[sl]) : this.uppy.use(rr, { storeFingerprintForResuming: !1, useFastRemoteRetry: !1, allowedMetaFields: ["assembly_url", "filename", "fieldname"], limit: this.opts.limit, rateLimitedQueue: ae(this, Ri)[Ri], retryDelays: this.opts.retryDelays }), this.uppy.on("restore:get-data", ae(this, gp)[gp]), this.uppy.on("restored", ae(this, yp)[yp]), this.setPluginState({ assemblies: {}, uploadsAssemblies: {}, files: {}, results: [] }); let { capabilities: e } = this.uppy.getState(); this.uppy.setState({ capabilities: { ...e, individualCancellation: !1 } }) } uninstall() { this.uppy.removePreProcessor(ae(this, nl)[nl]), this.uppy.removePostProcessor(ae(this, ho)[ho]), this.uppy.off("error", ae(this, ll)[ll]), this.opts.importFromUploadURLs && this.uppy.off("upload-success", ae(this, sl)[sl]); let { capabilities: e } = this.uppy.getState(); this.uppy.setState({ capabilities: { ...e, individualCancellation: !0 } }) } getAssembly(e) { let { assemblies: t } = this.getPluginState(); return t[e] } getAssemblyFiles(e) { return this.uppy.getFiles().filter(t => { var r; return (t == null || (r = t.transloadit) == null ? void 0 : r.assembly) === e }) } }; n(mi, "Transloadit"); function C5() { let i = [`uppy-core:${this.uppy.constructor.VERSION}`, `uppy-transloadit:${this.constructor.VERSION}`, `uppy-tus:${rr.VERSION}`], e = n((t, r) => { let s = this.uppy.getPlugin(t); s && i.push(`${r}:${s.constructor.VERSION}`) }, "addPluginVersion"); return this.opts.importFromUploadURLs && (e("XHRUpload", "uppy-xhr-upload"), e("AwsS3", "uppy-aws-s3"), e("AwsS3Multipart", "uppy-aws-s3-multipart")), e("Dropbox", "uppy-dropbox"), e("Box", "uppy-box"), e("Facebook", "uppy-facebook"), e("GoogleDrive", "uppy-google-drive"), e("Instagram", "uppy-instagram"), e("OneDrive", "uppy-onedrive"), e("Zoom", "uppy-zoom"), e("Url", "uppy-url"), i.join(",") } n(C5, "_getClientVersion2"); function A5(i, e) { let t = { ...i.meta, assembly_url: e.assembly_url, filename: i.name, fieldname: "file" }, r = { ...i.tus, endpoint: e.tus_url, addRequestId: !0 }, { remote: s } = i; if (i.remote && E5.test(i.remote.companionUrl)) { let a = e.companion_url.replace(/\/$/, ""), l = i.remote.url.replace(i.remote.companionUrl, "").replace(/^\//, ""); s = { ...i.remote, companionUrl: a, url: `${a}/${l}` } } let o = { ...i, transloadit: { assembly: e.assembly_id } }; return this.opts.importFromUploadURLs || Object.assign(o, { meta: t, tus: r, remote: s }), o } n(A5, "_attachAssemblyMetadata2"); function T5(i, e, t) { return this.uppy.log("[Transloadit] Create Assembly"), this.client.createAssembly({ ...t, expectedFiles: i.length }).then(async r => { let s = this.uppy.getFiles().filter(y => { let { id: b } = y; return i.includes(b) }); if (s.length !== i.length) { if (s.length === 0) return await this.client.cancelAssembly(r), null; await this.client.updateNumberOfFilesInAssembly(r, s.length) } let o = new np(r, ae(this, Ri)[Ri]), { status: a } = o, l = a.assembly_id, { assemblies: d, uploadsAssemblies: p } = this.getPluginState(); this.setPluginState({ assemblies: { ...d, [l]: a }, uploadsAssemblies: { ...p, [e]: [...p[e], l] } }); let h = {}; s.forEach(y => { h[y.id] = ae(this, bp)[bp](y, a) }), this.uppy.setState({ files: { ...this.uppy.getState().files, ...h } }); let m = n((y, b) => { var S; if (((S = o.status) == null ? void 0 : S.ok) === "ASSEMBLY_COMPLETED") { this.uppy.off("file-removed", m); return } if (b === "cancel-all") o.close(), this.uppy.off("file-removed", m); else if (y.id in h) { delete h[y.id]; let O = Object.keys(h).length; O === 0 ? (o.close(), ae(this, hl)[hl](r).catch(() => { }), this.uppy.off("file-removed", m)) : this.client.updateNumberOfFilesInAssembly(r, O).catch(() => { }) } }, "fileRemovedHandler"); return this.uppy.on("file-removed", m), this.uppy.emit("transloadit:assembly-created", a, i), this.uppy.log(`[Transloadit] Created Assembly ${l}`), o }).catch(r => { let s = new gr(`${this.i18n("creatingAssemblyFailed")}: ${r.message}`, { cause: r }); throw "details" in r && (s.details = r.details), "assembly" in r && (s.assembly = r.assembly), s }) } n(T5, "_createAssembly2"); function R5(i, e) { let t = new _0(this.uppy, i); t.on("assembly-complete", r => { this.getAssemblyFiles(r).forEach(o => { this.completedFiles[o.id] = !0, this.uppy.emit("postprocess-complete", o) }) }), t.on("assembly-error", (r, s) => { let o = this.getAssemblyFiles(r); o.forEach(l => { this.uppy.emit("upload-error", l, s), this.uppy.emit("postprocess-complete", l) }); let a = { ...this.uppy.getState().files }; o.forEach(l => delete a[l.id].tus), this.uppy.setState({ files: a }), this.uppy.emit("error", s) }), this.assemblyWatchers[e] = t } n(R5, "_createAssemblyWatcher2"); function U5() { return this.opts.waitForEncoding || this.opts.waitForMetadata } n(U5, "_shouldWaitAfterUpload2"); function k5(i, e) { return Promise.all(e.map(t => { let r = this.uppy.getFile(t); return this.client.reserveFile(i.status, r) })) } n(k5, "_reserveFiles2"); function D5(i) { let e = this.uppy.getFiles(); for (let t = 0; t < e.length; t++) { let r = e[t]; if (r.uploadURL === i.tus_upload_url || r.tus && r.tus.uploadUrl === i.tus_upload_url || !i.is_tus_file && r.name === i.name && r.size === i.size) return r } } n(D5, "_findFile2"); function I5(i, e) { let t = this.getPluginState(), r = ae(this, dl)[dl](e); if (!r) { this.uppy.log("[Transloadit] Couldn\u2019t find the file, it was likely removed in the process"); return } this.setPluginState({ files: { ...t.files, [e.id]: { assembly: i, id: r.id, uploadedFile: e } } }), this.uppy.emit("transloadit:upload", e, this.getAssembly(i)) } n(I5, "_onFileUploadComplete2"); function N5(i, e, t) { let r = this.getPluginState(), s = r.files[t.original_id]; t.localId = s ? s.id : null; let o = { result: t, stepName: e, id: t.id, assembly: i }; this.setPluginState({ results: [...r.results, o] }), this.uppy.emit("transloadit:result", e, t, this.getAssembly(i)) } n(N5, "_onResult2"); function M5(i) { let e = i.assembly_ssl_url; this.client.getAssemblyStatus(e).then(t => { let r = t.assembly_id, s = this.getPluginState(); this.setPluginState({ assemblies: { ...s.assemblies, [r]: t } }), this.uppy.emit("transloadit:complete", t) }) } n(M5, "_onAssemblyFinished2"); async function B5(i) { await this.client.cancelAssembly(i), this.uppy.emit("transloadit:assembly-cancelled", i) } n(B5, "_cancelAssembly2"); function L5(i) { let { status: e } = i, t = e.assembly_id; return this.activeAssemblies[t] = i, i.on("status", r => { let { assemblies: s } = this.getPluginState(); this.setPluginState({ assemblies: { ...s, [t]: r } }) }), i.on("upload", r => { ae(this, wp)[wp](t, r) }), i.on("error", r => { r.assembly = i.status, this.uppy.emit("transloadit:assembly-error", i.status, r) }), i.on("executing", () => { this.uppy.emit("transloadit:assembly-executing", i.status) }), i.on("execution-progress", r => { if (this.uppy.emit("transloadit:execution-progress", r), r.progress_combined != null) for (let s of this.uppy.getFiles()) this.uppy.emit("postprocess-progress", s, { mode: "determinate", value: r.progress_combined / 100, message: this.i18n("encoding") }) }), this.opts.waitForEncoding && i.on("result", (r, s) => { ae(this, Sp)[Sp](t, r, s) }), this.opts.waitForEncoding ? i.on("finished", () => { ae(this, ul)[ul](i.status) }) : this.opts.waitForMetadata && i.on("metadata", () => { ae(this, ul)[ul](i.status) }), i.ok === "ASSEMBLY_COMPLETE" || i.connect(), i } n(L5, "_connectAssembly2"); mi.VERSION = O5.version; mi.COMPANION = Pp; mi.COMPANION_PATTERN = _p; var O0 = { strings: { uploadStalled: "Upload has not made any progress for %{seconds} seconds. You may want to retry it." } }; function tn(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(tn, "_classPrivateFieldLooseBase"); var j5 = 0; function pl(i) { return "__private_" + j5++ + "_" + i } n(pl, "_classPrivateFieldLooseKey"); var z5 = { version: "3.4.1" }; function E0(i, e) { let t = e; return t || (t = new Error("Upload error")), typeof t == "string" && (t = new Error(t)), t instanceof Error || (t = Object.assign(new Error("Upload error"), { data: t })), to(i) ? (t = new wi(t, i), t) : (t.request = i, t) } n(E0, "buildResponseError"); function C0(i) { return i.data.slice(0, i.data.size, i.meta.type) } n(C0, "setTypeInBlob"); var Op = pl("uploadLocalFile"), Fp = pl("uploadBundle"), Ep = pl("getCompanionClientArgs"), xp = pl("uploadFiles"), cl = pl("handleUpload"), co = class extends Se { constructor(e, t) { super(e, t), Object.defineProperty(this, xp, { value: V5 }), Object.defineProperty(this, Ep, { value: q5 }), Object.defineProperty(this, Fp, { value: $5 }), Object.defineProperty(this, Op, { value: H5 }), Object.defineProperty(this, cl, { writable: !0, value: async s => { if (s.length === 0) { this.uppy.log("[XHRUpload] No files to upload!"); return } this.opts.limit === 0 && !this.opts[us] && this.uppy.log("[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0", "warning"), this.uppy.log("[XHRUpload] Uploading..."); let o = this.uppy.getFilesByIds(s), a = ds(o), l = hs(a); if (this.uppy.emit("upload-start", l), this.opts.bundle) { if (a.some(p => p.isRemote)) throw new Error("Can\u2019t upload remote files when the `bundle: true` option is set"); if (typeof this.opts.headers == "function") throw new TypeError("`headers` may not be a function when the `bundle: true` option is set"); await tn(this, Fp)[Fp](a) } else await tn(this, xp)[xp](a) } }), this.type = "uploader", this.id = this.opts.id || "XHRUpload", this.title = "XHRUpload", this.defaultLocale = O0; let r = { formData: !0, fieldName: t.bundle ? "files[]" : "file", method: "post", allowedMetaFields: null, responseUrlFieldName: "url", bundle: !1, headers: {}, timeout: 30 * 1e3, limit: 5, withCredentials: !1, responseType: "", getResponseData(s) { let o = {}; try { o = JSON.parse(s) } catch (a) { e.log(a) } return o }, getResponseError(s, o) { let a = new Error("Upload error"); return to(o) && (a = new wi(a, o)), a }, validateStatus(s) { return s >= 200 && s < 300 } }; if (this.opts = { ...r, ...t }, this.i18nInit(), us in this.opts ? this.requests = this.opts[us] : this.requests = new Nt(this.opts.limit), this.opts.bundle && !this.opts.formData) throw new Error("`opts.formData` must be true when `opts.bundle` is enabled."); if (t?.allowedMetaFields === void 0 && "metaFields" in this.opts) throw new Error("The `metaFields` option has been renamed to `allowedMetaFields`."); this.uploaderEvents = Object.create(null) } getOptions(e) { let t = this.uppy.getState().xhrUpload, { headers: r } = this.opts, s = { ...this.opts, ...t || {}, ...e.xhrUpload || {}, headers: {} }; return typeof r == "function" ? s.headers = r(e) : Object.assign(s.headers, this.opts.headers), t && Object.assign(s.headers, t.headers), e.xhrUpload && Object.assign(s.headers, e.xhrUpload.headers), s } addMetadata(e, t, r) { (Array.isArray(r.allowedMetaFields) ? r.allowedMetaFields : Object.keys(t)).forEach(o => { Array.isArray(t[o]) ? t[o].forEach(a => e.append(o, a)) : e.append(o, t[o]) }) } createFormDataUpload(e, t) { let r = new FormData; this.addMetadata(r, e.meta, t); let s = C0(e); return e.name ? r.append(t.fieldName, s, e.meta.name) : r.append(t.fieldName, s), r } createBundledUpload(e, t) { let r = new FormData, { meta: s } = this.uppy.getState(); return this.addMetadata(r, s, t), e.forEach(o => { let a = this.getOptions(o), l = C0(o); o.name ? r.append(a.fieldName, l, o.name) : r.append(a.fieldName, l) }), r } install() { if (this.opts.bundle) { let { capabilities: e } = this.uppy.getState(); this.uppy.setState({ capabilities: { ...e, individualCancellation: !1 } }) } this.uppy.addUploader(tn(this, cl)[cl]) } uninstall() { if (this.opts.bundle) { let { capabilities: e } = this.uppy.getState(); this.uppy.setState({ capabilities: { ...e, individualCancellation: !0 } }) } this.uppy.removeUploader(tn(this, cl)[cl]) } }; n(co, "XHRUpload"); async function H5(i, e, t) { let r = this.getOptions(i); return this.uppy.log(`uploading ${e} of ${t}`), new Promise((s, o) => { let a = r.formData ? this.createFormDataUpload(i, r) : i.data, l = new XMLHttpRequest, d = new $t(this.uppy); this.uploaderEvents[i.id] = d; let p, h = new ja(r.timeout, () => { let y = new Error(this.i18n("uploadStalled", { seconds: Math.ceil(r.timeout / 1e3) })); this.uppy.emit("upload-stalled", y, [i]) }), m = St(); l.upload.addEventListener("loadstart", () => { this.uppy.log(`[XHRUpload] ${m} started`) }), l.upload.addEventListener("progress", y => { this.uppy.log(`[XHRUpload] ${m} progress: ${y.loaded} / ${y.total}`), h.progress(), y.lengthComputable && this.uppy.emit("upload-progress", i, { uploader: this, bytesUploaded: y.loaded, bytesTotal: y.total }) }), l.addEventListener("load", () => { if (this.uppy.log(`[XHRUpload] ${m} finished`), h.done(), p.done(), this.uploaderEvents[i.id] && (this.uploaderEvents[i.id].remove(), this.uploaderEvents[i.id] = null), r.validateStatus(l.status, l.responseText, l)) { let O = r.getResponseData(l.responseText, l), F = O[r.responseUrlFieldName], x = { status: l.status, body: O, uploadURL: F }; return this.uppy.emit("upload-success", i, x), F && this.uppy.log(`Download ${i.name} from ${F}`), s(i) } let y = r.getResponseData(l.responseText, l), b = E0(l, r.getResponseError(l.responseText, l)), S = { status: l.status, body: y }; return this.uppy.emit("upload-error", i, b, S), o(b) }), l.addEventListener("error", () => { this.uppy.log(`[XHRUpload] ${m} errored`), h.done(), p.done(), this.uploaderEvents[i.id] && (this.uploaderEvents[i.id].remove(), this.uploaderEvents[i.id] = null); let y = E0(l, r.getResponseError(l.responseText, l)); return this.uppy.emit("upload-error", i, y), o(y) }), l.open(r.method.toUpperCase(), r.endpoint, !0), l.withCredentials = r.withCredentials, r.responseType !== "" && (l.responseType = r.responseType), p = this.requests.run(() => { let y = this.getOptions(i); return Object.keys(y.headers).forEach(b => { l.setRequestHeader(b, y.headers[b]) }), l.send(a), () => { h.done(), l.abort() } }), d.onFileRemove(i.id, () => { p.abort(), o(new Error("File removed")) }), d.onCancelAll(i.id, y => { let { reason: b } = y; b === "user" && p.abort(), o(new Error("Upload cancelled")) }) }) } n(H5, "_uploadLocalFile2"); function $5(i) { return new Promise((e, t) => { let { endpoint: r } = this.opts, { method: s } = this.opts, o = this.uppy.getState().xhrUpload, a = this.createBundledUpload(i, { ...this.opts, ...o || {} }), l = new XMLHttpRequest, d = n(h => { i.forEach(m => { this.uppy.emit("upload-error", m, h) }) }, "emitError"), p = new ja(this.opts.timeout, () => { let h = new Error(this.i18n("uploadStalled", { seconds: Math.ceil(this.opts.timeout / 1e3) })); this.uppy.emit("upload-stalled", h, i) }); l.upload.addEventListener("loadstart", () => { this.uppy.log("[XHRUpload] started uploading bundle"), p.progress() }), l.upload.addEventListener("progress", h => { p.progress(), h.lengthComputable && i.forEach(m => { this.uppy.emit("upload-progress", m, { uploader: this, bytesUploaded: h.loaded / h.total * m.size, bytesTotal: m.size }) }) }), l.addEventListener("load", h => { if (p.done(), this.opts.validateStatus(h.target.status, l.responseText, l)) { let y = this.opts.getResponseData(l.responseText, l), b = { status: h.target.status, body: y }; return i.forEach(S => { this.uppy.emit("upload-success", S, b) }), e() } let m = this.opts.getResponseError(l.responseText, l) || new Error("Upload error"); return m.request = l, d(m), t(m) }), l.addEventListener("error", () => { p.done(); let h = this.opts.getResponseError(l.responseText, l) || new Error("Upload error"); return d(h), t(h) }), this.uppy.on("cancel-all", function (h) { let { reason: m } = h === void 0 ? {} : h; m === "user" && (p.done(), l.abort()) }), l.open(s.toUpperCase(), r, !0), l.withCredentials = this.opts.withCredentials, this.opts.responseType !== "" && (l.responseType = this.opts.responseType), Object.keys(this.opts.headers).forEach(h => { l.setRequestHeader(h, this.opts.headers[h]) }), l.send(a) }) } n($5, "_uploadBundle2"); function q5(i) { let e = this.getOptions(i), t = Array.isArray(e.allowedMetaFields) ? e.allowedMetaFields : Object.keys(i.meta); return { ...i.remote.body, protocol: "multipart", endpoint: e.endpoint, size: i.data.size, fieldname: e.fieldName, metadata: Object.fromEntries(t.map(r => [r, i.meta[r]])), httpMethod: e.method, useFormData: e.formData, headers: e.headers } } n(q5, "_getCompanionClientArgs2"); async function V5(i) { await Promise.allSettled(i.map((e, t) => { let r = parseInt(t, 10) + 1, s = i.length; if (e.isRemote) { let o = e.remote.providerOptions.provider ? ne : xe, a = n(() => this.requests, "getQueue"), l = new o(this.uppy, e.remote.providerOptions, a), d = new AbortController, p = n(m => { m.id === e.id && d.abort() }, "removedHandler"); this.uppy.on("file-removed", p); let h = l.uploadRemoteFile(e, tn(this, Ep)[Ep](e), { signal: d.signal }); return this.requests.wrapSyncFunction(() => { this.uppy.off("file-removed", p) }, { priority: -1 })(), h } return tn(this, Op)[Op](e, r, s) })) } n(V5, "_uploadFiles2"); co.VERSION = z5.version; var Tp = de(Rl(), 1), U0 = de(A0(), 1); var T0 = { strings: { compressingImages: "Compressing images...", compressedX: "Saved %{size} by compressing images" } }; function R0(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(R0, "_classPrivateFieldLooseBase"); var W5 = 0; function G5(i) { return "__private_" + W5++ + "_" + i } n(G5, "_classPrivateFieldLooseKey"); var fl = G5("RateLimitedQueue"), rn = class extends Se { constructor(e, t) { super(e, t), Object.defineProperty(this, fl, { writable: !0, value: void 0 }), this.id = this.opts.id || "Compressor", this.type = "modifier", this.defaultLocale = T0; let r = { quality: .6, limit: 10 }; this.opts = { ...r, ...t }, R0(this, fl)[fl] = new Nt(this.opts.limit), this.i18nInit(), this.prepareUpload = this.prepareUpload.bind(this), this.compress = this.compress.bind(this) } compress(e) { return new Promise((t, r) => { new U0.default(e, { ...this.opts, success: t, error: r }) }) } async prepareUpload(e) { let t = 0, r = [], s = R0(this, fl)[fl].wrapPromiseFunction(async a => { try { let l = await this.compress(a.data), d = a.data.size - l.size; this.uppy.log(`[Image Compressor] Image ${a.id} compressed by ${(0, Tp.default)(d)}`), t += d; let { name: p, type: h, size: m } = l, y = Mi(p), S = `${Mi(a.meta.name).name}.${y.extension}`; this.uppy.setFileState(a.id, { ...p && { name: p }, ...y.extension && { extension: y.extension }, ...h && { type: h }, ...m && { size: m }, data: l, meta: { ...a.meta, type: h, name: S } }), r.push(a) } catch (l) { this.uppy.log(`[Image Compressor] Failed to compress ${a.id}:`, "warning"), this.uppy.log(l, "warning") } }), o = e.map(a => { let l = this.uppy.getFile(a); return this.uppy.emit("preprocess-progress", l, { mode: "indeterminate", message: this.i18n("compressingImages") }), l.isRemote || (l.data.type || (l.data = l.data.slice(0, l.data.size, l.type)), !l.type.startsWith("image/")) ? Promise.resolve() : s(l) }); await Promise.all(o), this.uppy.emit("compressor:complete", r), t > 1024 && this.uppy.info(this.i18n("compressedX", { size: (0, Tp.default)(t) }), "info"); for (let a of e) { let l = this.uppy.getFile(a); this.uppy.emit("preprocess-complete", l) } } install() { this.uppy.addPreProcessor(this.prepareUpload) } uninstall() { this.uppy.removePreProcessor(this.prepareUpload) } }; n(rn, "Compressor"); function Ju() { return Ju = Object.assign || function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, Ju.apply(this, arguments) } n(Ju, "_extends"); var K5 = { "[object HTMLCollection]": !0, "[object NodeList]": !0, "[object RadioNodeList]": !0 }, X5 = { button: !0, fieldset: !0, reset: !0, submit: !0 }, Y5 = { checkbox: !0, radio: !0 }, Q5 = /^\s+|\s+$/g, J5 = Array.prototype.slice, k0 = Object.prototype.toString; function Zu(i, e) { if (!i) throw new Error("A form is required by getFormData, was given form=" + i); e = Ju({ includeDisabled: !1, trim: !1 }, e); for (var t = {}, r, s = [], o = {}, a = 0, l = i.elements.length; a < l; a++) { var d = i.elements[a]; X5[d.type] || d.disabled && !e.includeDisabled || (r = d.name || d.id, r && !o[r] && (s.push(r), o[r] = !0)) } for (var p = 0, h = s.length; p < h; p++) { r = s[p]; var m = I0(i, r, e); m != null && (t[r] = m) } return t } n(Zu, "getFormData"); function I0(i, e, t) { if (!i) throw new Error("A form is required by getFieldData, was given form=" + i); if (!e && k0.call(e) !== "[object String]") throw new Error("A field name is required by getFieldData, was given fieldName=" + e); t = Ju({ includeDisabled: !1, trim: !1 }, t); var r = i.elements[e]; if (!r || r.disabled && !t.includeDisabled) return null; if (!K5[k0.call(r)]) return D0(r, t.trim); for (var s = [], o = !0, a = 0, l = r.length; a < l; a++)if (!(r[a].disabled && !t.includeDisabled)) { o && r[a].type !== "radio" && (o = !1); var d = D0(r[a], t.trim); d != null && (s = s.concat(d)) } return o && s.length === 1 ? s[0] : s.length > 0 ? s : null } n(I0, "getFieldData"); function D0(i, e) { var t = null, r = i.type; if (r === "select-one") return i.options.length && (t = i.options[i.selectedIndex].value), t; if (r === "select-multiple") { t = []; for (var s = 0, o = i.options.length; s < o; s++)i.options[s].selected && t.push(i.options[s].value); return t.length === 0 && (t = null), t } return r === "file" && "files" in i ? (i.multiple ? (t = J5.call(i.files), t.length === 0 && (t = null)) : t = i.files[0], t) : (Y5[r] ? i.checked && (r === "checkbox" && !i.hasAttribute("value") ? t = !0 : t = i.value) : t = e ? i.value.replace(Q5, "") : i.value, t) } n(D0, "getFormElementValue"); Zu.getFieldData = I0; var Z5 = { version: "3.0.2" }, po = class extends Se { constructor(e, t) { super(e, t), this.type = "acquirer", this.id = this.opts.id || "Form", this.title = "Form"; let r = { target: null, resultName: "uppyResult", getMetaFromForm: !0, addResultToForm: !0, submitOnSuccess: !1, triggerUploadOnSubmit: !1 }; this.opts = { ...r, ...t }, this.handleFormSubmit = this.handleFormSubmit.bind(this), this.handleUploadStart = this.handleUploadStart.bind(this), this.handleSuccess = this.handleSuccess.bind(this), this.addResultToForm = this.addResultToForm.bind(this), this.getMetaFromForm = this.getMetaFromForm.bind(this) } handleUploadStart() { this.opts.getMetaFromForm && this.getMetaFromForm() } handleSuccess(e) { this.opts.addResultToForm && this.addResultToForm(e), this.opts.submitOnSuccess && this.form.submit() } handleFormSubmit(e) { if (this.opts.triggerUploadOnSubmit) { e.preventDefault(); let t = Ke(e.target.elements), r = []; t.forEach(s => { (s.tagName === "BUTTON" || s.tagName === "INPUT" && s.type === "submit") && !s.disabled && (s.disabled = !0, r.push(s)) }), this.uppy.upload().then(() => { r.forEach(s => { s.disabled = !1 }) }, s => (r.forEach(o => { o.disabled = !1 }), Promise.reject(s))).catch(s => { this.uppy.log(s.stack || s.message || s) }) } } addResultToForm(e) { this.uppy.log("[Form] Adding result to the original form:"), this.uppy.log(e); let t = this.form.querySelector(`[name="${this.opts.resultName}"]`); if (t) { let r; try { r = JSON.parse(t.value) } catch { } Array.isArray(r) || (r = []), r.push(e), t.value = JSON.stringify(r); return } t = document.createElement("input"), t.name = this.opts.resultName, t.type = "hidden", t.value = JSON.stringify([e]), this.form.appendChild(t) } getMetaFromForm() { let e = Zu(this.form); delete e[this.opts.resultName], this.uppy.setMeta(e) } install() { if (this.form = xn(this.opts.target), !this.form || this.form.nodeName !== "FORM") { this.uppy.log("Form plugin requires a <form> target element passed in options to operate, none was found", "error"); return } this.form.addEventListener("submit", this.handleFormSubmit), this.uppy.on("upload", this.handleUploadStart), this.uppy.on("complete", this.handleSuccess) } uninstall() { this.form.removeEventListener("submit", this.handleFormSubmit), this.uppy.off("upload", this.handleUploadStart), this.uppy.off("complete", this.handleSuccess) } }; n(po, "Form"); po.VERSION = Z5.version; var G0 = de(El(), 1); function fo(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(fo, "_classPrivateFieldLooseBase"); var eF = 0; function tF(i) { return "__private_" + eF++ + "_" + i } n(tF, "_classPrivateFieldLooseKey"); var N0 = typeof navigator < "u" && "serviceWorker" in navigator; function iF() { return new Promise((i, e) => { N0 ? navigator.serviceWorker.controller ? i() : navigator.serviceWorker.addEventListener("controllerchange", () => { i() }) : e(new Error("Unsupported")) }) } n(iF, "waitForServiceWorker"); var Lt = tF("ready"), ml = class { constructor(e) { Object.defineProperty(this, Lt, { writable: !0, value: void 0 }), fo(this, Lt)[Lt] = iF().then(t => { fo(this, Lt)[Lt] = t }), this.name = e.storeName } get ready() { return Promise.resolve(fo(this, Lt)[Lt]) } set ready(e) { fo(this, Lt)[Lt] = e } async list() { return await fo(this, Lt)[Lt], new Promise((e, t) => { let r = n(s => { if (s.data.store === this.name) switch (s.data.type) { case "uppy/ALL_FILES": e(s.data.files), navigator.serviceWorker.removeEventListener("message", r); break; default: t() } }, "onMessage"); navigator.serviceWorker.addEventListener("message", r), navigator.serviceWorker.controller.postMessage({ type: "uppy/GET_FILES", store: this.name }) }) } async put(e) { await fo(this, Lt)[Lt], navigator.serviceWorker.controller.postMessage({ type: "uppy/ADD_FILE", store: this.name, file: e }) } async delete(e) { await fo(this, Lt)[Lt], navigator.serviceWorker.controller.postMessage({ type: "uppy/REMOVE_FILE", store: this.name, fileID: e }) } }; n(ml, "ServiceWorkerStore"); ml.isSupported = N0; var M0 = ml; function or(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(or, "_classPrivateFieldLooseBase"); var rF = 0; function sF(i) { return "__private_" + rF++ + "_" + i } n(sF, "_classPrivateFieldLooseKey"); var H0 = typeof window < "u" && (window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.OIndexedDB || window.msIndexedDB), oF = !!H0, B0 = "uppy-blobs", Wt = "files", $0 = 24 * 60 * 60 * 1e3, nF = 3, L0 = 1048576; function aF(i) { let e = i.openCursor(); e.onsuccess = t => { let r = t.target.result; if (!r) return; let s = r.value; s.expires = Date.now() + $0, r.update(s) } } n(aF, "migrateExpiration"); function j0(i) { let e = H0.open(i, nF); return new Promise((t, r) => { e.onupgradeneeded = s => { let o = s.target.result, { transaction: a } = s.currentTarget; if (s.oldVersion < 2 && o.createObjectStore(Wt, { keyPath: "id" }).createIndex("store", "store", { unique: !1 }), s.oldVersion < 3) { let l = a.objectStore(Wt); l.createIndex("expires", "expires", { unique: !1 }), aF(l) } a.oncomplete = () => { t(o) } }, e.onsuccess = s => { t(s.target.result) }, e.onerror = r }) } n(j0, "connect"); function ed(i) { return new Promise((e, t) => { i.onsuccess = r => { e(r.target.result) }, i.onerror = t }) } n(ed, "waitForRequest"); var z0 = !1, He = sF("ready"), mo = class { constructor(e) { Object.defineProperty(this, He, { writable: !0, value: void 0 }), this.opts = { dbName: B0, storeName: "default", expires: $0, maxFileSize: 10 * L0, maxTotalSize: 300 * L0, ...e }, this.name = this.opts.storeName; let t = n(async () => { let r = await j0(this.opts.dbName); return or(this, He)[He] = r, r }, "createConnection"); z0 ? or(this, He)[He] = t() : (z0 = !0, or(this, He)[He] = mo.cleanup().then(t, t)) } get ready() { return Promise.resolve(or(this, He)[He]) } set ready(e) { or(this, He)[He] = e } key(e) { return `${this.name}!${e}` } async list() { let s = (await or(this, He)[He]).transaction([Wt], "readonly").objectStore(Wt).index("store").getAll(IDBKeyRange.only(this.name)), o = await ed(s); return Object.fromEntries(o.map(a => [a.fileID, a.data])) } async get(e) { let s = (await or(this, He)[He]).transaction([Wt], "readonly").objectStore(Wt).get(this.key(e)), { data: o } = await ed(s); return { id: o.fileID, data: o.data } } async getSize() { let s = (await or(this, He)[He]).transaction([Wt], "readonly").objectStore(Wt).index("store").openCursor(IDBKeyRange.only(this.name)); return new Promise((o, a) => { let l = 0; s.onsuccess = d => { let p = d.target.result; p ? (l += p.value.data.size, p.continue()) : o(l) }, s.onerror = () => { a(new Error("Could not retrieve stored blobs size")) } }) } async put(e) { if (e.data.size > this.opts.maxFileSize) throw new Error("File is too big to store."); if (await this.getSize() > this.opts.maxTotalSize) throw new Error("No space left"); let o = or(this, He)[He].transaction([Wt], "readwrite").objectStore(Wt).add({ id: this.key(e.id), fileID: e.id, store: this.name, expires: Date.now() + this.opts.expires, data: e.data }); return ed(o) } async delete(e) { let s = (await or(this, He)[He]).transaction([Wt], "readwrite").objectStore(Wt).delete(this.key(e)); return ed(s) } static async cleanup() { let e = await j0(B0), s = e.transaction([Wt], "readwrite").objectStore(Wt).index("expires").openCursor(IDBKeyRange.upperBound(Date.now())); await new Promise((o, a) => { s.onsuccess = l => { let d = l.target.result; d ? (d.delete(), d.continue()) : o() }, s.onerror = a }), e.close() } }; n(mo, "IndexedDBStore"); mo.isSupported = oF; var q0 = mo; function lF() { let i = []; for (let e = 0; e < localStorage.length; e++) { let t = localStorage.key(e); t.startsWith("uppyState:") && i.push(t.slice(10)) } return i } n(lF, "findUppyInstances"); function V0(i) { try { return JSON.parse(i) } catch { return null } } n(V0, "maybeParse"); var W0 = !1, Ui = class { constructor(e) { this.opts = { expires: 24 * 60 * 60 * 1e3, ...e }, this.name = `uppyState:${e.storeName}`, W0 || (W0 = !0, Ui.cleanup()) } load() { let e = localStorage.getItem(this.name); if (!e) return null; let t = V0(e); return t ? t.metadata ? t.metadata : (this.save(t), t) : null } save(e) { let t = Date.now() + this.opts.expires, r = JSON.stringify({ metadata: e, expires: t }); localStorage.setItem(this.name, r) } static cleanup(e) { if (e) { localStorage.removeItem(`uppyState:${e}`); return } let t = lF(), r = Date.now(); t.forEach(s => { let o = localStorage.getItem(`uppyState:${s}`); if (!o) return; let a = V0(o); a && a.expires && a.expires < r && localStorage.removeItem(`uppyState:${s}`) }) } }; n(Ui, "MetaDataStore"); var uF = { version: "3.1.0" }, go = class extends Se { constructor(e, t) { super(e, t), this.addBlobToStores = s => { s.isRemote || (this.ServiceWorkerStore && this.ServiceWorkerStore.put(s).catch(o => { this.uppy.log("[GoldenRetriever] Could not store file", "warning"), this.uppy.log(o) }), this.IndexedDBStore.put(s).catch(o => { this.uppy.log("[GoldenRetriever] Could not store file", "warning"), this.uppy.log(o) })) }, this.removeBlobFromStores = s => { this.ServiceWorkerStore && this.ServiceWorkerStore.delete(s.id).catch(o => { this.uppy.log("[GoldenRetriever] Failed to remove file", "warning"), this.uppy.log(o) }), this.IndexedDBStore.delete(s.id).catch(o => { this.uppy.log("[GoldenRetriever] Failed to remove file", "warning"), this.uppy.log(o) }) }, this.replaceBlobInStores = s => { this.removeBlobFromStores(s), this.addBlobToStores(s) }, this.handleRestoreConfirmed = () => { this.uppy.log("[GoldenRetriever] Restore confirmed, proceeding..."); let { currentUploads: s } = this.uppy.getState(); s && (this.uppy.resumeAll(), Object.keys(s).forEach(o => { this.uppy.restore(o, s[o]) })), this.uppy.setState({ recoveredState: null }) }, this.abortRestore = () => { this.uppy.log("[GoldenRetriever] Aborting restore..."); let s = Object.keys(this.uppy.getState().files); this.deleteBlobs(s).then(() => { this.uppy.log(`[GoldenRetriever] Removed ${s.length} files`) }).catch(o => { this.uppy.log(`[GoldenRetriever] Could not remove ${s.length} files`, "warning"), this.uppy.log(o) }), this.uppy.cancelAll(), this.uppy.setState({ recoveredState: null }), Ui.cleanup(this.uppy.opts.id) }, this.handleComplete = s => { let { successful: o } = s, a = o.map(l => l.id); this.deleteBlobs(a).then(() => { this.uppy.log(`[GoldenRetriever] Removed ${o.length} files that finished uploading`) }).catch(l => { this.uppy.log(`[GoldenRetriever] Could not remove ${o.length} files that finished uploading`, "warning"), this.uppy.log(l) }), this.uppy.setState({ recoveredState: null }), Ui.cleanup(this.uppy.opts.id) }, this.restoreBlobs = () => { this.uppy.getFiles().length > 0 ? Promise.all([this.loadFileBlobsFromServiceWorker(), this.loadFileBlobsFromIndexedDB()]).then(s => { let o = { ...s[0], ...s[1] }; this.onBlobsLoaded(o) }) : this.uppy.log("[GoldenRetriever] No files need to be loaded, only restoring processing state...") }, this.type = "debugger", this.id = this.opts.id || "GoldenRetriever", this.title = "Golden Retriever"; let r = { expires: 24 * 60 * 60 * 1e3, serviceWorker: !1 }; this.opts = { ...r, ...t }, this.MetaDataStore = new Ui({ expires: this.opts.expires, storeName: e.getID() }), this.ServiceWorkerStore = null, this.opts.serviceWorker && (this.ServiceWorkerStore = new M0({ storeName: e.getID() })), this.IndexedDBStore = new q0({ expires: this.opts.expires, ...this.opts.indexedDB || {}, storeName: e.getID() }), this.saveFilesStateToLocalStorage = (0, G0.default)(this.saveFilesStateToLocalStorage.bind(this), 500, { leading: !0, trailing: !0 }), this.restoreState = this.restoreState.bind(this), this.loadFileBlobsFromServiceWorker = this.loadFileBlobsFromServiceWorker.bind(this), this.loadFileBlobsFromIndexedDB = this.loadFileBlobsFromIndexedDB.bind(this), this.onBlobsLoaded = this.onBlobsLoaded.bind(this) } restoreState() { let e = this.MetaDataStore.load(); e && (this.uppy.log("[GoldenRetriever] Recovered some state from Local Storage"), this.uppy.setState({ currentUploads: e.currentUploads || {}, files: e.files || {}, recoveredState: e }), this.savedPluginData = e.pluginData) } getWaitingFiles() { let e = {}; return this.uppy.getFiles().forEach(t => { (!t.progress || !t.progress.uploadStarted) && (e[t.id] = t) }), e } getUploadingFiles() { let e = {}, { currentUploads: t } = this.uppy.getState(); return t && Object.keys(t).forEach(s => { t[s].fileIDs.forEach(a => { e[a] = this.uppy.getFile(a) }) }), e } saveFilesStateToLocalStorage() { let e = { ...this.getWaitingFiles(), ...this.getUploadingFiles() }, t = Object.entries(e); if (t.length === 0) { this.uppy.getState().recoveredState !== null && this.uppy.setState({ recoveredState: null }), Ui.cleanup(this.uppy.opts.id); return } let r = Object.fromEntries(t.map(a => { let [l, d] = a; return [l, d.isRemote ? { ...d, isRestored: !0 } : { ...d, isRestored: !0, data: null, preview: null }] })), s = {}; this.uppy.emit("restore:get-data", a => { Object.assign(s, a) }); let { currentUploads: o } = this.uppy.getState(); this.MetaDataStore.save({ currentUploads: o, files: r, pluginData: s }) } loadFileBlobsFromServiceWorker() { return this.ServiceWorkerStore ? this.ServiceWorkerStore.list().then(e => { let t = Object.keys(e).length; return t > 0 ? (this.uppy.log(`[GoldenRetriever] Successfully recovered ${t} blobs from Service Worker!`), e) : (this.uppy.log("[GoldenRetriever] No blobs found in Service Worker, trying IndexedDB now..."), {}) }).catch(e => (this.uppy.log("[GoldenRetriever] Failed to recover blobs from Service Worker", "warning"), this.uppy.log(e), {})) : Promise.resolve({}) } loadFileBlobsFromIndexedDB() { return this.IndexedDBStore.list().then(e => { let t = Object.keys(e).length; return t > 0 ? (this.uppy.log(`[GoldenRetriever] Successfully recovered ${t} blobs from IndexedDB!`), e) : (this.uppy.log("[GoldenRetriever] No blobs found in IndexedDB"), {}) }).catch(e => (this.uppy.log("[GoldenRetriever] Failed to recover blobs from IndexedDB", "warning"), this.uppy.log(e), {})) } onBlobsLoaded(e) { let t = [], r = { ...this.uppy.getState().files }; Object.keys(e).forEach(s => { let o = this.uppy.getFile(s); if (!o) { t.push(s); return } let l = { data: e[s], isRestored: !0, isGhost: !1 }; r[s] = { ...o, ...l } }), Object.keys(r).forEach(s => { r[s].data === null && (r[s] = { ...r[s], isGhost: !0 }) }), this.uppy.setState({ files: r }), this.uppy.emit("restored", this.savedPluginData), t.length && this.deleteBlobs(t).then(() => { this.uppy.log(`[GoldenRetriever] Cleaned up ${t.length} old files`) }).catch(s => { this.uppy.log(`[GoldenRetriever] Could not clean up ${t.length} old files`, "warning"), this.uppy.log(s) }) } deleteBlobs(e) { return Promise.all(e.map(t => { var r, s, o; return (r = (s = this.ServiceWorkerStore) == null ? void 0 : s.delete(t)) != null ? r : (o = this.IndexedDBStore) == null ? void 0 : o.delete(t) })) } install() { this.restoreState(), this.restoreBlobs(), this.uppy.on("file-added", this.addBlobToStores), this.uppy.on("file-editor:complete", this.replaceBlobInStores), this.uppy.on("file-removed", this.removeBlobFromStores), this.uppy.on("state-update", this.saveFilesStateToLocalStorage), this.uppy.on("restore-confirmed", this.handleRestoreConfirmed), this.uppy.on("restore-canceled", this.abortRestore), this.uppy.on("complete", this.handleComplete) } uninstall() { this.uppy.off("file-added", this.addBlobToStores), this.uppy.off("file-editor:complete", this.replaceBlobInStores), this.uppy.off("file-removed", this.removeBlobFromStores), this.uppy.off("state-update", this.saveFilesStateToLocalStorage), this.uppy.off("restore-confirmed", this.handleRestoreConfirmed), this.uppy.off("restore-canceled", this.abortRestore), this.uppy.off("complete", this.handleComplete) } }; n(go, "GoldenRetriever"); go.VERSION = uF.version; var dF = { version: "3.0.3" }, yo = class extends Q { constructor(e, t) { super(e, t), this.type = "debugger", this.id = this.opts.id || "ReduxDevTools", this.title = "Redux DevTools"; let r = {}; this.opts = { ...r, ...t }, this.handleStateChange = this.handleStateChange.bind(this), this.initDevTools = this.initDevTools.bind(this) } handleStateChange(e, t) { this.devTools.send("UPPY_STATE_UPDATE", t) } initDevTools() { this.devTools = window.devToolsExtension.connect(), this.devToolsUnsubscribe = this.devTools.subscribe(e => { if (e.type === "DISPATCH") switch (e.payload.type) { case "RESET": this.uppy.cancelAll(); return; case "IMPORT_STATE": { let { computedStates: t } = e.payload.nextLiftedState; this.uppy.store.state = { ...this.uppy.getState(), ...t[t.length - 1].state }, this.uppy.updateAll(this.uppy.getState()); return } case "JUMP_TO_STATE": case "JUMP_TO_ACTION": this.uppy.store.state = { ...this.uppy.getState(), ...JSON.parse(e.state) }, this.uppy.updateAll(this.uppy.getState()); break; default: } }) } install() { this.withDevTools = typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION__, this.withDevTools && (this.initDevTools(), this.uppy.on("state-update", this.handleStateChange)) } uninstall() { this.withDevTools && (this.devToolsUnsubscribe(), this.uppy.off("state-update", this.handleStateUpdate)) } }; n(yo, "ReduxDevTools"); yo.VERSION = dF.version; function hF() { throw new Error("Core has been renamed to Uppy") } n(hF, "Core"); var cF = { ProviderView: qd }; mi.COMPANION_URL = Pp; mi.COMPANION_ALLOWED_HOSTS = _p; var pF = {}; globalThis.Uppy = Rp;
})();
/**
 * Takes a string with placeholder variables like `%{smart_count} file selected`
 * and replaces it with values from options `{smart_count: 5}`
 *
 * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE
 * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299
 *
 * @param {string} phrase that needs interpolation, with placeholders
 * @param {object} options with values that will be used to replace placeholders
 * @returns {any[]} interpolated
 */
/*! Bundled license information:

classnames/index.js:
  (*!
    Copyright (c) 2018 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  *)

cropperjs/dist/cropper.js:
  (*!
   * Cropper.js v1.5.7
   * https://fengyuanchen.github.io/cropperjs
   *
   * Copyright 2015-present Chen Fengyuan
   * Released under the MIT license
   *
   * Date: 2020-05-23T05:23:00.081Z
   *)

compressorjs/dist/compressor.js:
  (*!
   * Compressor.js v1.1.1
   * https://fengyuanchen.github.io/compressorjs
   *
   * Copyright 2018-present Chen Fengyuan
   * Released under the MIT license
   *
   * Date: 2021-10-05T02:32:40.212Z
   *)
*/
