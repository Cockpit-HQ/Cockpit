"use strict"; (() => {
    var H1 = Object.create; var Dl = Object.defineProperty; var q1 = Object.getOwnPropertyDescriptor; var $1 = Object.getOwnPropertyNames; var V1 = Object.getPrototypeOf, W1 = Object.prototype.hasOwnProperty; var n = (i, e) => Dl(i, "name", { value: e, configurable: !0 }); var ae = (i, e) => () => (e || i((e = { exports: {} }).exports, e), e.exports), cn = (i, e) => { for (var t in e) Dl(i, t, { get: e[t], enumerable: !0 }) }, K1 = (i, e, t, r) => { if (e && typeof e == "object" || typeof e == "function") for (let s of $1(e)) !W1.call(i, s) && s !== t && Dl(i, s, { get: () => e[s], enumerable: !(r = q1(e, s)) || r.enumerable }); return i }; var se = (i, e, t) => (t = i != null ? H1(V1(i)) : {}, K1(e || !i || !i.__esModule ? Dl(t, "default", { value: i, enumerable: !0 }) : t, i)); var Rh = ae((UF, Cf) => { Cf.exports = n(function () { var e = {}, t = e._fns = {}; e.emit = n(function (a, l, h, c, d, p, y) { var v = r(a); v.length && s(a, v, [l, h, c, d, p, y]) }, "emit"), e.on = n(function (a, l) { t[a] || (t[a] = []), t[a].push(l) }, "on"), e.once = n(function (a, l) { function h() { l.apply(this, arguments), e.off(a, h) } n(h, "one"), this.on(a, h) }, "once"), e.off = n(function (a, l) { var h = []; if (a && l) { var c = this._fns[a], d = 0, p = c ? c.length : 0; for (d; d < p; d++)c[d] !== l && h.push(c[d]) } h.length ? this._fns[a] = h : delete this._fns[a] }, "off"); function r(o) { var a = t[o] ? t[o] : [], l = o.indexOf(":"), h = l === -1 ? [o] : [o.substring(0, l), o.substring(l + 1)], c = Object.keys(t), d = 0, p = c.length; for (d; d < p; d++) { var y = c[d]; if (y === "*" && (a = a.concat(t[y])), h.length === 2 && h[0] === y) { a = a.concat(t[y]); break } } return a } n(r, "getListeners"); function s(o, a, l) { var h = 0, c = a.length; for (h; h < c && a[h]; h++)a[h].event = o, a[h].apply(a[h], l) } return n(s, "emitAll"), e }, "createNamespaceEmitter") }); var Nl = ae((BF, Rf) => { function Z1(i) { var e = typeof i; return i != null && (e == "object" || e == "function") } n(Z1, "isObject"); Rf.exports = Z1 }); var Uf = ae((MF, kf) => { var ew = typeof global == "object" && global && global.Object === Object && global; kf.exports = ew }); var kh = ae((zF, Df) => { var tw = Uf(), iw = typeof self == "object" && self && self.Object === Object && self, rw = tw || iw || Function("return this")(); Df.exports = rw }); var If = ae((jF, Nf) => { var sw = kh(), ow = n(function () { return sw.Date.now() }, "now"); Nf.exports = ow }); var Lf = ae((qF, Bf) => { var nw = /\s/; function aw(i) { for (var e = i.length; e-- && nw.test(i.charAt(e));); return e } n(aw, "trimmedEndIndex"); Bf.exports = aw }); var zf = ae((VF, Mf) => { var lw = Lf(), uw = /^\s+/; function hw(i) { return i && i.slice(0, lw(i) + 1).replace(uw, "") } n(hw, "baseTrim"); Mf.exports = hw }); var Uh = ae((KF, jf) => { var cw = kh(), dw = cw.Symbol; jf.exports = dw }); var Vf = ae((GF, $f) => { var Hf = Uh(), qf = Object.prototype, pw = qf.hasOwnProperty, fw = qf.toString, pn = Hf ? Hf.toStringTag : void 0; function mw(i) { var e = pw.call(i, pn), t = i[pn]; try { i[pn] = void 0; var r = !0 } catch { } var s = fw.call(i); return r && (e ? i[pn] = t : delete i[pn]), s } n(mw, "getRawTag"); $f.exports = mw }); var Kf = ae((YF, Wf) => { var gw = Object.prototype, yw = gw.toString; function vw(i) { return yw.call(i) } n(vw, "objectToString"); Wf.exports = vw }); var Qf = ae((JF, Yf) => { var Gf = Uh(), bw = Vf(), ww = Kf(), Sw = "[object Null]", Pw = "[object Undefined]", Xf = Gf ? Gf.toStringTag : void 0; function _w(i) { return i == null ? i === void 0 ? Pw : Sw : Xf && Xf in Object(i) ? bw(i) : ww(i) } n(_w, "baseGetTag"); Yf.exports = _w }); var Zf = ae((eO, Jf) => { function xw(i) { return i != null && typeof i == "object" } n(xw, "isObjectLike"); Jf.exports = xw }); var tm = ae((iO, em) => { var Ew = Qf(), Fw = Zf(), Ow = "[object Symbol]"; function Aw(i) { return typeof i == "symbol" || Fw(i) && Ew(i) == Ow } n(Aw, "isSymbol"); em.exports = Aw }); var om = ae((sO, sm) => { var Tw = zf(), im = Nl(), Cw = tm(), rm = 0 / 0, Rw = /^[-+]0x[0-9a-f]+$/i, kw = /^0b[01]+$/i, Uw = /^0o[0-7]+$/i, Dw = parseInt; function Nw(i) { if (typeof i == "number") return i; if (Cw(i)) return rm; if (im(i)) { var e = typeof i.valueOf == "function" ? i.valueOf() : i; i = im(e) ? e + "" : e } if (typeof i != "string") return i === 0 ? i : +i; i = Tw(i); var t = kw.test(i); return t || Uw.test(i) ? Dw(i.slice(2), t ? 2 : 8) : Rw.test(i) ? rm : +i } n(Nw, "toNumber"); sm.exports = Nw }); var Nh = ae((nO, am) => { var Iw = Nl(), Dh = If(), nm = om(), Bw = "Expected a function", Lw = Math.max, Mw = Math.min; function zw(i, e, t) { var r, s, o, a, l, h, c = 0, d = !1, p = !1, y = !0; if (typeof i != "function") throw new TypeError(Bw); e = nm(e) || 0, Iw(t) && (d = !!t.leading, p = "maxWait" in t, o = p ? Lw(nm(t.maxWait) || 0, e) : o, y = "trailing" in t ? !!t.trailing : y); function v(I) { var q = r, $ = s; return r = s = void 0, c = I, a = i.apply($, q), a } n(v, "invokeFunc"); function S(I) { return c = I, l = setTimeout(F, e), d ? v(I) : a } n(S, "leadingEdge"); function x(I) { var q = I - h, $ = I - c, V = e - q; return p ? Mw(V, o - $) : V } n(x, "remainingWait"); function E(I) { var q = I - h, $ = I - c; return h === void 0 || q >= e || q < 0 || p && $ >= o } n(E, "shouldInvoke"); function F() { var I = Dh(); if (E(I)) return k(I); l = setTimeout(F, x(I)) } n(F, "timerExpired"); function k(I) { return l = void 0, y && r ? v(I) : (r = s = void 0, a) } n(k, "trailingEdge"); function B() { l !== void 0 && clearTimeout(l), c = 0, r = h = s = l = void 0 } n(B, "cancel"); function H() { return l === void 0 ? a : k(Dh()) } n(H, "flush"); function W() { var I = Dh(), q = E(I); if (r = arguments, s = this, h = I, q) { if (l === void 0) return S(h); if (p) return clearTimeout(l), l = setTimeout(F, e), v(h) } return l === void 0 && (l = setTimeout(F, e)), a } return n(W, "debounced"), W.cancel = B, W.flush = H, W } n(zw, "debounce"); am.exports = zw }); var Il = ae((lO, lm) => { var jw = Nh(), Hw = Nl(), qw = "Expected a function"; function $w(i, e, t) { var r = !0, s = !0; if (typeof i != "function") throw new TypeError(qw); return Hw(t) && (r = "leading" in t ? !!t.leading : r, s = "trailing" in t ? !!t.trailing : s), jw(i, e, { leading: r, maxWait: e, trailing: s }) } n($w, "throttle"); lm.exports = $w }); var zl = ae((CO, pm) => { pm.exports = n(function (e) { if (typeof e != "number" || isNaN(e)) throw new TypeError(`Expected a number, got ${typeof e}`); let t = e < 0, r = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]; if (t && (e = -e), e < 1) return `${(t ? "-" : "") + e} B`; let s = Math.min(Math.floor(Math.log(e) / Math.log(1024)), r.length - 1); e = Number(e / Math.pow(1024, s)); let o = r[s]; return e >= 10 || e % 1 === 0 ? `${(t ? "-" : "") + e.toFixed(0)} ${o}` : `${(t ? "-" : "") + e.toFixed(1)} ${o}` }, "prettierBytes") }); var gm = ae((kO, mm) => { "use strict"; function fm(i, e) { this.text = i = i || "", this.hasWild = ~i.indexOf("*"), this.separator = e, this.parts = i.split(e) } n(fm, "WildcardMatcher"); fm.prototype.match = function (i) { var e = !0, t = this.parts, r, s = t.length, o; if (typeof i == "string" || i instanceof String) if (!this.hasWild && this.text != i) e = !1; else { for (o = (i || "").split(this.separator), r = 0; e && r < s; r++)t[r] !== "*" && (r < o.length ? e = t[r] === o[r] : e = !1); e = e && o } else if (typeof i.splice == "function") for (e = [], r = i.length; r--;)this.match(i[r]) && (e[e.length] = i[r]); else if (typeof i == "object") { e = {}; for (var a in i) this.match(a) && (e[a] = i[a]) } return e }; mm.exports = function (i, e, t) { var r = new fm(i, t || /[\/\.]/); return typeof e < "u" ? r.match(e) : r } }); var vm = ae((DO, ym) => { var Yw = gm(), Qw = /[\/\+\.]/; ym.exports = function (i, e) { function t(r) { var s = Yw(r, i, Qw); return s && s.length >= 2 } return n(t, "test"), e ? t(e.split(";")[0]) : t } }); var Qm = ae((Y3, Jh) => { "use strict"; var LS = Object.prototype.hasOwnProperty, dt = "~"; function kn() { } n(kn, "Events"); Object.create && (kn.prototype = Object.create(null), new kn().__proto__ || (dt = !1)); function MS(i, e, t) { this.fn = i, this.context = e, this.once = t || !1 } n(MS, "EE"); function Ym(i, e, t, r, s) { if (typeof t != "function") throw new TypeError("The listener must be a function"); var o = new MS(t, r || i, s), a = dt ? dt + e : e; return i._events[a] ? i._events[a].fn ? i._events[a] = [i._events[a], o] : i._events[a].push(o) : (i._events[a] = o, i._eventsCount++), i } n(Ym, "addListener"); function Ql(i, e) { --i._eventsCount === 0 ? i._events = new kn : delete i._events[e] } n(Ql, "clearEvent"); function nt() { this._events = new kn, this._eventsCount = 0 } n(nt, "EventEmitter"); nt.prototype.eventNames = n(function () { var e = [], t, r; if (this._eventsCount === 0) return e; for (r in t = this._events) LS.call(t, r) && e.push(dt ? r.slice(1) : r); return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(t)) : e }, "eventNames"); nt.prototype.listeners = n(function (e) { var t = dt ? dt + e : e, r = this._events[t]; if (!r) return []; if (r.fn) return [r.fn]; for (var s = 0, o = r.length, a = new Array(o); s < o; s++)a[s] = r[s].fn; return a }, "listeners"); nt.prototype.listenerCount = n(function (e) { var t = dt ? dt + e : e, r = this._events[t]; return r ? r.fn ? 1 : r.length : 0 }, "listenerCount"); nt.prototype.emit = n(function (e, t, r, s, o, a) { var l = dt ? dt + e : e; if (!this._events[l]) return !1; var h = this._events[l], c = arguments.length, d, p; if (h.fn) { switch (h.once && this.removeListener(e, h.fn, void 0, !0), c) { case 1: return h.fn.call(h.context), !0; case 2: return h.fn.call(h.context, t), !0; case 3: return h.fn.call(h.context, t, r), !0; case 4: return h.fn.call(h.context, t, r, s), !0; case 5: return h.fn.call(h.context, t, r, s, o), !0; case 6: return h.fn.call(h.context, t, r, s, o, a), !0 }for (p = 1, d = new Array(c - 1); p < c; p++)d[p - 1] = arguments[p]; h.fn.apply(h.context, d) } else { var y = h.length, v; for (p = 0; p < y; p++)switch (h[p].once && this.removeListener(e, h[p].fn, void 0, !0), c) { case 1: h[p].fn.call(h[p].context); break; case 2: h[p].fn.call(h[p].context, t); break; case 3: h[p].fn.call(h[p].context, t, r); break; case 4: h[p].fn.call(h[p].context, t, r, s); break; default: if (!d) for (v = 1, d = new Array(c - 1); v < c; v++)d[v - 1] = arguments[v]; h[p].fn.apply(h[p].context, d) } } return !0 }, "emit"); nt.prototype.on = n(function (e, t, r) { return Ym(this, e, t, r, !1) }, "on"); nt.prototype.once = n(function (e, t, r) { return Ym(this, e, t, r, !0) }, "once"); nt.prototype.removeListener = n(function (e, t, r, s) { var o = dt ? dt + e : e; if (!this._events[o]) return this; if (!t) return Ql(this, o), this; var a = this._events[o]; if (a.fn) a.fn === t && (!s || a.once) && (!r || a.context === r) && Ql(this, o); else { for (var l = 0, h = [], c = a.length; l < c; l++)(a[l].fn !== t || s && !a[l].once || r && a[l].context !== r) && h.push(a[l]); h.length ? this._events[o] = h.length === 1 ? h[0] : h : Ql(this, o) } return this }, "removeListener"); nt.prototype.removeAllListeners = n(function (e) { var t; return e ? (t = dt ? dt + e : e, this._events[t] && Ql(this, t)) : (this._events = new kn, this._eventsCount = 0), this }, "removeAllListeners"); nt.prototype.off = nt.prototype.removeListener; nt.prototype.addListener = nt.prototype.on; nt.prefixed = dt; nt.EventEmitter = nt; typeof Jh < "u" && (Jh.exports = nt) }); var It = ae((PA, nu) => { (function () { "use strict"; var i = {}.hasOwnProperty; function e() { for (var t = [], r = 0; r < arguments.length; r++) { var s = arguments[r]; if (s) { var o = typeof s; if (o === "string" || o === "number") t.push(s); else if (Array.isArray(s)) { if (s.length) { var a = e.apply(null, s); a && t.push(a) } } else if (o === "object") if (s.toString === Object.prototype.toString) for (var l in s) i.call(s, l) && s[l] && t.push(l); else t.push(s.toString()) } } return t.join(" ") } n(e, "classNames"), typeof nu < "u" && nu.exports ? (e.default = e, nu.exports = e) : typeof define == "function" && typeof define.amd == "object" && define.amd ? define("classnames", [], function () { return e }) : window.classNames = e })() }); var vy = ae((zR, yy) => { yy.exports = n(function (e, t) { if (e === t) return !0; for (var r in e) if (!(r in t)) return !1; for (var r in t) if (e[r] !== t[r]) return !1; return !0 }, "isShallowEqual") }); var Sy = ae((a4, wy) => { wy.exports = n(function (e) { if (typeof e != "number" || isNaN(e)) throw new TypeError("Expected a number, got " + typeof e); var t = e < 0, r = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]; if (t && (e = -e), e < 1) return (t ? "-" : "") + e + " B"; var s = Math.min(Math.floor(Math.log(e) / Math.log(1024)), r.length - 1); e = Number(e / Math.pow(1024, s)); var o = r[s]; return e >= 10 || e % 1 === 0 ? (t ? "-" : "") + e.toFixed(0) + " " + o : (t ? "-" : "") + e.toFixed(1) + " " + o }, "prettierBytes") }); var Wy = ae((ed, td) => {
        (function (i, e) { typeof ed == "object" && typeof td < "u" ? td.exports = e() : typeof define == "function" && define.amd ? define(e) : (i = i || self, i.Cropper = e()) })(ed, function () {
            "use strict"; function i(b) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? i = n(function (f) { return typeof f }, "_typeof") : i = n(function (f) { return f && typeof Symbol == "function" && f.constructor === Symbol && f !== Symbol.prototype ? "symbol" : typeof f }, "_typeof"), i(b) } n(i, "_typeof"); function e(b, f) { if (!(b instanceof f)) throw new TypeError("Cannot call a class as a function") } n(e, "_classCallCheck"); function t(b, f) { for (var g = 0; g < f.length; g++) { var m = f[g]; m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(b, m.key, m) } } n(t, "_defineProperties"); function r(b, f, g) { return f && t(b.prototype, f), g && t(b, g), b } n(r, "_createClass"); function s(b, f, g) { return f in b ? Object.defineProperty(b, f, { value: g, enumerable: !0, configurable: !0, writable: !0 }) : b[f] = g, b } n(s, "_defineProperty"); function o(b, f) { var g = Object.keys(b); if (Object.getOwnPropertySymbols) { var m = Object.getOwnPropertySymbols(b); f && (m = m.filter(function (P) { return Object.getOwnPropertyDescriptor(b, P).enumerable })), g.push.apply(g, m) } return g } n(o, "ownKeys"); function a(b) { for (var f = 1; f < arguments.length; f++) { var g = arguments[f] != null ? arguments[f] : {}; f % 2 ? o(Object(g), !0).forEach(function (m) { s(b, m, g[m]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(b, Object.getOwnPropertyDescriptors(g)) : o(Object(g)).forEach(function (m) { Object.defineProperty(b, m, Object.getOwnPropertyDescriptor(g, m)) }) } return b } n(a, "_objectSpread2"); function l(b) { return h(b) || c(b) || d(b) || y() } n(l, "_toConsumableArray"); function h(b) { if (Array.isArray(b)) return p(b) } n(h, "_arrayWithoutHoles"); function c(b) { if (typeof Symbol < "u" && Symbol.iterator in Object(b)) return Array.from(b) } n(c, "_iterableToArray"); function d(b, f) { if (b) { if (typeof b == "string") return p(b, f); var g = Object.prototype.toString.call(b).slice(8, -1); if (g === "Object" && b.constructor && (g = b.constructor.name), g === "Map" || g === "Set") return Array.from(b); if (g === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(g)) return p(b, f) } } n(d, "_unsupportedIterableToArray"); function p(b, f) { (f == null || f > b.length) && (f = b.length); for (var g = 0, m = new Array(f); g < f; g++)m[g] = b[g]; return m } n(p, "_arrayLikeToArray"); function y() {
                throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
            } n(y, "_nonIterableSpread"); var v = typeof window < "u" && typeof window.document < "u", S = v ? window : {}, x = v && S.document.documentElement ? "ontouchstart" in S.document.documentElement : !1, E = v ? "PointerEvent" in S : !1, F = "cropper", k = "all", B = "crop", H = "move", W = "zoom", I = "e", q = "w", $ = "s", V = "n", xe = "ne", Pt = "nw", ut = "se", rt = "sw", st = "".concat(F, "-crop"), We = "".concat(F, "-disabled"), Ee = "".concat(F, "-hidden"), ai = "".concat(F, "-hide"), go = "".concat(F, "-invisible"), xi = "".concat(F, "-modal"), ts = "".concat(F, "-move"), Xi = "".concat(F, "Action"), Cr = "".concat(F, "Preview"), Yi = "crop", is = "move", rs = "none", Qi = "crop", Jt = "cropend", yo = "cropmove", vo = "cropstart", ln = "dblclick", Rl = x ? "touchstart" : "mousedown", nf = x ? "touchmove" : "mousemove", _h = x ? "touchend touchcancel" : "mouseup", af = E ? "pointerdown" : Rl, lf = E ? "pointermove" : nf, uf = E ? "pointerup pointercancel" : _h, hf = "ready", cf = "resize", df = "wheel", xh = "zoom", pf = "image/jpeg", u1 = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/, h1 = /^data:/, c1 = /^data:image\/jpeg;base64,/, d1 = /^img|canvas$/i, ff = { viewMode: 0, dragMode: Yi, initialAspectRatio: NaN, aspectRatio: NaN, data: null, preview: "", responsive: !0, restore: !0, checkCrossOrigin: !0, checkOrientation: !0, modal: !0, guides: !0, center: !0, highlight: !0, background: !0, autoCrop: !0, autoCropArea: .8, movable: !0, rotatable: !0, scalable: !0, zoomable: !0, zoomOnTouch: !0, zoomOnWheel: !0, wheelZoomRatio: .1, cropBoxMovable: !0, cropBoxResizable: !0, toggleDragModeOnDblclick: !0, minCanvasWidth: 0, minCanvasHeight: 0, minCropBoxWidth: 0, minCropBoxHeight: 0, minContainerWidth: 200, minContainerHeight: 100, ready: null, cropstart: null, cropmove: null, cropend: null, crop: null, zoom: null }, p1 = '<div class="cropper-container" touch-action="none"><div class="cropper-wrap-box"><div class="cropper-canvas"></div></div><div class="cropper-drag-box"></div><div class="cropper-crop-box"><span class="cropper-view-box"></span><span class="cropper-dashed dashed-h"></span><span class="cropper-dashed dashed-v"></span><span class="cropper-center"></span><span class="cropper-face"></span><span class="cropper-line line-e" data-cropper-action="e"></span><span class="cropper-line line-n" data-cropper-action="n"></span><span class="cropper-line line-w" data-cropper-action="w"></span><span class="cropper-line line-s" data-cropper-action="s"></span><span class="cropper-point point-e" data-cropper-action="e"></span><span class="cropper-point point-n" data-cropper-action="n"></span><span class="cropper-point point-w" data-cropper-action="w"></span><span class="cropper-point point-s" data-cropper-action="s"></span><span class="cropper-point point-ne" data-cropper-action="ne"></span><span class="cropper-point point-nw" data-cropper-action="nw"></span><span class="cropper-point point-sw" data-cropper-action="sw"></span><span class="cropper-point point-se" data-cropper-action="se"></span></div></div>', f1 = Number.isNaN || S.isNaN; function Z(b) { return typeof b == "number" && !f1(b) } n(Z, "isNumber"); var mf = n(function (f) { return f > 0 && f < 1 / 0 }, "isPositiveNumber"); function Eh(b) { return typeof b > "u" } n(Eh, "isUndefined"); function ss(b) { return i(b) === "object" && b !== null } n(ss, "isObject"); var m1 = Object.prototype.hasOwnProperty; function bo(b) { if (!ss(b)) return !1; try { var f = b.constructor, g = f.prototype; return f && g && m1.call(g, "isPrototypeOf") } catch { return !1 } } n(bo, "isPlainObject"); function _t(b) { return typeof b == "function" } n(_t, "isFunction"); var g1 = Array.prototype.slice; function gf(b) { return Array.from ? Array.from(b) : g1.call(b) } n(gf, "toArray"); function Ce(b, f) { return b && _t(f) && (Array.isArray(b) || Z(b.length) ? gf(b).forEach(function (g, m) { f.call(b, g, m, b) }) : ss(b) && Object.keys(b).forEach(function (g) { f.call(b, b[g], g, b) })), b } n(Ce, "forEach"); var fe = Object.assign || n(function (f) { for (var g = arguments.length, m = new Array(g > 1 ? g - 1 : 0), P = 1; P < g; P++)m[P - 1] = arguments[P]; return ss(f) && m.length > 0 && m.forEach(function (w) { ss(w) && Object.keys(w).forEach(function (_) { f[_] = w[_] }) }), f }, "assign"), y1 = /\.\d*(?:0|9){12}\d*$/; function wo(b) { var f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e11; return y1.test(b) ? Math.round(b * f) / f : b } n(wo, "normalizeDecimalNumber"); var v1 = /^width|height|left|top|marginLeft|marginTop$/; function Rr(b, f) { var g = b.style; Ce(f, function (m, P) { v1.test(P) && Z(m) && (m = "".concat(m, "px")), g[P] = m }) } n(Rr, "setStyle"); function b1(b, f) { return b.classList ? b.classList.contains(f) : b.className.indexOf(f) > -1 } n(b1, "hasClass"); function qe(b, f) { if (f) { if (Z(b.length)) { Ce(b, function (m) { qe(m, f) }); return } if (b.classList) { b.classList.add(f); return } var g = b.className.trim(); g ? g.indexOf(f) < 0 && (b.className = "".concat(g, " ").concat(f)) : b.className = f } } n(qe, "addClass"); function Ei(b, f) { if (f) { if (Z(b.length)) { Ce(b, function (g) { Ei(g, f) }); return } if (b.classList) { b.classList.remove(f); return } b.className.indexOf(f) >= 0 && (b.className = b.className.replace(f, "")) } } n(Ei, "removeClass"); function So(b, f, g) { if (f) { if (Z(b.length)) { Ce(b, function (m) { So(m, f, g) }); return } g ? qe(b, f) : Ei(b, f) } } n(So, "toggleClass"); var w1 = /([a-z\d])([A-Z])/g; function Fh(b) { return b.replace(w1, "$1-$2").toLowerCase() } n(Fh, "toParamCase"); function Oh(b, f) { return ss(b[f]) ? b[f] : b.dataset ? b.dataset[f] : b.getAttribute("data-".concat(Fh(f))) } n(Oh, "getData"); function un(b, f, g) { ss(g) ? b[f] = g : b.dataset ? b.dataset[f] = g : b.setAttribute("data-".concat(Fh(f)), g) } n(un, "setData"); function S1(b, f) { if (ss(b[f])) try { delete b[f] } catch { b[f] = void 0 } else if (b.dataset) try { delete b.dataset[f] } catch { b.dataset[f] = void 0 } else b.removeAttribute("data-".concat(Fh(f))) } n(S1, "removeData"); var yf = /\s\s*/, vf = function () { var b = !1; if (v) { var f = !1, g = n(function () { }, "listener"), m = Object.defineProperty({}, "once", { get: n(function () { return b = !0, f }, "get"), set: n(function (w) { f = w }, "set") }); S.addEventListener("test", g, m), S.removeEventListener("test", g, m) } return b }(); function li(b, f, g) { var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, P = g; f.trim().split(yf).forEach(function (w) { if (!vf) { var _ = b.listeners; _ && _[w] && _[w][g] && (P = _[w][g], delete _[w][g], Object.keys(_[w]).length === 0 && delete _[w], Object.keys(_).length === 0 && delete b.listeners) } b.removeEventListener(w, P, m) }) } n(li, "removeListener"); function Zt(b, f, g) { var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, P = g; f.trim().split(yf).forEach(function (w) { if (m.once && !vf) { var _ = b.listeners, O = _ === void 0 ? {} : _; P = n(function () { delete O[w][g], b.removeEventListener(w, P, m); for (var C = arguments.length, T = new Array(C), A = 0; A < C; A++)T[A] = arguments[A]; g.apply(b, T) }, "handler"), O[w] || (O[w] = {}), O[w][g] && b.removeEventListener(w, O[w][g], m), O[w][g] = P, b.listeners = O } b.addEventListener(w, P, m) }) } n(Zt, "addListener"); function Po(b, f, g) { var m; return _t(Event) && _t(CustomEvent) ? m = new CustomEvent(f, { detail: g, bubbles: !0, cancelable: !0 }) : (m = document.createEvent("CustomEvent"), m.initCustomEvent(f, !0, !0, g)), b.dispatchEvent(m) } n(Po, "dispatchEvent"); function bf(b) { var f = b.getBoundingClientRect(); return { left: f.left + (window.pageXOffset - document.documentElement.clientLeft), top: f.top + (window.pageYOffset - document.documentElement.clientTop) } } n(bf, "getOffset"); var Ah = S.location, P1 = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i; function wf(b) { var f = b.match(P1); return f !== null && (f[1] !== Ah.protocol || f[2] !== Ah.hostname || f[3] !== Ah.port) } n(wf, "isCrossOriginURL"); function Sf(b) { var f = "timestamp=".concat(new Date().getTime()); return b + (b.indexOf("?") === -1 ? "?" : "&") + f } n(Sf, "addTimestamp"); function hn(b) { var f = b.rotate, g = b.scaleX, m = b.scaleY, P = b.translateX, w = b.translateY, _ = []; Z(P) && P !== 0 && _.push("translateX(".concat(P, "px)")), Z(w) && w !== 0 && _.push("translateY(".concat(w, "px)")), Z(f) && f !== 0 && _.push("rotate(".concat(f, "deg)")), Z(g) && g !== 1 && _.push("scaleX(".concat(g, ")")), Z(m) && m !== 1 && _.push("scaleY(".concat(m, ")")); var O = _.length ? _.join(" ") : "none"; return { WebkitTransform: O, msTransform: O, transform: O } } n(hn, "getTransforms"); function _1(b) { var f = a({}, b), g = []; return Ce(b, function (m, P) { delete f[P], Ce(f, function (w) { var _ = Math.abs(m.startX - w.startX), O = Math.abs(m.startY - w.startY), U = Math.abs(m.endX - w.endX), C = Math.abs(m.endY - w.endY), T = Math.sqrt(_ * _ + O * O), A = Math.sqrt(U * U + C * C), R = (A - T) / T; g.push(R) }) }), g.sort(function (m, P) { return Math.abs(m) < Math.abs(P) }), g[0] } n(_1, "getMaxZoomRatio"); function kl(b, f) { var g = b.pageX, m = b.pageY, P = { endX: g, endY: m }; return f ? P : a({ startX: g, startY: m }, P) } n(kl, "getPointer"); function x1(b) { var f = 0, g = 0, m = 0; return Ce(b, function (P) { var w = P.startX, _ = P.startY; f += w, g += _, m += 1 }), f /= m, g /= m, { pageX: f, pageY: g } } n(x1, "getPointersCenter"); function kr(b) { var f = b.aspectRatio, g = b.height, m = b.width, P = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "contain", w = mf(m), _ = mf(g); if (w && _) { var O = g * f; P === "contain" && O > m || P === "cover" && O < m ? g = m / f : m = g * f } else w ? g = m / f : _ && (m = g * f); return { width: m, height: g } } n(kr, "getAdjustedSizes"); function E1(b) { var f = b.width, g = b.height, m = b.degree; if (m = Math.abs(m) % 180, m === 90) return { width: g, height: f }; var P = m % 90 * Math.PI / 180, w = Math.sin(P), _ = Math.cos(P), O = f * _ + g * w, U = f * w + g * _; return m > 90 ? { width: U, height: O } : { width: O, height: U } } n(E1, "getRotatedSizes"); function F1(b, f, g, m) { var P = f.aspectRatio, w = f.naturalWidth, _ = f.naturalHeight, O = f.rotate, U = O === void 0 ? 0 : O, C = f.scaleX, T = C === void 0 ? 1 : C, A = f.scaleY, R = A === void 0 ? 1 : A, re = g.aspectRatio, ee = g.naturalWidth, me = g.naturalHeight, oe = m.fillColor, Ie = oe === void 0 ? "transparent" : oe, $e = m.imageSmoothingEnabled, Re = $e === void 0 ? !0 : $e, Ji = m.imageSmoothingQuality, Rt = Ji === void 0 ? "low" : Ji, N = m.maxWidth, ne = N === void 0 ? 1 / 0 : N, Be = m.maxHeight, ei = Be === void 0 ? 1 / 0 : Be, Zi = m.minWidth, os = Zi === void 0 ? 0 : Zi, ns = m.minHeight, Ur = ns === void 0 ? 0 : ns, Fi = document.createElement("canvas"), xt = Fi.getContext("2d"), as = kr({ aspectRatio: re, width: ne, height: ei }), Ul = kr({ aspectRatio: re, width: os, height: Ur }, "cover"), Th = Math.min(as.width, Math.max(Ul.width, ee)), Ch = Math.min(as.height, Math.max(Ul.height, me)), xf = kr({ aspectRatio: P, width: ne, height: ei }), Ef = kr({ aspectRatio: P, width: os, height: Ur }, "cover"), Ff = Math.min(xf.width, Math.max(Ef.width, w)), Of = Math.min(xf.height, Math.max(Ef.height, _)), z1 = [-Ff / 2, -Of / 2, Ff, Of]; return Fi.width = wo(Th), Fi.height = wo(Ch), xt.fillStyle = Ie, xt.fillRect(0, 0, Th, Ch), xt.save(), xt.translate(Th / 2, Ch / 2), xt.rotate(U * Math.PI / 180), xt.scale(T, R), xt.imageSmoothingEnabled = Re, xt.imageSmoothingQuality = Rt, xt.drawImage.apply(xt, [b].concat(l(z1.map(function (j1) { return Math.floor(wo(j1)) })))), xt.restore(), Fi } n(F1, "getSourceCanvas"); var Pf = String.fromCharCode; function O1(b, f, g) { var m = ""; g += f; for (var P = f; P < g; P += 1)m += Pf(b.getUint8(P)); return m } n(O1, "getStringFromCharCode"); var A1 = /^data:.*,/; function T1(b) { var f = b.replace(A1, ""), g = atob(f), m = new ArrayBuffer(g.length), P = new Uint8Array(m); return Ce(P, function (w, _) { P[_] = g.charCodeAt(_) }), m } n(T1, "dataURLToArrayBuffer"); function C1(b, f) { for (var g = [], m = 8192, P = new Uint8Array(b); P.length > 0;)g.push(Pf.apply(null, gf(P.subarray(0, m)))), P = P.subarray(m); return "data:".concat(f, ";base64,").concat(btoa(g.join(""))) } n(C1, "arrayBufferToDataURL"); function R1(b) { var f = new DataView(b), g; try { var m, P, w; if (f.getUint8(0) === 255 && f.getUint8(1) === 216) for (var _ = f.byteLength, O = 2; O + 1 < _;) { if (f.getUint8(O) === 255 && f.getUint8(O + 1) === 225) { P = O; break } O += 1 } if (P) { var U = P + 4, C = P + 10; if (O1(f, U, 4) === "Exif") { var T = f.getUint16(C); if (m = T === 18761, (m || T === 19789) && f.getUint16(C + 2, m) === 42) { var A = f.getUint32(C + 4, m); A >= 8 && (w = C + A) } } } if (w) { var R = f.getUint16(w, m), re, ee; for (ee = 0; ee < R; ee += 1)if (re = w + ee * 12 + 2, f.getUint16(re, m) === 274) { re += 8, g = f.getUint16(re, m), f.setUint16(re, 1, m); break } } } catch { g = 1 } return g } n(R1, "resetAndGetOrientation"); function k1(b) { var f = 0, g = 1, m = 1; switch (b) { case 2: g = -1; break; case 3: f = -180; break; case 4: m = -1; break; case 5: f = 90, m = -1; break; case 6: f = 90; break; case 7: f = 90, g = -1; break; case 8: f = -90; break }return { rotate: f, scaleX: g, scaleY: m } } n(k1, "parseOrientation"); var U1 = { render: n(function () { this.initContainer(), this.initCanvas(), this.initCropBox(), this.renderCanvas(), this.cropped && this.renderCropBox() }, "render"), initContainer: n(function () { var f = this.element, g = this.options, m = this.container, P = this.cropper; qe(P, Ee), Ei(f, Ee); var w = { width: Math.max(m.offsetWidth, Number(g.minContainerWidth) || 200), height: Math.max(m.offsetHeight, Number(g.minContainerHeight) || 100) }; this.containerData = w, Rr(P, { width: w.width, height: w.height }), qe(f, Ee), Ei(P, Ee) }, "initContainer"), initCanvas: n(function () { var f = this.containerData, g = this.imageData, m = this.options.viewMode, P = Math.abs(g.rotate) % 180 === 90, w = P ? g.naturalHeight : g.naturalWidth, _ = P ? g.naturalWidth : g.naturalHeight, O = w / _, U = f.width, C = f.height; f.height * O > f.width ? m === 3 ? U = f.height * O : C = f.width / O : m === 3 ? C = f.width / O : U = f.height * O; var T = { aspectRatio: O, naturalWidth: w, naturalHeight: _, width: U, height: C }; T.left = (f.width - U) / 2, T.top = (f.height - C) / 2, T.oldLeft = T.left, T.oldTop = T.top, this.canvasData = T, this.limited = m === 1 || m === 2, this.limitCanvas(!0, !0), this.initialImageData = fe({}, g), this.initialCanvasData = fe({}, T) }, "initCanvas"), limitCanvas: n(function (f, g) { var m = this.options, P = this.containerData, w = this.canvasData, _ = this.cropBoxData, O = m.viewMode, U = w.aspectRatio, C = this.cropped && _; if (f) { var T = Number(m.minCanvasWidth) || 0, A = Number(m.minCanvasHeight) || 0; O > 1 ? (T = Math.max(T, P.width), A = Math.max(A, P.height), O === 3 && (A * U > T ? T = A * U : A = T / U)) : O > 0 && (T ? T = Math.max(T, C ? _.width : 0) : A ? A = Math.max(A, C ? _.height : 0) : C && (T = _.width, A = _.height, A * U > T ? T = A * U : A = T / U)); var R = kr({ aspectRatio: U, width: T, height: A }); T = R.width, A = R.height, w.minWidth = T, w.minHeight = A, w.maxWidth = 1 / 0, w.maxHeight = 1 / 0 } if (g) if (O > (C ? 0 : 1)) { var re = P.width - w.width, ee = P.height - w.height; w.minLeft = Math.min(0, re), w.minTop = Math.min(0, ee), w.maxLeft = Math.max(0, re), w.maxTop = Math.max(0, ee), C && this.limited && (w.minLeft = Math.min(_.left, _.left + (_.width - w.width)), w.minTop = Math.min(_.top, _.top + (_.height - w.height)), w.maxLeft = _.left, w.maxTop = _.top, O === 2 && (w.width >= P.width && (w.minLeft = Math.min(0, re), w.maxLeft = Math.max(0, re)), w.height >= P.height && (w.minTop = Math.min(0, ee), w.maxTop = Math.max(0, ee)))) } else w.minLeft = -w.width, w.minTop = -w.height, w.maxLeft = P.width, w.maxTop = P.height }, "limitCanvas"), renderCanvas: n(function (f, g) { var m = this.canvasData, P = this.imageData; if (g) { var w = E1({ width: P.naturalWidth * Math.abs(P.scaleX || 1), height: P.naturalHeight * Math.abs(P.scaleY || 1), degree: P.rotate || 0 }), _ = w.width, O = w.height, U = m.width * (_ / m.naturalWidth), C = m.height * (O / m.naturalHeight); m.left -= (U - m.width) / 2, m.top -= (C - m.height) / 2, m.width = U, m.height = C, m.aspectRatio = _ / O, m.naturalWidth = _, m.naturalHeight = O, this.limitCanvas(!0, !1) } (m.width > m.maxWidth || m.width < m.minWidth) && (m.left = m.oldLeft), (m.height > m.maxHeight || m.height < m.minHeight) && (m.top = m.oldTop), m.width = Math.min(Math.max(m.width, m.minWidth), m.maxWidth), m.height = Math.min(Math.max(m.height, m.minHeight), m.maxHeight), this.limitCanvas(!1, !0), m.left = Math.min(Math.max(m.left, m.minLeft), m.maxLeft), m.top = Math.min(Math.max(m.top, m.minTop), m.maxTop), m.oldLeft = m.left, m.oldTop = m.top, Rr(this.canvas, fe({ width: m.width, height: m.height }, hn({ translateX: m.left, translateY: m.top }))), this.renderImage(f), this.cropped && this.limited && this.limitCropBox(!0, !0) }, "renderCanvas"), renderImage: n(function (f) { var g = this.canvasData, m = this.imageData, P = m.naturalWidth * (g.width / g.naturalWidth), w = m.naturalHeight * (g.height / g.naturalHeight); fe(m, { width: P, height: w, left: (g.width - P) / 2, top: (g.height - w) / 2 }), Rr(this.image, fe({ width: m.width, height: m.height }, hn(fe({ translateX: m.left, translateY: m.top }, m)))), f && this.output() }, "renderImage"), initCropBox: n(function () { var f = this.options, g = this.canvasData, m = f.aspectRatio || f.initialAspectRatio, P = Number(f.autoCropArea) || .8, w = { width: g.width, height: g.height }; m && (g.height * m > g.width ? w.height = w.width / m : w.width = w.height * m), this.cropBoxData = w, this.limitCropBox(!0, !0), w.width = Math.min(Math.max(w.width, w.minWidth), w.maxWidth), w.height = Math.min(Math.max(w.height, w.minHeight), w.maxHeight), w.width = Math.max(w.minWidth, w.width * P), w.height = Math.max(w.minHeight, w.height * P), w.left = g.left + (g.width - w.width) / 2, w.top = g.top + (g.height - w.height) / 2, w.oldLeft = w.left, w.oldTop = w.top, this.initialCropBoxData = fe({}, w) }, "initCropBox"), limitCropBox: n(function (f, g) { var m = this.options, P = this.containerData, w = this.canvasData, _ = this.cropBoxData, O = this.limited, U = m.aspectRatio; if (f) { var C = Number(m.minCropBoxWidth) || 0, T = Number(m.minCropBoxHeight) || 0, A = O ? Math.min(P.width, w.width, w.width + w.left, P.width - w.left) : P.width, R = O ? Math.min(P.height, w.height, w.height + w.top, P.height - w.top) : P.height; C = Math.min(C, P.width), T = Math.min(T, P.height), U && (C && T ? T * U > C ? T = C / U : C = T * U : C ? T = C / U : T && (C = T * U), R * U > A ? R = A / U : A = R * U), _.minWidth = Math.min(C, A), _.minHeight = Math.min(T, R), _.maxWidth = A, _.maxHeight = R } g && (O ? (_.minLeft = Math.max(0, w.left), _.minTop = Math.max(0, w.top), _.maxLeft = Math.min(P.width, w.left + w.width) - _.width, _.maxTop = Math.min(P.height, w.top + w.height) - _.height) : (_.minLeft = 0, _.minTop = 0, _.maxLeft = P.width - _.width, _.maxTop = P.height - _.height)) }, "limitCropBox"), renderCropBox: n(function () { var f = this.options, g = this.containerData, m = this.cropBoxData; (m.width > m.maxWidth || m.width < m.minWidth) && (m.left = m.oldLeft), (m.height > m.maxHeight || m.height < m.minHeight) && (m.top = m.oldTop), m.width = Math.min(Math.max(m.width, m.minWidth), m.maxWidth), m.height = Math.min(Math.max(m.height, m.minHeight), m.maxHeight), this.limitCropBox(!1, !0), m.left = Math.min(Math.max(m.left, m.minLeft), m.maxLeft), m.top = Math.min(Math.max(m.top, m.minTop), m.maxTop), m.oldLeft = m.left, m.oldTop = m.top, f.movable && f.cropBoxMovable && un(this.face, Xi, m.width >= g.width && m.height >= g.height ? H : k), Rr(this.cropBox, fe({ width: m.width, height: m.height }, hn({ translateX: m.left, translateY: m.top }))), this.cropped && this.limited && this.limitCanvas(!0, !0), this.disabled || this.output() }, "renderCropBox"), output: n(function () { this.preview(), Po(this.element, Qi, this.getData()) }, "output") }, D1 = { initPreview: n(function () { var f = this.element, g = this.crossOrigin, m = this.options.preview, P = g ? this.crossOriginUrl : this.url, w = f.alt || "The image to preview", _ = document.createElement("img"); if (g && (_.crossOrigin = g), _.src = P, _.alt = w, this.viewBox.appendChild(_), this.viewBoxImage = _, !!m) { var O = m; typeof m == "string" ? O = f.ownerDocument.querySelectorAll(m) : m.querySelector && (O = [m]), this.previews = O, Ce(O, function (U) { var C = document.createElement("img"); un(U, Cr, { width: U.offsetWidth, height: U.offsetHeight, html: U.innerHTML }), g && (C.crossOrigin = g), C.src = P, C.alt = w, C.style.cssText = 'display:block;width:100%;height:auto;min-width:0!important;min-height:0!important;max-width:none!important;max-height:none!important;image-orientation:0deg!important;"', U.innerHTML = "", U.appendChild(C) }) } }, "initPreview"), resetPreview: n(function () { Ce(this.previews, function (f) { var g = Oh(f, Cr); Rr(f, { width: g.width, height: g.height }), f.innerHTML = g.html, S1(f, Cr) }) }, "resetPreview"), preview: n(function () { var f = this.imageData, g = this.canvasData, m = this.cropBoxData, P = m.width, w = m.height, _ = f.width, O = f.height, U = m.left - g.left - f.left, C = m.top - g.top - f.top; !this.cropped || this.disabled || (Rr(this.viewBoxImage, fe({ width: _, height: O }, hn(fe({ translateX: -U, translateY: -C }, f)))), Ce(this.previews, function (T) { var A = Oh(T, Cr), R = A.width, re = A.height, ee = R, me = re, oe = 1; P && (oe = R / P, me = w * oe), w && me > re && (oe = re / w, ee = P * oe, me = re), Rr(T, { width: ee, height: me }), Rr(T.getElementsByTagName("img")[0], fe({ width: _ * oe, height: O * oe }, hn(fe({ translateX: -U * oe, translateY: -C * oe }, f)))) })) }, "preview") }, N1 = { bind: n(function () { var f = this.element, g = this.options, m = this.cropper; _t(g.cropstart) && Zt(f, vo, g.cropstart), _t(g.cropmove) && Zt(f, yo, g.cropmove), _t(g.cropend) && Zt(f, Jt, g.cropend), _t(g.crop) && Zt(f, Qi, g.crop), _t(g.zoom) && Zt(f, xh, g.zoom), Zt(m, af, this.onCropStart = this.cropStart.bind(this)), g.zoomable && g.zoomOnWheel && Zt(m, df, this.onWheel = this.wheel.bind(this), { passive: !1, capture: !0 }), g.toggleDragModeOnDblclick && Zt(m, ln, this.onDblclick = this.dblclick.bind(this)), Zt(f.ownerDocument, lf, this.onCropMove = this.cropMove.bind(this)), Zt(f.ownerDocument, uf, this.onCropEnd = this.cropEnd.bind(this)), g.responsive && Zt(window, cf, this.onResize = this.resize.bind(this)) }, "bind"), unbind: n(function () { var f = this.element, g = this.options, m = this.cropper; _t(g.cropstart) && li(f, vo, g.cropstart), _t(g.cropmove) && li(f, yo, g.cropmove), _t(g.cropend) && li(f, Jt, g.cropend), _t(g.crop) && li(f, Qi, g.crop), _t(g.zoom) && li(f, xh, g.zoom), li(m, af, this.onCropStart), g.zoomable && g.zoomOnWheel && li(m, df, this.onWheel, { passive: !1, capture: !0 }), g.toggleDragModeOnDblclick && li(m, ln, this.onDblclick), li(f.ownerDocument, lf, this.onCropMove), li(f.ownerDocument, uf, this.onCropEnd), g.responsive && li(window, cf, this.onResize) }, "unbind") }, I1 = { resize: n(function () { if (!this.disabled) { var f = this.options, g = this.container, m = this.containerData, P = g.offsetWidth / m.width; if (P !== 1 || g.offsetHeight !== m.height) { var w, _; f.restore && (w = this.getCanvasData(), _ = this.getCropBoxData()), this.render(), f.restore && (this.setCanvasData(Ce(w, function (O, U) { w[U] = O * P })), this.setCropBoxData(Ce(_, function (O, U) { _[U] = O * P }))) } } }, "resize"), dblclick: n(function () { this.disabled || this.options.dragMode === rs || this.setDragMode(b1(this.dragBox, st) ? is : Yi) }, "dblclick"), wheel: n(function (f) { var g = this, m = Number(this.options.wheelZoomRatio) || .1, P = 1; this.disabled || (f.preventDefault(), !this.wheeling && (this.wheeling = !0, setTimeout(function () { g.wheeling = !1 }, 50), f.deltaY ? P = f.deltaY > 0 ? 1 : -1 : f.wheelDelta ? P = -f.wheelDelta / 120 : f.detail && (P = f.detail > 0 ? 1 : -1), this.zoom(-P * m, f))) }, "wheel"), cropStart: n(function (f) { var g = f.buttons, m = f.button; if (!(this.disabled || (f.type === "mousedown" || f.type === "pointerdown" && f.pointerType === "mouse") && (Z(g) && g !== 1 || Z(m) && m !== 0 || f.ctrlKey))) { var P = this.options, w = this.pointers, _; f.changedTouches ? Ce(f.changedTouches, function (O) { w[O.identifier] = kl(O) }) : w[f.pointerId || 0] = kl(f), Object.keys(w).length > 1 && P.zoomable && P.zoomOnTouch ? _ = W : _ = Oh(f.target, Xi), u1.test(_) && Po(this.element, vo, { originalEvent: f, action: _ }) !== !1 && (f.preventDefault(), this.action = _, this.cropping = !1, _ === B && (this.cropping = !0, qe(this.dragBox, xi))) } }, "cropStart"), cropMove: n(function (f) { var g = this.action; if (!(this.disabled || !g)) { var m = this.pointers; f.preventDefault(), Po(this.element, yo, { originalEvent: f, action: g }) !== !1 && (f.changedTouches ? Ce(f.changedTouches, function (P) { fe(m[P.identifier] || {}, kl(P, !0)) }) : fe(m[f.pointerId || 0] || {}, kl(f, !0)), this.change(f)) } }, "cropMove"), cropEnd: n(function (f) { if (!this.disabled) { var g = this.action, m = this.pointers; f.changedTouches ? Ce(f.changedTouches, function (P) { delete m[P.identifier] }) : delete m[f.pointerId || 0], g && (f.preventDefault(), Object.keys(m).length || (this.action = ""), this.cropping && (this.cropping = !1, So(this.dragBox, xi, this.cropped && this.options.modal)), Po(this.element, Jt, { originalEvent: f, action: g })) } }, "cropEnd") }, B1 = { change: n(function (f) { var g = this.options, m = this.canvasData, P = this.containerData, w = this.cropBoxData, _ = this.pointers, O = this.action, U = g.aspectRatio, C = w.left, T = w.top, A = w.width, R = w.height, re = C + A, ee = T + R, me = 0, oe = 0, Ie = P.width, $e = P.height, Re = !0, Ji; !U && f.shiftKey && (U = A && R ? A / R : 1), this.limited && (me = w.minLeft, oe = w.minTop, Ie = me + Math.min(P.width, m.width, m.left + m.width), $e = oe + Math.min(P.height, m.height, m.top + m.height)); var Rt = _[Object.keys(_)[0]], N = { x: Rt.endX - Rt.startX, y: Rt.endY - Rt.startY }, ne = n(function (ei) { switch (ei) { case I: re + N.x > Ie && (N.x = Ie - re); break; case q: C + N.x < me && (N.x = me - C); break; case V: T + N.y < oe && (N.y = oe - T); break; case $: ee + N.y > $e && (N.y = $e - ee); break } }, "check"); switch (O) { case k: C += N.x, T += N.y; break; case I: if (N.x >= 0 && (re >= Ie || U && (T <= oe || ee >= $e))) { Re = !1; break } ne(I), A += N.x, A < 0 && (O = q, A = -A, C -= A), U && (R = A / U, T += (w.height - R) / 2); break; case V: if (N.y <= 0 && (T <= oe || U && (C <= me || re >= Ie))) { Re = !1; break } ne(V), R -= N.y, T += N.y, R < 0 && (O = $, R = -R, T -= R), U && (A = R * U, C += (w.width - A) / 2); break; case q: if (N.x <= 0 && (C <= me || U && (T <= oe || ee >= $e))) { Re = !1; break } ne(q), A -= N.x, C += N.x, A < 0 && (O = I, A = -A, C -= A), U && (R = A / U, T += (w.height - R) / 2); break; case $: if (N.y >= 0 && (ee >= $e || U && (C <= me || re >= Ie))) { Re = !1; break } ne($), R += N.y, R < 0 && (O = V, R = -R, T -= R), U && (A = R * U, C += (w.width - A) / 2); break; case xe: if (U) { if (N.y <= 0 && (T <= oe || re >= Ie)) { Re = !1; break } ne(V), R -= N.y, T += N.y, A = R * U } else ne(V), ne(I), N.x >= 0 ? re < Ie ? A += N.x : N.y <= 0 && T <= oe && (Re = !1) : A += N.x, N.y <= 0 ? T > oe && (R -= N.y, T += N.y) : (R -= N.y, T += N.y); A < 0 && R < 0 ? (O = rt, R = -R, A = -A, T -= R, C -= A) : A < 0 ? (O = Pt, A = -A, C -= A) : R < 0 && (O = ut, R = -R, T -= R); break; case Pt: if (U) { if (N.y <= 0 && (T <= oe || C <= me)) { Re = !1; break } ne(V), R -= N.y, T += N.y, A = R * U, C += w.width - A } else ne(V), ne(q), N.x <= 0 ? C > me ? (A -= N.x, C += N.x) : N.y <= 0 && T <= oe && (Re = !1) : (A -= N.x, C += N.x), N.y <= 0 ? T > oe && (R -= N.y, T += N.y) : (R -= N.y, T += N.y); A < 0 && R < 0 ? (O = ut, R = -R, A = -A, T -= R, C -= A) : A < 0 ? (O = xe, A = -A, C -= A) : R < 0 && (O = rt, R = -R, T -= R); break; case rt: if (U) { if (N.x <= 0 && (C <= me || ee >= $e)) { Re = !1; break } ne(q), A -= N.x, C += N.x, R = A / U } else ne($), ne(q), N.x <= 0 ? C > me ? (A -= N.x, C += N.x) : N.y >= 0 && ee >= $e && (Re = !1) : (A -= N.x, C += N.x), N.y >= 0 ? ee < $e && (R += N.y) : R += N.y; A < 0 && R < 0 ? (O = xe, R = -R, A = -A, T -= R, C -= A) : A < 0 ? (O = ut, A = -A, C -= A) : R < 0 && (O = Pt, R = -R, T -= R); break; case ut: if (U) { if (N.x >= 0 && (re >= Ie || ee >= $e)) { Re = !1; break } ne(I), A += N.x, R = A / U } else ne($), ne(I), N.x >= 0 ? re < Ie ? A += N.x : N.y >= 0 && ee >= $e && (Re = !1) : A += N.x, N.y >= 0 ? ee < $e && (R += N.y) : R += N.y; A < 0 && R < 0 ? (O = Pt, R = -R, A = -A, T -= R, C -= A) : A < 0 ? (O = rt, A = -A, C -= A) : R < 0 && (O = xe, R = -R, T -= R); break; case H: this.move(N.x, N.y), Re = !1; break; case W: this.zoom(_1(_), f), Re = !1; break; case B: if (!N.x || !N.y) { Re = !1; break } Ji = bf(this.cropper), C = Rt.startX - Ji.left, T = Rt.startY - Ji.top, A = w.minWidth, R = w.minHeight, N.x > 0 ? O = N.y > 0 ? ut : xe : N.x < 0 && (C -= A, O = N.y > 0 ? rt : Pt), N.y < 0 && (T -= R), this.cropped || (Ei(this.cropBox, Ee), this.cropped = !0, this.limited && this.limitCropBox(!0, !0)); break }Re && (w.width = A, w.height = R, w.left = C, w.top = T, this.action = O, this.renderCropBox()), Ce(_, function (Be) { Be.startX = Be.endX, Be.startY = Be.endY }) }, "change") }, L1 = { crop: n(function () { return this.ready && !this.cropped && !this.disabled && (this.cropped = !0, this.limitCropBox(!0, !0), this.options.modal && qe(this.dragBox, xi), Ei(this.cropBox, Ee), this.setCropBoxData(this.initialCropBoxData)), this }, "crop"), reset: n(function () { return this.ready && !this.disabled && (this.imageData = fe({}, this.initialImageData), this.canvasData = fe({}, this.initialCanvasData), this.cropBoxData = fe({}, this.initialCropBoxData), this.renderCanvas(), this.cropped && this.renderCropBox()), this }, "reset"), clear: n(function () { return this.cropped && !this.disabled && (fe(this.cropBoxData, { left: 0, top: 0, width: 0, height: 0 }), this.cropped = !1, this.renderCropBox(), this.limitCanvas(!0, !0), this.renderCanvas(), Ei(this.dragBox, xi), qe(this.cropBox, Ee)), this }, "clear"), replace: n(function (f) { var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1; return !this.disabled && f && (this.isImg && (this.element.src = f), g ? (this.url = f, this.image.src = f, this.ready && (this.viewBoxImage.src = f, Ce(this.previews, function (m) { m.getElementsByTagName("img")[0].src = f }))) : (this.isImg && (this.replaced = !0), this.options.data = null, this.uncreate(), this.load(f))), this }, "replace"), enable: n(function () { return this.ready && this.disabled && (this.disabled = !1, Ei(this.cropper, We)), this }, "enable"), disable: n(function () { return this.ready && !this.disabled && (this.disabled = !0, qe(this.cropper, We)), this }, "disable"), destroy: n(function () { var f = this.element; return f[F] ? (f[F] = void 0, this.isImg && this.replaced && (f.src = this.originalUrl), this.uncreate(), this) : this }, "destroy"), move: n(function (f) { var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : f, m = this.canvasData, P = m.left, w = m.top; return this.moveTo(Eh(f) ? f : P + Number(f), Eh(g) ? g : w + Number(g)) }, "move"), moveTo: n(function (f) { var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : f, m = this.canvasData, P = !1; return f = Number(f), g = Number(g), this.ready && !this.disabled && this.options.movable && (Z(f) && (m.left = f, P = !0), Z(g) && (m.top = g, P = !0), P && this.renderCanvas(!0)), this }, "moveTo"), zoom: n(function (f, g) { var m = this.canvasData; return f = Number(f), f < 0 ? f = 1 / (1 - f) : f = 1 + f, this.zoomTo(m.width * f / m.naturalWidth, null, g) }, "zoom"), zoomTo: n(function (f, g, m) { var P = this.options, w = this.canvasData, _ = w.width, O = w.height, U = w.naturalWidth, C = w.naturalHeight; if (f = Number(f), f >= 0 && this.ready && !this.disabled && P.zoomable) { var T = U * f, A = C * f; if (Po(this.element, xh, { ratio: f, oldRatio: _ / U, originalEvent: m }) === !1) return this; if (m) { var R = this.pointers, re = bf(this.cropper), ee = R && Object.keys(R).length ? x1(R) : { pageX: m.pageX, pageY: m.pageY }; w.left -= (T - _) * ((ee.pageX - re.left - w.left) / _), w.top -= (A - O) * ((ee.pageY - re.top - w.top) / O) } else bo(g) && Z(g.x) && Z(g.y) ? (w.left -= (T - _) * ((g.x - w.left) / _), w.top -= (A - O) * ((g.y - w.top) / O)) : (w.left -= (T - _) / 2, w.top -= (A - O) / 2); w.width = T, w.height = A, this.renderCanvas(!0) } return this }, "zoomTo"), rotate: n(function (f) { return this.rotateTo((this.imageData.rotate || 0) + Number(f)) }, "rotate"), rotateTo: n(function (f) { return f = Number(f), Z(f) && this.ready && !this.disabled && this.options.rotatable && (this.imageData.rotate = f % 360, this.renderCanvas(!0, !0)), this }, "rotateTo"), scaleX: n(function (f) { var g = this.imageData.scaleY; return this.scale(f, Z(g) ? g : 1) }, "scaleX"), scaleY: n(function (f) { var g = this.imageData.scaleX; return this.scale(Z(g) ? g : 1, f) }, "scaleY"), scale: n(function (f) { var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : f, m = this.imageData, P = !1; return f = Number(f), g = Number(g), this.ready && !this.disabled && this.options.scalable && (Z(f) && (m.scaleX = f, P = !0), Z(g) && (m.scaleY = g, P = !0), P && this.renderCanvas(!0, !0)), this }, "scale"), getData: n(function () { var f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, g = this.options, m = this.imageData, P = this.canvasData, w = this.cropBoxData, _; if (this.ready && this.cropped) { _ = { x: w.left - P.left, y: w.top - P.top, width: w.width, height: w.height }; var O = m.width / m.naturalWidth; if (Ce(_, function (T, A) { _[A] = T / O }), f) { var U = Math.round(_.y + _.height), C = Math.round(_.x + _.width); _.x = Math.round(_.x), _.y = Math.round(_.y), _.width = C - _.x, _.height = U - _.y } } else _ = { x: 0, y: 0, width: 0, height: 0 }; return g.rotatable && (_.rotate = m.rotate || 0), g.scalable && (_.scaleX = m.scaleX || 1, _.scaleY = m.scaleY || 1), _ }, "getData"), setData: n(function (f) { var g = this.options, m = this.imageData, P = this.canvasData, w = {}; if (this.ready && !this.disabled && bo(f)) { var _ = !1; g.rotatable && Z(f.rotate) && f.rotate !== m.rotate && (m.rotate = f.rotate, _ = !0), g.scalable && (Z(f.scaleX) && f.scaleX !== m.scaleX && (m.scaleX = f.scaleX, _ = !0), Z(f.scaleY) && f.scaleY !== m.scaleY && (m.scaleY = f.scaleY, _ = !0)), _ && this.renderCanvas(!0, !0); var O = m.width / m.naturalWidth; Z(f.x) && (w.left = f.x * O + P.left), Z(f.y) && (w.top = f.y * O + P.top), Z(f.width) && (w.width = f.width * O), Z(f.height) && (w.height = f.height * O), this.setCropBoxData(w) } return this }, "setData"), getContainerData: n(function () { return this.ready ? fe({}, this.containerData) : {} }, "getContainerData"), getImageData: n(function () { return this.sized ? fe({}, this.imageData) : {} }, "getImageData"), getCanvasData: n(function () { var f = this.canvasData, g = {}; return this.ready && Ce(["left", "top", "width", "height", "naturalWidth", "naturalHeight"], function (m) { g[m] = f[m] }), g }, "getCanvasData"), setCanvasData: n(function (f) { var g = this.canvasData, m = g.aspectRatio; return this.ready && !this.disabled && bo(f) && (Z(f.left) && (g.left = f.left), Z(f.top) && (g.top = f.top), Z(f.width) ? (g.width = f.width, g.height = f.width / m) : Z(f.height) && (g.height = f.height, g.width = f.height * m), this.renderCanvas(!0)), this }, "setCanvasData"), getCropBoxData: n(function () { var f = this.cropBoxData, g; return this.ready && this.cropped && (g = { left: f.left, top: f.top, width: f.width, height: f.height }), g || {} }, "getCropBoxData"), setCropBoxData: n(function (f) { var g = this.cropBoxData, m = this.options.aspectRatio, P, w; return this.ready && this.cropped && !this.disabled && bo(f) && (Z(f.left) && (g.left = f.left), Z(f.top) && (g.top = f.top), Z(f.width) && f.width !== g.width && (P = !0, g.width = f.width), Z(f.height) && f.height !== g.height && (w = !0, g.height = f.height), m && (P ? g.height = g.width / m : w && (g.width = g.height * m)), this.renderCropBox()), this }, "setCropBoxData"), getCroppedCanvas: n(function () { var f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; if (!this.ready || !window.HTMLCanvasElement) return null; var g = this.canvasData, m = F1(this.image, this.imageData, g, f); if (!this.cropped) return m; var P = this.getData(), w = P.x, _ = P.y, O = P.width, U = P.height, C = m.width / Math.floor(g.naturalWidth); C !== 1 && (w *= C, _ *= C, O *= C, U *= C); var T = O / U, A = kr({ aspectRatio: T, width: f.maxWidth || 1 / 0, height: f.maxHeight || 1 / 0 }), R = kr({ aspectRatio: T, width: f.minWidth || 0, height: f.minHeight || 0 }, "cover"), re = kr({ aspectRatio: T, width: f.width || (C !== 1 ? m.width : O), height: f.height || (C !== 1 ? m.height : U) }), ee = re.width, me = re.height; ee = Math.min(A.width, Math.max(R.width, ee)), me = Math.min(A.height, Math.max(R.height, me)); var oe = document.createElement("canvas"), Ie = oe.getContext("2d"); oe.width = wo(ee), oe.height = wo(me), Ie.fillStyle = f.fillColor || "transparent", Ie.fillRect(0, 0, ee, me); var $e = f.imageSmoothingEnabled, Re = $e === void 0 ? !0 : $e, Ji = f.imageSmoothingQuality; Ie.imageSmoothingEnabled = Re, Ji && (Ie.imageSmoothingQuality = Ji); var Rt = m.width, N = m.height, ne = w, Be = _, ei, Zi, os, ns, Ur, Fi; ne <= -O || ne > Rt ? (ne = 0, ei = 0, os = 0, Ur = 0) : ne <= 0 ? (os = -ne, ne = 0, ei = Math.min(Rt, O + ne), Ur = ei) : ne <= Rt && (os = 0, ei = Math.min(O, Rt - ne), Ur = ei), ei <= 0 || Be <= -U || Be > N ? (Be = 0, Zi = 0, ns = 0, Fi = 0) : Be <= 0 ? (ns = -Be, Be = 0, Zi = Math.min(N, U + Be), Fi = Zi) : Be <= N && (ns = 0, Zi = Math.min(U, N - Be), Fi = Zi); var xt = [ne, Be, ei, Zi]; if (Ur > 0 && Fi > 0) { var as = ee / O; xt.push(os * as, ns * as, Ur * as, Fi * as) } return Ie.drawImage.apply(Ie, [m].concat(l(xt.map(function (Ul) { return Math.floor(wo(Ul)) })))), oe }, "getCroppedCanvas"), setAspectRatio: n(function (f) { var g = this.options; return !this.disabled && !Eh(f) && (g.aspectRatio = Math.max(0, f) || NaN, this.ready && (this.initCropBox(), this.cropped && this.renderCropBox())), this }, "setAspectRatio"), setDragMode: n(function (f) { var g = this.options, m = this.dragBox, P = this.face; if (this.ready && !this.disabled) { var w = f === Yi, _ = g.movable && f === is; f = w || _ ? f : rs, g.dragMode = f, un(m, Xi, f), So(m, st, w), So(m, ts, _), g.cropBoxMovable || (un(P, Xi, f), So(P, st, w), So(P, ts, _)) } return this }, "setDragMode") }, M1 = S.Cropper, _f = function () { function b(f) { var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; if (e(this, b), !f || !d1.test(f.tagName)) throw new Error("The first argument is required and must be an <img> or <canvas> element."); this.element = f, this.options = fe({}, ff, bo(g) && g), this.cropped = !1, this.disabled = !1, this.pointers = {}, this.ready = !1, this.reloading = !1, this.replaced = !1, this.sized = !1, this.sizing = !1, this.init() } return n(b, "Cropper"), r(b, [{ key: "init", value: n(function () { var g = this.element, m = g.tagName.toLowerCase(), P; if (!g[F]) { if (g[F] = this, m === "img") { if (this.isImg = !0, P = g.getAttribute("src") || "", this.originalUrl = P, !P) return; P = g.src } else m === "canvas" && window.HTMLCanvasElement && (P = g.toDataURL()); this.load(P) } }, "init") }, { key: "load", value: n(function (g) { var m = this; if (g) { this.url = g, this.imageData = {}; var P = this.element, w = this.options; if (!w.rotatable && !w.scalable && (w.checkOrientation = !1), !w.checkOrientation || !window.ArrayBuffer) { this.clone(); return } if (h1.test(g)) { c1.test(g) ? this.read(T1(g)) : this.clone(); return } var _ = new XMLHttpRequest, O = this.clone.bind(this); this.reloading = !0, this.xhr = _, _.onabort = O, _.onerror = O, _.ontimeout = O, _.onprogress = function () { _.getResponseHeader("content-type") !== pf && _.abort() }, _.onload = function () { m.read(_.response) }, _.onloadend = function () { m.reloading = !1, m.xhr = null }, w.checkCrossOrigin && wf(g) && P.crossOrigin && (g = Sf(g)), _.open("GET", g), _.responseType = "arraybuffer", _.withCredentials = P.crossOrigin === "use-credentials", _.send() } }, "load") }, { key: "read", value: n(function (g) { var m = this.options, P = this.imageData, w = R1(g), _ = 0, O = 1, U = 1; if (w > 1) { this.url = C1(g, pf); var C = k1(w); _ = C.rotate, O = C.scaleX, U = C.scaleY } m.rotatable && (P.rotate = _), m.scalable && (P.scaleX = O, P.scaleY = U), this.clone() }, "read") }, { key: "clone", value: n(function () { var g = this.element, m = this.url, P = g.crossOrigin, w = m; this.options.checkCrossOrigin && wf(m) && (P || (P = "anonymous"), w = Sf(m)), this.crossOrigin = P, this.crossOriginUrl = w; var _ = document.createElement("img"); P && (_.crossOrigin = P), _.src = w || m, _.alt = g.alt || "The image to crop", this.image = _, _.onload = this.start.bind(this), _.onerror = this.stop.bind(this), qe(_, ai), g.parentNode.insertBefore(_, g.nextSibling) }, "clone") }, { key: "start", value: n(function () { var g = this, m = this.image; m.onload = null, m.onerror = null, this.sizing = !0; var P = S.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(S.navigator.userAgent), w = n(function (C, T) { fe(g.imageData, { naturalWidth: C, naturalHeight: T, aspectRatio: C / T }), g.sizing = !1, g.sized = !0, g.build() }, "done"); if (m.naturalWidth && !P) { w(m.naturalWidth, m.naturalHeight); return } var _ = document.createElement("img"), O = document.body || document.documentElement; this.sizingImage = _, _.onload = function () { w(_.width, _.height), P || O.removeChild(_) }, _.src = m.src, P || (_.style.cssText = "left:0;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;opacity:0;position:absolute;top:0;z-index:-1;", O.appendChild(_)) }, "start") }, { key: "stop", value: n(function () { var g = this.image; g.onload = null, g.onerror = null, g.parentNode.removeChild(g), this.image = null }, "stop") }, { key: "build", value: n(function () { if (!(!this.sized || this.ready)) { var g = this.element, m = this.options, P = this.image, w = g.parentNode, _ = document.createElement("div"); _.innerHTML = p1; var O = _.querySelector(".".concat(F, "-container")), U = O.querySelector(".".concat(F, "-canvas")), C = O.querySelector(".".concat(F, "-drag-box")), T = O.querySelector(".".concat(F, "-crop-box")), A = T.querySelector(".".concat(F, "-face")); this.container = w, this.cropper = O, this.canvas = U, this.dragBox = C, this.cropBox = T, this.viewBox = O.querySelector(".".concat(F, "-view-box")), this.face = A, U.appendChild(P), qe(g, Ee), w.insertBefore(O, g.nextSibling), this.isImg || Ei(P, ai), this.initPreview(), this.bind(), m.initialAspectRatio = Math.max(0, m.initialAspectRatio) || NaN, m.aspectRatio = Math.max(0, m.aspectRatio) || NaN, m.viewMode = Math.max(0, Math.min(3, Math.round(m.viewMode))) || 0, qe(T, Ee), m.guides || qe(T.getElementsByClassName("".concat(F, "-dashed")), Ee), m.center || qe(T.getElementsByClassName("".concat(F, "-center")), Ee), m.background && qe(O, "".concat(F, "-bg")), m.highlight || qe(A, go), m.cropBoxMovable && (qe(A, ts), un(A, Xi, k)), m.cropBoxResizable || (qe(T.getElementsByClassName("".concat(F, "-line")), Ee), qe(T.getElementsByClassName("".concat(F, "-point")), Ee)), this.render(), this.ready = !0, this.setDragMode(m.dragMode), m.autoCrop && this.crop(), this.setData(m.data), _t(m.ready) && Zt(g, hf, m.ready, { once: !0 }), Po(g, hf) } }, "build") }, { key: "unbuild", value: n(function () { this.ready && (this.ready = !1, this.unbind(), this.resetPreview(), this.cropper.parentNode.removeChild(this.cropper), Ei(this.element, Ee)) }, "unbuild") }, { key: "uncreate", value: n(function () { this.ready ? (this.unbuild(), this.ready = !1, this.cropped = !1) : this.sizing ? (this.sizingImage.onload = null, this.sizing = !1, this.sized = !1) : this.reloading ? (this.xhr.onabort = null, this.xhr.abort()) : this.image && this.stop() }, "uncreate") }], [{ key: "noConflict", value: n(function () { return window.Cropper = M1, b }, "noConflict") }, { key: "setDefaults", value: n(function (g) { fe(ff, bo(g) && g) }, "setDefaults") }]), b }(); return fe(_f.prototype, U1, D1, N1, I1, B1, L1), _f
        })
    }); var gv = ae((f7, Mu) => { "use strict"; Mu.exports = Sd; Mu.exports.isMobile = Sd; Mu.exports.default = Sd; var h_ = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i, c_ = /CrOS/, d_ = /android|ipad|playbook|silk/i; function Sd(i) { i || (i = {}); let e = i.ua; if (!e && typeof navigator < "u" && (e = navigator.userAgent), e && e.headers && typeof e.headers["user-agent"] == "string" && (e = e.headers["user-agent"]), typeof e != "string") return !1; let t = h_.test(e) && !c_.test(e) || !!i.tablet && d_.test(e); return !t && i.tablet && i.featureDetect && navigator && navigator.maxTouchPoints > 1 && e.indexOf("Macintosh") !== -1 && e.indexOf("Safari") !== -1 && (t = !0), t } n(Sd, "isMobile") }); var a0 = ae((T9, n0) => { "use strict"; n0.exports = n(function (e, t) { if (t = t.split(":")[0], e = +e, !e) return !1; switch (t) { case "http": case "ws": return e !== 80; case "https": case "wss": return e !== 443; case "ftp": return e !== 21; case "gopher": return e !== 70; case "file": return !1 }return e !== 0 }, "required") }); var h0 = ae(Jd => { "use strict"; var _5 = Object.prototype.hasOwnProperty, x5; function l0(i) { try { return decodeURIComponent(i.replace(/\+/g, " ")) } catch { return null } } n(l0, "decode"); function u0(i) { try { return encodeURIComponent(i) } catch { return null } } n(u0, "encode"); function E5(i) { for (var e = /([^=?#&]+)=?([^&]*)/g, t = {}, r; r = e.exec(i);) { var s = l0(r[1]), o = l0(r[2]); s === null || o === null || s in t || (t[s] = o) } return t } n(E5, "querystring"); function F5(i, e) { e = e || ""; var t = [], r, s; typeof e != "string" && (e = "?"); for (s in i) if (_5.call(i, s)) { if (r = i[s], !r && (r === null || r === x5 || isNaN(r)) && (r = ""), s = u0(s), r = u0(r), s === null || r === null) continue; t.push(s + "=" + r) } return t.length ? e + t.join("&") : "" } n(F5, "querystringify"); Jd.stringify = F5; Jd.parse = E5 }); var v0 = ae((U9, y0) => { "use strict"; var d0 = a0(), Yu = h0(), O5 = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, p0 = /[\n\r\t]/g, A5 = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//, f0 = /:\d+$/, T5 = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i, C5 = /^[a-zA-Z]:/; function ep(i) { return (i || "").toString().replace(O5, "") } n(ep, "trimLeft"); var Zd = [["#", "hash"], ["?", "query"], n(function (e, t) { return Vi(t.protocol) ? e.replace(/\\/g, "/") : e }, "sanitize"), ["/", "pathname"], ["@", "auth", 1], [NaN, "host", void 0, 1, 1], [/:(\d*)$/, "port", void 0, 1], [NaN, "hostname", void 0, 1, 1]], c0 = { hash: 1, query: 1 }; function m0(i) { var e; typeof window < "u" ? e = window : typeof global < "u" ? e = global : typeof self < "u" ? e = self : e = {}; var t = e.location || {}; i = i || t; var r = {}, s = typeof i, o; if (i.protocol === "blob:") r = new Wi(unescape(i.pathname), {}); else if (s === "string") { r = new Wi(i, {}); for (o in c0) delete r[o] } else if (s === "object") { for (o in i) o in c0 || (r[o] = i[o]); r.slashes === void 0 && (r.slashes = A5.test(i.href)) } return r } n(m0, "lolcation"); function Vi(i) { return i === "file:" || i === "ftp:" || i === "http:" || i === "https:" || i === "ws:" || i === "wss:" } n(Vi, "isSpecial"); function g0(i, e) { i = ep(i), i = i.replace(p0, ""), e = e || {}; var t = T5.exec(i), r = t[1] ? t[1].toLowerCase() : "", s = !!t[2], o = !!t[3], a = 0, l; return s ? o ? (l = t[2] + t[3] + t[4], a = t[2].length + t[3].length) : (l = t[2] + t[4], a = t[2].length) : o ? (l = t[3] + t[4], a = t[3].length) : l = t[4], r === "file:" ? a >= 2 && (l = l.slice(2)) : Vi(r) ? l = t[4] : r ? s && (l = l.slice(2)) : a >= 2 && Vi(e.protocol) && (l = t[4]), { protocol: r, slashes: s || Vi(r), slashesCount: a, rest: l } } n(g0, "extractProtocol"); function R5(i, e) { if (i === "") return e; for (var t = (e || "/").split("/").slice(0, -1).concat(i.split("/")), r = t.length, s = t[r - 1], o = !1, a = 0; r--;)t[r] === "." ? t.splice(r, 1) : t[r] === ".." ? (t.splice(r, 1), a++) : a && (r === 0 && (o = !0), t.splice(r, 1), a--); return o && t.unshift(""), (s === "." || s === "..") && t.push(""), t.join("/") } n(R5, "resolve"); function Wi(i, e, t) { if (i = ep(i), i = i.replace(p0, ""), !(this instanceof Wi)) return new Wi(i, e, t); var r, s, o, a, l, h, c = Zd.slice(), d = typeof e, p = this, y = 0; for (d !== "object" && d !== "string" && (t = e, e = null), t && typeof t != "function" && (t = Yu.parse), e = m0(e), s = g0(i || "", e), r = !s.protocol && !s.slashes, p.slashes = s.slashes || r && e.slashes, p.protocol = s.protocol || e.protocol || "", i = s.rest, (s.protocol === "file:" && (s.slashesCount !== 2 || C5.test(i)) || !s.slashes && (s.protocol || s.slashesCount < 2 || !Vi(p.protocol))) && (c[3] = [/(.*)/, "pathname"]); y < c.length; y++) { if (a = c[y], typeof a == "function") { i = a(i, p); continue } o = a[0], h = a[1], o !== o ? p[h] = i : typeof o == "string" ? (l = o === "@" ? i.lastIndexOf(o) : i.indexOf(o), ~l && (typeof a[2] == "number" ? (p[h] = i.slice(0, l), i = i.slice(l + a[2])) : (p[h] = i.slice(l), i = i.slice(0, l)))) : (l = o.exec(i)) && (p[h] = l[1], i = i.slice(0, l.index)), p[h] = p[h] || r && a[3] && e[h] || "", a[4] && (p[h] = p[h].toLowerCase()) } t && (p.query = t(p.query)), r && e.slashes && p.pathname.charAt(0) !== "/" && (p.pathname !== "" || e.pathname !== "") && (p.pathname = R5(p.pathname, e.pathname)), p.pathname.charAt(0) !== "/" && Vi(p.protocol) && (p.pathname = "/" + p.pathname), d0(p.port, p.protocol) || (p.host = p.hostname, p.port = ""), p.username = p.password = "", p.auth && (l = p.auth.indexOf(":"), ~l ? (p.username = p.auth.slice(0, l), p.username = encodeURIComponent(decodeURIComponent(p.username)), p.password = p.auth.slice(l + 1), p.password = encodeURIComponent(decodeURIComponent(p.password))) : p.username = encodeURIComponent(decodeURIComponent(p.auth)), p.auth = p.password ? p.username + ":" + p.password : p.username), p.origin = p.protocol !== "file:" && Vi(p.protocol) && p.host ? p.protocol + "//" + p.host : "null", p.href = p.toString() } n(Wi, "Url"); function k5(i, e, t) { var r = this; switch (i) { case "query": typeof e == "string" && e.length && (e = (t || Yu.parse)(e)), r[i] = e; break; case "port": r[i] = e, d0(e, r.protocol) ? e && (r.host = r.hostname + ":" + e) : (r.host = r.hostname, r[i] = ""); break; case "hostname": r[i] = e, r.port && (e += ":" + r.port), r.host = e; break; case "host": r[i] = e, f0.test(e) ? (e = e.split(":"), r.port = e.pop(), r.hostname = e.join(":")) : (r.hostname = e, r.port = ""); break; case "protocol": r.protocol = e.toLowerCase(), r.slashes = !t; break; case "pathname": case "hash": if (e) { var s = i === "pathname" ? "/" : "#"; r[i] = e.charAt(0) !== s ? s + e : e } else r[i] = e; break; case "username": case "password": r[i] = encodeURIComponent(e); break; case "auth": var o = e.indexOf(":"); ~o ? (r.username = e.slice(0, o), r.username = encodeURIComponent(decodeURIComponent(r.username)), r.password = e.slice(o + 1), r.password = encodeURIComponent(decodeURIComponent(r.password))) : r.username = encodeURIComponent(decodeURIComponent(e)) }for (var a = 0; a < Zd.length; a++) { var l = Zd[a]; l[4] && (r[l[1]] = r[l[1]].toLowerCase()) } return r.auth = r.password ? r.username + ":" + r.password : r.username, r.origin = r.protocol !== "file:" && Vi(r.protocol) && r.host ? r.protocol + "//" + r.host : "null", r.href = r.toString(), r } n(k5, "set"); function U5(i) { (!i || typeof i != "function") && (i = Yu.stringify); var e, t = this, r = t.host, s = t.protocol; s && s.charAt(s.length - 1) !== ":" && (s += ":"); var o = s + (t.protocol && t.slashes || Vi(t.protocol) ? "//" : ""); return t.username ? (o += t.username, t.password && (o += ":" + t.password), o += "@") : t.password ? (o += ":" + t.password, o += "@") : t.protocol !== "file:" && Vi(t.protocol) && !r && t.pathname !== "/" && (o += "@"), (r[r.length - 1] === ":" || f0.test(t.hostname) && !t.port) && (r += ":"), o += r + t.pathname, e = typeof t.query == "object" ? i(t.query) : t.query, e && (o += e.charAt(0) !== "?" ? "?" + e : e), t.hash && (o += t.hash), o } n(U5, "toString"); Wi.prototype = { set: k5, toString: U5 }; Wi.extractProtocol = g0; Wi.location = m0; Wi.trimLeft = ep; Wi.qs = Yu; y0.exports = Wi }); var bp = ae((GI, vp) => { typeof vp < "u" && (vp.exports = Vt); function Vt(i) { if (i) return Rx(i) } n(Vt, "Emitter"); function Rx(i) { for (var e in Vt.prototype) i[e] = Vt.prototype[e]; return i } n(Rx, "mixin"); Vt.prototype.on = Vt.prototype.addEventListener = function (i, e) { return this._callbacks = this._callbacks || {}, (this._callbacks["$" + i] = this._callbacks["$" + i] || []).push(e), this }; Vt.prototype.once = function (i, e) { function t() { this.off(i, t), e.apply(this, arguments) } return n(t, "on"), t.fn = e, this.on(i, t), this }; Vt.prototype.off = Vt.prototype.removeListener = Vt.prototype.removeAllListeners = Vt.prototype.removeEventListener = function (i, e) { if (this._callbacks = this._callbacks || {}, arguments.length == 0) return this._callbacks = {}, this; var t = this._callbacks["$" + i]; if (!t) return this; if (arguments.length == 1) return delete this._callbacks["$" + i], this; for (var r, s = 0; s < t.length; s++)if (r = t[s], r === e || r.fn === e) { t.splice(s, 1); break } return t.length === 0 && delete this._callbacks["$" + i], this }; Vt.prototype.emit = function (i) { this._callbacks = this._callbacks || {}; for (var e = new Array(arguments.length - 1), t = this._callbacks["$" + i], r = 1; r < arguments.length; r++)e[r - 1] = arguments[r]; if (t) { t = t.slice(0); for (var r = 0, s = t.length; r < s; ++r)t[r].apply(this, e) } return this }; Vt.prototype.listeners = function (i) { return this._callbacks = this._callbacks || {}, this._callbacks["$" + i] || [] }; Vt.prototype.hasListeners = function (i) { return !!this.listeners(i).length } }); var $b = ae((jM, qb) => { "use strict"; function Ib(i, e) { var t = Object.keys(i); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(i); e && (r = r.filter(function (s) { return Object.getOwnPropertyDescriptor(i, s).enumerable })), t.push.apply(t, r) } return t } n(Ib, "ownKeys"); function yh(i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? Ib(Object(t), !0).forEach(function (r) { jE(i, r, t[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t)) : Ib(Object(t)).forEach(function (r) { Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(t, r)) }) } return i } n(yh, "_objectSpread2"); function ME(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(ME, "_classCallCheck"); function Bb(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(Bb, "_defineProperties"); function zE(i, e, t) { return e && Bb(i.prototype, e), t && Bb(i, t), i } n(zE, "_createClass"); function jE(i, e, t) { return e in i ? Object.defineProperty(i, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = t, i } n(jE, "_defineProperty"); function vh() { return vh = Object.assign || function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, vh.apply(this, arguments) } n(vh, "_extends"); var jb = { exports: {} }; (function (i) { typeof window > "u" || function (e) { var t = e.HTMLCanvasElement && e.HTMLCanvasElement.prototype, r = e.Blob && function () { try { return !!new Blob } catch { return !1 } }(), s = r && e.Uint8Array && function () { try { return new Blob([new Uint8Array(100)]).size === 100 } catch { return !1 } }(), o = e.BlobBuilder || e.WebKitBlobBuilder || e.MozBlobBuilder || e.MSBlobBuilder, a = /^data:((.*?)(;charset=.*?)?)(;base64)?,/, l = (r || o) && e.atob && e.ArrayBuffer && e.Uint8Array && function (h) { var c, d, p, y, v, S, x, E, F; if (c = h.match(a), !c) throw new Error("invalid data URI"); for (d = c[2] ? c[1] : "text/plain" + (c[3] || ";charset=US-ASCII"), p = !!c[4], y = h.slice(c[0].length), p ? v = atob(y) : v = decodeURIComponent(y), S = new ArrayBuffer(v.length), x = new Uint8Array(S), E = 0; E < v.length; E += 1)x[E] = v.charCodeAt(E); return r ? new Blob([s ? x : S], { type: d }) : (F = new o, F.append(S), F.getBlob(d)) }; e.HTMLCanvasElement && !t.toBlob && (t.mozGetAsFile ? t.toBlob = function (h, c, d) { var p = this; setTimeout(function () { d && t.toDataURL && l ? h(l(p.toDataURL(c, d))) : h(p.mozGetAsFile("blob", c)) }) } : t.toDataURL && l && (t.msToBlob ? t.toBlob = function (h, c, d) { var p = this; setTimeout(function () { (c && c !== "image/png" || d) && t.toDataURL && l ? h(l(p.toDataURL(c, d))) : h(p.msToBlob(c)) }) } : t.toBlob = function (h, c, d) { var p = this; setTimeout(function () { h(l(p.toDataURL(c, d))) }) })), i.exports ? i.exports = l : e.dataURLtoBlob = l }(window) })(jb); var HE = jb.exports, qE = n(function (e) { return typeof Blob > "u" ? !1 : e instanceof Blob || Object.prototype.toString.call(e) === "[object Blob]" }, "isBlob"), Lb = { strict: !0, checkOrientation: !0, maxWidth: 1 / 0, maxHeight: 1 / 0, minWidth: 0, minHeight: 0, width: void 0, height: void 0, resize: "none", quality: .8, mimeType: "auto", convertTypes: ["image/png"], convertSize: 5e6, beforeDraw: null, drew: null, success: null, error: null }, $E = typeof window < "u" && typeof window.document < "u", es = $E ? window : {}, bh = n(function (e) { return e > 0 && e < 1 / 0 }, "isPositiveNumber"), VE = Array.prototype.slice; function WE(i) { return Array.from ? Array.from(i) : VE.call(i) } n(WE, "toArray"); var KE = /^image\/.+$/; function rf(i) { return KE.test(i) } n(rf, "isImageType"); function GE(i) { var e = rf(i) ? i.substr(6) : ""; return e === "jpeg" && (e = "jpg"), ".".concat(e) } n(GE, "imageTypeToExtension"); var Hb = String.fromCharCode; function XE(i, e, t) { var r = "", s; for (t += e, s = e; s < t; s += 1)r += Hb(i.getUint8(s)); return r } n(XE, "getStringFromCharCode"); var YE = es.btoa; function QE(i, e) { for (var t = [], r = 8192, s = new Uint8Array(i); s.length > 0;)t.push(Hb.apply(null, WE(s.subarray(0, r)))), s = s.subarray(r); return "data:".concat(e, ";base64,").concat(YE(t.join(""))) } n(QE, "arrayBufferToDataURL"); function JE(i) { var e = new DataView(i), t; try { var r, s, o; if (e.getUint8(0) === 255 && e.getUint8(1) === 216) for (var a = e.byteLength, l = 2; l + 1 < a;) { if (e.getUint8(l) === 255 && e.getUint8(l + 1) === 225) { s = l; break } l += 1 } if (s) { var h = s + 4, c = s + 10; if (XE(e, h, 4) === "Exif") { var d = e.getUint16(c); if (r = d === 18761, (r || d === 19789) && e.getUint16(c + 2, r) === 42) { var p = e.getUint32(c + 4, r); p >= 8 && (o = c + p) } } } if (o) { var y = e.getUint16(o, r), v, S; for (S = 0; S < y; S += 1)if (v = o + S * 12 + 2, e.getUint16(v, r) === 274) { v += 8, t = e.getUint16(v, r), e.setUint16(v, 1, r); break } } } catch { t = 1 } return t } n(JE, "resetAndGetOrientation"); function ZE(i) { var e = 0, t = 1, r = 1; switch (i) { case 2: t = -1; break; case 3: e = -180; break; case 4: r = -1; break; case 5: e = 90, r = -1; break; case 6: e = 90; break; case 7: e = 90, t = -1; break; case 8: e = -90; break }return { rotate: e, scaleX: t, scaleY: r } } n(ZE, "parseOrientation"); var eF = /\.\d*(?:0|9){12}\d*$/; function Mb(i) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e11; return eF.test(i) ? Math.round(i * e) / e : i } n(Mb, "normalizeDecimalNumber"); function Al(i) { var e = i.aspectRatio, t = i.height, r = i.width, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "none", o = bh(r), a = bh(t); if (o && a) { var l = t * e; (s === "contain" || s === "none") && l > r || s === "cover" && l < r ? t = r / e : r = t * e } else o ? t = r / e : a && (r = t * e); return { width: r, height: t } } n(Al, "getAdjustedSizes"); var tF = es.ArrayBuffer, zb = es.FileReader, uo = es.URL || es.webkitURL, iF = /\.\w+$/, rF = es.Compressor, sF = function () { function i(e, t) { ME(this, i), this.file = e, this.image = new Image, this.options = yh(yh({}, Lb), t), this.aborted = !1, this.result = null, this.init() } return n(i, "Compressor"), zE(i, [{ key: "init", value: n(function () { var t = this, r = this.file, s = this.options; if (!qE(r)) { this.fail(new Error("The first argument must be a File or Blob object.")); return } var o = r.type; if (!rf(o)) { this.fail(new Error("The first argument must be an image File or Blob object.")); return } if (!uo || !zb) { this.fail(new Error("The current browser does not support image compression.")); return } if (tF || (s.checkOrientation = !1), uo && !s.checkOrientation) this.load({ url: uo.createObjectURL(r) }); else { var a = new zb, l = s.checkOrientation && o === "image/jpeg"; this.reader = a, a.onload = function (h) { var c = h.target, d = c.result, p = {}; if (l) { var y = JE(d); y > 1 || !uo ? (p.url = QE(d, o), y > 1 && vh(p, ZE(y))) : p.url = uo.createObjectURL(r) } else p.url = d; t.load(p) }, a.onabort = function () { t.fail(new Error("Aborted to read the image with FileReader.")) }, a.onerror = function () { t.fail(new Error("Failed to read the image with FileReader.")) }, a.onloadend = function () { t.reader = null }, l ? a.readAsArrayBuffer(r) : a.readAsDataURL(r) } }, "init") }, { key: "load", value: n(function (t) { var r = this, s = this.file, o = this.image; o.onload = function () { r.draw(yh(yh({}, t), {}, { naturalWidth: o.naturalWidth, naturalHeight: o.naturalHeight })) }, o.onabort = function () { r.fail(new Error("Aborted to load the image.")) }, o.onerror = function () { r.fail(new Error("Failed to load the image.")) }, es.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(es.navigator.userAgent) && (o.crossOrigin = "anonymous"), o.alt = s.name, o.src = t.url }, "load") }, { key: "draw", value: n(function (t) { var r = this, s = t.naturalWidth, o = t.naturalHeight, a = t.rotate, l = a === void 0 ? 0 : a, h = t.scaleX, c = h === void 0 ? 1 : h, d = t.scaleY, p = d === void 0 ? 1 : d, y = this.file, v = this.image, S = this.options, x = document.createElement("canvas"), E = x.getContext("2d"), F = Math.abs(l) % 180 === 90, k = (S.resize === "contain" || S.resize === "cover") && bh(S.width) && bh(S.height), B = Math.max(S.maxWidth, 0) || 1 / 0, H = Math.max(S.maxHeight, 0) || 1 / 0, W = Math.max(S.minWidth, 0) || 0, I = Math.max(S.minHeight, 0) || 0, q = s / o, $ = S.width, V = S.height; if (F) { var xe = [H, B]; B = xe[0], H = xe[1]; var Pt = [I, W]; W = Pt[0], I = Pt[1]; var ut = [V, $]; $ = ut[0], V = ut[1] } k && (q = $ / V); var rt = Al({ aspectRatio: q, width: B, height: H }, "contain"); B = rt.width, H = rt.height; var st = Al({ aspectRatio: q, width: W, height: I }, "cover"); if (W = st.width, I = st.height, k) { var We = Al({ aspectRatio: q, width: $, height: V }, S.resize); $ = We.width, V = We.height } else { var Ee = Al({ aspectRatio: q, width: $, height: V }), ai = Ee.width; $ = ai === void 0 ? s : ai; var go = Ee.height; V = go === void 0 ? o : go } $ = Math.floor(Mb(Math.min(Math.max($, W), B))), V = Math.floor(Mb(Math.min(Math.max(V, I), H))); var xi = -$ / 2, ts = -V / 2, Xi = $, Cr = V, Yi = []; if (k) { var is = 0, rs = 0, Qi = s, Jt = o, yo = Al({ aspectRatio: q, width: s, height: o }, { contain: "cover", cover: "contain" }[S.resize]); Qi = yo.width, Jt = yo.height, is = (s - Qi) / 2, rs = (o - Jt) / 2, Yi.push(is, rs, Qi, Jt) } if (Yi.push(xi, ts, Xi, Cr), F) { var vo = [V, $]; $ = vo[0], V = vo[1] } x.width = $, x.height = V, rf(S.mimeType) || (S.mimeType = y.type); var ln = "transparent"; if (y.size > S.convertSize && S.convertTypes.indexOf(S.mimeType) >= 0 && (S.mimeType = "image/jpeg"), S.mimeType === "image/jpeg" && (ln = "#fff"), E.fillStyle = ln, E.fillRect(0, 0, $, V), S.beforeDraw && S.beforeDraw.call(this, E, x), !this.aborted && (E.save(), E.translate($ / 2, V / 2), E.rotate(l * Math.PI / 180), E.scale(c, p), E.drawImage.apply(E, [v].concat(Yi)), E.restore(), S.drew && S.drew.call(this, E, x), !this.aborted)) { var Rl = n(function (_h) { r.aborted || r.done({ naturalWidth: s, naturalHeight: o, result: _h }) }, "done"); x.toBlob ? x.toBlob(Rl, S.mimeType, S.quality) : Rl(HE(x.toDataURL(S.mimeType, S.quality))) } }, "draw") }, { key: "done", value: n(function (t) { var r = t.naturalWidth, s = t.naturalHeight, o = t.result, a = this.file, l = this.image, h = this.options; if (uo && !h.checkOrientation && uo.revokeObjectURL(l.src), o) if (h.strict && o.size > a.size && h.mimeType === a.type && !(h.width > r || h.height > s || h.minWidth > r || h.minHeight > s || h.maxWidth < r || h.maxHeight < s)) o = a; else { var c = new Date; o.lastModified = c.getTime(), o.lastModifiedDate = c, o.name = a.name, o.name && o.type !== a.type && (o.name = o.name.replace(iF, GE(o.type))) } else o = a; this.result = o, h.success && h.success.call(this, o) }, "done") }, { key: "fail", value: n(function (t) { var r = this.options; if (r.error) r.error.call(this, t); else throw t }, "fail") }, { key: "abort", value: n(function () { this.aborted || (this.aborted = !0, this.reader ? this.reader.abort() : this.image.complete ? this.fail(new Error("The compression process has been aborted.")) : (this.image.onload = null, this.image.onabort())) }, "abort") }], [{ key: "noConflict", value: n(function () { return window.Compressor = rF, i }, "noConflict") }, { key: "setDefaults", value: n(function (t) { vh(Lb, t) }, "setDefaults") }]), i }(); qb.exports = sF }); var of = {}; cn(of, { Audio: () => Vr, AwsS3: () => Qs, AwsS3Multipart: () => vi, Box: () => Bi, Compressor: () => an, Core: () => xF, Dashboard: () => Di, DefaultStore: () => Ll, DragDrop: () => Ni, DropTarget: () => Os, Dropbox: () => Li, Facebook: () => Mi, FileInput: () => Hr, Form: () => ho, GoldenRetriever: () => fo, GoogleDrive: () => zi, ImageEditor: () => qr, Informer: () => Ri, Instagram: () => ji, OneDrive: () => Hi, ProgressBar: () => $r, ReduxDevTools: () => mo, ReduxStore: () => Cg, RemoteSources: () => Rs, ScreenCapture: () => Wr, StatusBar: () => Ci, ThumbnailGenerator: () => fr, Transloadit: () => ni, Tus: () => Ki, Unsplash: () => qi, Uppy: () => Hl, Url: () => gi, Webcam: () => Kr, XHRUpload: () => lo, Zoom: () => $i, debugLogger: () => gn, locales: () => FF, server: () => Qh, views: () => EF }); function ht(i, e) { return Object.prototype.hasOwnProperty.call(i, e) } n(ht, "has"); function Af(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Af, "_classPrivateFieldLooseBase"); var G1 = 0; function X1(i) { return "__private_" + G1++ + "_" + i } n(X1, "_classPrivateFieldLooseKey"); function Y1(i, e, t) { let r = []; return i.forEach(s => typeof s != "string" ? r.push(s) : e[Symbol.split](s).forEach((o, a, l) => { o !== "" && r.push(o), a < l.length - 1 && r.push(t) })), r } n(Y1, "insertReplacement"); function Tf(i, e) { let t = /\$/g, r = "$$$$", s = [i]; if (e == null) return s; for (let o of Object.keys(e)) if (o !== "_") { let a = e[o]; typeof a == "string" && (a = t[Symbol.replace](a, r)), s = Y1(s, new RegExp(`%\\{${o}\\}`, "g"), a) } return s } n(Tf, "interpolate"); var dn = X1("apply"), Dr = class { constructor(e) { Object.defineProperty(this, dn, { value: Q1 }), this.locale = { strings: {}, pluralize(t) { return t === 1 ? 0 : 1 } }, Array.isArray(e) ? e.forEach(Af(this, dn)[dn], this) : Af(this, dn)[dn](e) } translate(e, t) { return this.translateArray(e, t).join("") } translateArray(e, t) { if (!ht(this.locale.strings, e)) throw new Error(`missing string: ${e}`); let r = this.locale.strings[e]; if (typeof r == "object") { if (t && typeof t.smart_count < "u") { let o = this.locale.pluralize(t.smart_count); return Tf(r[o], t) } throw new Error("Attempted to use a string with plural forms, but no value was given for %{smart_count}") } return Tf(r, t) } }; n(Dr, "Translator"); function Q1(i) { if (!(i != null && i.strings)) return; let e = this.locale; this.locale = { ...e, strings: { ...e.strings, ...i.strings } }, this.locale.pluralize = i.pluralize || e.pluralize } n(Q1, "_apply2"); var xm = se(Rh(), 1); var J1 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"; var ot = n((i = 21) => { let e = "", t = i; for (; t--;)e += J1[Math.random() * 64 | 0]; return e }, "nanoid"); var Em = se(Il(), 1); function Bl(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Bl, "_classPrivateFieldLooseBase"); var Vw = 0; function um(i) { return "__private_" + Vw++ + "_" + i } n(um, "_classPrivateFieldLooseKey"); var Ww = { version: "3.0.3" }, ls = um("callbacks"), Ih = um("publish"), fn = class { constructor() { Object.defineProperty(this, Ih, { value: Kw }), Object.defineProperty(this, ls, { writable: !0, value: new Set }), this.state = {} } getState() { return this.state } setState(e) { let t = { ...this.state }, r = { ...this.state, ...e }; this.state = r, Bl(this, Ih)[Ih](t, r, e) } subscribe(e) { return Bl(this, ls)[ls].add(e), () => { Bl(this, ls)[ls].delete(e) } } }; n(fn, "DefaultStore"); function Kw() { for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)e[t] = arguments[t]; Bl(this, ls)[ls].forEach(r => { r(...e) }) } n(Kw, "_publish2"); fn.VERSION = Ww.version; var Ll = fn; function er(i) { let e = i.lastIndexOf("."); return e === -1 || e === i.length - 1 ? { name: i, extension: void 0 } : { name: i.slice(0, e), extension: i.slice(e + 1) } } n(er, "getFileNameAndExtension"); var mn = { md: "text/markdown", markdown: "text/markdown", mp4: "video/mp4", mp3: "audio/mp3", svg: "image/svg+xml", jpg: "image/jpeg", png: "image/png", webp: "image/webp", gif: "image/gif", heic: "image/heic", heif: "image/heif", yaml: "text/yaml", yml: "text/yaml", csv: "text/csv", tsv: "text/tab-separated-values", tab: "text/tab-separated-values", avi: "video/x-msvideo", mks: "video/x-matroska", mkv: "video/x-matroska", mov: "video/quicktime", dicom: "application/dicom", doc: "application/msword", docm: "application/vnd.ms-word.document.macroenabled.12", docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document", dot: "application/msword", dotm: "application/vnd.ms-word.template.macroenabled.12", dotx: "application/vnd.openxmlformats-officedocument.wordprocessingml.template", xla: "application/vnd.ms-excel", xlam: "application/vnd.ms-excel.addin.macroenabled.12", xlc: "application/vnd.ms-excel", xlf: "application/x-xliff+xml", xlm: "application/vnd.ms-excel", xls: "application/vnd.ms-excel", xlsb: "application/vnd.ms-excel.sheet.binary.macroenabled.12", xlsm: "application/vnd.ms-excel.sheet.macroenabled.12", xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", xlt: "application/vnd.ms-excel", xltm: "application/vnd.ms-excel.template.macroenabled.12", xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template", xlw: "application/vnd.ms-excel", txt: "text/plain", text: "text/plain", conf: "text/plain", log: "text/plain", pdf: "application/pdf", zip: "application/zip", "7z": "application/x-7z-compressed", rar: "application/x-rar-compressed", tar: "application/x-tar", gz: "application/gzip", dmg: "application/x-apple-diskimage" }; function us(i) { var e; if (i.type) return i.type; let t = i.name ? (e = er(i.name).extension) == null ? void 0 : e.toLowerCase() : null; return t && t in mn ? mn[t] : "application/octet-stream" } n(us, "getFileType"); function Gw(i) { return i.charCodeAt(0).toString(32) } n(Gw, "encodeCharacter"); function hm(i) { let e = ""; return i.replace(/[^A-Z0-9]/ig, t => (e += `-${Gw(t)}`, "/")) + e } n(hm, "encodeFilename"); function cm(i) { let e = "uppy"; return typeof i.name == "string" && (e += `-${hm(i.name.toLowerCase())}`), i.type !== void 0 && (e += `-${i.type}`), i.meta && typeof i.meta.relativePath == "string" && (e += `-${hm(i.meta.relativePath.toLowerCase())}`), i.data.size !== void 0 && (e += `-${i.data.size}`), i.data.lastModified !== void 0 && (e += `-${i.data.lastModified}`), e } n(cm, "generateFileID"); function Xw(i) { return !i.isRemote || !i.remote ? !1 : new Set(["box", "dropbox", "drive", "facebook", "unsplash"]).has(i.remote.provider) } n(Xw, "hasFileStableId"); function Ml(i) { if (Xw(i)) return i.id; let e = us(i); return cm({ ...i, type: e }) } n(Ml, "getSafeFileId"); function Bh(i) { if (i == null && typeof navigator < "u" && (i = navigator.userAgent), !i) return !0; let e = /Edge\/(\d+\.\d+)/.exec(i); if (!e) return !0; let t = e[1], [r, s] = t.split("."); return r = parseInt(r, 10), s = parseInt(s, 10), r < 15 || r === 15 && s < 15063 || r > 18 || r === 18 && s >= 18218 } n(Bh, "supportsUploadProgress"); function Lh(i, e) { return e.name ? e.name : i.split("/")[0] === "image" ? `${i.split("/")[0]}.${i.split("/")[1]}` : "noname" } n(Lh, "getFileName"); function Mh(i) { return i < 10 ? `0${i}` : i.toString() } n(Mh, "pad"); function _o() { let i = new Date, e = Mh(i.getHours()), t = Mh(i.getMinutes()), r = Mh(i.getSeconds()); return `${e}:${t}:${r}` } n(_o, "getTimeStamp"); var dm = { debug: () => { }, warn: () => { }, error: function () { for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)e[t] = arguments[t]; return console.error(`[Uppy] [${_o()}]`, ...e) } }, gn = { debug: function () { for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)e[t] = arguments[t]; return console.debug(`[Uppy] [${_o()}]`, ...e) }, warn: function () { for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)e[t] = arguments[t]; return console.warn(`[Uppy] [${_o()}]`, ...e) }, error: function () { for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)e[t] = arguments[t]; return console.error(`[Uppy] [${_o()}]`, ...e) } }; var jl = se(zl(), 1), bm = se(vm(), 1); var wm = { maxFileSize: null, minFileSize: null, maxTotalFileSize: null, maxNumberOfFiles: null, minNumberOfFiles: null, allowedFileTypes: null, requiredMetaFields: [] }, ct = class extends Error { constructor(e, t) { let { isUserFacing: r = !0, file: s } = t === void 0 ? {} : t; super(e), this.isRestriction = !0, this.isUserFacing = r, s != null && (this.file = s) } }; n(ct, "RestrictionError"); var yn = class { constructor(e, t) { this.i18n = t, this.getOpts = () => { let r = e(); if (r.restrictions.allowedFileTypes != null && !Array.isArray(r.restrictions.allowedFileTypes)) throw new TypeError("`restrictions.allowedFileTypes` must be an array"); return r } } validateAggregateRestrictions(e, t) { let { maxTotalFileSize: r, maxNumberOfFiles: s } = this.getOpts().restrictions; if (s && e.filter(a => !a.isGhost).length + t.length > s) throw new ct(`${this.i18n("youCanOnlyUploadX", { smart_count: s })}`); if (r) { let o = e.reduce((a, l) => a + l.size, 0); for (let a of t) if (a.size != null && (o += a.size, o > r)) throw new ct(this.i18n("exceedsSize", { size: (0, jl.default)(r), file: a.name })) } } validateSingleFile(e) { let { maxFileSize: t, minFileSize: r, allowedFileTypes: s } = this.getOpts().restrictions; if (s && !s.some(a => a.includes("/") ? e.type ? (0, bm.default)(e.type.replace(/;.*?$/, ""), a) : !1 : a[0] === "." && e.extension ? e.extension.toLowerCase() === a.slice(1).toLowerCase() : !1)) { let a = s.join(", "); throw new ct(this.i18n("youCanOnlyUploadFileTypes", { types: a }), { file: e }) } if (t && e.size != null && e.size > t) throw new ct(this.i18n("exceedsSize", { size: (0, jl.default)(t), file: e.name }), { file: e }); if (r && e.size != null && e.size < r) throw new ct(this.i18n("inferiorSize", { size: (0, jl.default)(r) }), { file: e }) } validate(e, t) { t.forEach(r => { this.validateSingleFile(r) }), this.validateAggregateRestrictions(e, t) } validateMinNumberOfFiles(e) { let { minNumberOfFiles: t } = this.getOpts().restrictions; if (Object.keys(e).length < t) throw new ct(this.i18n("youHaveToAtLeastSelectX", { smart_count: t })) } getMissingRequiredMetaFields(e) { let t = new ct(this.i18n("missingRequiredMetaFieldOnFile", { fileName: e.name })), { requiredMetaFields: r } = this.getOpts().restrictions, s = []; for (let o of r) (!Object.hasOwn(e.meta, o) || e.meta[o] === "") && s.push(o); return { missingFields: s, error: t } } }; n(yn, "Restricter"); var Sm = { strings: { addBulkFilesFailed: { 0: "Failed to add %{smart_count} file due to an internal error", 1: "Failed to add %{smart_count} files due to internal errors" }, youCanOnlyUploadX: { 0: "You can only upload %{smart_count} file", 1: "You can only upload %{smart_count} files" }, youHaveToAtLeastSelectX: { 0: "You have to select at least %{smart_count} file", 1: "You have to select at least %{smart_count} files" }, exceedsSize: "%{file} exceeds maximum allowed size of %{size}", missingRequiredMetaField: "Missing required meta fields", missingRequiredMetaFieldOnFile: "Missing required meta fields in %{fileName}", inferiorSize: "This file is smaller than the allowed size of %{size}", youCanOnlyUploadFileTypes: "You can only upload: %{types}", noMoreFilesAllowed: "Cannot add more files", noDuplicates: "Cannot add the duplicate file '%{fileName}', it already exists", companionError: "Connection with Companion failed", authAborted: "Authentication aborted", companionUnauthorizeHint: "To unauthorize to your %{provider} account, please go to %{url}", failedToUpload: "Failed to upload %{file}", noInternetConnection: "No Internet connection", connectedToInternet: "Connected to the Internet", noFilesFound: "You have no files or folders here", noSearchResults: "Unfortunately, there are no results for this search", selectX: { 0: "Select %{smart_count}", 1: "Select %{smart_count}" }, allFilesFromFolderNamed: "All files from folder %{name}", openFolderNamed: "Open folder %{name}", cancel: "Cancel", logOut: "Log out", filter: "Filter", resetFilter: "Reset filter", loading: "Loading...", loadedXFiles: "Loaded %{numFiles} files", authenticateWithTitle: "Please authenticate with %{pluginName} to select files", authenticateWith: "Connect to %{pluginName}", signInWithGoogle: "Sign in with Google", searchImages: "Search for images", enterTextToSearch: "Enter text to search for images", search: "Search", resetSearch: "Reset search", emptyFolderAdded: "No files were added from empty folder", addedNumFiles: "Added %{numFiles} file(s)", folderAlreadyAdded: 'The folder "%{folder}" was already added', folderAdded: { 0: "Added %{smart_count} file from %{folder}", 1: "Added %{smart_count} files from %{folder}" }, additionalRestrictionsFailed: "%{count} additional restrictions were not fulfilled" } }; var Pm, _m; function z(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(z, "_classPrivateFieldLooseBase"); var Jw = 0; function ke(i) { return "__private_" + Jw++ + "_" + i } n(ke, "_classPrivateFieldLooseKey"); var Zw = { version: "3.4.0" }, Ke = ke("plugins"), kt = ke("restricter"), vn = ke("storeUnsubscribe"), tr = ke("emitter"), hs = ke("preProcessors"), cs = ke("uploaders"), sr = ke("postProcessors"), Ut = ke("informAndEmit"), _n = ke("checkRequiredMetaFieldsOnFile"), zh = ke("checkRequiredMetaFields"), bn = ke("assertNewUploadAllowed"), qh = ke("transformFile"), wn = ke("startIfAutoProceed"), Sn = ke("checkAndUpdateFileState"), jh = ke("addListeners"), ui = ke("updateOnlineStatus"), ir = ke("createUpload"), Hh = ke("getUpload"), ds = ke("removeUpload"), rr = ke("runUpload"); Pm = Symbol.for("uppy test: getPlugins"); _m = Symbol.for("uppy test: createUpload"); var Pn = class {
        constructor(e) { Object.defineProperty(this, rr, { value: cS }), Object.defineProperty(this, ds, { value: hS }), Object.defineProperty(this, Hh, { value: uS }), Object.defineProperty(this, ir, { value: lS }), Object.defineProperty(this, jh, { value: aS }), Object.defineProperty(this, Sn, { value: nS }), Object.defineProperty(this, wn, { value: oS }), Object.defineProperty(this, qh, { value: sS }), Object.defineProperty(this, bn, { value: rS }), Object.defineProperty(this, zh, { value: iS }), Object.defineProperty(this, _n, { value: tS }), Object.defineProperty(this, Ut, { value: eS }), Object.defineProperty(this, Ke, { writable: !0, value: Object.create(null) }), Object.defineProperty(this, kt, { writable: !0, value: void 0 }), Object.defineProperty(this, vn, { writable: !0, value: void 0 }), Object.defineProperty(this, tr, { writable: !0, value: (0, xm.default)() }), Object.defineProperty(this, hs, { writable: !0, value: new Set }), Object.defineProperty(this, cs, { writable: !0, value: new Set }), Object.defineProperty(this, sr, { writable: !0, value: new Set }), this.calculateProgress = (0, Em.default)((r, s) => { let o = this.getFile(r?.id); if (r == null || !o) { this.log(`Not setting progress for a file that has been removed: ${r?.id}`); return } if (o.progress.percentage === 100) { this.log(`Not setting progress for a file that has been already uploaded: ${r.id}`); return } let a = Number.isFinite(s.bytesTotal) && s.bytesTotal > 0; this.setFileState(r.id, { progress: { ...o.progress, bytesUploaded: s.bytesUploaded, bytesTotal: s.bytesTotal, percentage: a ? Math.round(s.bytesUploaded / s.bytesTotal * 100) : 0 } }), this.calculateTotalProgress() }, 500, { leading: !0, trailing: !0 }), Object.defineProperty(this, ui, { writable: !0, value: this.updateOnlineStatus.bind(this) }), this.defaultLocale = Sm; let t = { id: "uppy", autoProceed: !1, allowMultipleUploadBatches: !0, debug: !1, restrictions: wm, meta: {}, onBeforeFileAdded: (r, s) => !Object.hasOwn(s, r.id), onBeforeUpload: r => r, store: new Ll, logger: dm, infoTimeout: 5e3 }; this.opts = { ...t, ...e, restrictions: { ...t.restrictions, ...e && e.restrictions } }, e && e.logger && e.debug ? this.log("You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.", "warning") : e && e.debug && (this.opts.logger = gn), this.log(`Using Core v${this.constructor.VERSION}`), this.i18nInit(), this.store = this.opts.store, this.setState({ plugins: {}, files: {}, currentUploads: {}, allowNewUpload: !0, capabilities: { uploadProgress: Bh(), individualCancellation: !0, resumableUploads: !1 }, totalProgress: 0, meta: { ...this.opts.meta }, info: [], recoveredState: null }), z(this, kt)[kt] = new yn(() => this.opts, this.i18n), z(this, vn)[vn] = this.store.subscribe((r, s, o) => { this.emit("state-update", r, s, o), this.updateAll(s) }), this.opts.debug && typeof window < "u" && (window[this.opts.id] = this), z(this, jh)[jh]() } emit(e) { for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)r[s - 1] = arguments[s]; z(this, tr)[tr].emit(e, ...r) } on(e, t) { return z(this, tr)[tr].on(e, t), this } once(e, t) { return z(this, tr)[tr].once(e, t), this } off(e, t) { return z(this, tr)[tr].off(e, t), this } updateAll(e) { this.iteratePlugins(t => { t.update(e) }) } setState(e) { this.store.setState(e) } getState() { return this.store.getState() } patchFilesState(e) { let t = this.getState().files; this.setState({ files: { ...t, ...Object.fromEntries(Object.entries(e).map(r => { let [s, o] = r; return [s, { ...t[s], ...o }] })) } }) } setFileState(e, t) { if (!this.getState().files[e]) throw new Error(`Can\u2019t set state for ${e} (the file could have been removed)`); this.patchFilesState({ [e]: t }) } i18nInit() { let e = new Dr([this.defaultLocale, this.opts.locale]); this.i18n = e.translate.bind(e), this.i18nArray = e.translateArray.bind(e), this.locale = e.locale } setOptions(e) { this.opts = { ...this.opts, ...e, restrictions: { ...this.opts.restrictions, ...e && e.restrictions } }, e.meta && this.setMeta(e.meta), this.i18nInit(), e.locale && this.iteratePlugins(t => { t.setOptions(e) }), this.setState() } resetProgress() { let e = { percentage: 0, bytesUploaded: 0, uploadComplete: !1, uploadStarted: null }, t = { ...this.getState().files }, r = {}; Object.keys(t).forEach(s => { r[s] = { ...t[s], progress: { ...t[s].progress, ...e } } }), this.setState({ files: r, totalProgress: 0, allowNewUpload: !0, error: null, recoveredState: null }), this.emit("reset-progress") } addPreProcessor(e) { z(this, hs)[hs].add(e) } removePreProcessor(e) { return z(this, hs)[hs].delete(e) } addPostProcessor(e) { z(this, sr)[sr].add(e) } removePostProcessor(e) { return z(this, sr)[sr].delete(e) } addUploader(e) { z(this, cs)[cs].add(e) } removeUploader(e) { return z(this, cs)[cs].delete(e) } setMeta(e) { let t = { ...this.getState().meta, ...e }, r = { ...this.getState().files }; Object.keys(r).forEach(s => { r[s] = { ...r[s], meta: { ...r[s].meta, ...e } } }), this.log("Adding metadata:"), this.log(e), this.setState({ meta: t, files: r }) } setFileMeta(e, t) { let r = { ...this.getState().files }; if (!r[e]) { this.log("Was trying to set metadata for a file that has been removed: ", e); return } let s = { ...r[e].meta, ...t }; r[e] = { ...r[e], meta: s }, this.setState({ files: r }) } getFile(e) { return this.getState().files[e] } getFiles() { let { files: e } = this.getState(); return Object.values(e) } getFilesByIds(e) { return e.map(t => this.getFile(t)) } getObjectOfFilesPerState() { let { files: e, totalProgress: t, error: r } = this.getState(), s = Object.values(e), o = s.filter(S => { let { progress: x } = S; return !x.uploadComplete && x.uploadStarted }), a = s.filter(S => !S.progress.uploadStarted), l = s.filter(S => S.progress.uploadStarted || S.progress.preprocess || S.progress.postprocess), h = s.filter(S => S.progress.uploadStarted), c = s.filter(S => S.isPaused), d = s.filter(S => S.progress.uploadComplete), p = s.filter(S => S.error), y = o.filter(S => !S.isPaused), v = s.filter(S => S.progress.preprocess || S.progress.postprocess); return { newFiles: a, startedFiles: l, uploadStartedFiles: h, pausedFiles: c, completeFiles: d, erroredFiles: p, inProgressFiles: o, inProgressNotPausedFiles: y, processingFiles: v, isUploadStarted: h.length > 0, isAllComplete: t === 100 && d.length === s.length && v.length === 0, isAllErrored: !!r && p.length === s.length, isAllPaused: o.length !== 0 && c.length === o.length, isUploadInProgress: o.length > 0, isSomeGhost: s.some(S => S.isGhost) } } validateRestrictions(e, t) { t === void 0 && (t = this.getFiles()); try { z(this, kt)[kt].validate(t, [e]) } catch (r) { return r } return null } checkIfFileAlreadyExists(e) { let { files: t } = this.getState(); return !!(t[e] && !t[e].isGhost) } addFile(e) { z(this, bn)[bn](e); let { nextFilesState: t, validFilesToAdd: r, errors: s } = z(this, Sn)[Sn]([e]), o = s.filter(l => l.isRestriction); if (z(this, Ut)[Ut](o), s.length > 0) throw s[0]; this.setState({ files: t }); let [a] = r; return this.emit("file-added", a), this.emit("files-added", r), this.log(`Added file: ${a.name}, ${a.id}, mime type: ${a.type}`), z(this, wn)[wn](), a.id } addFiles(e) {
            z(this, bn)[bn](); let { nextFilesState: t, validFilesToAdd: r, errors: s } = z(this, Sn)[Sn](e), o = s.filter(l => l.isRestriction); z(this, Ut)[Ut](o); let a = s.filter(l => !l.isRestriction); if (a.length > 0) {
                let l = `Multiple errors occurred while adding files:
`; if (a.forEach(h => {
                    l += `
 * ${h.message}`
                }), this.info({ message: this.i18n("addBulkFilesFailed", { smart_count: a.length }), details: l }, "error", this.opts.infoTimeout), typeof AggregateError == "function") throw new AggregateError(a, l); { let h = new Error(l); throw h.errors = a, h }
            } this.setState({ files: t }), r.forEach(l => { this.emit("file-added", l) }), this.emit("files-added", r), r.length > 5 ? this.log(`Added batch of ${r.length} files`) : Object.values(r).forEach(l => {
                this.log(`Added file: ${l.name}
 id: ${l.id}
 type: ${l.type}`)
            }), r.length > 0 && z(this, wn)[wn]()
        } removeFiles(e, t) { let { files: r, currentUploads: s } = this.getState(), o = { ...r }, a = { ...s }, l = Object.create(null); e.forEach(p => { r[p] && (l[p] = r[p], delete o[p]) }); function h(p) { return l[p] === void 0 } n(h, "fileIsNotRemoved"), Object.keys(a).forEach(p => { let y = s[p].fileIDs.filter(h); if (y.length === 0) { delete a[p]; return } let { capabilities: v } = this.getState(); if (y.length !== s[p].fileIDs.length && !v.individualCancellation) throw new Error("individualCancellation is disabled"); a[p] = { ...s[p], fileIDs: y } }); let c = { currentUploads: a, files: o }; Object.keys(o).length === 0 && (c.allowNewUpload = !0, c.error = null, c.recoveredState = null), this.setState(c), this.calculateTotalProgress(); let d = Object.keys(l); d.forEach(p => { this.emit("file-removed", l[p], t) }), d.length > 5 ? this.log(`Removed ${d.length} files`) : this.log(`Removed files: ${d.join(", ")}`) } removeFile(e, t) { t === void 0 && (t = null), this.removeFiles([e], t) } pauseResume(e) { if (!this.getState().capabilities.resumableUploads || this.getFile(e).uploadComplete) return; let r = !(this.getFile(e).isPaused || !1); return this.setFileState(e, { isPaused: r }), this.emit("upload-pause", e, r), r } pauseAll() { let e = { ...this.getState().files }; Object.keys(e).filter(r => !e[r].progress.uploadComplete && e[r].progress.uploadStarted).forEach(r => { let s = { ...e[r], isPaused: !0 }; e[r] = s }), this.setState({ files: e }), this.emit("pause-all") } resumeAll() { let e = { ...this.getState().files }; Object.keys(e).filter(r => !e[r].progress.uploadComplete && e[r].progress.uploadStarted).forEach(r => { let s = { ...e[r], isPaused: !1, error: null }; e[r] = s }), this.setState({ files: e }), this.emit("resume-all") } retryAll() { let e = { ...this.getState().files }, t = Object.keys(e).filter(s => e[s].error); if (t.forEach(s => { let o = { ...e[s], isPaused: !1, error: null }; e[s] = o }), this.setState({ files: e, error: null }), this.emit("retry-all", t), t.length === 0) return Promise.resolve({ successful: [], failed: [] }); let r = z(this, ir)[ir](t, { forceAllowNewUpload: !0 }); return z(this, rr)[rr](r) } cancelAll(e) { let { reason: t = "user" } = e === void 0 ? {} : e; if (this.emit("cancel-all", { reason: t }), t === "user") { let { files: r } = this.getState(), s = Object.keys(r); s.length && this.removeFiles(s, "cancel-all"), this.setState({ totalProgress: 0, error: null, recoveredState: null }) } } retryUpload(e) { this.setFileState(e, { error: null, isPaused: !1 }), this.emit("upload-retry", e); let t = z(this, ir)[ir]([e], { forceAllowNewUpload: !0 }); return z(this, rr)[rr](t) } logout() { this.iteratePlugins(e => { e.provider && e.provider.logout && e.provider.logout() }) } calculateTotalProgress() { let t = this.getFiles().filter(c => c.progress.uploadStarted || c.progress.preprocess || c.progress.postprocess); if (t.length === 0) { this.emit("progress", 0), this.setState({ totalProgress: 0 }); return } let r = t.filter(c => c.progress.bytesTotal != null), s = t.filter(c => c.progress.bytesTotal == null); if (r.length === 0) { let c = t.length * 100, d = s.reduce((y, v) => y + v.progress.percentage, 0), p = Math.round(d / c * 100); this.setState({ totalProgress: p }); return } let o = r.reduce((c, d) => c + d.progress.bytesTotal, 0), a = o / r.length; o += a * s.length; let l = 0; r.forEach(c => { l += c.progress.bytesUploaded }), s.forEach(c => { l += a * (c.progress.percentage || 0) / 100 }); let h = o === 0 ? 0 : Math.round(l / o * 100); h > 100 && (h = 100), this.setState({ totalProgress: h }), this.emit("progress", h) } updateOnlineStatus() { (typeof window.navigator.onLine < "u" ? window.navigator.onLine : !0) ? (this.emit("is-online"), this.wasOffline && (this.emit("back-online"), this.info(this.i18n("connectedToInternet"), "success", 3e3), this.wasOffline = !1)) : (this.emit("is-offline"), this.info(this.i18n("noInternetConnection"), "error", 0), this.wasOffline = !0) } getID() { return this.opts.id } use(e, t) {
            if (typeof e != "function") { let a = `Expected a plugin class, but got ${e === null ? "null" : typeof e}. Please verify that the plugin was imported and spelled correctly.`; throw new TypeError(a) } let r = new e(this, t), s = r.id; if (!s) throw new Error("Your plugin must have an id"); if (!r.type) throw new Error("Your plugin must have a type"); let o = this.getPlugin(s); if (o) {
                let a = `Already found a plugin named '${o.id}'. Tried to use: '${s}'.
Uppy plugins must have unique \`id\` options. See https://uppy.io/docs/plugins/#id.`; throw new Error(a)
            } return e.VERSION && this.log(`Using ${s} v${e.VERSION}`), r.type in z(this, Ke)[Ke] ? z(this, Ke)[Ke][r.type].push(r) : z(this, Ke)[Ke][r.type] = [r], r.install(), this
        } getPlugin(e) { for (let t of Object.values(z(this, Ke)[Ke])) { let r = t.find(s => s.id === e); if (r != null) return r } } [Pm](e) { return z(this, Ke)[Ke][e] } iteratePlugins(e) { Object.values(z(this, Ke)[Ke]).flat(1).forEach(e) } removePlugin(e) { this.log(`Removing plugin ${e.id}`), this.emit("plugin-remove", e), e.uninstall && e.uninstall(); let t = z(this, Ke)[Ke][e.type], r = t.findIndex(a => a.id === e.id); r !== -1 && t.splice(r, 1); let o = { plugins: { ...this.getState().plugins, [e.id]: void 0 } }; this.setState(o) } close(e) { let { reason: t } = e === void 0 ? {} : e; this.log(`Closing Uppy instance ${this.opts.id}: removing all files and uninstalling plugins`), this.cancelAll({ reason: t }), z(this, vn)[vn](), this.iteratePlugins(r => { this.removePlugin(r) }), typeof window < "u" && window.removeEventListener && (window.removeEventListener("online", z(this, ui)[ui]), window.removeEventListener("offline", z(this, ui)[ui])) } hideInfo() { let { info: e } = this.getState(); this.setState({ info: e.slice(1) }), this.emit("info-hidden") } info(e, t, r) { t === void 0 && (t = "info"), r === void 0 && (r = 3e3); let s = typeof e == "object"; this.setState({ info: [...this.getState().info, { type: t, message: s ? e.message : e, details: s ? e.details : null }] }), setTimeout(() => this.hideInfo(), r), this.emit("info-visible") } log(e, t) { let { logger: r } = this.opts; switch (t) { case "error": r.error(e); break; case "warning": r.warn(e); break; default: r.debug(e); break } } restore(e) { return this.log(`Core: attempting to restore upload "${e}"`), this.getState().currentUploads[e] ? z(this, rr)[rr](e) : (z(this, ds)[ds](e), Promise.reject(new Error("Nonexistent upload"))) } [_m]() { return z(this, ir)[ir](...arguments) } addResultData(e, t) { if (!z(this, Hh)[Hh](e)) { this.log(`Not setting result for an upload that has been removed: ${e}`); return } let { currentUploads: r } = this.getState(), s = { ...r[e], result: { ...r[e].result, ...t } }; this.setState({ currentUploads: { ...r, [e]: s } }) } upload() { var e; (e = z(this, Ke)[Ke].uploader) != null && e.length || this.log("No uploader type plugins are used", "warning"); let { files: t } = this.getState(), r = this.opts.onBeforeUpload(t); return r === !1 ? Promise.reject(new Error("Not starting the upload because onBeforeUpload returned false")) : (r && typeof r == "object" && (t = r, this.setState({ files: t })), Promise.resolve().then(() => z(this, kt)[kt].validateMinNumberOfFiles(t)).catch(s => { throw z(this, Ut)[Ut]([s]), s }).then(() => { if (!z(this, zh)[zh](t)) throw new ct(this.i18n("missingRequiredMetaField")) }).catch(s => { throw s }).then(() => { let { currentUploads: s } = this.getState(), o = Object.values(s).flatMap(h => h.fileIDs), a = []; Object.keys(t).forEach(h => { let c = this.getFile(h); !c.progress.uploadStarted && o.indexOf(h) === -1 && a.push(c.id) }); let l = z(this, ir)[ir](a); return z(this, rr)[rr](l) }).catch(s => { throw this.emit("error", s), this.log(s, "error"), s })) }
    }; n(Pn, "Uppy"); function eS(i) { for (let o of i) { let { file: a, isRestriction: l } = o; l ? this.emit("restriction-failed", a, o) : this.emit("error", o), this.log(o, "warning") } let e = i.filter(o => o.isUserFacing), t = 4, r = e.slice(0, t), s = e.slice(t); r.forEach(o => { let { message: a, details: l = "" } = o; this.info({ message: a, details: l }, "error", this.opts.infoTimeout) }), s.length > 0 && this.info({ message: this.i18n("additionalRestrictionsFailed", { count: s.length }) }) } n(eS, "_informAndEmit2"); function tS(i) { let { missingFields: e, error: t } = z(this, kt)[kt].getMissingRequiredMetaFields(i); return e.length > 0 ? (this.setFileState(i.id, { missingRequiredMetaFields: e }), this.log(t.message), this.emit("restriction-failed", i, t), !1) : !0 } n(tS, "_checkRequiredMetaFieldsOnFile2"); function iS(i) { let e = !0; for (let t of Object.values(i)) z(this, _n)[_n](t) || (e = !1); return e } n(iS, "_checkRequiredMetaFields2"); function rS(i) { let { allowNewUpload: e } = this.getState(); if (e === !1) { let t = new ct(this.i18n("noMoreFilesAllowed"), { file: i }); throw z(this, Ut)[Ut]([t]), t } } n(rS, "_assertNewUploadAllowed2"); function sS(i) { let e = i instanceof File ? { name: i.name, type: i.type, size: i.size, data: i } : i, t = us(e), r = Lh(t, e), s = er(r).extension, o = !!e.isRemote, a = Ml(e), l = e.meta || {}; l.name = r, l.type = t; let h = Number.isFinite(e.data.size) ? e.data.size : null; return { source: e.source || "", id: a, name: r, extension: s || "", meta: { ...this.getState().meta, ...l }, type: t, data: e.data, progress: { percentage: 0, bytesUploaded: 0, bytesTotal: h, uploadComplete: !1, uploadStarted: null }, size: h, isRemote: o, remote: e.remote || "", preview: e.preview } } n(sS, "_transformFile2"); function oS() { this.opts.autoProceed && !this.scheduledAutoProceed && (this.scheduledAutoProceed = setTimeout(() => { this.scheduledAutoProceed = null, this.upload().catch(i => { i.isRestriction || this.log(i.stack || i.message || i) }) }, 4)) } n(oS, "_startIfAutoProceed2"); function nS(i) { let { files: e } = this.getState(), t = { ...e }, r = [], s = []; for (let a of i) try { var o; let l = z(this, qh)[qh](a); if ((o = e[l.id]) != null && o.isGhost) { let { isGhost: c, ...d } = e[l.id]; l = { ...d, data: a.data }, this.log(`Replaced the blob in the restored ghost file: ${l.name}, ${l.id}`) } let h = this.opts.onBeforeFileAdded(l, t); if (!h && this.checkIfFileAlreadyExists(l.id)) throw new ct(this.i18n("noDuplicates", { fileName: l.name }), { file: a }); if (h === !1) throw new ct("Cannot add the file because onBeforeFileAdded returned false.", { isUserFacing: !1, file: a }); typeof h == "object" && h !== null && (l = h), z(this, kt)[kt].validateSingleFile(l), t[l.id] = l, r.push(l) } catch (l) { s.push(l) } try { z(this, kt)[kt].validateAggregateRestrictions(Object.values(e), r) } catch (a) { return s.push(a), { nextFilesState: e, validFilesToAdd: [], errors: s } } return { nextFilesState: t, validFilesToAdd: r, errors: s } } n(nS, "_checkAndUpdateFileState2"); function aS() { let i = n((r, s, o) => { let a = r.message || "Unknown error"; r.details && (a += ` ${r.details}`), this.setState({ error: a }), s != null && s.id in this.getState().files && this.setFileState(s.id, { error: a, response: o }) }, "errorHandler"); this.on("error", i), this.on("upload-error", (r, s, o) => { if (i(s, r, o), typeof s == "object" && s.message) { this.log(s.message, "error"); let a = new Error(this.i18n("failedToUpload", { file: r?.name })); a.isUserFacing = !0, a.details = s.message, s.details && (a.details += ` ${s.details}`), z(this, Ut)[Ut]([a]) } else z(this, Ut)[Ut]([s]) }); let e; this.on("upload-stalled", (r, s) => { let { message: o } = r, a = s.map(l => l.meta.name).join(", "); e || (this.info({ message: o, details: a }, "warning", this.opts.infoTimeout), e = setTimeout(() => { e = null }, this.opts.infoTimeout)), this.log(`${o} ${a}`.trim(), "warning") }), this.on("upload", () => { this.setState({ error: null }) }); let t = n(r => { let s = r.filter(a => { let l = a != null && this.getFile(a.id); return l || this.log(`Not setting progress for a file that has been removed: ${a?.id}`), l }), o = Object.fromEntries(s.map(a => [a.id, { progress: { uploadStarted: Date.now(), uploadComplete: !1, percentage: 0, bytesUploaded: 0, bytesTotal: a.size } }])); this.patchFilesState(o) }, "onUploadStarted"); this.on("upload-start", r => { r.forEach(s => { this.emit("upload-started", s) }), t(r) }), this.on("upload-progress", this.calculateProgress), this.on("upload-success", (r, s) => { if (r == null || !this.getFile(r.id)) { this.log(`Not setting progress for a file that has been removed: ${r?.id}`); return } let o = this.getFile(r.id).progress; this.setFileState(r.id, { progress: { ...o, postprocess: z(this, sr)[sr].size > 0 ? { mode: "indeterminate" } : null, uploadComplete: !0, percentage: 100, bytesUploaded: o.bytesTotal }, response: s, uploadURL: s.uploadURL, isPaused: !1 }), r.size == null && this.setFileState(r.id, { size: s.bytesUploaded || o.bytesTotal }), this.calculateTotalProgress() }), this.on("preprocess-progress", (r, s) => { if (r == null || !this.getFile(r.id)) { this.log(`Not setting progress for a file that has been removed: ${r?.id}`); return } this.setFileState(r.id, { progress: { ...this.getFile(r.id).progress, preprocess: s } }) }), this.on("preprocess-complete", r => { if (r == null || !this.getFile(r.id)) { this.log(`Not setting progress for a file that has been removed: ${r?.id}`); return } let s = { ...this.getState().files }; s[r.id] = { ...s[r.id], progress: { ...s[r.id].progress } }, delete s[r.id].progress.preprocess, this.setState({ files: s }) }), this.on("postprocess-progress", (r, s) => { if (r == null || !this.getFile(r.id)) { this.log(`Not setting progress for a file that has been removed: ${r?.id}`); return } this.setFileState(r.id, { progress: { ...this.getState().files[r.id].progress, postprocess: s } }) }), this.on("postprocess-complete", r => { if (r == null || !this.getFile(r.id)) { this.log(`Not setting progress for a file that has been removed: ${r?.id}`); return } let s = { ...this.getState().files }; s[r.id] = { ...s[r.id], progress: { ...s[r.id].progress } }, delete s[r.id].progress.postprocess, this.setState({ files: s }) }), this.on("restored", () => { this.calculateTotalProgress() }), this.on("dashboard:file-edit-complete", r => { r && z(this, _n)[_n](r) }), typeof window < "u" && window.addEventListener && (window.addEventListener("online", z(this, ui)[ui]), window.addEventListener("offline", z(this, ui)[ui]), setTimeout(z(this, ui)[ui], 3e3)) } n(aS, "_addListeners2"); function lS(i, e) { e === void 0 && (e = {}); let { forceAllowNewUpload: t = !1 } = e, { allowNewUpload: r, currentUploads: s } = this.getState(); if (!r && !t) throw new Error("Cannot create a new upload: already uploading."); let o = ot(); return this.emit("upload", { id: o, fileIDs: i }), this.setState({ allowNewUpload: this.opts.allowMultipleUploadBatches !== !1 && this.opts.allowMultipleUploads !== !1, currentUploads: { ...s, [o]: { fileIDs: i, step: 0, result: {} } } }), o } n(lS, "_createUpload2"); function uS(i) { let { currentUploads: e } = this.getState(); return e[i] } n(uS, "_getUpload2"); function hS(i) { let e = { ...this.getState().currentUploads }; delete e[i], this.setState({ currentUploads: e }) } n(hS, "_removeUpload2"); async function cS(i) { let e = n(() => { let { currentUploads: o } = this.getState(); return o[i] }, "getCurrentUpload"), t = e(), r = [...z(this, hs)[hs], ...z(this, cs)[cs], ...z(this, sr)[sr]]; try { for (let o = t.step || 0; o < r.length && t; o++) { let a = r[o]; this.setState({ currentUploads: { ...this.getState().currentUploads, [i]: { ...t, step: o } } }); let { fileIDs: l } = t; await a(l, i), t = e() } } catch (o) { throw z(this, ds)[ds](i), o } if (t) { t.fileIDs.forEach(h => { let c = this.getFile(h); c && c.progress.postprocess && this.emit("postprocess-complete", c) }); let o = t.fileIDs.map(h => this.getFile(h)), a = o.filter(h => !h.error), l = o.filter(h => h.error); await this.addResultData(i, { successful: a, failed: l, uploadID: i }), t = e() } let s; return t && (s = t.result, this.emit("complete", s), z(this, ds)[ds](i)), s == null && this.log(`Not setting result for an upload that has been removed: ${i}`), s } n(cS, "_runUpload2"); Pn.VERSION = Zw.version; var Hl = Pn; var Fn, X, Rm, dS, xn, Fm, pS, ql = {}, km = [], fS = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i; function or(i, e) { for (var t in e) i[t] = e[t]; return i } n(or, "s"); function Um(i) { var e = i.parentNode; e && e.removeChild(i) } n(Um, "a"); function u(i, e, t) { var r, s, o, a = {}; for (o in e) o == "key" ? r = e[o] : o == "ref" ? s = e[o] : a[o] = e[o]; if (arguments.length > 2 && (a.children = arguments.length > 3 ? Fn.call(arguments, 2) : t), typeof i == "function" && i.defaultProps != null) for (o in i.defaultProps) a[o] === void 0 && (a[o] = i.defaultProps[o]); return En(i, a, r, s, null) } n(u, "h"); function En(i, e, t, r, s) { var o = { type: i, props: e, key: t, ref: r, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: s ?? ++Rm }; return s == null && X.vnode != null && X.vnode(o), o } n(En, "v"); function Dm() { return { current: null } } n(Dm, "y"); function Et(i) { return i.children } n(Et, "p"); function ue(i, e) { this.props = i, this.context = e } n(ue, "d"); function xo(i, e) { if (e == null) return i.__ ? xo(i.__, i.__.__k.indexOf(i) + 1) : null; for (var t; e < i.__k.length; e++)if ((t = i.__k[e]) != null && t.__e != null) return t.__e; return typeof i.type == "function" ? xo(i) : null } n(xo, "_"); function Nm(i) { var e, t; if ((i = i.__) != null && i.__c != null) { for (i.__e = i.__c.base = null, e = 0; e < i.__k.length; e++)if ((t = i.__k[e]) != null && t.__e != null) { i.__e = i.__c.base = t.__e; break } return Nm(i) } } n(Nm, "k"); function Om(i) { (!i.__d && (i.__d = !0) && xn.push(i) && !$l.__r++ || Fm !== X.debounceRendering) && ((Fm = X.debounceRendering) || setTimeout)($l) } n(Om, "b"); function $l() { for (var i; $l.__r = xn.length;)i = xn.sort(function (e, t) { return e.__v.__b - t.__v.__b }), xn = [], i.some(function (e) { var t, r, s, o, a, l; e.__d && (a = (o = (t = e).__v).__e, (l = t.__P) && (r = [], (s = or({}, o)).__v = o.__v + 1, $h(l, o, s, t.__n, l.ownerSVGElement !== void 0, o.__h != null ? [a] : null, r, a ?? xo(o), o.__h), Mm(r, o), o.__e != a && Nm(o))) }) } n($l, "g"); function Im(i, e, t, r, s, o, a, l, h, c) { var d, p, y, v, S, x, E, F = r && r.__k || km, k = F.length; for (t.__k = [], d = 0; d < e.length; d++)if ((v = t.__k[d] = (v = e[d]) == null || typeof v == "boolean" ? null : typeof v == "string" || typeof v == "number" || typeof v == "bigint" ? En(null, v, null, null, v) : Array.isArray(v) ? En(Et, { children: v }, null, null, null) : v.__b > 0 ? En(v.type, v.props, v.key, null, v.__v) : v) != null) { if (v.__ = t, v.__b = t.__b + 1, (y = F[d]) === null || y && v.key == y.key && v.type === y.type) F[d] = void 0; else for (p = 0; p < k; p++) { if ((y = F[p]) && v.key == y.key && v.type === y.type) { F[p] = void 0; break } y = null } $h(i, v, y = y || ql, s, o, a, l, h, c), S = v.__e, (p = v.ref) && y.ref != p && (E || (E = []), y.ref && E.push(y.ref, null, v), E.push(p, v.__c || S, v)), S != null ? (x == null && (x = S), typeof v.type == "function" && v.__k === y.__k ? v.__d = h = Bm(v, h, i) : h = Lm(i, v, y, F, S, h), typeof t.type == "function" && (t.__d = h)) : h && y.__e == h && h.parentNode != i && (h = xo(y)) } for (t.__e = x, d = k; d--;)F[d] != null && (typeof t.type == "function" && F[d].__e != null && F[d].__e == t.__d && (t.__d = xo(r, d + 1)), jm(F[d], F[d])); if (E) for (d = 0; d < E.length; d++)zm(E[d], E[++d], E[++d]) } n(Im, "w"); function Bm(i, e, t) { for (var r, s = i.__k, o = 0; s && o < s.length; o++)(r = s[o]) && (r.__ = i, e = typeof r.type == "function" ? Bm(r, e, t) : Lm(t, r, r, s, r.__e, e)); return e } n(Bm, "m"); function ti(i, e) { return e = e || [], i == null || typeof i == "boolean" || (Array.isArray(i) ? i.some(function (t) { ti(t, e) }) : e.push(i)), e } n(ti, "x"); function Lm(i, e, t, r, s, o) { var a, l, h; if (e.__d !== void 0) a = e.__d, e.__d = void 0; else if (t == null || s != o || s.parentNode == null) e: if (o == null || o.parentNode !== i) i.appendChild(s), a = null; else { for (l = o, h = 0; (l = l.nextSibling) && h < r.length; h += 2)if (l == s) break e; i.insertBefore(s, o), a = o } return a !== void 0 ? a : s.nextSibling } n(Lm, "A"); function mS(i, e, t, r, s) { var o; for (o in t) o === "children" || o === "key" || o in e || Vl(i, o, null, t[o], r); for (o in e) s && typeof e[o] != "function" || o === "children" || o === "key" || o === "value" || o === "checked" || t[o] === e[o] || Vl(i, o, e[o], t[o], r) } n(mS, "C"); function Am(i, e, t) { e[0] === "-" ? i.setProperty(e, t) : i[e] = t == null ? "" : typeof t != "number" || fS.test(e) ? t : t + "px" } n(Am, "$"); function Vl(i, e, t, r, s) { var o; e: if (e === "style") if (typeof t == "string") i.style.cssText = t; else { if (typeof r == "string" && (i.style.cssText = r = ""), r) for (e in r) t && e in t || Am(i.style, e, ""); if (t) for (e in t) r && t[e] === r[e] || Am(i.style, e, t[e]) } else if (e[0] === "o" && e[1] === "n") o = e !== (e = e.replace(/Capture$/, "")), e = e.toLowerCase() in i ? e.toLowerCase().slice(2) : e.slice(2), i.l || (i.l = {}), i.l[e + o] = t, t ? r || i.addEventListener(e, o ? Cm : Tm, o) : i.removeEventListener(e, o ? Cm : Tm, o); else if (e !== "dangerouslySetInnerHTML") { if (s) e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s"); else if (e !== "href" && e !== "list" && e !== "form" && e !== "tabIndex" && e !== "download" && e in i) try { i[e] = t ?? ""; break e } catch { } typeof t == "function" || (t != null && (t !== !1 || e[0] === "a" && e[1] === "r") ? i.setAttribute(e, t) : i.removeAttribute(e)) } } n(Vl, "H"); function Tm(i) { this.l[i.type + !1](X.event ? X.event(i) : i) } n(Tm, "I"); function Cm(i) { this.l[i.type + !0](X.event ? X.event(i) : i) } n(Cm, "T"); function $h(i, e, t, r, s, o, a, l, h) { var c, d, p, y, v, S, x, E, F, k, B, H, W, I = e.type; if (e.constructor !== void 0) return null; t.__h != null && (h = t.__h, l = e.__e = t.__e, e.__h = null, o = [l]), (c = X.__b) && c(e); try { e: if (typeof I == "function") { if (E = e.props, F = (c = I.contextType) && r[c.__c], k = c ? F ? F.props.value : c.__ : r, t.__c ? x = (d = e.__c = t.__c).__ = d.__E : ("prototype" in I && I.prototype.render ? e.__c = d = new I(E, k) : (e.__c = d = new ue(E, k), d.constructor = I, d.render = yS), F && F.sub(d), d.props = E, d.state || (d.state = {}), d.context = k, d.__n = r, p = d.__d = !0, d.__h = []), d.__s == null && (d.__s = d.state), I.getDerivedStateFromProps != null && (d.__s == d.state && (d.__s = or({}, d.__s)), or(d.__s, I.getDerivedStateFromProps(E, d.__s))), y = d.props, v = d.state, p) I.getDerivedStateFromProps == null && d.componentWillMount != null && d.componentWillMount(), d.componentDidMount != null && d.__h.push(d.componentDidMount); else { if (I.getDerivedStateFromProps == null && E !== y && d.componentWillReceiveProps != null && d.componentWillReceiveProps(E, k), !d.__e && d.shouldComponentUpdate != null && d.shouldComponentUpdate(E, d.__s, k) === !1 || e.__v === t.__v) { d.props = E, d.state = d.__s, e.__v !== t.__v && (d.__d = !1), d.__v = e, e.__e = t.__e, e.__k = t.__k, e.__k.forEach(function (q) { q && (q.__ = e) }), d.__h.length && a.push(d); break e } d.componentWillUpdate != null && d.componentWillUpdate(E, d.__s, k), d.componentDidUpdate != null && d.__h.push(function () { d.componentDidUpdate(y, v, S) }) } if (d.context = k, d.props = E, d.__v = e, d.__P = i, B = X.__r, H = 0, "prototype" in I && I.prototype.render) d.state = d.__s, d.__d = !1, B && B(e), c = d.render(d.props, d.state, d.context); else do d.__d = !1, B && B(e), c = d.render(d.props, d.state, d.context), d.state = d.__s; while (d.__d && ++H < 25); d.state = d.__s, d.getChildContext != null && (r = or(or({}, r), d.getChildContext())), p || d.getSnapshotBeforeUpdate == null || (S = d.getSnapshotBeforeUpdate(y, v)), W = c != null && c.type === Et && c.key == null ? c.props.children : c, Im(i, Array.isArray(W) ? W : [W], e, t, r, s, o, a, l, h), d.base = e.__e, e.__h = null, d.__h.length && a.push(d), x && (d.__E = d.__ = null), d.__e = !1 } else o == null && e.__v === t.__v ? (e.__k = t.__k, e.__e = t.__e) : e.__e = gS(t.__e, e, t, r, s, o, a, h); (c = X.diffed) && c(e) } catch (q) { e.__v = null, (h || o != null) && (e.__e = l, e.__h = !!h, o[o.indexOf(l)] = null), X.__e(q, e, t) } } n($h, "j"); function Mm(i, e) { X.__c && X.__c(e, i), i.some(function (t) { try { i = t.__h, t.__h = [], i.some(function (r) { r.call(t) }) } catch (r) { X.__e(r, t.__v) } }) } n(Mm, "z"); function gS(i, e, t, r, s, o, a, l) { var h, c, d, p = t.props, y = e.props, v = e.type, S = 0; if (v === "svg" && (s = !0), o != null) { for (; S < o.length; S++)if ((h = o[S]) && "setAttribute" in h == !!v && (v ? h.localName === v : h.nodeType === 3)) { i = h, o[S] = null; break } } if (i == null) { if (v === null) return document.createTextNode(y); i = s ? document.createElementNS("http://www.w3.org/2000/svg", v) : document.createElement(v, y.is && y), o = null, l = !1 } if (v === null) p === y || l && i.data === y || (i.data = y); else { if (o = o && Fn.call(i.childNodes), c = (p = t.props || ql).dangerouslySetInnerHTML, d = y.dangerouslySetInnerHTML, !l) { if (o != null) for (p = {}, S = 0; S < i.attributes.length; S++)p[i.attributes[S].name] = i.attributes[S].value; (d || c) && (d && (c && d.__html == c.__html || d.__html === i.innerHTML) || (i.innerHTML = d && d.__html || "")) } if (mS(i, y, p, s, l), d) e.__k = []; else if (S = e.props.children, Im(i, Array.isArray(S) ? S : [S], e, t, r, s && v !== "foreignObject", o, a, o ? o[0] : t.__k && xo(t, 0), l), o != null) for (S = o.length; S--;)o[S] != null && Um(o[S]); l || ("value" in y && (S = y.value) !== void 0 && (S !== i.value || v === "progress" && !S || v === "option" && S !== p.value) && Vl(i, "value", S, p.value, !1), "checked" in y && (S = y.checked) !== void 0 && S !== i.checked && Vl(i, "checked", S, p.checked, !1)) } return i } n(gS, "L"); function zm(i, e, t) { try { typeof i == "function" ? i(e) : i.current = e } catch (r) { X.__e(r, t) } } n(zm, "M"); function jm(i, e, t) { var r, s; if (X.unmount && X.unmount(i), (r = i.ref) && (r.current && r.current !== i.__e || zm(r, null, e)), (r = i.__c) != null) { if (r.componentWillUnmount) try { r.componentWillUnmount() } catch (o) { X.__e(o, e) } r.base = r.__P = null } if (r = i.__k) for (s = 0; s < r.length; s++)r[s] && jm(r[s], e, typeof i.type != "function"); t || i.__e == null || Um(i.__e), i.__e = i.__d = void 0 } n(jm, "N"); function yS(i, e, t) { return this.constructor(i, t) } n(yS, "O"); function Vh(i, e, t) { var r, s, o; X.__ && X.__(i, e), s = (r = typeof t == "function") ? null : t && t.__k || e.__k, o = [], $h(e, i = (!r && t || e).__k = u(Et, null, [i]), s || ql, ql, e.ownerSVGElement !== void 0, !r && t ? [t] : s ? null : e.firstChild ? Fn.call(e.childNodes) : null, o, !r && t ? t : s ? s.__e : e.firstChild, r), Mm(o, i) } n(Vh, "P"); function Wl(i, e, t) { var r, s, o, a = or({}, i.props); for (o in e) o == "key" ? r = e[o] : o == "ref" ? s = e[o] : a[o] = e[o]; return arguments.length > 2 && (a.children = arguments.length > 3 ? Fn.call(arguments, 2) : t), En(i.type, a, r || i.key, s || i.ref, null) } n(Wl, "q"); Fn = km.slice, X = { __e: function (i, e, t, r) { for (var s, o, a; e = e.__;)if ((s = e.__c) && !s.__) try { if ((o = s.constructor) && o.getDerivedStateFromError != null && (s.setState(o.getDerivedStateFromError(i)), a = s.__d), s.componentDidCatch != null && (s.componentDidCatch(i, r || {}), a = s.__d), a) return s.__E = s } catch (l) { i = l } throw i } }, Rm = 0, dS = n(function (i) { return i != null && i.constructor === void 0 }, "i"), ue.prototype.setState = function (i, e) { var t; t = this.__s != null && this.__s !== this.state ? this.__s : this.__s = or({}, this.state), typeof i == "function" && (i = i(or({}, t), this.props)), i && or(t, i), i != null && this.__v && (e && this.__h.push(e), Om(this)) }, ue.prototype.forceUpdate = function (i) { this.__v && (this.__e = !0, i && this.__h.push(i), Om(this)) }, ue.prototype.render = Et, xn = [], $l.__r = 0, pS = 0; function On(i) { return i?.nodeType === Node.ELEMENT_NODE } n(On, "isDOMElement"); function An(i, e) { return e === void 0 && (e = document), typeof i == "string" ? e.querySelector(i) : On(i) ? i : null } n(An, "findDOMElement"); function vS(i) { for (var e; i && !i.dir;)i = i.parentNode; return (e = i) == null ? void 0 : e.dir } n(vS, "getTextDirection"); var Kl = vS; var Fe = class { constructor(e, t) { t === void 0 && (t = {}), this.uppy = e, this.opts = t } getPluginState() { let { plugins: e } = this.uppy.getState(); return e[this.id] || {} } setPluginState(e) { let { plugins: t } = this.uppy.getState(); this.uppy.setState({ plugins: { ...t, [this.id]: { ...t[this.id], ...e } } }) } setOptions(e) { this.opts = { ...this.opts, ...e }, this.setPluginState(), this.i18nInit() } i18nInit() { let e = new Dr([this.defaultLocale, this.uppy.locale, this.opts.locale]); this.i18n = e.translate.bind(e), this.i18nArray = e.translateArray.bind(e), this.setPluginState() } addTarget() { throw new Error("Extend the addTarget method to add your plugin to another plugin's target") } install() { } uninstall() { } render() { throw new Error("Extend the render method to add your plugin to a DOM element") } update() { } afterUpdate() { } }; n(Fe, "BasePlugin"); function Hm(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Hm, "_classPrivateFieldLooseBase"); var bS = 0; function wS(i) { return "__private_" + bS++ + "_" + i } n(wS, "_classPrivateFieldLooseKey"); function SS(i) { let e = null, t = null; return function () { for (var r = arguments.length, s = new Array(r), o = 0; o < r; o++)s[o] = arguments[o]; return t = s, e || (e = Promise.resolve().then(() => (e = null, i(...t)))), e } } n(SS, "debounce"); var Tn = wS("updateUI"), Eo = class extends Fe { constructor() { super(...arguments), Object.defineProperty(this, Tn, { writable: !0, value: void 0 }) } getTargetPlugin(e) { let t; if (typeof e == "object" && e instanceof Eo) t = e; else if (typeof e == "function") { let r = e; this.uppy.iteratePlugins(s => { s instanceof r && (t = s) }) } return t } mount(e, t) { let r = t.id, s = An(e); if (s) { this.isTargetDOMEl = !0; let l = document.createElement("div"); return l.classList.add("uppy-Root"), Hm(this, Tn)[Tn] = SS(h => { this.uppy.getPlugin(this.id) && (Vh(this.render(h), l), this.afterUpdate()) }), this.uppy.log(`Installing ${r} to a DOM element '${e}'`), this.opts.replaceTargetContent && (s.innerHTML = ""), Vh(this.render(this.uppy.getState()), l), this.el = l, s.appendChild(l), l.dir = this.opts.direction || Kl(l) || "ltr", this.onMount(), this.el } let o = this.getTargetPlugin(e); if (o) return this.uppy.log(`Installing ${r} to ${o.id}`), this.parent = o, this.el = o.addTarget(t), this.onMount(), this.el; this.uppy.log(`Not installing ${r}`); let a = `Invalid target option given to ${r}.`; throw typeof e == "function" ? a += " The given target is not a Plugin class. Please check that you're not specifying a React Component instead of a plugin. If you are using @uppy/* packages directly, make sure you have only 1 version of @uppy/core installed: run `npm ls @uppy/core` on the command line and verify that all the versions match and are deduped correctly." : a += "If you meant to target an HTML element, please make sure that the element exists. Check that the <script> tag initializing Uppy is right before the closing </body> tag at the end of the page. (see https://github.com/transloadit/uppy/issues/1042)\n\nIf you meant to target a plugin, please confirm that your `import` statements or `require` calls are correct.", new Error(a) } update(e) { if (this.el != null) { var t, r; (t = (r = Hm(this, Tn))[Tn]) == null || t.call(r, e) } } unmount() { if (this.isTargetDOMEl) { var e; (e = this.el) == null || e.remove() } this.onUnmount() } onMount() { } onUnmount() { } }; n(Eo, "UIPlugin"); var G = Eo; var Qh = {}; cn(Qh, { Provider: () => Q, RequestClient: () => de, SearchProvider: () => Nr, Socket: () => Ft }); var Gl = class extends Error { constructor(e, t) { t === void 0 && (t = null), super("This looks like a network error, the endpoint might be blocked by an internet provider or a firewall."), this.cause = e, this.isNetworkError = !0, this.request = t } }; n(Gl, "NetworkError"); var hi = Gl; function ps() { return fetch(...arguments).catch(i => { throw i.name === "AbortError" ? i : new hi(i) }) } n(ps, "fetchWithNetworkError"); var Xl = class extends Error { constructor(e, t) { t === void 0 && (t = {}), super(e), this.cause = t.cause, this.cause && ht(this.cause, "isNetworkError") && (this.isNetworkError = this.cause.isNetworkError) } }; n(Xl, "ErrorWithCause"); var Oi = Xl; var Yl = class extends Error { constructor() { super("Authorization required"), this.name = "AuthError", this.isAuthError = !0 } }; n(Yl, "AuthError"); var qm = Yl; var $m; function fs(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(fs, "_classPrivateFieldLooseBase"); var PS = 0; function Vm(i) { return "__private_" + PS++ + "_" + i } n(Vm, "_classPrivateFieldLooseKey"); var _S = { version: "3.3.0" }; function xS(i) { return i.replace(/\/$/, "") } n(xS, "stripSlash"); async function ES(i) { if (i.status === 401) throw new qm; let e = i.json(); if (i.ok) return e; let t = `Failed request with status: ${i.status}. ${i.statusText}`; try { let r = await e; t = r.message ? `${t} message: ${r.message}` : t, t = r.requestId ? `${t} request-Id: ${r.requestId}` : t } catch { } throw new Error(t) } n(ES, "handleJSONResponse"); var Cn = new Map, nr = Vm("companionHeaders"), ms = Vm("getUrl"); $m = Symbol.for("uppy test: getCompanionHeaders"); var de = class { constructor(e, t) { Object.defineProperty(this, ms, { value: FS }), Object.defineProperty(this, nr, { writable: !0, value: void 0 }), this.uppy = e, this.opts = t, this.onReceiveResponse = this.onReceiveResponse.bind(this), fs(this, nr)[nr] = t?.companionHeaders } setCompanionHeaders(e) { fs(this, nr)[nr] = e } [$m]() { return fs(this, nr)[nr] } get hostname() { let { companion: e } = this.uppy.getState(), t = this.opts.companionUrl; return xS(e && e[t] ? e[t] : t) } async headers() { return { ...{ Accept: "application/json", "Content-Type": "application/json", "Uppy-Versions": `@uppy/companion-client=${de.VERSION}` }, ...fs(this, nr)[nr] } } onReceiveResponse(e) { let { headers: t } = e, s = this.uppy.getState().companion || {}, o = this.opts.companionUrl; t.has("i-am") && t.get("i-am") !== s[o] && this.uppy.setState({ companion: { ...s, [o]: t.get("i-am") } }) } async preflight(e) { let t = Cn.get(this.hostname); if (t != null) return t; let r = ["accept", "content-type", "uppy-auth-token"], s = (async () => { try { let a = (await fetch(fs(this, ms)[ms](e), { method: "OPTIONS" })).headers.get("access-control-allow-headers"); if (a == null || a === "*") return Cn.set(this.hostname, r), r; this.uppy.log(`[CompanionClient] adding allowed preflight headers to companion cache: ${this.hostname} ${a}`); let l = a.split(",").map(h => h.trim().toLowerCase()); return Cn.set(this.hostname, l), l } catch (o) { return this.uppy.log(`[CompanionClient] unable to make preflight request ${o}`, "warning"), Cn.delete(this.hostname), r } })(); return Cn.set(this.hostname, s), s } async preflightAndHeaders(e) { let [t, r] = await Promise.all([this.preflight(e), this.headers()]); return Object.fromEntries(Object.entries(r).filter(s => { let [o] = s; return t.includes(o.toLowerCase()) ? !0 : (this.uppy.log(`[CompanionClient] excluding disallowed header ${o}`), !1) })) } async request(e) { let { path: t, method: r = "GET", data: s, skipPostResponse: o, signal: a } = e; try { let l = await this.preflightAndHeaders(t), h = await ps(fs(this, ms)[ms](t), { method: r, signal: a, headers: l, credentials: this.opts.companionCookiesRule || "same-origin", body: s ? JSON.stringify(s) : null }); return o || this.onReceiveResponse(h), ES(h) } catch (l) { throw l != null && l.isAuthError ? l : new Oi(`Could not ${r} ${fs(this, ms)[ms](t)}`, { cause: l }) } } async get(e, t) { return t === void 0 && (t = void 0), typeof t == "boolean" && (t = { skipPostResponse: t }), this.request({ ...t, path: e }) } async post(e, t, r) { return r === void 0 && (r = void 0), typeof r == "boolean" && (r = { skipPostResponse: r }), this.request({ ...r, path: e, method: "POST", data: t }) } async delete(e, t, r) { return t === void 0 && (t = void 0), typeof r == "boolean" && (r = { skipPostResponse: r }), this.request({ ...r, path: e, method: "DELETE", data: t }) } }; n(de, "RequestClient"); function FS(i) { return /^(https?:|)\/\//.test(i) ? i : `${this.hostname}/${i}` } n(FS, "_getUrl2"); de.VERSION = _S.version; var Wh = {}; cn(Wh, { getItem: () => AS, removeItem: () => TS, setItem: () => OS }); function OS(i, e) { return new Promise(t => { localStorage.setItem(i, e), t() }) } n(OS, "setItem"); function AS(i) { return Promise.resolve(localStorage.getItem(i)) } n(AS, "getItem"); function TS(i) { return new Promise(e => { localStorage.removeItem(i), e() }) } n(TS, "removeItem"); function gs(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(gs, "_classPrivateFieldLooseBase"); var CS = 0; function Xh(i) { return "__private_" + CS++ + "_" + i } n(Xh, "_classPrivateFieldLooseKey"); var RS = n(i => i.split("-").map(e => e.charAt(0).toUpperCase() + e.slice(1)).join(" "), "getName"); function kS() { return location.origin } n(kS, "getOrigin"); function Wm(i) { if (typeof i == "string") return new RegExp(`^${i}$`); if (i instanceof RegExp) return i } n(Wm, "getRegex"); function US(i, e) { return (Array.isArray(e) ? e.map(Wm) : [Wm(e)]).some(r => r?.test(i) || r?.test(`${i}/`)) } n(US, "isOriginAllowed"); var ci = Xh("refreshingTokenPromise"), Kh = Xh("getAuthToken"), Gh = Xh("removeAuthToken"), Q = class extends de { constructor(e, t) { super(e, t), Object.defineProperty(this, Gh, { value: NS }), Object.defineProperty(this, Kh, { value: DS }), Object.defineProperty(this, ci, { writable: !0, value: void 0 }), this.provider = t.provider, this.id = this.provider, this.name = this.opts.name || RS(this.id), this.pluginId = this.opts.pluginId, this.tokenKey = `companion-${this.pluginId}-auth-token`, this.companionKeysParams = this.opts.companionKeysParams, this.preAuthToken = null } async headers() { let [e, t] = await Promise.all([super.headers(), gs(this, Kh)[Kh]()]), r = {}; return t && (r["uppy-auth-token"] = t), this.companionKeysParams && (r["uppy-credentials-params"] = btoa(JSON.stringify({ params: this.companionKeysParams }))), { ...e, ...r } } onReceiveResponse(e) { super.onReceiveResponse(e); let t = this.uppy.getPlugin(this.pluginId), s = t.getPluginState().authenticated ? e.status !== 401 : e.status < 400; return t.setPluginState({ authenticated: s }), e } async setAuthToken(e) { return this.uppy.getPlugin(this.pluginId).storage.setItem(this.tokenKey, e) } async ensurePreAuth() { if (this.companionKeysParams && !this.preAuthToken && (await this.fetchPreAuthToken(), !this.preAuthToken)) throw new Error("Could not load authentication data required for third-party login. Please try again later.") } authUrl(e) { e === void 0 && (e = {}); let t = new URLSearchParams({ state: btoa(JSON.stringify({ origin: kS() })), ...e }); return this.preAuthToken && t.set("uppyPreAuthToken", this.preAuthToken), `${this.hostname}/${this.id}/connect?${t}` } async login(e) { return await this.ensurePreAuth(), new Promise((t, r) => { let s = this.authUrl(e), o = window.open(s, "_blank"), a = n(l => { if (l.source !== o) { this.uppy.log.warn("ignoring event from unknown source", l); return } let { companionAllowedHosts: h } = this.uppy.getPlugin(this.pluginId).opts; if (!US(l.origin, h)) { r(new Error(`rejecting event from ${l.origin} vs allowed pattern ${h}`)); return } let c = typeof l.data == "string" ? JSON.parse(l.data) : l.data; if (c.error) { let { uppy: d } = this, p = d.i18n("authAborted"); d.info({ message: p }, "warning", 5e3), r(new Error("auth aborted")); return } if (!c.token) { r(new Error("did not receive token from auth window")); return } o.close(), window.removeEventListener("message", a), this.setAuthToken(c.token), t() }, "handleToken"); window.addEventListener("message", a) }) } refreshTokenUrl() { return `${this.hostname}/${this.id}/refresh-token` } fileUrl(e) { return `${this.hostname}/${this.id}/get/${e}` } async request() { await gs(this, ci)[ci]; try { return await super.request(...arguments) } catch (e) { if (!e.isAuthError) throw e; return await gs(this, ci)[ci], gs(this, ci)[ci] = (async () => { try { let t = await super.request({ path: this.refreshTokenUrl(), method: "POST" }); await this.setAuthToken(t.uppyAuthToken) } finally { gs(this, ci)[ci] = void 0 } })(), await gs(this, ci)[ci], super.request(...arguments) } } async fetchPreAuthToken() { if (this.companionKeysParams) try { let e = await this.post(`${this.id}/preauth/`, { params: this.companionKeysParams }); this.preAuthToken = e.token } catch (e) { this.uppy.log(`[CompanionClient] unable to fetch preAuthToken ${e}`, "warning") } } list(e, t) { return this.get(`${this.id}/list/${e || ""}`, t) } async logout(e) { let t = await this.get(`${this.id}/logout`, e); return await gs(this, Gh)[Gh](), t } static initPlugin(e, t, r) { if (e.type = "acquirer", e.files = [], r && (e.opts = { ...r, ...t }), t.serverUrl || t.serverPattern) throw new Error("`serverUrl` and `serverPattern` have been renamed to `companionUrl` and `companionAllowedHosts` respectively in the 0.30.5 release. Please consult the docs (for example, https://uppy.io/docs/instagram/ for the Instagram plugin) and use the updated options.`"); if (t.companionAllowedHosts) { let s = t.companionAllowedHosts; if (typeof s != "string" && !Array.isArray(s) && !(s instanceof RegExp)) throw new TypeError(`${e.id}: the option "companionAllowedHosts" must be one of string, Array, RegExp`); e.opts.companionAllowedHosts = s } else /^(?!https?:\/\/).*$/i.test(t.companionUrl) ? e.opts.companionAllowedHosts = `https://${t.companionUrl.replace(/^\/\//, "")}` : e.opts.companionAllowedHosts = new URL(t.companionUrl).origin; e.storage = e.opts.storage || Wh } }; n(Q, "Provider"); async function DS() { return this.uppy.getPlugin(this.pluginId).storage.getItem(this.tokenKey) } n(DS, "_getAuthToken2"); async function NS() { return this.uppy.getPlugin(this.pluginId).storage.removeItem(this.tokenKey) } n(NS, "_removeAuthToken2"); var IS = n(i => i.split("-").map(e => e.charAt(0).toUpperCase() + e.slice(1)).join(" "), "getName"), Nr = class extends de { constructor(e, t) { super(e, t), this.provider = t.provider, this.id = this.provider, this.name = this.opts.name || IS(this.id), this.pluginId = this.opts.pluginId } fileUrl(e) { return `${this.hostname}/search/${this.id}/get/${e}` } search(e, t) { return this.get(`search/${this.id}/list?q=${encodeURIComponent(e)}${t ? `&${t}` : ""}`) } }; n(Nr, "SearchProvider"); var Xm = se(Rh(), 1); var Km, Gm; function Pe(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Pe, "_classPrivateFieldLooseBase"); var BS = 0; function Rn(i) { return "__private_" + BS++ + "_" + i } n(Rn, "_classPrivateFieldLooseKey"); var ar = Rn("queued"), ys = Rn("emitter"), di = Rn("isOpen"), Le = Rn("socket"), Yh = Rn("handleMessage"); Km = Symbol.for("uppy test: getSocket"); Gm = Symbol.for("uppy test: getQueued"); var Ft = class { constructor(e) { Object.defineProperty(this, ar, { writable: !0, value: [] }), Object.defineProperty(this, ys, { writable: !0, value: (0, Xm.default)() }), Object.defineProperty(this, di, { writable: !0, value: !1 }), Object.defineProperty(this, Le, { writable: !0, value: void 0 }), Object.defineProperty(this, Yh, { writable: !0, value: t => { try { let r = JSON.parse(t.data); this.emit(r.action, r.payload) } catch (r) { console.log(r) } } }), this.opts = e, (!e || e.autoOpen !== !1) && this.open() } get isOpen() { return Pe(this, di)[di] } [Km]() { return Pe(this, Le)[Le] } [Gm]() { return Pe(this, ar)[ar] } open() { Pe(this, Le)[Le] == null && (Pe(this, Le)[Le] = new WebSocket(this.opts.target), Pe(this, Le)[Le].onopen = () => { for (Pe(this, di)[di] = !0; Pe(this, ar)[ar].length > 0 && Pe(this, di)[di];) { let e = Pe(this, ar)[ar].shift(); this.send(e.action, e.payload) } }, Pe(this, Le)[Le].onclose = () => { Pe(this, di)[di] = !1, Pe(this, Le)[Le] = null }, Pe(this, Le)[Le].onmessage = Pe(this, Yh)[Yh]) } close() { var e; (e = Pe(this, Le)[Le]) == null || e.close() } send(e, t) { if (!Pe(this, di)[di]) { Pe(this, ar)[ar].push({ action: e, payload: t }); return } Pe(this, Le)[Le].send(JSON.stringify({ action: e, payload: t })) } on(e, t) { Pe(this, ys)[ys].on(e, t) } emit(e, t) { Pe(this, ys)[ys].emit(e, t) } once(e, t) { Pe(this, ys)[ys].once(e, t) } }; n(Ft, "UppySocket"); var dc = {}; cn(dc, { ProviderViews: () => ge, SearchProviderViews: () => Ai, defaultPickerIcon: () => ko }); var ng = se(Qm(), 1); var Fo = class extends Error { constructor(e) { super(e), this.name = "TimeoutError" } }; n(Fo, "TimeoutError"); var Jl = class extends Error { constructor(e) { super(), this.name = "AbortError", this.message = e } }; n(Jl, "AbortError"); var Jm = n(i => globalThis.DOMException === void 0 ? new Jl(i) : new DOMException(i), "getDOMException"), Zm = n(i => { let e = i.reason === void 0 ? Jm("This operation was aborted.") : i.reason; return e instanceof Error ? e : Jm(e) }, "getAbortedReason"); function Zh(i, e, t, r) { let s, o = new Promise((a, l) => { if (typeof e != "number" || Math.sign(e) !== 1) throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${e}\``); if (e === Number.POSITIVE_INFINITY) { a(i); return } if (r = { customTimers: { setTimeout, clearTimeout }, ...r }, r.signal) { let { signal: h } = r; h.aborted && l(Zm(h)), h.addEventListener("abort", () => { l(Zm(h)) }) } s = r.customTimers.setTimeout.call(void 0, () => { if (typeof t == "function") { try { a(t()) } catch (d) { l(d) } return } let h = typeof t == "string" ? t : `Promise timed out after ${e} milliseconds`, c = t instanceof Error ? t : new Fo(h); typeof i.cancel == "function" && i.cancel(), l(c) }, e), (async () => { try { a(await i) } catch (h) { l(h) } finally { r.customTimers.clearTimeout.call(void 0, s) } })() }); return o.clear = () => { clearTimeout(s), s = void 0 }, o } n(Zh, "pTimeout"); function ec(i, e, t) { let r = 0, s = i.length; for (; s > 0;) { let o = Math.trunc(s / 2), a = r + o; t(i[a], e) <= 0 ? (r = ++a, s -= o + 1) : s = o } return r } n(ec, "lowerBound"); var vs = function (i, e, t, r) { if (t === "a" && !r) throw new TypeError("Private accessor was defined without a getter"); if (typeof e == "function" ? i !== e || !r : !e.has(i)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return t === "m" ? r : t === "a" ? r.call(i) : r ? r.value : e.get(i) }, lr, Oo = class { constructor() { lr.set(this, []) } enqueue(e, t) { t = { priority: 0, ...t }; let r = { priority: t.priority, run: e }; if (this.size && vs(this, lr, "f")[this.size - 1].priority >= t.priority) { vs(this, lr, "f").push(r); return } let s = ec(vs(this, lr, "f"), r, (o, a) => a.priority - o.priority); vs(this, lr, "f").splice(s, 0, r) } dequeue() { let e = vs(this, lr, "f").shift(); return e?.run } filter(e) { return vs(this, lr, "f").filter(t => t.priority === e.priority).map(t => t.run) } get size() { return vs(this, lr, "f").length } }; n(Oo, "PriorityQueue"); lr = new WeakMap; var ye = function (i, e, t, r, s) { if (r === "m") throw new TypeError("Private method is not writable"); if (r === "a" && !s) throw new TypeError("Private accessor was defined without a setter"); if (typeof e == "function" ? i !== e || !s : !e.has(i)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return r === "a" ? s.call(i, t) : s ? s.value = t : e.set(i, t), t }, j = function (i, e, t, r) { if (t === "a" && !r) throw new TypeError("Private accessor was defined without a getter"); if (typeof e == "function" ? i !== e || !r : !e.has(i)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return t === "m" ? r : t === "a" ? r.call(i) : r ? r.value : e.get(i) }, Oe, Dn, Nn, Br, su, In, Zl, pi, Un, Dt, eu, Nt, Bn, Ir, tu, eg, tg, sg, ig, rg, iu, tc, ic, ou, og, ru, Ln = class extends Error { }; n(Ln, "AbortError"); var Ao = class extends ng.default { constructor(e) { var t, r, s, o; if (super(), Oe.add(this), Dn.set(this, void 0), Nn.set(this, void 0), Br.set(this, 0), su.set(this, void 0), In.set(this, void 0), Zl.set(this, 0), pi.set(this, void 0), Un.set(this, void 0), Dt.set(this, void 0), eu.set(this, void 0), Nt.set(this, 0), Bn.set(this, void 0), Ir.set(this, void 0), tu.set(this, void 0), Object.defineProperty(this, "timeout", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), e = { carryoverConcurrencyCount: !1, intervalCap: Number.POSITIVE_INFINITY, interval: 0, concurrency: Number.POSITIVE_INFINITY, autoStart: !0, queueClass: Oo, ...e }, !(typeof e.intervalCap == "number" && e.intervalCap >= 1)) throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(r = (t = e.intervalCap) === null || t === void 0 ? void 0 : t.toString()) !== null && r !== void 0 ? r : ""}\` (${typeof e.intervalCap})`); if (e.interval === void 0 || !(Number.isFinite(e.interval) && e.interval >= 0)) throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(o = (s = e.interval) === null || s === void 0 ? void 0 : s.toString()) !== null && o !== void 0 ? o : ""}\` (${typeof e.interval})`); ye(this, Dn, e.carryoverConcurrencyCount, "f"), ye(this, Nn, e.intervalCap === Number.POSITIVE_INFINITY || e.interval === 0, "f"), ye(this, su, e.intervalCap, "f"), ye(this, In, e.interval, "f"), ye(this, Dt, new e.queueClass, "f"), ye(this, eu, e.queueClass, "f"), this.concurrency = e.concurrency, this.timeout = e.timeout, ye(this, tu, e.throwOnTimeout === !0, "f"), ye(this, Ir, e.autoStart === !1, "f") } get concurrency() { return j(this, Bn, "f") } set concurrency(e) { if (!(typeof e == "number" && e >= 1)) throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`); ye(this, Bn, e, "f"), j(this, Oe, "m", ou).call(this) } async add(e, t = {}) { return t = { timeout: this.timeout, throwOnTimeout: j(this, tu, "f"), ...t }, new Promise((r, s) => { j(this, Dt, "f").enqueue(async () => { var o, a, l; ye(this, Nt, (a = j(this, Nt, "f"), a++, a), "f"), ye(this, Br, (l = j(this, Br, "f"), l++, l), "f"); try { if (!((o = t.signal) === null || o === void 0) && o.aborted) throw new Ln("The task was aborted."); let h = e({ signal: t.signal }); t.timeout && (h = Zh(Promise.resolve(h), t.timeout)), t.signal && (h = Promise.race([h, j(this, Oe, "m", og).call(this, t.signal)])); let c = await h; r(c), this.emit("completed", c) } catch (h) { if (h instanceof Fo && !t.throwOnTimeout) { r(); return } s(h), this.emit("error", h) } finally { j(this, Oe, "m", sg).call(this) } }, t), this.emit("add"), j(this, Oe, "m", iu).call(this) }) } async addAll(e, t) { return Promise.all(e.map(async r => this.add(r, t))) } start() { return j(this, Ir, "f") ? (ye(this, Ir, !1, "f"), j(this, Oe, "m", ou).call(this), this) : this } pause() { ye(this, Ir, !0, "f") } clear() { ye(this, Dt, new (j(this, eu, "f")), "f") } async onEmpty() { j(this, Dt, "f").size !== 0 && await j(this, Oe, "m", ru).call(this, "empty") } async onSizeLessThan(e) { j(this, Dt, "f").size < e || await j(this, Oe, "m", ru).call(this, "next", () => j(this, Dt, "f").size < e) } async onIdle() { j(this, Nt, "f") === 0 && j(this, Dt, "f").size === 0 || await j(this, Oe, "m", ru).call(this, "idle") } get size() { return j(this, Dt, "f").size } sizeBy(e) { return j(this, Dt, "f").filter(e).length } get pending() { return j(this, Nt, "f") } get isPaused() { return j(this, Ir, "f") } }; n(Ao, "PQueue"); Dn = new WeakMap, Nn = new WeakMap, Br = new WeakMap, su = new WeakMap, In = new WeakMap, Zl = new WeakMap, pi = new WeakMap, Un = new WeakMap, Dt = new WeakMap, eu = new WeakMap, Nt = new WeakMap, Bn = new WeakMap, Ir = new WeakMap, tu = new WeakMap, Oe = new WeakSet, eg = n(function () { return j(this, Nn, "f") || j(this, Br, "f") < j(this, su, "f") }, "_PQueue_doesIntervalAllowAnother_get"), tg = n(function () { return j(this, Nt, "f") < j(this, Bn, "f") }, "_PQueue_doesConcurrentAllowAnother_get"), sg = n(function () { var e; ye(this, Nt, (e = j(this, Nt, "f"), e--, e), "f"), j(this, Oe, "m", iu).call(this), this.emit("next") }, "_PQueue_next"), ig = n(function () { j(this, Oe, "m", ic).call(this), j(this, Oe, "m", tc).call(this), ye(this, Un, void 0, "f") }, "_PQueue_onResumeInterval"), rg = n(function () { let e = Date.now(); if (j(this, pi, "f") === void 0) { let t = j(this, Zl, "f") - e; if (t < 0) ye(this, Br, j(this, Dn, "f") ? j(this, Nt, "f") : 0, "f"); else return j(this, Un, "f") === void 0 && ye(this, Un, setTimeout(() => { j(this, Oe, "m", ig).call(this) }, t), "f"), !0 } return !1 }, "_PQueue_isIntervalPaused_get"), iu = n(function () { if (j(this, Dt, "f").size === 0) return j(this, pi, "f") && clearInterval(j(this, pi, "f")), ye(this, pi, void 0, "f"), this.emit("empty"), j(this, Nt, "f") === 0 && this.emit("idle"), !1; if (!j(this, Ir, "f")) { let e = !j(this, Oe, "a", rg); if (j(this, Oe, "a", eg) && j(this, Oe, "a", tg)) { let t = j(this, Dt, "f").dequeue(); return t ? (this.emit("active"), t(), e && j(this, Oe, "m", tc).call(this), !0) : !1 } } return !1 }, "_PQueue_tryToStartAnother"), tc = n(function () { j(this, Nn, "f") || j(this, pi, "f") !== void 0 || (ye(this, pi, setInterval(() => { j(this, Oe, "m", ic).call(this) }, j(this, In, "f")), "f"), ye(this, Zl, Date.now() + j(this, In, "f"), "f")) }, "_PQueue_initializeIntervalIfNeeded"), ic = n(function () { j(this, Br, "f") === 0 && j(this, Nt, "f") === 0 && j(this, pi, "f") && (clearInterval(j(this, pi, "f")), ye(this, pi, void 0, "f")), ye(this, Br, j(this, Dn, "f") ? j(this, Nt, "f") : 0, "f"), j(this, Oe, "m", ou).call(this) }, "_PQueue_onInterval"), ou = n(function () { for (; j(this, Oe, "m", iu).call(this);); }, "_PQueue_processQueue"), og = n(async function (e) { return new Promise((t, r) => { e.addEventListener("abort", () => { r(new Ln("The task was aborted.")) }, { once: !0 }) }) }, "_PQueue_throwOnAbort"), ru = n(async function (e, t) { return new Promise(r => { let s = n(() => { t && !t() || (this.off(e, s), r()) }, "listener"); this.on(e, s) }) }, "_PQueue_onEvent"); function zS() { return u("svg", { width: "26", height: "26", viewBox: "0 0 26 26", xmlns: "http://www.w3.org/2000/svg" }, u("g", { fill: "none", "fill-rule": "evenodd" }, u("circle", { fill: "#FFF", cx: "13", cy: "13", r: "13" }), u("path", { d: "M21.64 13.205c0-.639-.057-1.252-.164-1.841H13v3.481h4.844a4.14 4.14 0 01-1.796 2.716v2.259h2.908c1.702-1.567 2.684-3.875 2.684-6.615z", fill: "#4285F4", "fill-rule": "nonzero" }), u("path", { d: "M13 22c2.43 0 4.467-.806 5.956-2.18l-2.908-2.259c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H4.957v2.332A8.997 8.997 0 0013 22z", fill: "#34A853", "fill-rule": "nonzero" }), u("path", { d: "M7.964 14.71A5.41 5.41 0 017.682 13c0-.593.102-1.17.282-1.71V8.958H4.957A8.996 8.996 0 004 13c0 1.452.348 2.827.957 4.042l3.007-2.332z", fill: "#FBBC05", "fill-rule": "nonzero" }), u("path", { d: "M13 7.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C17.463 4.891 15.426 4 13 4a8.997 8.997 0 00-8.043 4.958l3.007 2.332C8.672 9.163 10.656 7.58 13 7.58z", fill: "#EA4335", "fill-rule": "nonzero" }), u("path", { d: "M4 4h18v18H4z" }))) } n(zS, "GoogleIcon"); function jS(i) { let { pluginName: e, pluginIcon: t, i18nArray: r, handleAuth: s } = i, o = e === "Google Drive", a = u("span", { className: "uppy-Provider-authTitleName" }, e, u("br", null)); return u("div", { className: "uppy-Provider-auth" }, u("div", { className: "uppy-Provider-authIcon" }, t()), u("div", { className: "uppy-Provider-authTitle" }, r("authenticateWithTitle", { pluginName: a })), o ? u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Provider-authBtn uppy-Provider-btn-google", onClick: s, "data-uppy-super-focusable": !0 }, u(zS, null), r("signInWithGoogle")) : u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Provider-authBtn", onClick: s, "data-uppy-super-focusable": !0 }, r("authenticateWith", { pluginName: e }))) } n(jS, "AuthView"); var ag = jS; var lg = n(i => { let { i18n: e, logout: t, username: r } = i; return [u("span", { className: "uppy-ProviderBrowser-user", key: "username" }, r), u("button", { type: "button", onClick: t, className: "uppy-u-reset uppy-c-btn uppy-ProviderBrowser-userLogout", key: "logout" }, e("logOut"))] }, "default"); var HS = n(i => { let { getFolder: e, title: t, isLast: r } = i; return u(Et, null, u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", onClick: e }, t), r ? "" : " / ") }, "Breadcrumb"), ug = n(i => { let { getFolder: e, title: t, breadcrumbsIcon: r, breadcrumbs: s } = i; return u("div", { className: "uppy-Provider-breadcrumbs" }, u("div", { className: "uppy-Provider-breadcrumbsIcon" }, r), s.map((o, a) => u(HS, { key: o.id, getFolder: () => e(o.requestPath), title: a === 0 ? t : o.name, isLast: a + 1 === s.length }))) }, "default"); var hg = n(i => { let e = []; return i.showBreadcrumbs && e.push(ug({ getFolder: i.getFolder, breadcrumbs: i.breadcrumbs, breadcrumbsIcon: i.pluginIcon && i.pluginIcon(), title: i.title })), e.push(lg({ logout: i.logout, username: i.username, i18n: i.i18n })), e }, "default"); var hc = se(It(), 1); function Mn(i) { return { ...i, type: i.mimeType, extension: i.name ? er(i.name).extension : null } } n(Mn, "remoteFileObjToLocal"); var uu, pt, rc, cg, zn = 0, vg = [], au = [], dg = X.__b, pg = X.__r, fg = X.diffed, mg = X.__c, gg = X.unmount; function oc(i, e) { X.__h && X.__h(pt, i, zn || e), zn = 0; var t = pt.__H || (pt.__H = { __: [], __h: [] }); return i >= t.__.length && t.__.push({ __V: au }), t.__[i] } n(oc, "p"); function To(i) { return zn = 1, qS(wg, i) } n(To, "y"); function qS(i, e, t) { var r = oc(uu++, 2); return r.t = i, r.__c || (r.__ = [t ? t(e) : wg(void 0, e), function (s) { var o = r.t(r.__[0], s); r.__[0] !== o && (r.__ = [o, r.__[1]], r.__c.setState({})) }], r.__c = pt), r.__ } n(qS, "d"); function bs(i, e) { var t = oc(uu++, 3); !X.__s && bg(t.__H, e) && (t.__ = i, t.u = e, pt.__H.__h.push(t)) } n(bs, "_"); function nc(i) { return zn = 5, Co(function () { return { current: i } }, []) } n(nc, "s"); function Co(i, e) { var t = oc(uu++, 7); return bg(t.__H, e) ? (t.__V = i(), t.u = e, t.__h = i, t.__V) : t.__ } n(Co, "F"); function jn(i, e) { return zn = 8, Co(function () { return i }, e) } n(jn, "T"); function $S() { for (var i; i = vg.shift();)if (i.__P) try { i.__H.__h.forEach(lu), i.__H.__h.forEach(sc), i.__H.__h = [] } catch (e) { i.__H.__h = [], X.__e(e, i.__v) } } n($S, "b"); X.__b = function (i) { pt = null, dg && dg(i) }, X.__r = function (i) { pg && pg(i), uu = 0; var e = (pt = i.__c).__H; e && (rc === pt ? (e.__h = [], pt.__h = [], e.__.forEach(function (t) { t.__V = au, t.u = void 0 })) : (e.__h.forEach(lu), e.__h.forEach(sc), e.__h = [])), rc = pt }, X.diffed = function (i) { fg && fg(i); var e = i.__c; e && e.__H && (e.__H.__h.length && (vg.push(e) !== 1 && cg === X.requestAnimationFrame || ((cg = X.requestAnimationFrame) || function (t) { var r, s = n(function () { clearTimeout(o), yg && cancelAnimationFrame(r), setTimeout(t) }, "u"), o = setTimeout(s, 100); yg && (r = requestAnimationFrame(s)) })($S)), e.__H.__.forEach(function (t) { t.u && (t.__H = t.u), t.__V !== au && (t.__ = t.__V), t.u = void 0, t.__V = au })), rc = pt = null }, X.__c = function (i, e) { e.some(function (t) { try { t.__h.forEach(lu), t.__h = t.__h.filter(function (r) { return !r.__ || sc(r) }) } catch (r) { e.some(function (s) { s.__h && (s.__h = []) }), e = [], X.__e(r, t.__v) } }), mg && mg(i, e) }, X.unmount = function (i) { gg && gg(i); var e, t = i.__c; t && t.__H && (t.__H.__.forEach(function (r) { try { lu(r) } catch (s) { e = s } }), e && X.__e(e, t.__v)) }; var yg = typeof requestAnimationFrame == "function"; function lu(i) { var e = pt, t = i.__c; typeof t == "function" && (i.__c = void 0, t()), pt = e } n(lu, "j"); function sc(i) { var e = pt; i.__c = i.__(), pt = e } n(sc, "k"); function bg(i, e) { return !i || i.length !== e.length || e.some(function (t, r) { return t !== i[r] }) } n(bg, "w"); function wg(i, e) { return typeof e == "function" ? e(i) : e } n(wg, "z"); function ac() { return ac = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, ac.apply(this, arguments) } n(ac, "_extends"); var VS = { position: "relative", width: "100%", minHeight: "100%" }, WS = { position: "absolute", top: 0, left: 0, width: "100%", overflow: "visible" }, hu = class extends ue { constructor(e) { super(e), this.handleScroll = () => { this.setState({ offset: this.base.scrollTop }) }, this.handleResize = () => { this.resize() }, this.focusElement = null, this.state = { offset: 0, height: 0 } } componentDidMount() { this.resize(), window.addEventListener("resize", this.handleResize) } componentWillUpdate() { this.base.contains(document.activeElement) && (this.focusElement = document.activeElement) } componentDidUpdate() { this.focusElement && this.focusElement.parentNode && document.activeElement !== this.focusElement && this.focusElement.focus(), this.focusElement = null, this.resize() } componentWillUnmount() { window.removeEventListener("resize", this.handleResize) } resize() { let { height: e } = this.state; e !== this.base.offsetHeight && this.setState({ height: this.base.offsetHeight }) } render(e) { let { data: t, rowHeight: r, renderRow: s, overscanCount: o = 10, ...a } = e, { offset: l, height: h } = this.state, c = Math.floor(l / r), d = Math.floor(h / r); o && (c = Math.max(0, c - c % o), d += o); let p = c + d + 4, y = t.slice(c, p), v = { ...VS, height: t.length * r }, S = { ...WS, top: c * r }; return u("div", ac({ onScroll: this.handleScroll }, a), u("div", { role: "presentation", style: v }, u("div", { role: "presentation", style: S }, y.map(s)))) } }; n(hu, "VirtualList"); var cu = hu; function Hn(i) { let { search: e, searchOnInput: t, searchTerm: r, showButton: s, inputLabel: o, clearSearchLabel: a, buttonLabel: l, clearSearch: h, inputClassName: c, buttonCSSClassName: d } = i, [p, y] = To(r ?? ""), v = jn(F => { F.preventDefault(), e(p) }, [e, p]), S = jn(F => { let k = F.target.value; y(k), t && e(k) }, [y, t, e]), x = n(() => { y(""), h && h() }, "handleReset"), [E] = To(() => { let F = document.createElement("form"); return F.setAttribute("tabindex", "-1"), F.id = ot(), F }); return bs(() => (document.body.appendChild(E), E.addEventListener("submit", v), () => { E.removeEventListener("submit", v), document.body.removeChild(E) }), [E, v]), u(Et, null, u("input", { className: `uppy-u-reset ${c}`, type: "search", "aria-label": o, placeholder: o, value: p, onInput: S, form: E.id, "data-uppy-super-focusable": !0 }), !s && u("svg", { "aria-hidden": "true", focusable: "false", class: "uppy-c-icon uppy-ProviderBrowser-searchFilterIcon", width: "12", height: "12", viewBox: "0 0 12 12" }, u("path", { d: "M8.638 7.99l3.172 3.172a.492.492 0 1 1-.697.697L7.91 8.656a4.977 4.977 0 0 1-2.983.983C2.206 9.639 0 7.481 0 4.819 0 2.158 2.206 0 4.927 0c2.721 0 4.927 2.158 4.927 4.82a4.74 4.74 0 0 1-1.216 3.17zm-3.71.685c2.176 0 3.94-1.726 3.94-3.856 0-2.129-1.764-3.855-3.94-3.855C2.75.964.984 2.69.984 4.819c0 2.13 1.765 3.856 3.942 3.856z" })), !s && p && u("button", { className: "uppy-u-reset uppy-ProviderBrowser-searchFilterReset", type: "button", "aria-label": a, title: a, onClick: x }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", viewBox: "0 0 19 19" }, u("path", { d: "M17.318 17.232L9.94 9.854 9.586 9.5l-.354.354-7.378 7.378h.707l-.62-.62v.706L9.318 9.94l.354-.354-.354-.354L1.94 1.854v.707l.62-.62h-.706l7.378 7.378.354.354.354-.354 7.378-7.378h-.707l.622.62v-.706L9.854 9.232l-.354.354.354.354 7.378 7.378.708-.707-7.38-7.378v.708l7.38-7.38.353-.353-.353-.353-.622-.622-.353-.353-.354.352-7.378 7.38h.708L2.56 1.23 2.208.88l-.353.353-.622.62-.353.355.352.353 7.38 7.38v-.708l-7.38 7.38-.353.353.352.353.622.622.353.353.354-.353 7.38-7.38h-.708l7.38 7.38z" }))), s && u("button", { className: `uppy-u-reset uppy-c-btn uppy-c-btn-primary ${d}`, type: "submit", form: E.id }, l)) } n(Hn, "SearchFilterInput"); var Sg = n(i => { let { cancel: e, done: t, i18n: r, selected: s } = i; return u("div", { className: "uppy-ProviderBrowser-footer" }, u("button", { className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary", onClick: t, type: "button" }, r("selectX", { smart_count: s })), u("button", { className: "uppy-u-reset uppy-c-btn uppy-c-btn-link", onClick: e, type: "button" }, r("cancel"))) }, "default"); var Eg = se(It(), 1); function KS() { return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: 11, height: 14.5, viewBox: "0 0 44 58" }, u("path", { d: "M27.437.517a1 1 0 0 0-.094.03H4.25C2.037.548.217 2.368.217 4.58v48.405c0 2.212 1.82 4.03 4.03 4.03H39.03c2.21 0 4.03-1.818 4.03-4.03V15.61a1 1 0 0 0-.03-.28 1 1 0 0 0 0-.093 1 1 0 0 0-.03-.032 1 1 0 0 0 0-.03 1 1 0 0 0-.032-.063 1 1 0 0 0-.03-.063 1 1 0 0 0-.032 0 1 1 0 0 0-.03-.063 1 1 0 0 0-.032-.03 1 1 0 0 0-.03-.063 1 1 0 0 0-.063-.062l-14.593-14a1 1 0 0 0-.062-.062A1 1 0 0 0 28 .708a1 1 0 0 0-.374-.157 1 1 0 0 0-.156 0 1 1 0 0 0-.03-.03l-.003-.003zM4.25 2.547h22.218v9.97c0 2.21 1.82 4.03 4.03 4.03h10.564v36.438a2.02 2.02 0 0 1-2.032 2.032H4.25c-1.13 0-2.032-.9-2.032-2.032V4.58c0-1.13.902-2.032 2.03-2.032zm24.218 1.345l10.375 9.937.75.718H30.5c-1.13 0-2.032-.9-2.032-2.03V3.89z" })) } n(KS, "FileIcon"); function GS() { return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", style: { minWidth: 16, marginRight: 3 }, viewBox: "0 0 276.157 276.157" }, u("path", { d: "M273.08 101.378c-3.3-4.65-8.86-7.32-15.254-7.32h-24.34V67.59c0-10.2-8.3-18.5-18.5-18.5h-85.322c-3.63 0-9.295-2.875-11.436-5.805l-6.386-8.735c-4.982-6.814-15.104-11.954-23.546-11.954H58.73c-9.292 0-18.638 6.608-21.737 15.372l-2.033 5.752c-.958 2.71-4.72 5.37-7.596 5.37H18.5C8.3 49.09 0 57.39 0 67.59v167.07c0 .886.16 1.73.443 2.52.152 3.306 1.18 6.424 3.053 9.064 3.3 4.652 8.86 7.32 15.255 7.32h188.487c11.395 0 23.27-8.425 27.035-19.18l40.677-116.188c2.11-6.035 1.43-12.164-1.87-16.816zM18.5 64.088h8.864c9.295 0 18.64-6.607 21.738-15.37l2.032-5.75c.96-2.712 4.722-5.373 7.597-5.373h29.565c3.63 0 9.295 2.876 11.437 5.806l6.386 8.735c4.982 6.815 15.104 11.954 23.546 11.954h85.322c1.898 0 3.5 1.602 3.5 3.5v26.47H69.34c-11.395 0-23.27 8.423-27.035 19.178L15 191.23V67.59c0-1.898 1.603-3.5 3.5-3.5zm242.29 49.15l-40.676 116.188c-1.674 4.78-7.812 9.135-12.877 9.135H18.75c-1.447 0-2.576-.372-3.02-.997-.442-.625-.422-1.814.057-3.18l40.677-116.19c1.674-4.78 7.812-9.134 12.877-9.134h188.487c1.448 0 2.577.372 3.02.997.443.625.423 1.814-.056 3.18z" })) } n(GS, "FolderIcon"); function XS() { return u("svg", { "aria-hidden": "true", focusable: "false", style: { width: 16, marginRight: 4 }, viewBox: "0 0 58 58" }, u("path", { d: "M36.537 28.156l-11-7a1.005 1.005 0 0 0-1.02-.033C24.2 21.3 24 21.635 24 22v14a1 1 0 0 0 1.537.844l11-7a1.002 1.002 0 0 0 0-1.688zM26 34.18V23.82L34.137 29 26 34.18z" }), u("path", { d: "M57 6H1a1 1 0 0 0-1 1v44a1 1 0 0 0 1 1h56a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zM10 28H2v-9h8v9zm-8 2h8v9H2v-9zm10 10V8h34v42H12V40zm44-12h-8v-9h8v9zm-8 2h8v9h-8v-9zm8-22v9h-8V8h8zM2 8h8v9H2V8zm0 42v-9h8v9H2zm54 0h-8v-9h8v9z" })) } n(XS, "VideoIcon"); var Pg = n(i => { let { itemIconString: e } = i; if (e !== null) switch (e) { case "file": return u(KS, null); case "folder": return u(GS, null); case "video": return u(XS, null); default: { let { alt: t } = i; return u("img", { src: e, alt: t, loading: "lazy", width: 16, height: 16 }) } } }, "default"); var _g = se(It(), 1); function YS(i) { let { className: e, isDisabled: t, restrictionError: r, isChecked: s, title: o, itemIconEl: a, showTitles: l, toggleCheckbox: h, recordShiftKeyPress: c, id: d, children: p } = i, y = (0, _g.default)("uppy-u-reset", "uppy-ProviderBrowserItem-checkbox", "uppy-ProviderBrowserItem-checkbox--grid", { "uppy-ProviderBrowserItem-checkbox--is-checked": s }); return u("li", { className: e, title: t ? r?.message : null }, u("input", { type: "checkbox", className: y, onChange: h, onKeyDown: c, onMouseDown: c, name: "listitem", id: d, checked: s, disabled: t, "data-uppy-super-focusable": !0 }), u("label", { htmlFor: d, "aria-label": o, className: "uppy-u-reset uppy-ProviderBrowserItem-inner" }, a, l && o, p)) } n(YS, "GridListItem"); var lc = YS; function QS(i) { let { className: e, isDisabled: t, restrictionError: r, isCheckboxDisabled: s, isChecked: o, toggleCheckbox: a, recordShiftKeyPress: l, type: h, id: c, itemIconEl: d, title: p, handleFolderClick: y, showTitles: v, i18n: S } = i; return u("li", { className: e, title: t ? r?.message : null }, s ? null : u("input", { type: "checkbox", className: `uppy-u-reset uppy-ProviderBrowserItem-checkbox ${o ? "uppy-ProviderBrowserItem-checkbox--is-checked" : ""}`, onChange: a, onKeyDown: l, onMouseDown: l, name: "listitem", id: c, checked: o, "aria-label": h === "file" ? null : S("allFilesFromFolderNamed", { name: p }), disabled: t, "data-uppy-super-focusable": !0 }), h === "file" ? u("label", { htmlFor: c, className: "uppy-u-reset uppy-ProviderBrowserItem-inner" }, u("div", { className: "uppy-ProviderBrowserItem-iconWrap" }, d), v && p) : u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-ProviderBrowserItem-inner", onClick: y, "aria-label": S("openFolderNamed", { name: p }) }, u("div", { className: "uppy-ProviderBrowserItem-iconWrap" }, d), v && u("span", null, p))) } n(QS, "ListItem"); var xg = QS; function qn() { return qn = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, qn.apply(this, arguments) } n(qn, "_extends"); var uc = n(i => { let { author: e, getItemIcon: t, isChecked: r, isDisabled: s, viewType: o } = i, a = t(), l = (0, Eg.default)("uppy-ProviderBrowserItem", { "uppy-ProviderBrowserItem--selected": r }, { "uppy-ProviderBrowserItem--disabled": s }, { "uppy-ProviderBrowserItem--noPreview": a === "video" }), h = u(Pg, { itemIconString: a }); switch (o) { case "grid": return u(lc, qn({}, i, { className: l, itemIconEl: h })); case "list": return u(xg, qn({}, i, { className: l, itemIconEl: h })); case "unsplash": return u(lc, qn({}, i, { className: l, itemIconEl: h }), u("a", { href: `${e.url}?utm_source=Companion&utm_medium=referral`, target: "_blank", rel: "noopener noreferrer", className: "uppy-ProviderBrowserItem-author", tabIndex: "-1" }, e.name)); default: throw new Error(`There is no such type ${o}`) } }, "default"); var JS = "shared-with-me"; function Fg(i) { let { currentSelection: e, uppyFiles: t, viewType: r, isChecked: s, toggleCheckbox: o, recordShiftKeyPress: a, showTitles: l, i18n: h, validateRestrictions: c, getNextFolder: d, columns: p, f: y } = i; if (y.isFolder) { var v; return uc({ columns: p, showTitles: l, viewType: r, i18n: h, id: y.id, title: y.name, getItemIcon: () => y.icon, isChecked: s(y), toggleCheckbox: x => o(x, y), recordShiftKeyPress: a, type: "folder", isDisabled: (v = s(y)) == null ? void 0 : v.loading, isCheckboxDisabled: y.id === JS, handleFolderClick: () => d(y) }) } let S = c(Mn(y), [...t, ...e]); return uc({ id: y.id, title: y.name, author: y.author, getItemIcon: () => y.icon, isChecked: s(y), toggleCheckbox: x => o(x, y), recordShiftKeyPress: a, columns: p, showTitles: l, viewType: r, i18n: h, type: "file", isDisabled: S && !s(y), restrictionError: S }) } n(Fg, "ListItem"); function ZS(i) { let { currentSelection: e, folders: t, files: r, uppyFiles: s, viewType: o, headerComponent: a, showBreadcrumbs: l, isChecked: h, toggleCheckbox: c, recordShiftKeyPress: d, handleScroll: p, showTitles: y, i18n: v, validateRestrictions: S, isLoading: x, showSearchFilter: E, search: F, searchTerm: k, clearSearch: B, searchOnInput: H, searchInputLabel: W, clearSearchLabel: I, getNextFolder: q, cancel: $, done: V, columns: xe, noResultsLabel: Pt, loadAllFiles: ut } = i, rt = e.length, st = Co(() => [...t, ...r], [t, r]); return u("div", { className: (0, hc.default)("uppy-ProviderBrowser", `uppy-ProviderBrowser-viewType--${o}`) }, a && u("div", { className: "uppy-ProviderBrowser-header" }, u("div", { className: (0, hc.default)("uppy-ProviderBrowser-headerBar", !l && "uppy-ProviderBrowser-headerBar--simple") }, a)), E && u("div", { class: "uppy-ProviderBrowser-searchFilter" }, u(Hn, { search: F, searchTerm: k, clearSearch: B, inputLabel: W, clearSearchLabel: I, inputClassName: "uppy-ProviderBrowser-searchFilterInput", searchOnInput: H })), (() => x ? u("div", { className: "uppy-Provider-loading" }, u("span", null, v("loading"))) : !t.length && !r.length ? u("div", { className: "uppy-Provider-empty" }, Pt) : ut ? u("div", { className: "uppy-ProviderBrowser-body" }, u("ul", { className: "uppy-ProviderBrowser-list" }, u(cu, { data: st, renderRow: We => u(Fg, { currentSelection: e, uppyFiles: s, viewType: o, isChecked: h, toggleCheckbox: c, recordShiftKeyPress: d, showTitles: y, i18n: v, validateRestrictions: S, getNextFolder: q, columns: xe, f: We }), rowHeight: 31 }))) : u("div", { className: "uppy-ProviderBrowser-body" }, u("ul", { className: "uppy-ProviderBrowser-list", onScroll: p, role: "listbox", tabIndex: "-1" }, st.map(We => u(Fg, { currentSelection: e, uppyFiles: s, viewType: o, isChecked: h, toggleCheckbox: c, recordShiftKeyPress: d, showTitles: y, i18n: v, validateRestrictions: S, getNextFolder: q, columns: xe, f: We })))))(), rt > 0 && u(Sg, { selected: rt, done: V, cancel: $, i18n: v })) } n(ZS, "Browser"); var du = ZS; var Og = n(i => { let { i18n: e, loading: t } = i; return u("div", { className: "uppy-Provider-loading" }, u("span", null, e("loading")), typeof t == "string" && u("span", { style: { marginTop: ".7em" } }, t)) }, "default"); var fi = class extends ue { componentWillUnmount() { let { onUnmount: e } = this.props; e() } render() { let { children: e } = this.props; return ti(e)[0] } }; n(fi, "CloseWrapper"); function Ro(i) { return i ? /^[^/]+\/(jpe?g|gif|png|svg|svg\+xml|bmp|webp|avif)$/.test(i) : !1 } n(Ro, "isPreviewSupported"); var Lr = class { constructor(e, t) { this.filterItems = r => { let s = this.plugin.getPluginState(); return !s.filterInput || s.filterInput === "" ? r : r.filter(o => o.name.toLowerCase().indexOf(s.filterInput.toLowerCase()) !== -1) }, this.recordShiftKeyPress = r => { this.isShiftKeyPressed = r.shiftKey }, this.toggleCheckbox = (r, s) => { r.stopPropagation(), r.preventDefault(), r.currentTarget.focus(); let { folders: o, files: a } = this.plugin.getPluginState(), l = this.filterItems(o.concat(a)); if (this.lastCheckbox && this.isShiftKeyPressed) { let { currentSelection: c } = this.plugin.getPluginState(), d = l.indexOf(this.lastCheckbox), p = l.indexOf(s), y = d < p ? l.slice(d, p + 1) : l.slice(p, d + 1), v = []; for (let S of y) { let { uppy: x } = this.plugin, E = x.validateRestrictions(Mn(S), [...x.getFiles(), ...v]); E ? x.info({ message: E.message }, "error", x.opts.infoTimeout) : v.push(S) } this.plugin.setPluginState({ currentSelection: [...new Set([...c, ...v])] }); return } this.lastCheckbox = s; let { currentSelection: h } = this.plugin.getPluginState(); this.isChecked(s) ? this.plugin.setPluginState({ currentSelection: h.filter(c => c.id !== s.id) }) : this.plugin.setPluginState({ currentSelection: h.concat([s]) }) }, this.isChecked = r => { let { currentSelection: s } = this.plugin.getPluginState(); return s.some(o => o.id === r.id) }, this.plugin = e, this.provider = t.provider, this.isHandlingScroll = !1, this.preFirstRender = this.preFirstRender.bind(this), this.handleError = this.handleError.bind(this), this.clearSelection = this.clearSelection.bind(this), this.cancelPicking = this.cancelPicking.bind(this) } preFirstRender() { this.plugin.setPluginState({ didFirstRender: !0 }), this.plugin.onFirstRender() } shouldHandleScroll(e) { let { scrollHeight: t, scrollTop: r, offsetHeight: s } = e.target; return t - (r + s) < 50 && !this.isHandlingScroll } clearSelection() { this.plugin.setPluginState({ currentSelection: [], filterInput: "" }) } cancelPicking() { this.clearSelection(); let e = this.plugin.uppy.getPlugin("Dashboard"); e && e.hideAllPanels() } handleError(e) { var t; let { uppy: r } = this.plugin, s = r.i18n("companionError"); r.log(e.toString()), !(e.isAuthError || ((t = e.cause) == null ? void 0 : t.name) === "AbortError") && r.info({ message: s, details: e.toString() }, "error", 5e3) } getTagFile(e) { let t = { id: e.id, source: this.plugin.id, data: e, name: e.name || e.id, type: e.mimeType, isRemote: !0, meta: {}, body: { fileId: e.id }, remote: { companionUrl: this.plugin.opts.companionUrl, url: `${this.provider.fileUrl(e.requestPath)}`, body: { fileId: e.id }, providerOptions: this.provider.opts, providerName: this.provider.name, provider: this.provider.provider } }, r = us(t); return r && Ro(r) && (t.preview = e.thumbnail), e.author && (e.author.name != null && (t.meta.authorName = String(e.author.name)), e.author.url && (t.meta.authorUrl = e.author.url)), e.relDirPath != null && (t.meta.relativePath = e.relDirPath ? `${e.relDirPath}/${t.name}` : null), e.absDirPath != null && (t.meta.absolutePath = e.absDirPath ? `/${e.absDirPath}/${t.name}` : `/${t.name}`), t } setLoading(e) { this.plugin.setPluginState({ loading: e }) } }; n(Lr, "View"); function Bt(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Bt, "_classPrivateFieldLooseBase"); var e2 = 0; function Kn(i) { return "__private_" + e2++ + "_" + i } n(Kn, "_classPrivateFieldLooseKey"); var t2 = { version: "3.5.0" }; function i2(i) { return i.slice(1).map(e => e.name).join("/") } n(i2, "formatBreadcrumbs"); function cc(i, e) { return i ? `${i}/${e}` : e } n(cc, "prependPath"); function ko() { return u("svg", { "aria-hidden": "true", focusable: "false", width: "30", height: "30", viewBox: "0 0 30 30" }, u("path", { d: "M15 30c8.284 0 15-6.716 15-15 0-8.284-6.716-15-15-15C6.716 0 0 6.716 0 15c0 8.284 6.716 15 15 15zm4.258-12.676v6.846h-8.426v-6.846H5.204l9.82-12.364 9.82 12.364H19.26z" })) } n(ko, "defaultPickerIcon"); var ws = Kn("abortController"), ur = Kn("withAbort"), Wn = Kn("list"), $n = Kn("listFilesAndFolders"), Vn = Kn("recursivelyListAllFiles"), ge = class extends Lr { constructor(e, t) { super(e, t), Object.defineProperty(this, Vn, { value: n2 }), Object.defineProperty(this, $n, { value: o2 }), Object.defineProperty(this, Wn, { value: s2 }), Object.defineProperty(this, ur, { value: r2 }), Object.defineProperty(this, ws, { writable: !0, value: void 0 }); let r = { viewType: "list", showTitles: !0, showFilter: !0, showBreadcrumbs: !0, loadAllFiles: !1 }; this.opts = { ...r, ...t }, this.filterQuery = this.filterQuery.bind(this), this.clearFilter = this.clearFilter.bind(this), this.getFolder = this.getFolder.bind(this), this.getNextFolder = this.getNextFolder.bind(this), this.logout = this.logout.bind(this), this.handleAuth = this.handleAuth.bind(this), this.handleScroll = this.handleScroll.bind(this), this.donePicking = this.donePicking.bind(this), this.render = this.render.bind(this), this.plugin.setPluginState({ authenticated: !1, files: [], folders: [], breadcrumbs: [], filterInput: "", isSearchVisible: !1, currentSelection: [] }) } tearDown() { } async getFolder(e, t) { this.setLoading(!0); try { await Bt(this, ur)[ur](async r => { this.lastCheckbox = void 0; let { breadcrumbs: s } = this.plugin.getPluginState(), o = s.findIndex(h => e === h.requestPath); o !== -1 ? s = s.slice(0, o + 1) : s = [...s, { requestPath: e, name: t }], this.nextPagePath = e; let a = [], l = []; do { let { files: h, folders: c } = await Bt(this, $n)[$n]({ breadcrumbs: s, signal: r }); a = a.concat(h), l = l.concat(c), this.setLoading(this.plugin.uppy.i18n("loadedXFiles", { numFiles: a.length + l.length })) } while (this.opts.loadAllFiles && this.nextPagePath); this.plugin.setPluginState({ folders: l, files: a, breadcrumbs: s, filterInput: "" }) }) } catch (r) { this.handleError(r) } finally { this.setLoading(!1) } } getNextFolder(e) { this.getFolder(e.requestPath, e.name), this.lastCheckbox = void 0 } async logout() { try { await Bt(this, ur)[ur](async e => { let t = await this.provider.logout({ signal: e }); if (t.ok) { if (!t.revoked) { let s = this.plugin.uppy.i18n("companionUnauthorizeHint", { provider: this.plugin.title, url: t.manual_revoke_url }); this.plugin.uppy.info(s, "info", 7e3) } let r = { authenticated: !1, files: [], folders: [], breadcrumbs: [], filterInput: "" }; this.plugin.setPluginState(r) } }) } catch (e) { this.handleError(e) } } filterQuery(e) { this.plugin.setPluginState({ filterInput: e }) } clearFilter() { this.plugin.setPluginState({ filterInput: "" }) } async handleAuth() { let e = `@uppy/provider-views=${ge.VERSION}`; try { await this.provider.login({ uppyVersions: e }), this.plugin.setPluginState({ authenticated: !0 }), this.preFirstRender() } catch (t) { this.plugin.uppy.log(`login failed: ${t.message}`) } } async handleScroll(e) { if (this.shouldHandleScroll(e) && this.nextPagePath) { this.isHandlingScroll = !0; try { await Bt(this, ur)[ur](async t => { let { files: r, folders: s, breadcrumbs: o } = this.plugin.getPluginState(), { files: a, folders: l } = await Bt(this, $n)[$n]({ breadcrumbs: o, signal: t }), h = r.concat(a), c = s.concat(l); this.plugin.setPluginState({ folders: c, files: h }) }) } catch (t) { this.handleError(t) } finally { this.isHandlingScroll = !1 } } } async donePicking() { this.setLoading(!0); try { await Bt(this, ur)[ur](async e => { let { currentSelection: t } = this.plugin.getPluginState(), r = [], s = []; for (let o of t) { let { requestPath: a } = o, l = n(h => ({ ...h, relDirPath: h.absDirPath.replace(o.absDirPath, "").replace(/^\//, "") }), "withRelDirPath"); if (o.isFolder) { let h = !0, c = 0, d = new Ao({ concurrency: 6 }), p = n(v => { for (let S of v) { let x = this.getTagFile(S), E = Ml(x); this.plugin.uppy.checkIfFileAlreadyExists(E) || (s.push(l(S)), c++, this.setLoading(this.plugin.uppy.i18n("addedNumFiles", { numFiles: c }))), h = !1 } }, "onFiles"); await Bt(this, Vn)[Vn]({ requestPath: a, absDirPath: cc(o.absDirPath, o.name), relDirPath: o.name, queue: d, onFiles: p, signal: e }), await d.onIdle(); let y; h ? y = this.plugin.uppy.i18n("emptyFolderAdded") : c === 0 ? y = this.plugin.uppy.i18n("folderAlreadyAdded", { folder: o.name }) : y = this.plugin.uppy.i18n("folderAdded", { smart_count: c, folder: o.name }), r.push(y) } else s.push(l(o)) } this.plugin.uppy.log("Adding remote provider files"), this.plugin.uppy.addFiles(s.map(o => this.getTagFile(o))), this.plugin.setPluginState({ filterInput: "" }), r.forEach(o => this.plugin.uppy.info(o)), this.clearSelection() }) } catch (e) { this.handleError(e) } finally { this.setLoading(!1) } } render(e, t) { var r = this; t === void 0 && (t = {}); let { authenticated: s, didFirstRender: o } = this.plugin.getPluginState(), { i18n: a } = this.plugin.uppy; o || this.preFirstRender(); let l = { ...this.opts, ...t }, { files: h, folders: c, filterInput: d, loading: p, currentSelection: y } = this.plugin.getPluginState(), { isChecked: v, toggleCheckbox: S, recordShiftKeyPress: x, filterItems: E } = this, F = d !== "", k = this.plugin.icon || ko, B = { showBreadcrumbs: l.showBreadcrumbs, getFolder: this.getFolder, breadcrumbs: this.plugin.getPluginState().breadcrumbs, pluginIcon: k, title: this.plugin.title, logout: this.logout, username: this.username, i18n: a }, H = { isChecked: v, toggleCheckbox: S, recordShiftKeyPress: x, currentSelection: y, files: F ? E(h) : h, folders: F ? E(c) : c, username: this.username, getNextFolder: this.getNextFolder, getFolder: this.getFolder, loadAllFiles: this.opts.loadAllFiles, showSearchFilter: l.showFilter, search: this.filterQuery, clearSearch: this.clearFilter, searchTerm: d, searchOnInput: !0, searchInputLabel: a("filter"), clearSearchLabel: a("resetFilter"), noResultsLabel: a("noFilesFound"), logout: this.logout, handleScroll: this.handleScroll, done: this.donePicking, cancel: this.cancelPicking, headerComponent: hg(B), title: this.plugin.title, viewType: l.viewType, showTitles: l.showTitles, showBreadcrumbs: l.showBreadcrumbs, pluginIcon: k, i18n: this.plugin.uppy.i18n, uppyFiles: this.plugin.uppy.getFiles(), validateRestrictions: function () { return r.plugin.uppy.validateRestrictions(...arguments) } }; return p ? u(fi, { onUnmount: this.clearSelection }, u(Og, { i18n: this.plugin.uppy.i18n, loading: p })) : s ? u(fi, { onUnmount: this.clearSelection }, u(du, H)) : u(fi, { onUnmount: this.clearSelection }, u(ag, { pluginName: this.plugin.title, pluginIcon: k, handleAuth: this.handleAuth, i18n: this.plugin.uppy.i18n, i18nArray: this.plugin.uppy.i18nArray })) } }; n(ge, "ProviderView"); async function r2(i) { var e; (e = Bt(this, ws)[ws]) == null || e.abort(); let t = new AbortController; Bt(this, ws)[ws] = t; let r = n(() => { t.abort(), this.clearSelection() }, "cancelRequest"); try { this.plugin.uppy.on("dashboard:close-panel", r), this.plugin.uppy.on("cancel-all", r), await i(t.signal) } finally { this.plugin.uppy.off("dashboard:close-panel", r), this.plugin.uppy.off("cancel-all", r), Bt(this, ws)[ws] = void 0 } } n(r2, "_withAbort2"); async function s2(i) { let { requestPath: e, absDirPath: t, signal: r } = i, { username: s, nextPagePath: o, items: a } = await this.provider.list(e, { signal: r }); return this.username = s || this.username, { items: a.map(l => ({ ...l, absDirPath: t })), nextPagePath: o } } n(s2, "_list2"); async function o2(i) { let { breadcrumbs: e, signal: t } = i, r = i2(e), { items: s, nextPagePath: o } = await Bt(this, Wn)[Wn]({ requestPath: this.nextPagePath, absDirPath: r, signal: t }); this.nextPagePath = o; let a = [], l = []; return s.forEach(h => { h.isFolder ? l.push(h) : a.push(h) }), { files: a, folders: l } } n(o2, "_listFilesAndFolders2"); async function n2(i) { let { requestPath: e, absDirPath: t, relDirPath: r, queue: s, onFiles: o, signal: a } = i, l = e; for (; l;) { let h = await Bt(this, Wn)[Wn]({ requestPath: l, absDirPath: t, signal: a }); l = h.nextPagePath; let c = h.items.filter(y => !y.isFolder), d = h.items.filter(y => y.isFolder); o(c); let p = d.map(async y => s.add(async () => Bt(this, Vn)[Vn]({ requestPath: y.requestPath, absDirPath: cc(t, y.name), relDirPath: cc(r, y.name), queue: s, onFiles: o, signal: a }))); await Promise.all(p) } } n(n2, "_recursivelyListAllFiles2"); ge.VERSION = t2.version; function Ag(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Ag, "_classPrivateFieldLooseBase"); var a2 = 0; function l2(i) { return "__private_" + a2++ + "_" + i } n(l2, "_classPrivateFieldLooseKey"); var u2 = { version: "3.5.0" }, Gn = l2("updateFilesAndInputMode"), Ai = class extends Lr { constructor(e, t) { super(e, t), Object.defineProperty(this, Gn, { value: h2 }); let r = { viewType: "grid", showTitles: !1, showFilter: !1, showBreadcrumbs: !1 }; this.opts = { ...r, ...t }, this.search = this.search.bind(this), this.clearSearch = this.clearSearch.bind(this), this.resetPluginState = this.resetPluginState.bind(this), this.handleScroll = this.handleScroll.bind(this), this.donePicking = this.donePicking.bind(this), this.render = this.render.bind(this), this.defaultState = { isInputMode: !0, files: [], folders: [], breadcrumbs: [], filterInput: "", currentSelection: [], searchTerm: null }, this.plugin.setPluginState(this.defaultState) } tearDown() { } resetPluginState() { this.plugin.setPluginState(this.defaultState) } async search(e) { let { searchTerm: t } = this.plugin.getPluginState(); if (!(e && e === t)) { this.setLoading(!0); try { let r = await this.provider.search(e); Ag(this, Gn)[Gn](r, []) } catch (r) { this.handleError(r) } finally { this.setLoading(!1) } } } clearSearch() { this.plugin.setPluginState({ currentSelection: [], files: [], searchTerm: null }) } async handleScroll(e) { let t = this.nextPageQuery || null; if (this.shouldHandleScroll(e) && t) { this.isHandlingScroll = !0; try { let { files: r, searchTerm: s } = this.plugin.getPluginState(), o = await this.provider.search(s, t); Ag(this, Gn)[Gn](o, r) } catch (r) { this.handleError(r) } finally { this.isHandlingScroll = !1 } } } donePicking() { let { currentSelection: e } = this.plugin.getPluginState(); this.plugin.uppy.log("Adding remote search provider files"), this.plugin.uppy.addFiles(e.map(t => this.getTagFile(t))), this.resetPluginState() } render(e, t) { var r = this; t === void 0 && (t = {}); let { didFirstRender: s, isInputMode: o, searchTerm: a } = this.plugin.getPluginState(), { i18n: l } = this.plugin.uppy; s || this.preFirstRender(); let h = { ...this.opts, ...t }, { files: c, folders: d, filterInput: p, loading: y, currentSelection: v } = this.plugin.getPluginState(), { isChecked: S, toggleCheckbox: x, filterItems: E, recordShiftKeyPress: F } = this, k = p !== "", B = { isChecked: S, toggleCheckbox: x, recordShiftKeyPress: F, currentSelection: v, files: k ? E(c) : c, folders: k ? E(d) : d, handleScroll: this.handleScroll, done: this.donePicking, cancel: this.cancelPicking, showSearchFilter: h.showFilter, search: this.search, clearSearch: this.clearSearch, searchTerm: a, searchOnInput: !1, searchInputLabel: l("search"), clearSearchLabel: l("resetSearch"), noResultsLabel: l("noSearchResults"), title: this.plugin.title, viewType: h.viewType, showTitles: h.showTitles, showFilter: h.showFilter, isLoading: y, showBreadcrumbs: h.showBreadcrumbs, pluginIcon: this.plugin.icon, i18n: l, uppyFiles: this.plugin.uppy.getFiles(), validateRestrictions: function () { return r.plugin.uppy.validateRestrictions(...arguments) } }; return o ? u(fi, { onUnmount: this.resetPluginState }, u("div", { className: "uppy-SearchProvider" }, u(Hn, { search: this.search, clearSelection: this.clearSelection, inputLabel: l("enterTextToSearch"), buttonLabel: l("searchImages"), inputClassName: "uppy-c-textInput uppy-SearchProvider-input", buttonCSSClassName: "uppy-SearchProvider-searchButton", showButton: !0 }))) : u(fi, { onUnmount: this.resetPluginState }, u(du, B)) } }; n(Ai, "SearchProviderView"); function h2(i, e) { this.nextPageQuery = i.nextPageQuery, i.items.forEach(t => { e.push(t) }), this.plugin.setPluginState({ currentSelection: [], isInputMode: !1, files: e, searchTerm: i.searchedFor }) } n(h2, "_updateFilesAndInputMode2"); Ai.VERSION = u2.version; var Tg; function Ti(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Ti, "_classPrivateFieldLooseBase"); var c2 = 0; function pc(i) { return "__private_" + c2++ + "_" + i } n(pc, "_classPrivateFieldLooseKey"); var d2 = { version: "3.0.3" }, p2 = "uppy/STATE_UPDATE", f2 = n(i => e => e.uppy[i], "defaultSelector"); function m2(i, e) { let t = Object.keys(e), r = {}; return t.forEach(s => { i[s] !== e[s] && (r[s] = e[s]) }), r } n(m2, "getPatch"); var hr = pc("id"), Xn = pc("selector"), cr = pc("store"); Tg = Symbol.for("uppy test: get id"); var Yn = class { constructor(e) { Object.defineProperty(this, hr, { writable: !0, value: void 0 }), Object.defineProperty(this, Xn, { writable: !0, value: void 0 }), Object.defineProperty(this, cr, { writable: !0, value: void 0 }), Ti(this, cr)[cr] = e.store, Ti(this, hr)[hr] = e.id || ot(), Ti(this, Xn)[Xn] = e.selector || f2(Ti(this, hr)[hr]), this.setState({}) } setState(e) { Ti(this, cr)[cr].dispatch({ type: p2, id: Ti(this, hr)[hr], payload: e }) } getState() { return Ti(this, Xn)[Xn](Ti(this, cr)[cr].getState()) } subscribe(e) { let t = this.getState(); return Ti(this, cr)[cr].subscribe(() => { let r = this.getState(); if (t !== r) { let s = m2(t, r); e(t, r, s), t = r } }) } [Tg]() { return Ti(this, hr)[hr] } }; n(Yn, "ReduxStore"); Yn.VERSION = d2.version; var Cg = Yn; function pu(i, e, t, r) { return t === 0 || i === e ? i : r === 0 ? e : i + (e - i) * 2 ** (-r / t) } n(pu, "emaFilter"); var ft = { STATE_ERROR: "error", STATE_WAITING: "waiting", STATE_PREPROCESSING: "preprocessing", STATE_UPLOADING: "uploading", STATE_POSTPROCESSING: "postprocessing", STATE_COMPLETE: "complete" }; var wc = se(It(), 1); function Qn(i) { let e = [], t, r; for (let { progress: o } of Object.values(i)) { let { preprocess: a, postprocess: l } = o; r == null && (a || l) && ({ mode: t, message: r } = a || l), a?.mode === "determinate" && e.push(a.value), l?.mode === "determinate" && e.push(l.value) } let s = e.reduce((o, a) => o + a / e.length, 0); return { mode: t, message: r, value: s } } n(Qn, "calculateProcessingProgress"); var yc = se(It(), 1), gc = se(zl(), 1); function fc(i) { let e = Math.floor(i / 3600) % 24, t = Math.floor(i / 60) % 60, r = Math.floor(i % 60); return { hours: e, minutes: t, seconds: r } } n(fc, "secondsToTime"); function mc(i) { let e = fc(i), t = e.hours === 0 ? "" : `${e.hours}h`, r = e.minutes === 0 ? "" : `${e.hours === 0 ? e.minutes : ` ${e.minutes.toString(10).padStart(2, "0")}`}m`, s = e.hours !== 0 ? "" : `${e.minutes === 0 ? e.seconds : ` ${e.seconds.toString(10).padStart(2, "0")}`}s`; return `${t}${r}${s}` } n(mc, "prettyETA"); var g2 = "\xB7", Rg = n(() => ` ${g2} `, "renderDot"); function kg(i) { let { newFiles: e, isUploadStarted: t, recoveredState: r, i18n: s, uploadState: o, isSomeGhost: a, startUpload: l } = i, h = (0, yc.default)("uppy-u-reset", "uppy-c-btn", "uppy-StatusBar-actionBtn", "uppy-StatusBar-actionBtn--upload", { "uppy-c-btn-primary": o === ft.STATE_WAITING }, { "uppy-StatusBar-actionBtn--disabled": a }), c = e && t && !r ? s("uploadXNewFiles", { smart_count: e }) : s("uploadXFiles", { smart_count: e }); return u("button", { type: "button", className: h, "aria-label": s("uploadXFiles", { smart_count: e }), onClick: l, disabled: a, "data-uppy-super-focusable": !0 }, c) } n(kg, "UploadBtn"); function Ug(i) { let { i18n: e, uppy: t } = i; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--retry", "aria-label": e("retryUpload"), onClick: () => t.retryAll().catch(() => { }), "data-uppy-super-focusable": !0, "data-cy": "retry" }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "8", height: "10", viewBox: "0 0 8 10" }, u("path", { d: "M4 2.408a2.75 2.75 0 1 0 2.75 2.75.626.626 0 0 1 1.25.018v.023a4 4 0 1 1-4-4.041V.25a.25.25 0 0 1 .389-.208l2.299 1.533a.25.25 0 0 1 0 .416l-2.3 1.533A.25.25 0 0 1 4 3.316v-.908z" })), e("retry")) } n(Ug, "RetryBtn"); function Dg(i) { let { i18n: e, uppy: t } = i; return u("button", { type: "button", className: "uppy-u-reset uppy-StatusBar-actionCircleBtn", title: e("cancel"), "aria-label": e("cancel"), onClick: () => t.cancelAll(), "data-cy": "cancel", "data-uppy-super-focusable": !0 }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "16", height: "16", viewBox: "0 0 16 16" }, u("g", { fill: "none", fillRule: "evenodd" }, u("circle", { fill: "#888", cx: "8", cy: "8", r: "8" }), u("path", { fill: "#FFF", d: "M9.283 8l2.567 2.567-1.283 1.283L8 9.283 5.433 11.85 4.15 10.567 6.717 8 4.15 5.433 5.433 4.15 8 6.717l2.567-2.567 1.283 1.283z" })))) } n(Dg, "CancelBtn"); function Ng(i) { let { isAllPaused: e, i18n: t, isAllComplete: r, resumableUploads: s, uppy: o } = i, a = t(e ? "resume" : "pause"); function l() { return r ? null : s ? e ? o.resumeAll() : o.pauseAll() : o.cancelAll() } return n(l, "togglePauseResume"), u("button", { title: a, "aria-label": a, className: "uppy-u-reset uppy-StatusBar-actionCircleBtn", type: "button", onClick: l, "data-cy": "togglePauseResume", "data-uppy-super-focusable": !0 }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "16", height: "16", viewBox: "0 0 16 16" }, u("g", { fill: "none", fillRule: "evenodd" }, u("circle", { fill: "#888", cx: "8", cy: "8", r: "8" }), u("path", { fill: "#FFF", d: e ? "M6 4.25L11.5 8 6 11.75z" : "M5 4.5h2v7H5v-7zm4 0h2v7H9v-7z" })))) } n(Ng, "PauseResumeButton"); function Ig(i) { let { i18n: e, doneButtonHandler: t } = i; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--done", onClick: t, "data-uppy-super-focusable": !0 }, e("done")) } n(Ig, "DoneBtn"); function Bg() { return u("svg", { className: "uppy-StatusBar-spinner", "aria-hidden": "true", focusable: "false", width: "14", height: "14" }, u("path", { d: "M13.983 6.547c-.12-2.509-1.64-4.893-3.939-5.936-2.48-1.127-5.488-.656-7.556 1.094C.524 3.367-.398 6.048.162 8.562c.556 2.495 2.46 4.52 4.94 5.183 2.932.784 5.61-.602 7.256-3.015-1.493 1.993-3.745 3.309-6.298 2.868-2.514-.434-4.578-2.349-5.153-4.84a6.226 6.226 0 0 1 2.98-6.778C6.34.586 9.74 1.1 11.373 3.493c.407.596.693 1.282.842 1.988.127.598.073 1.197.161 1.794.078.525.543 1.257 1.15.864.525-.341.49-1.05.456-1.592-.007-.15.02.3 0 0", fillRule: "evenodd" })) } n(Bg, "LoadingSpinner"); function Lg(i) { let { progress: e } = i, { value: t, mode: r, message: s } = e, o = Math.round(t * 100), a = "\xB7"; return u("div", { className: "uppy-StatusBar-content" }, u(Bg, null), r === "determinate" ? `${o}% ${a} ` : "", s) } n(Lg, "ProgressBarProcessing"); function y2(i) { let { numUploads: e, complete: t, totalUploadedSize: r, totalSize: s, totalETA: o, i18n: a } = i, l = e > 1; return u("div", { className: "uppy-StatusBar-statusSecondary" }, l && a("filesUploadedOfTotal", { complete: t, smart_count: e }), u("span", { className: "uppy-StatusBar-additionalInfo" }, l && Rg(), a("dataUploadedOfTotal", { complete: (0, gc.default)(r), total: (0, gc.default)(s) }), Rg(), a("xTimeLeft", { time: mc(o) }))) } n(y2, "ProgressDetails"); function Mg(i) { let { i18n: e, complete: t, numUploads: r } = i; return u("div", { className: "uppy-StatusBar-statusSecondary" }, e("filesUploadedOfTotal", { complete: t, smart_count: r })) } n(Mg, "FileUploadCount"); function v2(i) { let { i18n: e, newFiles: t, startUpload: r } = i, s = (0, yc.default)("uppy-u-reset", "uppy-c-btn", "uppy-StatusBar-actionBtn", "uppy-StatusBar-actionBtn--uploadNewlyAdded"); return u("div", { className: "uppy-StatusBar-statusSecondary" }, u("div", { className: "uppy-StatusBar-statusSecondaryHint" }, e("xMoreFilesAdded", { smart_count: t })), u("button", { type: "button", className: s, "aria-label": e("uploadXFiles", { smart_count: t }), onClick: r }, e("upload"))) } n(v2, "UploadNewlyAddedFiles"); function zg(i) { let { i18n: e, supportsUploadProgress: t, totalProgress: r, showProgressDetails: s, isUploadStarted: o, isAllComplete: a, isAllPaused: l, newFiles: h, numUploads: c, complete: d, totalUploadedSize: p, totalSize: y, totalETA: v, startUpload: S } = i, x = h && o; if (!o || a) return null; let E = e(l ? "paused" : "uploading"); function F() { return !l && !x && s ? t ? u(y2, { numUploads: c, complete: d, totalUploadedSize: p, totalSize: y, totalETA: v, i18n: e }) : u(Mg, { i18n: e, complete: d, numUploads: c }) : null } return n(F, "renderProgressDetails"), u("div", { className: "uppy-StatusBar-content", "aria-label": E, title: E }, l ? null : u(Bg, null), u("div", { className: "uppy-StatusBar-status" }, u("div", { className: "uppy-StatusBar-statusPrimary" }, t ? `${E}: ${r}%` : E), F(), x ? u(v2, { i18n: e, newFiles: h, startUpload: S }) : null)) } n(zg, "ProgressBarUploading"); function jg(i) { let { i18n: e } = i; return u("div", { className: "uppy-StatusBar-content", role: "status", title: e("complete") }, u("div", { className: "uppy-StatusBar-status" }, u("div", { className: "uppy-StatusBar-statusPrimary" }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-StatusBar-statusIndicator uppy-c-icon", width: "15", height: "11", viewBox: "0 0 15 11" }, u("path", { d: "M.414 5.843L1.627 4.63l3.472 3.472L13.202 0l1.212 1.213L5.1 10.528z" })), e("complete")))) } n(jg, "ProgressBarComplete"); function Hg(i) {
        let { error: e, i18n: t, complete: r, numUploads: s } = i; function o() {
            let a = `${t("uploadFailed")}

 ${e}`; alert(a)
        } return n(o, "displayErrorAlert"), u("div", { className: "uppy-StatusBar-content", title: t("uploadFailed") }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-StatusBar-statusIndicator uppy-c-icon", width: "11", height: "11", viewBox: "0 0 11 11" }, u("path", { d: "M4.278 5.5L0 1.222 1.222 0 5.5 4.278 9.778 0 11 1.222 6.722 5.5 11 9.778 9.778 11 5.5 6.722 1.222 11 0 9.778z" })), u("div", { className: "uppy-StatusBar-status" }, u("div", { className: "uppy-StatusBar-statusPrimary" }, t("uploadFailed"), u("button", { className: "uppy-u-reset uppy-StatusBar-details", "aria-label": t("showErrorDetails"), "data-microtip-position": "top-right", "data-microtip-size": "medium", onClick: o, type: "button" }, "?")), u(Mg, { i18n: t, complete: r, numUploads: s })))
    } n(Hg, "ProgressBarError"); var { STATE_ERROR: qg, STATE_WAITING: $g, STATE_PREPROCESSING: vc, STATE_UPLOADING: fu, STATE_POSTPROCESSING: bc, STATE_COMPLETE: mu } = ft; function Sc(i) { let { newFiles: e, allowNewUpload: t, isUploadInProgress: r, isAllPaused: s, resumableUploads: o, error: a, hideUploadButton: l, hidePauseResumeButton: h, hideCancelButton: c, hideRetryButton: d, recoveredState: p, uploadState: y, totalProgress: v, files: S, supportsUploadProgress: x, hideAfterFinish: E, isSomeGhost: F, doneButtonHandler: k, isUploadStarted: B, i18n: H, startUpload: W, uppy: I, isAllComplete: q, showProgressDetails: $, numUploads: V, complete: xe, totalSize: Pt, totalETA: ut, totalUploadedSize: rt } = i; function st() { switch (y) { case bc: case vc: { let Jt = Qn(S); return Jt.mode === "determinate" ? Jt.value * 100 : v } case qg: return null; case fu: return x ? v : null; default: return v } } n(st, "getProgressValue"); function We() { switch (y) { case bc: case vc: { let { mode: Jt } = Qn(S); return Jt === "indeterminate" } case fu: return !x; default: return !1 } } n(We, "getIsIndeterminate"); function Ee() { if (p) return !1; switch (y) { case $g: return l || e === 0; case mu: return E; default: return !1 } } n(Ee, "getIsHidden"); let ai = st(), go = Ee(), xi = ai ?? 100, ts = !a && e && !r && !s && t && !l, Xi = !c && y !== $g && y !== mu, Cr = o && !h && y === fu, Yi = a && !q && !d, is = k && y === mu, rs = (0, wc.default)("uppy-StatusBar-progress", { "is-indeterminate": We() }), Qi = (0, wc.default)("uppy-StatusBar", `is-${y}`, { "has-ghosts": F }); return u("div", { className: Qi, "aria-hidden": go }, u("div", { className: rs, style: { width: `${xi}%` }, role: "progressbar", "aria-label": `${xi}%`, "aria-valuetext": `${xi}%`, "aria-valuemin": "0", "aria-valuemax": "100", "aria-valuenow": ai }), (() => { switch (y) { case vc: case bc: return u(Lg, { progress: Qn(S) }); case mu: return u(jg, { i18n: H }); case qg: return u(Hg, { error: a, i18n: H, numUploads: V, complete: xe }); case fu: return u(zg, { i18n: H, supportsUploadProgress: x, totalProgress: v, showProgressDetails: $, isUploadStarted: B, isAllComplete: q, isAllPaused: s, newFiles: e, numUploads: V, complete: xe, totalUploadedSize: rt, totalSize: Pt, totalETA: ut, startUpload: W }); default: return null } })(), u("div", { className: "uppy-StatusBar-actions" }, p || ts ? u(kg, { newFiles: e, isUploadStarted: B, recoveredState: p, i18n: H, isSomeGhost: F, startUpload: W, uploadState: y }) : null, Yi ? u(Ug, { i18n: H, uppy: I }) : null, Cr ? u(Ng, { isAllPaused: s, i18n: H, isAllComplete: q, resumableUploads: o, uppy: I }) : null, Xi ? u(Dg, { i18n: H, uppy: I }) : null, is ? u(Ig, { i18n: H, doneButtonHandler: k }) : null)) } n(Sc, "StatusBar"); var Vg = { strings: { uploading: "Uploading", complete: "Complete", uploadFailed: "Upload failed", paused: "Paused", retry: "Retry", cancel: "Cancel", pause: "Pause", resume: "Resume", done: "Done", filesUploadedOfTotal: { 0: "%{complete} of %{smart_count} file uploaded", 1: "%{complete} of %{smart_count} files uploaded" }, dataUploadedOfTotal: "%{complete} of %{total}", xTimeLeft: "%{time} left", uploadXFiles: { 0: "Upload %{smart_count} file", 1: "Upload %{smart_count} files" }, uploadXNewFiles: { 0: "Upload +%{smart_count} file", 1: "Upload +%{smart_count} files" }, upload: "Upload", retryUpload: "Retry upload", xMoreFilesAdded: { 0: "%{smart_count} more file added", 1: "%{smart_count} more files added" }, showErrorDetails: "Show error details" } }; function ve(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(ve, "_classPrivateFieldLooseBase"); var b2 = 0; function Uo(i) { return "__private_" + b2++ + "_" + i } n(Uo, "_classPrivateFieldLooseKey"); var w2 = { version: "3.2.4" }, S2 = 2e3, P2 = 2e3; function _2(i, e, t, r) { if (i) return ft.STATE_ERROR; if (e) return ft.STATE_COMPLETE; if (t) return ft.STATE_WAITING; let s = ft.STATE_WAITING, o = Object.keys(r); for (let a = 0; a < o.length; a++) { let { progress: l } = r[o[a]]; if (l.uploadStarted && !l.uploadComplete) return ft.STATE_UPLOADING; l.preprocess && s !== ft.STATE_UPLOADING && (s = ft.STATE_PREPROCESSING), l.postprocess && s !== ft.STATE_UPLOADING && s !== ft.STATE_PREPROCESSING && (s = ft.STATE_POSTPROCESSING) } return s } n(_2, "getUploadingState"); var ii = Uo("lastUpdateTime"), mi = Uo("previousUploadedBytes"), dr = Uo("previousSpeed"), Lt = Uo("previousETA"), Pc = Uo("computeSmoothETA"), Jn = Uo("onUploadStart"), Ci = class extends G { constructor(e, t) { super(e, t), Object.defineProperty(this, Pc, { value: x2 }), Object.defineProperty(this, ii, { writable: !0, value: void 0 }), Object.defineProperty(this, mi, { writable: !0, value: void 0 }), Object.defineProperty(this, dr, { writable: !0, value: void 0 }), Object.defineProperty(this, Lt, { writable: !0, value: void 0 }), this.startUpload = () => this.uppy.upload().catch(() => { }), Object.defineProperty(this, Jn, { writable: !0, value: () => { let { recoveredState: s } = this.uppy.getState(); if (ve(this, dr)[dr] = null, ve(this, Lt)[Lt] = null, s) { ve(this, mi)[mi] = Object.values(s.files).reduce((o, a) => { let { progress: l } = a; return o + l.bytesUploaded }, 0), this.uppy.emit("restore-confirmed"); return } ve(this, ii)[ii] = performance.now(), ve(this, mi)[mi] = 0 } }), this.id = this.opts.id || "StatusBar", this.title = "StatusBar", this.type = "progressindicator", this.defaultLocale = Vg; let r = { target: "body", hideUploadButton: !1, hideRetryButton: !1, hidePauseResumeButton: !1, hideCancelButton: !1, showProgressDetails: !1, hideAfterFinish: !0, doneButtonHandler: null }; this.opts = { ...r, ...t }, this.i18nInit(), this.render = this.render.bind(this), this.install = this.install.bind(this) } render(e) { let { capabilities: t, files: r, allowNewUpload: s, totalProgress: o, error: a, recoveredState: l } = e, { newFiles: h, startedFiles: c, completeFiles: d, isUploadStarted: p, isAllComplete: y, isAllErrored: v, isAllPaused: S, isUploadInProgress: x, isSomeGhost: E } = this.uppy.getObjectOfFilesPerState(), F = l ? Object.values(r) : h, k = !!t.resumableUploads, B = t.uploadProgress !== !1, H = 0, W = 0; c.forEach(q => { H += q.progress.bytesTotal || 0, W += q.progress.bytesUploaded || 0 }); let I = ve(this, Pc)[Pc]({ uploaded: W, total: H, remaining: H - W }); return Sc({ error: a, uploadState: _2(a, y, l, e.files || {}), allowNewUpload: s, totalProgress: o, totalSize: H, totalUploadedSize: W, isAllComplete: !1, isAllPaused: S, isAllErrored: v, isUploadStarted: p, isUploadInProgress: x, isSomeGhost: E, recoveredState: l, complete: d.length, newFiles: F.length, numUploads: c.length, totalETA: I, files: r, i18n: this.i18n, uppy: this.uppy, startUpload: this.startUpload, doneButtonHandler: this.opts.doneButtonHandler, resumableUploads: k, supportsUploadProgress: B, showProgressDetails: this.opts.showProgressDetails, hideUploadButton: this.opts.hideUploadButton, hideRetryButton: this.opts.hideRetryButton, hidePauseResumeButton: this.opts.hidePauseResumeButton, hideCancelButton: this.opts.hideCancelButton, hideAfterFinish: this.opts.hideAfterFinish, isTargetDOMEl: this.isTargetDOMEl }) } onMount() { let e = this.el; Kl(e) || (e.dir = "ltr") } install() { let { target: e } = this.opts; e && this.mount(e, this), this.uppy.on("upload", ve(this, Jn)[Jn]), ve(this, ii)[ii] = performance.now(), ve(this, mi)[mi] = this.uppy.getFiles().reduce((t, r) => t + r.progress.bytesUploaded, 0) } uninstall() { this.unmount(), this.uppy.off("upload", ve(this, Jn)[Jn]) } }; n(Ci, "StatusBar"); function x2(i) { var e, t; if (i.total === 0 || i.remaining === 0) return 0; (t = (e = ve(this, ii))[ii]) != null || (e[ii] = performance.now()); let r = performance.now() - ve(this, ii)[ii]; if (r === 0) { var s; return Math.round(((s = ve(this, Lt)[Lt]) != null ? s : 0) / 100) / 10 } let o = i.uploaded - ve(this, mi)[mi]; if (ve(this, mi)[mi] = i.uploaded, o <= 0) { var a; return Math.round(((a = ve(this, Lt)[Lt]) != null ? a : 0) / 100) / 10 } let l = o / r, h = ve(this, dr)[dr] == null ? l : pu(l, ve(this, dr)[dr], S2, r); ve(this, dr)[dr] = h; let c = i.remaining / h, d = Math.max(ve(this, Lt)[Lt] - r, 0), p = ve(this, Lt)[Lt] == null ? c : pu(c, d, P2, r); return ve(this, Lt)[Lt] = p, ve(this, ii)[ii] = performance.now(), Math.round(p / 100) / 10 } n(x2, "_computeSmoothETA2"); Ci.VERSION = w2.version; var Wg = 300, Do = class extends ue { constructor() { super(...arguments), this.ref = Dm() } componentWillEnter(e) { this.ref.current.style.opacity = "1", this.ref.current.style.transform = "none", setTimeout(e, Wg) } componentWillLeave(e) { this.ref.current.style.opacity = "0", this.ref.current.style.transform = "translateY(350%)", setTimeout(e, Wg) } render() { let { children: e } = this.props; return u("div", { className: "uppy-Informer-animated", ref: this.ref }, e) } }; n(Do, "FadeIn"); function E2(i, e) { return Object.assign(i, e) } n(E2, "assign"); function F2(i, e) { var t; return (t = i?.key) != null ? t : e } n(F2, "getKey"); function O2(i, e) { let t = i._ptgLinkedRefs || (i._ptgLinkedRefs = {}); return t[e] || (t[e] = r => { i.refs[e] = r }) } n(O2, "linkRef"); function Zn(i) { let e = {}; for (let t = 0; t < i.length; t++)if (i[t] != null) { let r = F2(i[t], t.toString(36)); e[r] = i[t] } return e } n(Zn, "getChildMapping"); function A2(i, e) { i = i || {}, e = e || {}; let t = n(a => e.hasOwnProperty(a) ? e[a] : i[a], "getValueForKey"), r = {}, s = []; for (let a in i) e.hasOwnProperty(a) ? s.length && (r[a] = s, s = []) : s.push(a); let o = {}; for (let a in e) { if (r.hasOwnProperty(a)) for (let l = 0; l < r[a].length; l++) { let h = r[a][l]; o[r[a][l]] = t(h) } o[a] = t(a) } for (let a = 0; a < s.length; a++)o[s[a]] = t(s[a]); return o } n(A2, "mergeChildMappings"); var T2 = n(i => i, "identity"), ea = class extends ue { constructor(e, t) { super(e, t), this.refs = {}, this.state = { children: Zn(ti(ti(this.props.children)) || []) }, this.performAppear = this.performAppear.bind(this), this.performEnter = this.performEnter.bind(this), this.performLeave = this.performLeave.bind(this) } componentWillMount() { this.currentlyTransitioningKeys = {}, this.keysToAbortLeave = [], this.keysToEnter = [], this.keysToLeave = [] } componentDidMount() { let e = this.state.children; for (let t in e) e[t] && this.performAppear(t) } componentWillReceiveProps(e) { let t = Zn(ti(e.children) || []), r = this.state.children; this.setState(o => ({ children: A2(o.children, t) })); let s; for (s in t) if (t.hasOwnProperty(s)) { let o = r && r.hasOwnProperty(s); t[s] && o && this.currentlyTransitioningKeys[s] ? (this.keysToEnter.push(s), this.keysToAbortLeave.push(s)) : t[s] && !o && !this.currentlyTransitioningKeys[s] && this.keysToEnter.push(s) } for (s in r) if (r.hasOwnProperty(s)) { let o = t && t.hasOwnProperty(s); r[s] && !o && !this.currentlyTransitioningKeys[s] && this.keysToLeave.push(s) } } componentDidUpdate() { let { keysToEnter: e } = this; this.keysToEnter = [], e.forEach(this.performEnter); let { keysToLeave: t } = this; this.keysToLeave = [], t.forEach(this.performLeave) } _finishAbort(e) { let t = this.keysToAbortLeave.indexOf(e); t !== -1 && this.keysToAbortLeave.splice(t, 1) } performAppear(e) { this.currentlyTransitioningKeys[e] = !0; let t = this.refs[e]; t != null && t.componentWillAppear ? t.componentWillAppear(this._handleDoneAppearing.bind(this, e)) : this._handleDoneAppearing(e) } _handleDoneAppearing(e) { let t = this.refs[e]; t != null && t.componentDidAppear && t.componentDidAppear(), delete this.currentlyTransitioningKeys[e], this._finishAbort(e); let r = Zn(ti(this.props.children) || []); (!r || !r.hasOwnProperty(e)) && this.performLeave(e) } performEnter(e) { this.currentlyTransitioningKeys[e] = !0; let t = this.refs[e]; t != null && t.componentWillEnter ? t.componentWillEnter(this._handleDoneEntering.bind(this, e)) : this._handleDoneEntering(e) } _handleDoneEntering(e) { let t = this.refs[e]; t != null && t.componentDidEnter && t.componentDidEnter(), delete this.currentlyTransitioningKeys[e], this._finishAbort(e); let r = Zn(ti(this.props.children) || []); (!r || !r.hasOwnProperty(e)) && this.performLeave(e) } performLeave(e) { if (this.keysToAbortLeave.indexOf(e) !== -1) return; this.currentlyTransitioningKeys[e] = !0; let r = this.refs[e]; r != null && r.componentWillLeave ? r.componentWillLeave(this._handleDoneLeaving.bind(this, e)) : this._handleDoneLeaving(e) } _handleDoneLeaving(e) { if (this.keysToAbortLeave.indexOf(e) !== -1) return; let r = this.refs[e]; r != null && r.componentDidLeave && r.componentDidLeave(), delete this.currentlyTransitioningKeys[e]; let s = Zn(ti(this.props.children) || []); if (s && s.hasOwnProperty(e)) this.performEnter(e); else { let o = E2({}, this.state.children); delete o[e], this.setState({ children: o }) } } render(e, t) { let { childFactory: r, transitionLeave: s, transitionName: o, transitionAppear: a, transitionEnter: l, transitionLeaveTimeout: h, transitionEnterTimeout: c, transitionAppearTimeout: d, component: p, ...y } = e, { children: v } = t, S = Object.entries(v).map(x => { let [E, F] = x; if (!F) return; let k = O2(this, E); return Wl(r(F), { ref: k, key: E }) }).filter(Boolean); return u(p, y, S) } }; n(ea, "TransitionGroup"); ea.defaultProps = { component: "span", childFactory: T2 }; var Kg = ea; var C2 = { version: "3.0.3" }, Ri = class extends G {
        constructor(e, t) {
            super(e, t), this.render = s => u("div", { className: "uppy uppy-Informer" }, u(Kg, null, s.info.map(o => u(Do, { key: o.message }, u("p", { role: "alert" }, o.message, " ", o.details && u("span", {
                "aria-label": o.details, "data-microtip-position": "top-left", "data-microtip-size": "medium", role: "tooltip", onClick: () => alert(`${o.message}

 ${o.details}`)
            }, "?")))))), this.type = "progressindicator", this.id = this.opts.id || "Informer", this.title = "Informer"; let r = {}; this.opts = { ...r, ...t }
        } install() { let { target: e } = this.opts; e && this.mount(e, this) }
    }; n(Ri, "Informer"); Ri.VERSION = C2.version; var R2 = /^data:([^/]+\/[^,;]+(?:[^,]*?))(;base64)?,([\s\S]*)$/; function _c(i, e, t) { var r, s; let o = R2.exec(i), a = (r = (s = e.mimeType) != null ? s : o?.[1]) != null ? r : "plain/text", l; if (o[2] != null) { let h = atob(decodeURIComponent(o[3])), c = new Uint8Array(h.length); for (let d = 0; d < h.length; d++)c[d] = h.charCodeAt(d); l = [c] } else l = [decodeURIComponent(o[3])]; return t ? new File(l, e.name || "", { type: a }) : new Blob(l, { type: a }) } n(_c, "dataURItoBlob"); function gu(i) { return i.startsWith("blob:") } n(gu, "isObjectURL"); function le(i, e, t) { return e in i ? Object.defineProperty(i, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = t, i } n(le, "e"); var iy = typeof self < "u" ? self : global, oa = typeof navigator < "u", k2 = oa && typeof HTMLImageElement > "u", Gg = !(typeof global > "u" || typeof process > "u" || !process.versions || !process.versions.node), ry = iy.Buffer, sy = !!ry, U2 = n(i => i !== void 0, "h"); function oy(i) { return i === void 0 || (i instanceof Map ? i.size === 0 : Object.values(i).filter(U2).length === 0) } n(oy, "f"); function Ve(i) { let e = new Error(i); throw delete e.stack, e } n(Ve, "l"); function Xg(i) { let e = function (t) { let r = 0; return t.ifd0.enabled && (r += 1024), t.exif.enabled && (r += 2048), t.makerNote && (r += 2048), t.userComment && (r += 1024), t.gps.enabled && (r += 512), t.interop.enabled && (r += 100), t.ifd1.enabled && (r += 1024), r + 2048 }(i); return i.jfif.enabled && (e += 50), i.xmp.enabled && (e += 2e4), i.iptc.enabled && (e += 14e3), i.icc.enabled && (e += 6e3), e } n(Xg, "o"); var xc = n(i => String.fromCharCode.apply(null, i), "u"), Yg = typeof TextDecoder < "u" ? new TextDecoder("utf-8") : void 0, Ot = class { static from(e, t) { return e instanceof this && e.le === t ? e : new Ot(e, void 0, void 0, t) } constructor(e, t = 0, r, s) { if (typeof s == "boolean" && (this.le = s), Array.isArray(e) && (e = new Uint8Array(e)), e === 0) this.byteOffset = 0, this.byteLength = 0; else if (e instanceof ArrayBuffer) { r === void 0 && (r = e.byteLength - t); let o = new DataView(e, t, r); this._swapDataView(o) } else if (e instanceof Uint8Array || e instanceof DataView || e instanceof Ot) { r === void 0 && (r = e.byteLength - t), (t += e.byteOffset) + r > e.byteOffset + e.byteLength && Ve("Creating view outside of available memory in ArrayBuffer"); let o = new DataView(e.buffer, t, r); this._swapDataView(o) } else if (typeof e == "number") { let o = new DataView(new ArrayBuffer(e)); this._swapDataView(o) } else Ve("Invalid input argument for BufferView: " + e) } _swapArrayBuffer(e) { this._swapDataView(new DataView(e)) } _swapBuffer(e) { this._swapDataView(new DataView(e.buffer, e.byteOffset, e.byteLength)) } _swapDataView(e) { this.dataView = e, this.buffer = e.buffer, this.byteOffset = e.byteOffset, this.byteLength = e.byteLength } _lengthToEnd(e) { return this.byteLength - e } set(e, t, r = Ot) { return e instanceof DataView || e instanceof Ot ? e = new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e instanceof ArrayBuffer && (e = new Uint8Array(e)), e instanceof Uint8Array || Ve("BufferView.set(): Invalid data argument."), this.toUint8().set(e, t), new r(this, t, e.byteLength) } subarray(e, t) { return t = t || this._lengthToEnd(e), new Ot(this, e, t) } toUint8() { return new Uint8Array(this.buffer, this.byteOffset, this.byteLength) } getUint8Array(e, t) { return new Uint8Array(this.buffer, this.byteOffset + e, t) } getString(e = 0, t = this.byteLength) { return s = this.getUint8Array(e, t), Yg ? Yg.decode(s) : sy ? Buffer.from(s).toString("utf8") : decodeURIComponent(escape(xc(s))); var s } getLatin1String(e = 0, t = this.byteLength) { let r = this.getUint8Array(e, t); return xc(r) } getUnicodeString(e = 0, t = this.byteLength) { let r = []; for (let s = 0; s < t && e + s < this.byteLength; s += 2)r.push(this.getUint16(e + s)); return xc(r) } getInt8(e) { return this.dataView.getInt8(e) } getUint8(e) { return this.dataView.getUint8(e) } getInt16(e, t = this.le) { return this.dataView.getInt16(e, t) } getInt32(e, t = this.le) { return this.dataView.getInt32(e, t) } getUint16(e, t = this.le) { return this.dataView.getUint16(e, t) } getUint32(e, t = this.le) { return this.dataView.getUint32(e, t) } getFloat32(e, t = this.le) { return this.dataView.getFloat32(e, t) } getFloat64(e, t = this.le) { return this.dataView.getFloat64(e, t) } getFloat(e, t = this.le) { return this.dataView.getFloat32(e, t) } getDouble(e, t = this.le) { return this.dataView.getFloat64(e, t) } getUintBytes(e, t, r) { switch (t) { case 1: return this.getUint8(e, r); case 2: return this.getUint16(e, r); case 4: return this.getUint32(e, r); case 8: return this.getUint64 && this.getUint64(e, r) } } getUint(e, t, r) { switch (t) { case 8: return this.getUint8(e, r); case 16: return this.getUint16(e, r); case 32: return this.getUint32(e, r); case 64: return this.getUint64 && this.getUint64(e, r) } } toString(e) { return this.dataView.toString(e, this.constructor.name) } ensureChunk() { } }; n(Ot, "c"); function Fc(i, e) { Ve(`${i} '${e}' was not loaded, try using full build of exifr.`) } n(Fc, "p"); var Mo = class extends Map { constructor(e) { super(), this.kind = e } get(e, t) { return this.has(e) || Fc(this.kind, e), t && (e in t || function (r, s) { Ve(`Unknown ${r} '${s}'.`) }(this.kind, e), t[e].enabled || Fc(this.kind, e)), super.get(e) } keyList() { return Array.from(this.keys()) } }; n(Mo, "g"); var xu = new Mo("file parser"), Mt = new Mo("segment parser"), la = new Mo("file reader"), D2 = iy.fetch; function Qg(i, e) { return (t = i).startsWith("data:") || t.length > 1e4 ? Ac(i, e, "base64") : Gg && i.includes("://") ? Oc(i, e, "url", Pu) : Gg ? Ac(i, e, "fs") : oa ? Oc(i, e, "url", Pu) : void Ve("Invalid input argument"); var t } n(Qg, "k"); async function Oc(i, e, t, r) { return la.has(t) ? Ac(i, e, t) : r ? async function (s, o) { let a = await o(s); return new Ot(a) }(i, r) : void Ve(`Parser ${t} is not loaded`) } n(Oc, "O"); async function Ac(i, e, t) { let r = new (la.get(t))(i, e); return await r.read(), r } n(Ac, "v"); var Pu = n(i => D2(i).then(e => e.arrayBuffer()), "S"), na = n(i => new Promise((e, t) => { let r = new FileReader; r.onloadend = () => e(r.result || new ArrayBuffer), r.onerror = t, r.readAsArrayBuffer(i) }), "A"), yu = class extends Map { get tagKeys() { return this.allKeys || (this.allKeys = Array.from(this.keys())), this.allKeys } get tagValues() { return this.allValues || (this.allValues = Array.from(this.values())), this.allValues } }; n(yu, "U"); function ny(i, e, t) { let r = new yu; for (let [s, o] of t) r.set(s, o); if (Array.isArray(e)) for (let s of e) i.set(s, r); else i.set(e, r); return r } n(ny, "x"); function ay(i, e, t) { let r, s = i.get(e); for (r of t) s.set(r[0], r[1]) } n(ay, "C"); var ua = new Map, Tc = new Map, Cc = new Map, No = ["chunked", "firstChunkSize", "firstChunkSizeNode", "firstChunkSizeBrowser", "chunkSize", "chunkLimit"], Eu = ["jfif", "xmp", "icc", "iptc", "ihdr"], aa = ["tiff", ...Eu], Ue = ["ifd0", "ifd1", "exif", "gps", "interop"], Io = [...aa, ...Ue], Bo = ["makerNote", "userComment"], Fu = ["translateKeys", "translateValues", "reviveValues", "multiSegment"], Lo = [...Fu, "sanitize", "mergeOutput", "silentErrors"], ra = class { get translate() { return this.translateKeys || this.translateValues || this.reviveValues } }; n(ra, "_"); var Mr = class extends ra { get needed() { return this.enabled || this.deps.size > 0 } constructor(e, t, r, s) { if (super(), le(this, "enabled", !1), le(this, "skip", new Set), le(this, "pick", new Set), le(this, "deps", new Set), le(this, "translateKeys", !1), le(this, "translateValues", !1), le(this, "reviveValues", !1), this.key = e, this.enabled = t, this.parse = this.enabled, this.applyInheritables(s), this.canBeFiltered = Ue.includes(e), this.canBeFiltered && (this.dict = ua.get(e)), r !== void 0) if (Array.isArray(r)) this.parse = this.enabled = !0, this.canBeFiltered && r.length > 0 && this.translateTagSet(r, this.pick); else if (typeof r == "object") { if (this.enabled = !0, this.parse = r.parse !== !1, this.canBeFiltered) { let { pick: o, skip: a } = r; o && o.length > 0 && this.translateTagSet(o, this.pick), a && a.length > 0 && this.translateTagSet(a, this.skip) } this.applyInheritables(r) } else r === !0 || r === !1 ? this.parse = this.enabled = r : Ve(`Invalid options argument: ${r}`) } applyInheritables(e) { let t, r; for (t of Fu) r = e[t], r !== void 0 && (this[t] = r) } translateTagSet(e, t) { if (this.dict) { let r, s, { tagKeys: o, tagValues: a } = this.dict; for (r of e) typeof r == "string" ? (s = a.indexOf(r), s === -1 && (s = o.indexOf(Number(r))), s !== -1 && t.add(Number(o[s]))) : t.add(r) } else for (let r of e) t.add(r) } finalizeFilters() { !this.enabled && this.deps.size > 0 ? (this.enabled = !0, _u(this.pick, this.deps)) : this.enabled && this.pick.size > 0 && _u(this.pick, this.deps) } }; n(Mr, "D"); var mt = { jfif: !1, tiff: !0, xmp: !1, icc: !1, iptc: !1, ifd0: !0, ifd1: !1, exif: !0, gps: !0, interop: !1, ihdr: void 0, makerNote: !1, userComment: !1, multiSegment: !1, skip: [], pick: [], translateKeys: !0, translateValues: !0, reviveValues: !0, sanitize: !0, mergeOutput: !0, silentErrors: !0, chunked: !0, firstChunkSize: void 0, firstChunkSizeNode: 512, firstChunkSizeBrowser: 65536, chunkSize: 65536, chunkLimit: 5 }, Jg = new Map, zr = class extends ra { static useCached(e) { let t = Jg.get(e); return t !== void 0 || (t = new this(e), Jg.set(e, t)), t } constructor(e) { super(), e === !0 ? this.setupFromTrue() : e === void 0 ? this.setupFromUndefined() : Array.isArray(e) ? this.setupFromArray(e) : typeof e == "object" ? this.setupFromObject(e) : Ve(`Invalid options argument ${e}`), this.firstChunkSize === void 0 && (this.firstChunkSize = oa ? this.firstChunkSizeBrowser : this.firstChunkSizeNode), this.mergeOutput && (this.ifd1.enabled = !1), this.filterNestedSegmentTags(), this.traverseTiffDependencyTree(), this.checkLoadedPlugins() } setupFromUndefined() { let e; for (e of No) this[e] = mt[e]; for (e of Lo) this[e] = mt[e]; for (e of Bo) this[e] = mt[e]; for (e of Io) this[e] = new Mr(e, mt[e], void 0, this) } setupFromTrue() { let e; for (e of No) this[e] = mt[e]; for (e of Lo) this[e] = mt[e]; for (e of Bo) this[e] = !0; for (e of Io) this[e] = new Mr(e, !0, void 0, this) } setupFromArray(e) { let t; for (t of No) this[t] = mt[t]; for (t of Lo) this[t] = mt[t]; for (t of Bo) this[t] = mt[t]; for (t of Io) this[t] = new Mr(t, !1, void 0, this); this.setupGlobalFilters(e, void 0, Ue) } setupFromObject(e) { let t; for (t of (Ue.ifd0 = Ue.ifd0 || Ue.image, Ue.ifd1 = Ue.ifd1 || Ue.thumbnail, Object.assign(this, e), No)) this[t] = Ec(e[t], mt[t]); for (t of Lo) this[t] = Ec(e[t], mt[t]); for (t of Bo) this[t] = Ec(e[t], mt[t]); for (t of aa) this[t] = new Mr(t, mt[t], e[t], this); for (t of Ue) this[t] = new Mr(t, mt[t], e[t], this.tiff); this.setupGlobalFilters(e.pick, e.skip, Ue, Io), e.tiff === !0 ? this.batchEnableWithBool(Ue, !0) : e.tiff === !1 ? this.batchEnableWithUserValue(Ue, e) : Array.isArray(e.tiff) ? this.setupGlobalFilters(e.tiff, void 0, Ue) : typeof e.tiff == "object" && this.setupGlobalFilters(e.tiff.pick, e.tiff.skip, Ue) } batchEnableWithBool(e, t) { for (let r of e) this[r].enabled = t } batchEnableWithUserValue(e, t) { for (let r of e) { let s = t[r]; this[r].enabled = s !== !1 && s !== void 0 } } setupGlobalFilters(e, t, r, s = r) { if (e && e.length) { for (let a of s) this[a].enabled = !1; let o = Zg(e, r); for (let [a, l] of o) _u(this[a].pick, l), this[a].enabled = !0 } else if (t && t.length) { let o = Zg(t, r); for (let [a, l] of o) _u(this[a].skip, l) } } filterNestedSegmentTags() { let { ifd0: e, exif: t, xmp: r, iptc: s, icc: o } = this; this.makerNote ? t.deps.add(37500) : t.skip.add(37500), this.userComment ? t.deps.add(37510) : t.skip.add(37510), r.enabled || e.skip.add(700), s.enabled || e.skip.add(33723), o.enabled || e.skip.add(34675) } traverseTiffDependencyTree() { let { ifd0: e, exif: t, gps: r, interop: s } = this; s.needed && (t.deps.add(40965), e.deps.add(40965)), t.needed && e.deps.add(34665), r.needed && e.deps.add(34853), this.tiff.enabled = Ue.some(o => this[o].enabled === !0) || this.makerNote || this.userComment; for (let o of Ue) this[o].finalizeFilters() } get onlyTiff() { return !Eu.map(e => this[e].enabled).some(e => e === !0) && this.tiff.enabled } checkLoadedPlugins() { for (let e of aa) this[e].enabled && !Mt.has(e) && Fc("segment parser", e) } }; n(zr, "R"); function Zg(i, e) { let t, r, s, o, a = []; for (s of e) { for (o of (t = ua.get(s), r = [], t)) (i.includes(o[0]) || i.includes(o[1])) && r.push(o[0]); r.length && a.push([s, r]) } return a } n(Zg, "K"); function Ec(i, e) { return i !== void 0 ? i : e !== void 0 ? e : void 0 } n(Ec, "W"); function _u(i, e) { for (let t of e) i.add(t) } n(_u, "X"); le(zr, "default", mt); var Ss = class { constructor(e) { le(this, "parsers", {}), le(this, "output", {}), le(this, "errors", []), le(this, "pushToErrors", t => this.errors.push(t)), this.options = zr.useCached(e) } async read(e) { this.file = await function (t, r) { return typeof t == "string" ? Qg(t, r) : oa && !k2 && t instanceof HTMLImageElement ? Qg(t.src, r) : t instanceof Uint8Array || t instanceof ArrayBuffer || t instanceof DataView ? new Ot(t) : oa && t instanceof Blob ? Oc(t, r, "blob", na) : void Ve("Invalid input argument") }(e, this.options) } setup() { if (this.fileParser) return; let { file: e } = this, t = e.getUint16(0); for (let [r, s] of xu) if (s.canHandle(e, t)) return this.fileParser = new s(this.options, this.file, this.parsers), e[r] = !0; this.file.close && this.file.close(), Ve("Unknown file format") } async parse() { let { output: e, errors: t } = this; return this.setup(), this.options.silentErrors ? (await this.executeParsers().catch(this.pushToErrors), t.push(...this.fileParser.errors)) : await this.executeParsers(), this.file.close && this.file.close(), this.options.silentErrors && t.length > 0 && (e.errors = t), oy(r = e) ? void 0 : r; var r } async executeParsers() { let { output: e } = this; await this.fileParser.parse(); let t = Object.values(this.parsers).map(async r => { let s = await r.parse(); r.assignToOutput(e, s) }); this.options.silentErrors && (t = t.map(r => r.catch(this.pushToErrors))), await Promise.all(t) } async extractThumbnail() { this.setup(); let { options: e, file: t } = this, r = Mt.get("tiff", e); var s; if (t.tiff ? s = { start: 0, type: "tiff" } : t.jpeg && (s = await this.fileParser.getOrFindSegment("tiff")), s === void 0) return; let o = await this.fileParser.ensureSegmentChunk(s), a = this.parsers.tiff = new r(o, e, t), l = await a.extractThumbnail(); return t.close && t.close(), l } }; n(Ss, "H"); async function ly(i, e) { let t = new Ss(e); return await t.read(i), t.parse() } n(ly, "Y"); var N2 = Object.freeze({ __proto__: null, parse: ly, Exifr: Ss, fileParsers: xu, segmentParsers: Mt, fileReaders: la, tagKeys: ua, tagValues: Tc, tagRevivers: Cc, createDictionary: ny, extendDictionary: ay, fetchUrlAsArrayBuffer: Pu, readBlobAsArrayBuffer: na, chunkedProps: No, otherSegments: Eu, segments: aa, tiffBlocks: Ue, segmentsAndBlocks: Io, tiffExtractables: Bo, inheritables: Fu, allFormatters: Lo, Options: zr }), pr = class { static findPosition(e, t) { let r = e.getUint16(t + 2) + 2, s = typeof this.headerLength == "function" ? this.headerLength(e, t, r) : this.headerLength, o = t + s, a = r - s; return { offset: t, length: r, headerLength: s, start: o, size: a, end: o + a } } static parse(e, t = {}) { return new this(e, new zr({ [this.type]: t }), e).parse() } normalizeInput(e) { return e instanceof Ot ? e : new Ot(e) } constructor(e, t = {}, r) { le(this, "errors", []), le(this, "raw", new Map), le(this, "handleError", s => { if (!this.options.silentErrors) throw s; this.errors.push(s.message) }), this.chunk = this.normalizeInput(e), this.file = r, this.type = this.constructor.type, this.globalOptions = this.options = t, this.localOptions = t[this.type], this.canTranslate = this.localOptions && this.localOptions.translate } translate() { this.canTranslate && (this.translated = this.translateBlock(this.raw, this.type)) } get output() { return this.translated ? this.translated : this.raw ? Object.fromEntries(this.raw) : void 0 } translateBlock(e, t) { let r = Cc.get(t), s = Tc.get(t), o = ua.get(t), a = this.options[t], l = a.reviveValues && !!r, h = a.translateValues && !!s, c = a.translateKeys && !!o, d = {}; for (let [p, y] of e) l && r.has(p) ? y = r.get(p)(y) : h && s.has(p) && (y = this.translateValue(y, s.get(p))), c && o.has(p) && (p = o.get(p) || p), d[p] = y; return d } translateValue(e, t) { return t[e] || t.DEFAULT || e } assignToOutput(e, t) { this.assignObjectToOutput(e, this.constructor.type, t) } assignObjectToOutput(e, t, r) { if (this.globalOptions.mergeOutput) return Object.assign(e, r); e[t] ? Object.assign(e[t], r) : e[t] = r } }; n(pr, "J"); le(pr, "headerLength", 4), le(pr, "type", void 0), le(pr, "multiSegment", !1), le(pr, "canHandle", () => !1); function I2(i) { return i === 192 || i === 194 || i === 196 || i === 219 || i === 221 || i === 218 || i === 254 } n(I2, "q"); function B2(i) { return i >= 224 && i <= 239 } n(B2, "Q"); function L2(i, e, t) { for (let [r, s] of Mt) if (s.canHandle(i, e, t)) return r } n(L2, "Z"); var sa = class extends class { constructor(e, t, r) { le(this, "errors", []), le(this, "ensureSegmentChunk", async s => { let o = s.start, a = s.size || 65536; if (this.file.chunked) if (this.file.available(o, a)) s.chunk = this.file.subarray(o, a); else try { s.chunk = await this.file.readChunk(o, a) } catch (l) { Ve(`Couldn't read segment: ${JSON.stringify(s)}. ${l.message}`) } else this.file.byteLength > o + a ? s.chunk = this.file.subarray(o, a) : s.size === void 0 ? s.chunk = this.file.subarray(o) : Ve("Segment unreachable: " + JSON.stringify(s)); return s.chunk }), this.extendOptions && this.extendOptions(e), this.options = e, this.file = t, this.parsers = r } injectSegment(e, t) { this.options[e].enabled && this.createParser(e, t) } createParser(e, t) { let r = new (Mt.get(e))(t, this.options, this.file); return this.parsers[e] = r } createParsers(e) { for (let t of e) { let { type: r, chunk: s } = t, o = this.options[r]; if (o && o.enabled) { let a = this.parsers[r]; a && a.append || a || this.createParser(r, s) } } } async readSegments(e) { let t = e.map(this.ensureSegmentChunk); await Promise.all(t) } }{ constructor(...e) { super(...e), le(this, "appSegments", []), le(this, "jpegSegments", []), le(this, "unknownSegments", []) } static canHandle(e, t) { return t === 65496 } async parse() { await this.findAppSegments(), await this.readSegments(this.appSegments), this.mergeMultiSegments(), this.createParsers(this.mergedAppSegments || this.appSegments) } setupSegmentFinderArgs(e) { e === !0 ? (this.findAll = !0, this.wanted = new Set(Mt.keyList())) : (e = e === void 0 ? Mt.keyList().filter(t => this.options[t].enabled) : e.filter(t => this.options[t].enabled && Mt.has(t)), this.findAll = !1, this.remaining = new Set(e), this.wanted = new Set(e)), this.unfinishedMultiSegment = !1 } async findAppSegments(e = 0, t) { this.setupSegmentFinderArgs(t); let { file: r, findAll: s, wanted: o, remaining: a } = this; if (!s && this.file.chunked && (s = Array.from(o).some(l => { let h = Mt.get(l), c = this.options[l]; return h.multiSegment && c.multiSegment }), s && await this.file.readWhole()), e = this.findAppSegmentsInRange(e, r.byteLength), !this.options.onlyTiff && r.chunked) { let l = !1; for (; a.size > 0 && !l && (r.canReadNextChunk || this.unfinishedMultiSegment);) { let { nextChunkOffset: h } = r, c = this.appSegments.some(d => !this.file.available(d.offset || d.start, d.length || d.size)); if (l = e > h && !c ? !await r.readNextChunk(e) : !await r.readNextChunk(h), (e = this.findAppSegmentsInRange(e, r.byteLength)) === void 0) return } } } findAppSegmentsInRange(e, t) { t -= 2; let r, s, o, a, l, h, { file: c, findAll: d, wanted: p, remaining: y, options: v } = this; for (; e < t; e++)if (c.getUint8(e) === 255) { if (r = c.getUint8(e + 1), B2(r)) { if (s = c.getUint16(e + 2), o = L2(c, e, s), o && p.has(o) && (a = Mt.get(o), l = a.findPosition(c, e), h = v[o], l.type = o, this.appSegments.push(l), !d && (a.multiSegment && h.multiSegment ? (this.unfinishedMultiSegment = l.chunkNumber < l.chunkCount, this.unfinishedMultiSegment || y.delete(o)) : y.delete(o), y.size === 0))) break; v.recordUnknownSegments && (l = pr.findPosition(c, e), l.marker = r, this.unknownSegments.push(l)), e += s + 1 } else if (I2(r)) { if (s = c.getUint16(e + 2), r === 218 && v.stopAfterSos !== !1) return; v.recordJpegSegments && this.jpegSegments.push({ offset: e, length: s, marker: r }), e += s + 1 } } return e } mergeMultiSegments() { if (!this.appSegments.some(t => t.multiSegment)) return; let e = function (t, r) { let s, o, a, l = new Map; for (let h = 0; h < t.length; h++)s = t[h], o = s[r], l.has(o) ? a = l.get(o) : l.set(o, a = []), a.push(s); return Array.from(l) }(this.appSegments, "type"); this.mergedAppSegments = e.map(([t, r]) => { let s = Mt.get(t, this.options); return s.handleMultiSegments ? { type: t, chunk: s.handleMultiSegments(r) } : r[0] }) } getSegment(e) { return this.appSegments.find(t => t.type === e) } async getOrFindSegment(e) { let t = this.getSegment(e); return t === void 0 && (await this.findAppSegments(0, [e]), t = this.getSegment(e)), t } }; n(sa, "ee"); le(sa, "type", "jpeg"), xu.set("jpeg", sa); var M2 = [void 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, 4], vu = class extends pr { parseHeader() { var e = this.chunk.getUint16(); e === 18761 ? this.le = !0 : e === 19789 && (this.le = !1), this.chunk.le = this.le, this.headerParsed = !0 } parseTags(e, t, r = new Map) { let { pick: s, skip: o } = this.options[t]; s = new Set(s); let a = s.size > 0, l = o.size === 0, h = this.chunk.getUint16(e); e += 2; for (let c = 0; c < h; c++) { let d = this.chunk.getUint16(e); if (a) { if (s.has(d) && (r.set(d, this.parseTag(e, d, t)), s.delete(d), s.size === 0)) break } else !l && o.has(d) || r.set(d, this.parseTag(e, d, t)); e += 12 } return r } parseTag(e, t, r) { let { chunk: s } = this, o = s.getUint16(e + 2), a = s.getUint32(e + 4), l = M2[o]; if (l * a <= 4 ? e += 8 : e = s.getUint32(e + 8), (o < 1 || o > 13) && Ve(`Invalid TIFF value type. block: ${r.toUpperCase()}, tag: ${t.toString(16)}, type: ${o}, offset ${e}`), e > s.byteLength && Ve(`Invalid TIFF value offset. block: ${r.toUpperCase()}, tag: ${t.toString(16)}, type: ${o}, offset ${e} is outside of chunk size ${s.byteLength}`), o === 1) return s.getUint8Array(e, a); if (o === 2) return (h = function (c) { for (; c.endsWith("\0");)c = c.slice(0, -1); return c }(h = s.getString(e, a)).trim()) === "" ? void 0 : h; var h; if (o === 7) return s.getUint8Array(e, a); if (a === 1) return this.parseTagValue(o, e); { let c = new (function (p) { switch (p) { case 1: return Uint8Array; case 3: return Uint16Array; case 4: return Uint32Array; case 5: return Array; case 6: return Int8Array; case 8: return Int16Array; case 9: return Int32Array; case 10: return Array; case 11: return Float32Array; case 12: return Float64Array; default: return Array } }(o))(a), d = l; for (let p = 0; p < a; p++)c[p] = this.parseTagValue(o, e), e += d; return c } } parseTagValue(e, t) { let { chunk: r } = this; switch (e) { case 1: return r.getUint8(t); case 3: return r.getUint16(t); case 4: return r.getUint32(t); case 5: return r.getUint32(t) / r.getUint32(t + 4); case 6: return r.getInt8(t); case 8: return r.getInt16(t); case 9: return r.getInt32(t); case 10: return r.getInt32(t) / r.getInt32(t + 4); case 11: return r.getFloat(t); case 12: return r.getDouble(t); case 13: return r.getUint32(t); default: Ve(`Invalid tiff type ${e}`) } } }; n(vu, "se"); var zo = class extends vu {
        static canHandle(e, t) { return e.getUint8(t + 1) === 225 && e.getUint32(t + 4) === 1165519206 && e.getUint16(t + 8) === 0 } async parse() { this.parseHeader(); let { options: e } = this; return e.ifd0.enabled && await this.parseIfd0Block(), e.exif.enabled && await this.safeParse("parseExifBlock"), e.gps.enabled && await this.safeParse("parseGpsBlock"), e.interop.enabled && await this.safeParse("parseInteropBlock"), e.ifd1.enabled && await this.safeParse("parseThumbnailBlock"), this.createOutput() } safeParse(e) { let t = this[e](); return t.catch !== void 0 && (t = t.catch(this.handleError)), t } findIfd0Offset() { this.ifd0Offset === void 0 && (this.ifd0Offset = this.chunk.getUint32(4)) } findIfd1Offset() { if (this.ifd1Offset === void 0) { this.findIfd0Offset(); let e = this.chunk.getUint16(this.ifd0Offset), t = this.ifd0Offset + 2 + 12 * e; this.ifd1Offset = this.chunk.getUint32(t) } } parseBlock(e, t) { let r = new Map; return this[t] = r, this.parseTags(e, t, r), r } async parseIfd0Block() {
            if (this.ifd0) return; let { file: e } = this; this.findIfd0Offset(), this.ifd0Offset < 8 && Ve("Malformed EXIF data"), !e.chunked && this.ifd0Offset > e.byteLength && Ve(`IFD0 offset points to outside of file.
this.ifd0Offset: ${this.ifd0Offset}, file.byteLength: ${e.byteLength}`), e.tiff && await e.ensureChunk(this.ifd0Offset, Xg(this.options)); let t = this.parseBlock(this.ifd0Offset, "ifd0"); return t.size !== 0 ? (this.exifOffset = t.get(34665), this.interopOffset = t.get(40965), this.gpsOffset = t.get(34853), this.xmp = t.get(700), this.iptc = t.get(33723), this.icc = t.get(34675), this.options.sanitize && (t.delete(34665), t.delete(40965), t.delete(34853), t.delete(700), t.delete(33723), t.delete(34675)), t) : void 0
        } async parseExifBlock() { if (this.exif || (this.ifd0 || await this.parseIfd0Block(), this.exifOffset === void 0)) return; this.file.tiff && await this.file.ensureChunk(this.exifOffset, Xg(this.options)); let e = this.parseBlock(this.exifOffset, "exif"); return this.interopOffset || (this.interopOffset = e.get(40965)), this.makerNote = e.get(37500), this.userComment = e.get(37510), this.options.sanitize && (e.delete(40965), e.delete(37500), e.delete(37510)), this.unpack(e, 41728), this.unpack(e, 41729), e } unpack(e, t) { let r = e.get(t); r && r.length === 1 && e.set(t, r[0]) } async parseGpsBlock() { if (this.gps || (this.ifd0 || await this.parseIfd0Block(), this.gpsOffset === void 0)) return; let e = this.parseBlock(this.gpsOffset, "gps"); return e && e.has(2) && e.has(4) && (e.set("latitude", ey(...e.get(2), e.get(1))), e.set("longitude", ey(...e.get(4), e.get(3)))), e } async parseInteropBlock() { if (!this.interop && (this.ifd0 || await this.parseIfd0Block(), this.interopOffset !== void 0 || this.exif || await this.parseExifBlock(), this.interopOffset !== void 0)) return this.parseBlock(this.interopOffset, "interop") } async parseThumbnailBlock(e = !1) { if (!this.ifd1 && !this.ifd1Parsed && (!this.options.mergeOutput || e)) return this.findIfd1Offset(), this.ifd1Offset > 0 && (this.parseBlock(this.ifd1Offset, "ifd1"), this.ifd1Parsed = !0), this.ifd1 } async extractThumbnail() { if (this.headerParsed || this.parseHeader(), this.ifd1Parsed || await this.parseThumbnailBlock(!0), this.ifd1 === void 0) return; let e = this.ifd1.get(513), t = this.ifd1.get(514); return this.chunk.getUint8Array(e, t) } get image() { return this.ifd0 } get thumbnail() { return this.ifd1 } createOutput() { let e, t, r, s = {}; for (t of Ue) if (e = this[t], !oy(e)) if (r = this.canTranslate ? this.translateBlock(e, t) : Object.fromEntries(e), this.options.mergeOutput) { if (t === "ifd1") continue; Object.assign(s, r) } else s[t] = r; return this.makerNote && (s.makerNote = this.makerNote), this.userComment && (s.userComment = this.userComment), s } assignToOutput(e, t) { if (this.globalOptions.mergeOutput) Object.assign(e, t); else for (let [r, s] of Object.entries(t)) this.assignObjectToOutput(e, r, s) }
    }; n(zo, "ie"); function ey(i, e, t, r) { var s = i + e / 60 + t / 3600; return r !== "S" && r !== "W" || (s *= -1), s } n(ey, "ne"); le(zo, "type", "tiff"), le(zo, "headerLength", 10), Mt.set("tiff", zo); var KC = Object.freeze({ __proto__: null, default: N2, Exifr: Ss, fileParsers: xu, segmentParsers: Mt, fileReaders: la, tagKeys: ua, tagValues: Tc, tagRevivers: Cc, createDictionary: ny, extendDictionary: ay, fetchUrlAsArrayBuffer: Pu, readBlobAsArrayBuffer: na, chunkedProps: No, otherSegments: Eu, segments: aa, tiffBlocks: Ue, segmentsAndBlocks: Io, tiffExtractables: Bo, inheritables: Fu, allFormatters: Lo, Options: zr, parse: ly }), Rc = { ifd0: !1, ifd1: !1, exif: !1, gps: !1, interop: !1, sanitize: !1, reviveValues: !0, translateKeys: !1, translateValues: !1, mergeOutput: !1 }, GC = Object.assign({}, Rc, { firstChunkSize: 4e4, gps: [1, 2, 3, 4] }); var XC = Object.assign({}, Rc, { tiff: !1, ifd1: !0, mergeOutput: !1 }); var z2 = Object.assign({}, Rc, { firstChunkSize: 4e4, ifd0: [274] }); async function j2(i) { let e = new Ss(z2); await e.read(i); let t = await e.parse(); if (t && t.ifd0) return t.ifd0[274] } n(j2, "ce"); var H2 = Object.freeze({ 1: { dimensionSwapped: !1, scaleX: 1, scaleY: 1, deg: 0, rad: 0 }, 2: { dimensionSwapped: !1, scaleX: -1, scaleY: 1, deg: 0, rad: 0 }, 3: { dimensionSwapped: !1, scaleX: 1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 4: { dimensionSwapped: !1, scaleX: -1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 5: { dimensionSwapped: !0, scaleX: 1, scaleY: -1, deg: 90, rad: 90 * Math.PI / 180 }, 6: { dimensionSwapped: !0, scaleX: 1, scaleY: 1, deg: 90, rad: 90 * Math.PI / 180 }, 7: { dimensionSwapped: !0, scaleX: 1, scaleY: -1, deg: 270, rad: 270 * Math.PI / 180 }, 8: { dimensionSwapped: !0, scaleX: 1, scaleY: 1, deg: 270, rad: 270 * Math.PI / 180 } }), ta = !0, ia = !0; if (typeof navigator == "object") { let i = navigator.userAgent; if (i.includes("iPad") || i.includes("iPhone")) { let e = i.match(/OS (\d+)_(\d+)/); if (e) { let [, t, r] = e; ta = Number(t) + .1 * Number(r) < 13.4, ia = !1 } } else if (i.includes("OS X 10")) { let [, e] = i.match(/OS X 10[_.](\d+)/); ta = ia = Number(e) < 15 } if (i.includes("Chrome/")) { let [, e] = i.match(/Chrome\/(\d+)/); ta = ia = Number(e) < 81 } else if (i.includes("Firefox/")) { let [, e] = i.match(/Firefox\/(\d+)/); ta = ia = Number(e) < 77 } } async function uy(i) { let e = await j2(i); return Object.assign({ canvas: ta, css: ia }, H2[e]) } n(uy, "ye"); var bu = class extends Ot { constructor(...e) { super(...e), le(this, "ranges", new wu), this.byteLength !== 0 && this.ranges.add(0, this.byteLength) } _tryExtend(e, t, r) { if (e === 0 && this.byteLength === 0 && r) { let s = new DataView(r.buffer || r, r.byteOffset, r.byteLength); this._swapDataView(s) } else { let s = e + t; if (s > this.byteLength) { let { dataView: o } = this._extend(s); this._swapDataView(o) } } } _extend(e) { let t; t = sy ? ry.allocUnsafe(e) : new Uint8Array(e); let r = new DataView(t.buffer, t.byteOffset, t.byteLength); return t.set(new Uint8Array(this.buffer, this.byteOffset, this.byteLength), 0), { uintView: t, dataView: r } } subarray(e, t, r = !1) { return t = t || this._lengthToEnd(e), r && this._tryExtend(e, t), this.ranges.add(e, t), super.subarray(e, t) } set(e, t, r = !1) { r && this._tryExtend(t, e.byteLength, e); let s = super.set(e, t); return this.ranges.add(t, s.byteLength), s } async ensureChunk(e, t) { this.chunked && (this.ranges.available(e, t) || await this.readChunk(e, t)) } available(e, t) { return this.ranges.available(e, t) } }; n(bu, "be"); var wu = class { constructor() { le(this, "list", []) } get length() { return this.list.length } add(e, t, r = 0) { let s = e + t, o = this.list.filter(a => ty(e, a.offset, s) || ty(e, a.end, s)); if (o.length > 0) { e = Math.min(e, ...o.map(l => l.offset)), s = Math.max(s, ...o.map(l => l.end)), t = s - e; let a = o.shift(); a.offset = e, a.length = t, a.end = s, this.list = this.list.filter(l => !o.includes(l)) } else this.list.push({ offset: e, length: t, end: s }) } available(e, t) { let r = e + t; return this.list.some(s => s.offset <= e && r <= s.end) } }; n(wu, "we"); function ty(i, e, t) { return i <= e && e <= t } n(ty, "ke"); var Su = class extends bu { constructor(e, t) { super(0), le(this, "chunksRead", 0), this.input = e, this.options = t } async readWhole() { this.chunked = !1, await this.readChunk(this.nextChunkOffset) } async readChunked() { this.chunked = !0, await this.readChunk(0, this.options.firstChunkSize) } async readNextChunk(e = this.nextChunkOffset) { if (this.fullyRead) return this.chunksRead++, !1; let t = this.options.chunkSize, r = await this.readChunk(e, t); return !!r && r.byteLength === t } async readChunk(e, t) { if (this.chunksRead++, (t = this.safeWrapAddress(e, t)) !== 0) return this._readChunk(e, t) } safeWrapAddress(e, t) { return this.size !== void 0 && e + t > this.size ? Math.max(0, this.size - e) : t } get nextChunkOffset() { if (this.ranges.list.length !== 0) return this.ranges.list[0].length } get canReadNextChunk() { return this.chunksRead < this.options.chunkLimit } get fullyRead() { return this.size !== void 0 && this.nextChunkOffset === this.size } read() { return this.options.chunked ? this.readChunked() : this.readWhole() } close() { } }; n(Su, "Oe"); la.set("blob", class extends Su { async readWhole() { this.chunked = !1; let i = await na(this.input); this._swapArrayBuffer(i) } readChunked() { return this.chunked = !0, this.size = this.input.size, super.readChunked() } async _readChunk(i, e) { let t = e ? i + e : void 0, r = this.input.slice(i, t), s = await na(r); return this.set(s, i, !0) } }); var hy = { strings: { generatingThumbnails: "Generating thumbnails..." } }; var q2 = { version: "3.0.4" }; function $2(i, e, t) { try { i.getContext("2d").getImageData(0, 0, 1, 1) } catch (r) { if (r.code === 18) return Promise.reject(new Error("cannot read image, probably an svg with external resources")) } return i.toBlob ? new Promise(r => { i.toBlob(r, e, t) }).then(r => { if (r === null) throw new Error("cannot read image, probably an svg with external resources"); return r }) : Promise.resolve().then(() => _c(i.toDataURL(e, t), {})).then(r => { if (r === null) throw new Error("could not extract blob, probably an old browser"); return r }) } n($2, "canvasToBlob"); function V2(i, e) { let t = i.width, r = i.height; (e.deg === 90 || e.deg === 270) && (t = i.height, r = i.width); let s = document.createElement("canvas"); s.width = t, s.height = r; let o = s.getContext("2d"); return o.translate(t / 2, r / 2), e.canvas && (o.rotate(e.rad), o.scale(e.scaleX, e.scaleY)), o.drawImage(i, -i.width / 2, -i.height / 2, i.width, i.height), s } n(V2, "rotateImage"); function W2(i) { let e = i.width / i.height, t = 5e6, r = 4096, s = Math.floor(Math.sqrt(t * e)), o = Math.floor(t / Math.sqrt(t * e)); if (s > r && (s = r, o = Math.round(s / e)), o > r && (o = r, s = Math.round(e * o)), i.width > s) { let a = document.createElement("canvas"); return a.width = s, a.height = o, a.getContext("2d").drawImage(i, 0, 0, s, o), a } return i } n(W2, "protect"); var fr = class extends G { constructor(e, t) { super(e, t), this.onFileAdded = s => { !s.preview && s.data && Ro(s.type) && !s.isRemote && this.addToQueue(s.id) }, this.onCancelRequest = s => { let o = this.queue.indexOf(s.id); o !== -1 && this.queue.splice(o, 1) }, this.onFileRemoved = s => { let o = this.queue.indexOf(s.id); o !== -1 && this.queue.splice(o, 1), s.preview && gu(s.preview) && URL.revokeObjectURL(s.preview) }, this.onRestored = () => { this.uppy.getFiles().filter(o => o.isRestored).forEach(o => { (!o.preview || gu(o.preview)) && this.addToQueue(o.id) }) }, this.onAllFilesRemoved = () => { this.queue = [] }, this.waitUntilAllProcessed = s => { s.forEach(a => { let l = this.uppy.getFile(a); this.uppy.emit("preprocess-progress", l, { mode: "indeterminate", message: this.i18n("generatingThumbnails") }) }); let o = n(() => { s.forEach(a => { let l = this.uppy.getFile(a); this.uppy.emit("preprocess-complete", l) }) }, "emitPreprocessCompleteForAll"); return new Promise(a => { this.queueProcessing ? this.uppy.once("thumbnail:all-generated", () => { o(), a() }) : (o(), a()) }) }, this.type = "modifier", this.id = this.opts.id || "ThumbnailGenerator", this.title = "Thumbnail Generator", this.queue = [], this.queueProcessing = !1, this.defaultThumbnailDimension = 200, this.thumbnailType = this.opts.thumbnailType || "image/jpeg", this.defaultLocale = hy; let r = { thumbnailWidth: null, thumbnailHeight: null, waitForThumbnailsBeforeUpload: !1, lazy: !1 }; if (this.opts = { ...r, ...t }, this.i18nInit(), this.opts.lazy && this.opts.waitForThumbnailsBeforeUpload) throw new Error("ThumbnailGenerator: The `lazy` and `waitForThumbnailsBeforeUpload` options are mutually exclusive. Please ensure at most one of them is set to `true`.") } createThumbnail(e, t, r) { let s = URL.createObjectURL(e.data), o = new Promise((l, h) => { let c = new Image; c.src = s, c.addEventListener("load", () => { URL.revokeObjectURL(s), l(c) }), c.addEventListener("error", d => { URL.revokeObjectURL(s), h(d.error || new Error("Could not create thumbnail")) }) }), a = uy(e.data).catch(() => 1); return Promise.all([o, a]).then(l => { let [h, c] = l, d = this.getProportionalDimensions(h, t, r, c.deg), p = V2(h, c), y = this.resizeImage(p, d.width, d.height); return $2(y, this.thumbnailType, 80) }).then(l => URL.createObjectURL(l)) } getProportionalDimensions(e, t, r, s) { let o = e.width / e.height; return (s === 90 || s === 270) && (o = e.height / e.width), t != null ? { width: t, height: Math.round(t / o) } : r != null ? { width: Math.round(r * o), height: r } : { width: this.defaultThumbnailDimension, height: Math.round(this.defaultThumbnailDimension / o) } } resizeImage(e, t, r) { let s = W2(e), o = Math.ceil(Math.log2(s.width / t)); o < 1 && (o = 1); let a = t * 2 ** (o - 1), l = r * 2 ** (o - 1), h = 2; for (; o--;) { let c = document.createElement("canvas"); c.width = a, c.height = l, c.getContext("2d").drawImage(s, 0, 0, a, l), s = c, a = Math.round(a / h), l = Math.round(l / h) } return s } setPreviewURL(e, t) { this.uppy.setFileState(e, { preview: t }) } addToQueue(e) { this.queue.push(e), this.queueProcessing === !1 && this.processQueue() } processQueue() { if (this.queueProcessing = !0, this.queue.length > 0) { let e = this.uppy.getFile(this.queue.shift()); return e ? this.requestThumbnail(e).catch(() => { }).then(() => this.processQueue()) : (this.uppy.log("[ThumbnailGenerator] file was removed before a thumbnail could be generated, but not removed from the queue. This is probably a bug", "error"), Promise.resolve()) } return this.queueProcessing = !1, this.uppy.log("[ThumbnailGenerator] Emptied thumbnail queue"), this.uppy.emit("thumbnail:all-generated"), Promise.resolve() } requestThumbnail(e) { return Ro(e.type) && !e.isRemote ? this.createThumbnail(e, this.opts.thumbnailWidth, this.opts.thumbnailHeight).then(t => { this.setPreviewURL(e.id, t), this.uppy.log(`[ThumbnailGenerator] Generated thumbnail for ${e.id}`), this.uppy.emit("thumbnail:generated", this.uppy.getFile(e.id), t) }).catch(t => { this.uppy.log(`[ThumbnailGenerator] Failed thumbnail for ${e.id}:`, "warning"), this.uppy.log(t, "warning"), this.uppy.emit("thumbnail:error", this.uppy.getFile(e.id), t) }) : Promise.resolve() } install() { this.uppy.on("file-removed", this.onFileRemoved), this.uppy.on("cancel-all", this.onAllFilesRemoved), this.opts.lazy ? (this.uppy.on("thumbnail:request", this.onFileAdded), this.uppy.on("thumbnail:cancel", this.onCancelRequest)) : (this.uppy.on("file-added", this.onFileAdded), this.uppy.on("restored", this.onRestored)), this.opts.waitForThumbnailsBeforeUpload && this.uppy.addPreProcessor(this.waitUntilAllProcessed) } uninstall() { this.uppy.off("file-removed", this.onFileRemoved), this.uppy.off("cancel-all", this.onAllFilesRemoved), this.opts.lazy ? (this.uppy.off("thumbnail:request", this.onFileAdded), this.uppy.off("thumbnail:cancel", this.onCancelRequest)) : (this.uppy.off("file-added", this.onFileAdded), this.uppy.off("restored", this.onRestored)), this.opts.waitForThumbnailsBeforeUpload && this.uppy.removePreProcessor(this.waitUntilAllProcessed) } }; n(fr, "ThumbnailGenerator"); fr.VERSION = q2.version; function Ou(i) { if (typeof i == "string") { let e = document.querySelectorAll(i); return e.length === 0 ? null : Array.from(e) } return typeof i == "object" && On(i) ? [i] : null } n(Ou, "findAllDOMElements"); var De = Array.from; function Au(i, e, t, r) { let { onSuccess: s } = r; i.readEntries(o => { let a = [...e, ...o]; o.length ? queueMicrotask(() => { Au(i, a, t, { onSuccess: s }) }) : s(a) }, o => { t(o), s(e) }) } n(Au, "getFilesAndDirectoriesFromDirectory"); function cy(i, e) { return i == null ? i : { kind: i.isFile ? "file" : i.isDirectory ? "directory" : void 0, name: i.name, getFile() { return new Promise((t, r) => i.file(t, r)) }, async*values() { let t = i.createReader(); yield* await new Promise(s => { Au(t, [], e, { onSuccess: o => s(o.map(a => cy(a, e))) }) }) } } } n(cy, "getAsFileSystemHandleFromEntry"); function dy(i, e, t) { try { return t === void 0 && (t = void 0), async function* () { let r = n(() => `${e}/${i.name}`, "getNextRelativePath"); if (i.kind === "file") { let s = await i.getFile(); s != null ? (s.relativePath = e ? r() : null, yield s) : t != null && (yield t) } else if (i.kind === "directory") for await (let s of i.values()) yield* dy(s, e ? r() : i.name); else t != null && (yield t) }() } catch (r) { return Promise.reject(r) } } n(dy, "createPromiseToAddFileOrParseDirectory"); async function* kc(i, e) { let t = await Promise.all(Array.from(i.items, async r => { var s; let o, a = n(() => typeof r.getAsEntry == "function" ? r.getAsEntry() : r.webkitGetAsEntry(), "getAsEntry"); return (s = o) != null || (o = cy(a(), e)), { fileSystemHandle: o, lastResortFile: r.getAsFile() } })); for (let { lastResortFile: r, fileSystemHandle: s } of t) if (s != null) try { yield* dy(s, "", r) } catch (o) { r != null ? yield r : e(o) } else r != null && (yield r) } n(kc, "getFilesFromDataTransfer"); function Uc(i) { let e = De(i.files); return Promise.resolve(e) } n(Uc, "fallbackApi"); async function Ps(i, e) { let { logDropError: t = n(() => { }, "logDropError") } = e === void 0 ? {} : e; try { let r = []; for await (let s of kc(i, t)) r.push(s); return r } catch { return Uc(i) } } n(Ps, "getDroppedFiles"); var py = Number.isNaN || n(function (e) { return typeof e == "number" && e !== e }, "ponyfill"); function K2(i, e) { return !!(i === e || py(i) && py(e)) } n(K2, "isEqual"); function G2(i, e) { if (i.length !== e.length) return !1; for (var t = 0; t < i.length; t++)if (!K2(i[t], e[t])) return !1; return !0 } n(G2, "areInputsEqual"); function Dc(i, e) { e === void 0 && (e = G2); var t = null; function r() { for (var s = [], o = 0; o < arguments.length; o++)s[o] = arguments[o]; if (t && t.lastThis === this && e(s, t.lastArgs)) return t.lastResult; var a = i.apply(this, s); return t = { lastResult: a, lastArgs: s, lastThis: this }, a } return n(r, "memoized"), r.clear = n(function () { t = null }, "clear"), r } n(Dc, "memoizeOne"); var Tu = ['a[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'area[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', "input:not([disabled]):not([inert]):not([aria-hidden])", "select:not([disabled]):not([inert]):not([aria-hidden])", "textarea:not([disabled]):not([inert]):not([aria-hidden])", "button:not([disabled]):not([inert]):not([aria-hidden])", 'iframe:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'object:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'embed:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[contenteditable]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[tabindex]:not([tabindex^="-"]):not([inert]):not([aria-hidden])']; function ha(i, e) { if (e) { let t = i.querySelector(`[data-uppy-paneltype="${e}"]`); if (t) return t } return i } n(ha, "getActiveOverlayEl"); function fy(i, e) { let t = e[0]; t && (t.focus(), i.preventDefault()) } n(fy, "focusOnFirstNode"); function X2(i, e) { let t = e[e.length - 1]; t && (t.focus(), i.preventDefault()) } n(X2, "focusOnLastNode"); function Y2(i) { return i.contains(document.activeElement) } n(Y2, "isFocusInOverlay"); function Nc(i, e, t) { let r = ha(t, e), s = De(r.querySelectorAll(Tu)), o = s.indexOf(document.activeElement); Y2(r) ? i.shiftKey && o === 0 ? X2(i, s) : !i.shiftKey && o === s.length - 1 && fy(i, s) : fy(i, s) } n(Nc, "trapFocus"); function my(i, e, t) { e === null || Nc(i, e, t) } n(my, "forInline"); var gy = se(Nh(), 1); function Ic() { let i = !1; return (0, gy.default)(n((t, r) => { let s = ha(t, r), o = s.contains(document.activeElement); if (o && i) return; let a = s.querySelector("[data-uppy-super-focusable]"); if (!(o && !a)) if (a) a.focus({ preventScroll: !0 }), i = !0; else { let l = s.querySelector(Tu); l?.focus({ preventScroll: !0 }), i = !1 } }, "superFocus"), 260) } n(Ic, "createSuperFocus"); var zy = se(It(), 1); function ca() { let i = document.body; return !(!("draggable" in i) || !("ondragstart" in i && "ondrop" in i) || !("FormData" in window) || !("FileReader" in window)) } n(ca, "isDragDropSupported"); var _y = se(It(), 1), xy = se(vy(), 1); function J2() { return u("svg", { "aria-hidden": "true", focusable: "false", width: "25", height: "25", viewBox: "0 0 25 25" }, u("g", { fill: "#686DE0", fillRule: "evenodd" }, u("path", { d: "M5 7v10h15V7H5zm0-1h15a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1z", fillRule: "nonzero" }), u("path", { d: "M6.35 17.172l4.994-5.026a.5.5 0 0 1 .707 0l2.16 2.16 3.505-3.505a.5.5 0 0 1 .707 0l2.336 2.31-.707.72-1.983-1.97-3.505 3.505a.5.5 0 0 1-.707 0l-2.16-2.159-3.938 3.939-1.409.026z", fillRule: "nonzero" }), u("circle", { cx: "7.5", cy: "9.5", r: "1.5" }))) } n(J2, "iconImage"); function Z2() { return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "25", height: "25", viewBox: "0 0 25 25" }, u("path", { d: "M9.5 18.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V7.25a.5.5 0 0 1 .379-.485l9-2.25A.5.5 0 0 1 18.5 5v11.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V8.67l-8 2v7.97zm8-11v-2l-8 2v2l8-2zM7 19.64c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1zm9-2c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1z", fill: "#049BCF", fillRule: "nonzero" })) } n(Z2, "iconAudio"); function eP() { return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "25", height: "25", viewBox: "0 0 25 25" }, u("path", { d: "M16 11.834l4.486-2.691A1 1 0 0 1 22 10v6a1 1 0 0 1-1.514.857L16 14.167V17a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2.834zM15 9H5v8h10V9zm1 4l5 3v-6l-5 3z", fill: "#19AF67", fillRule: "nonzero" })) } n(eP, "iconVideo"); function tP() { return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "25", height: "25", viewBox: "0 0 25 25" }, u("path", { d: "M9.766 8.295c-.691-1.843-.539-3.401.747-3.726 1.643-.414 2.505.938 2.39 3.299-.039.79-.194 1.662-.537 3.148.324.49.66.967 1.055 1.51.17.231.382.488.629.757 1.866-.128 3.653.114 4.918.655 1.487.635 2.192 1.685 1.614 2.84-.566 1.133-1.839 1.084-3.416.249-1.141-.604-2.457-1.634-3.51-2.707a13.467 13.467 0 0 0-2.238.426c-1.392 4.051-4.534 6.453-5.707 4.572-.986-1.58 1.38-4.206 4.914-5.375.097-.322.185-.656.264-1.001.08-.353.306-1.31.407-1.737-.678-1.059-1.2-2.031-1.53-2.91zm2.098 4.87c-.033.144-.068.287-.104.427l.033-.01-.012.038a14.065 14.065 0 0 1 1.02-.197l-.032-.033.052-.004a7.902 7.902 0 0 1-.208-.271c-.197-.27-.38-.526-.555-.775l-.006.028-.002-.003c-.076.323-.148.632-.186.8zm5.77 2.978c1.143.605 1.832.632 2.054.187.26-.519-.087-1.034-1.113-1.473-.911-.39-2.175-.608-3.55-.608.845.766 1.787 1.459 2.609 1.894zM6.559 18.789c.14.223.693.16 1.425-.413.827-.648 1.61-1.747 2.208-3.206-2.563 1.064-4.102 2.867-3.633 3.62zm5.345-10.97c.088-1.793-.351-2.48-1.146-2.28-.473.119-.564 1.05-.056 2.405.213.566.52 1.188.908 1.859.18-.858.268-1.453.294-1.984z", fill: "#E2514A", fillRule: "nonzero" })) } n(tP, "iconPDF"); function iP() { return u("svg", { "aria-hidden": "true", focusable: "false", width: "25", height: "25", viewBox: "0 0 25 25" }, u("path", { d: "M10.45 2.05h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V2.55a.5.5 0 0 1 .5-.5zm2.05 1.024h1.05a.5.5 0 0 1 .5.5V3.6a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5v-.001zM10.45 0h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 3.074h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 1.024h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm-2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-1.656 3.074l-.82 5.946c.52.302 1.174.458 1.976.458.803 0 1.455-.156 1.975-.458l-.82-5.946h-2.311zm0-1.025h2.312c.512 0 .946.378 1.015.885l.82 5.946c.056.412-.142.817-.501 1.026-.686.398-1.515.597-2.49.597-.974 0-1.804-.199-2.49-.597a1.025 1.025 0 0 1-.5-1.026l.819-5.946c.07-.507.503-.885 1.015-.885zm.545 6.6a.5.5 0 0 1-.397-.561l.143-.999a.5.5 0 0 1 .495-.429h.74a.5.5 0 0 1 .495.43l.143.998a.5.5 0 0 1-.397.561c-.404.08-.819.08-1.222 0z", fill: "#00C469", fillRule: "nonzero" })) } n(iP, "iconArchive"); function rP() { return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "25", height: "25", viewBox: "0 0 25 25" }, u("g", { fill: "#A7AFB7", fillRule: "nonzero" }, u("path", { d: "M5.5 22a.5.5 0 0 1-.5-.5v-18a.5.5 0 0 1 .5-.5h10.719a.5.5 0 0 1 .367.16l3.281 3.556a.5.5 0 0 1 .133.339V21.5a.5.5 0 0 1-.5.5h-14zm.5-1h13V7.25L16 4H6v17z" }), u("path", { d: "M15 4v3a1 1 0 0 0 1 1h3V7h-3V4h-1z" }))) } n(rP, "iconFile"); function sP() { return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "25", height: "25", viewBox: "0 0 25 25" }, u("path", { d: "M4.5 7h13a.5.5 0 1 1 0 1h-13a.5.5 0 0 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h10a.5.5 0 1 1 0 1h-10a.5.5 0 1 1 0-1z", fill: "#5A5E69", fillRule: "nonzero" })) } n(sP, "iconText"); function _s(i) { let e = { color: "#838999", icon: rP() }; if (!i) return e; let t = i.split("/")[0], r = i.split("/")[1]; return t === "text" ? { color: "#5a5e69", icon: sP() } : t === "image" ? { color: "#686de0", icon: J2() } : t === "audio" ? { color: "#068dbb", icon: Z2() } : t === "video" ? { color: "#19af67", icon: eP() } : t === "application" && r === "pdf" ? { color: "#e25149", icon: tP() } : t === "application" && ["zip", "x-7z-compressed", "x-rar-compressed", "x-tar", "x-gzip", "x-apple-diskimage"].indexOf(r) !== -1 ? { color: "#00C469", icon: iP() } : e } n(_s, "getIconByMime"); function da(i) { let { file: e } = i; if (e.preview) return u("img", { className: "uppy-Dashboard-Item-previewImg", alt: e.name, src: e.preview }); let { color: t, icon: r } = _s(e.type); return u("div", { className: "uppy-Dashboard-Item-previewIconWrap" }, u("span", { className: "uppy-Dashboard-Item-previewIcon", style: { color: t } }, r), u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-Dashboard-Item-previewIconBg", width: "58", height: "76", viewBox: "0 0 58 76" }, u("rect", { fill: "#FFF", width: "58", height: "76", rx: "3", fillRule: "evenodd" }))) } n(da, "FilePreview"); var oP = n((i, e) => (typeof e == "function" ? e() : e).filter(s => s.id === i)[0].name, "metaFieldIdToName"); function pa(i) { let { file: e, toggleFileCard: t, i18n: r, metaFields: s } = i, { missingRequiredMetaFields: o } = e; if (!(o != null && o.length)) return null; let a = o.map(l => oP(l, s)).join(", "); return u("div", { className: "uppy-Dashboard-Item-errorMessage" }, r("missingRequiredMetaFields", { smart_count: o.length, fields: a }), " ", u("button", { type: "button", class: "uppy-u-reset uppy-Dashboard-Item-errorMessageBtn", onClick: () => t(!0, e.id) }, r("editFile"))) } n(pa, "renderMissingMetaFieldsError"); function Bc(i) { let { file: e, i18n: t, toggleFileCard: r, metaFields: s, showLinkToFileUploadResult: o } = i, a = "rgba(255, 255, 255, 0.5)", l = e.preview ? a : _s(i.file.type).color; return u("div", { className: "uppy-Dashboard-Item-previewInnerWrap", style: { backgroundColor: l } }, o && e.uploadURL && u("a", { className: "uppy-Dashboard-Item-previewLink", href: e.uploadURL, rel: "noreferrer noopener", target: "_blank", "aria-label": e.meta.name }, u("span", { hidden: !0 }, e.meta.name)), u(da, { file: e }), u(pa, { file: e, i18n: t, toggleFileCard: r, metaFields: s })) } n(Bc, "FilePreviewAndLink"); function nP(i) { if (!i.isUploaded) { if (i.error && !i.hideRetryButton) { i.uppy.retryUpload(i.file.id); return } i.resumableUploads && !i.hidePauseResumeButton ? i.uppy.pauseResume(i.file.id) : i.individualCancellation && !i.hideCancelButton && i.uppy.removeFile(i.file.id) } } n(nP, "onPauseResumeCancelRetry"); function by(i) { return i.isUploaded ? i.i18n("uploadComplete") : i.error ? i.i18n("retryUpload") : i.resumableUploads ? i.file.isPaused ? i.i18n("resumeUpload") : i.i18n("pauseUpload") : i.individualCancellation ? i.i18n("cancelUpload") : "" } n(by, "progressIndicatorTitle"); function Lc(i) { return u("div", { className: "uppy-Dashboard-Item-progress" }, u("button", { className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-progressIndicator", type: "button", "aria-label": by(i), title: by(i), onClick: () => nP(i) }, i.children)) } n(Lc, "ProgressIndicatorButton"); function Cu(i) { let { children: e } = i; return u("svg", { "aria-hidden": "true", focusable: "false", width: "70", height: "70", viewBox: "0 0 36 36", className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--circle" }, e) } n(Cu, "ProgressCircleContainer"); function Mc(i) { let { progress: e } = i, t = 2 * Math.PI * 15; return u("g", null, u("circle", { className: "uppy-Dashboard-Item-progressIcon--bg", r: "15", cx: "18", cy: "18", "stroke-width": "2", fill: "none" }), u("circle", { className: "uppy-Dashboard-Item-progressIcon--progress", r: "15", cx: "18", cy: "18", transform: "rotate(-90, 18, 18)", fill: "none", "stroke-width": "2", "stroke-dasharray": t, "stroke-dashoffset": t - t / 100 * e })) } n(Mc, "ProgressCircle"); function zc(i) { if (!i.file.progress.uploadStarted) return null; if (i.isUploaded) return u("div", { className: "uppy-Dashboard-Item-progress" }, u("div", { className: "uppy-Dashboard-Item-progressIndicator" }, u(Cu, null, u("circle", { r: "15", cx: "18", cy: "18", fill: "#1bb240" }), u("polygon", { className: "uppy-Dashboard-Item-progressIcon--check", transform: "translate(2, 3)", points: "14 22.5 7 15.2457065 8.99985857 13.1732815 14 18.3547104 22.9729883 9 25 11.1005634" })))); if (!i.recoveredState) return i.error && !i.hideRetryButton ? u(Lc, i, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--retry", width: "28", height: "31", viewBox: "0 0 16 19" }, u("path", { d: "M16 11a8 8 0 1 1-8-8v2a6 6 0 1 0 6 6h2z" }), u("path", { d: "M7.9 3H10v2H7.9z" }), u("path", { d: "M8.536.5l3.535 3.536-1.414 1.414L7.12 1.914z" }), u("path", { d: "M10.657 2.621l1.414 1.415L8.536 7.57 7.12 6.157z" }))) : i.resumableUploads && !i.hidePauseResumeButton ? u(Lc, i, u(Cu, null, u(Mc, { progress: i.file.progress.percentage }), i.file.isPaused ? u("polygon", { className: "uppy-Dashboard-Item-progressIcon--play", transform: "translate(3, 3)", points: "12 20 12 10 20 15" }) : u("g", { className: "uppy-Dashboard-Item-progressIcon--pause", transform: "translate(14.5, 13)" }, u("rect", { x: "0", y: "0", width: "2", height: "10", rx: "0" }), u("rect", { x: "5", y: "0", width: "2", height: "10", rx: "0" })))) : !i.resumableUploads && i.individualCancellation && !i.hideCancelButton ? u(Lc, i, u(Cu, null, u(Mc, { progress: i.file.progress.percentage }), u("polygon", { className: "cancel", transform: "translate(2, 2)", points: "19.8856516 11.0625 16 14.9481516 12.1019737 11.0625 11.0625 12.1143484 14.9481516 16 11.0625 19.8980263 12.1019737 20.9375 16 17.0518484 19.8856516 20.9375 20.9375 19.8980263 17.0518484 16 20.9375 12" }))) : u("div", { className: "uppy-Dashboard-Item-progress" }, u("div", { className: "uppy-Dashboard-Item-progressIndicator" }, u(Cu, null, u(Mc, { progress: i.file.progress.percentage })))) } n(zc, "FileProgress"); var Py = se(Sy(), 1); var jc = "..."; function Ru(i, e) { if (e === 0) return ""; if (i.length <= e) return i; if (e <= jc.length + 1) return `${i.slice(0, e - 1)}\u2026`; let t = e - jc.length, r = Math.ceil(t / 2), s = Math.floor(t / 2); return i.slice(0, r) + jc + i.slice(-s) } n(Ru, "truncateString"); var aP = n(i => { let { author: e, name: t } = i.file.meta; function r() { return i.isSingleFile && i.containerHeight >= 350 ? 90 : i.containerWidth <= 352 ? 35 : i.containerWidth <= 576 ? 60 : e ? 20 : 30 } return n(r, "getMaxNameLength"), u("div", { className: "uppy-Dashboard-Item-name", title: t }, Ru(t, r())) }, "renderFileName"), lP = n(i => { let { author: e } = i.file.meta, { providerName: t } = i.file.remote, r = "\xB7"; return e ? u("div", { className: "uppy-Dashboard-Item-author" }, u("a", { href: `${e.url}?utm_source=Companion&utm_medium=referral`, target: "_blank", rel: "noopener noreferrer" }, Ru(e.name, 13)), t ? u(Et, null, ` ${r} `, t, ` ${r} `) : null) : null }, "renderAuthor"), uP = n(i => i.file.size && u("div", { className: "uppy-Dashboard-Item-statusSize" }, (0, Py.default)(i.file.size)), "renderFileSize"), hP = n(i => i.file.isGhost && u("span", null, " \u2022 ", u("button", { className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-reSelect", type: "button", onClick: i.toggleAddFilesPanel }, i.i18n("reSelect"))), "ReSelectButton"), cP = n(i => { let { file: e, onClick: t } = i; return e.error ? u("button", { className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-errorDetails", "aria-label": e.error, "data-microtip-position": "bottom", "data-microtip-size": "medium", onClick: t, type: "button" }, "?") : null }, "ErrorButton"); function Hc(i) { let { file: e } = i; return u("div", { className: "uppy-Dashboard-Item-fileInfo", "data-uppy-file-source": e.source }, u("div", { className: "uppy-Dashboard-Item-fileName" }, aP(i), u(cP, { file: i.file, onClick: () => alert(i.file.error) })), u("div", { className: "uppy-Dashboard-Item-status" }, lP(i), uP(i), hP(i)), u(pa, { file: i.file, i18n: i.i18n, toggleFileCard: i.toggleFileCard, metaFields: i.metaFields })) } n(Hc, "FileInfo"); function qc(i, e) { return e === void 0 && (e = "Copy the URL below"), new Promise(t => { let r = document.createElement("textarea"); r.setAttribute("style", { position: "fixed", top: 0, left: 0, width: "2em", height: "2em", padding: 0, border: "none", outline: "none", boxShadow: "none", background: "transparent" }), r.value = i, document.body.appendChild(r), r.select(); let s = n(() => { document.body.removeChild(r), window.prompt(e, i), t() }, "magicCopyFailed"); try { return document.execCommand("copy") ? (document.body.removeChild(r), t()) : s("copy command unavailable") } catch (o) { return document.body.removeChild(r), s(o) } }) } n(qc, "copyToClipboard"); function dP(i) { let { file: e, uploadInProgressOrComplete: t, metaFields: r, canEditFile: s, i18n: o, onClick: a } = i; return !t && r && r.length > 0 || !t && s(e) ? u("button", { className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-action uppy-Dashboard-Item-action--edit", type: "button", "aria-label": o("editFileWithFilename", { file: e.meta.name }), title: o("editFileWithFilename", { file: e.meta.name }), onClick: () => a() }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "14", height: "14", viewBox: "0 0 14 14" }, u("g", { fillRule: "evenodd" }, u("path", { d: "M1.5 10.793h2.793A1 1 0 0 0 5 10.5L11.5 4a1 1 0 0 0 0-1.414L9.707.793a1 1 0 0 0-1.414 0l-6.5 6.5A1 1 0 0 0 1.5 8v2.793zm1-1V8L9 1.5l1.793 1.793-6.5 6.5H2.5z", fillRule: "nonzero" }), u("rect", { x: "1", y: "12.293", width: "11", height: "1", rx: ".5" }), u("path", { fillRule: "nonzero", d: "M6.793 2.5L9.5 5.207l.707-.707L7.5 1.793z" })))) : null } n(dP, "EditButton"); function pP(i) { let { i18n: e, onClick: t, file: r } = i; return u("button", { className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--remove", type: "button", "aria-label": e("removeFile", { file: r.meta.name }), title: e("removeFile", { file: r.meta.name }), onClick: () => t() }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "18", height: "18", viewBox: "0 0 18 18" }, u("path", { d: "M9 0C4.034 0 0 4.034 0 9s4.034 9 9 9 9-4.034 9-9-4.034-9-9-9z" }), u("path", { fill: "#FFF", d: "M13 12.222l-.778.778L9 9.778 5.778 13 5 12.222 8.222 9 5 5.778 5.778 5 9 8.222 12.222 5l.778.778L9.778 9z" }))) } n(pP, "RemoveButton"); var fP = n((i, e) => { qc(e.file.uploadURL, e.i18n("copyLinkToClipboardFallback")).then(() => { e.uppy.log("Link copied to clipboard."), e.uppy.info(e.i18n("copyLinkToClipboardSuccess"), "info", 3e3) }).catch(e.uppy.log).then(() => i.target.focus({ preventScroll: !0 })) }, "copyLinkToClipboard"); function mP(i) { let { i18n: e } = i; return u("button", { className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--copyLink", type: "button", "aria-label": e("copyLink"), title: e("copyLink"), onClick: t => fP(t, i) }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "14", height: "14", viewBox: "0 0 14 12" }, u("path", { d: "M7.94 7.703a2.613 2.613 0 0 1-.626 2.681l-.852.851a2.597 2.597 0 0 1-1.849.766A2.616 2.616 0 0 1 2.764 7.54l.852-.852a2.596 2.596 0 0 1 2.69-.625L5.267 7.099a1.44 1.44 0 0 0-.833.407l-.852.851a1.458 1.458 0 0 0 1.03 2.486c.39 0 .755-.152 1.03-.426l.852-.852c.231-.231.363-.522.406-.824l1.04-1.038zm4.295-5.937A2.596 2.596 0 0 0 10.387 1c-.698 0-1.355.272-1.849.766l-.852.851a2.614 2.614 0 0 0-.624 2.688l1.036-1.036c.041-.304.173-.6.407-.833l.852-.852c.275-.275.64-.426 1.03-.426a1.458 1.458 0 0 1 1.03 2.486l-.852.851a1.442 1.442 0 0 1-.824.406l-1.04 1.04a2.596 2.596 0 0 0 2.683-.628l.851-.85a2.616 2.616 0 0 0 0-3.697zm-6.88 6.883a.577.577 0 0 0 .82 0l3.474-3.474a.579.579 0 1 0-.819-.82L5.355 7.83a.579.579 0 0 0 0 .819z" }))) } n(mP, "CopyLinkButton"); function $c(i) { let { uppy: e, file: t, uploadInProgressOrComplete: r, canEditFile: s, metaFields: o, showLinkToFileUploadResult: a, showRemoveButton: l, i18n: h, toggleFileCard: c, openFileEditor: d } = i; return u("div", { className: "uppy-Dashboard-Item-actionWrapper" }, u(dP, { i18n: h, file: t, uploadInProgressOrComplete: r, canEditFile: s, metaFields: o, onClick: n(() => { o && o.length > 0 ? c(!0, t.id) : d(t) }, "editAction") }), a && t.uploadURL ? u(mP, { file: t, uppy: e, i18n: h }) : null, l ? u(pP, { i18n: h, file: t, uppy: e, onClick: () => i.uppy.removeFile(t.id, "removed-by-user") }) : null) } n($c, "Buttons"); var jo = class extends ue { componentDidMount() { let { file: e } = this.props; e.preview || this.props.handleRequestThumbnail(e) } shouldComponentUpdate(e) { return !(0, xy.default)(this.props, e) } componentDidUpdate() { let { file: e } = this.props; e.preview || this.props.handleRequestThumbnail(e) } componentWillUnmount() { let { file: e } = this.props; e.preview || this.props.handleCancelThumbnail(e) } render() { let { file: e } = this.props, t = e.progress.preprocess || e.progress.postprocess, r = e.progress.uploadComplete && !t && !e.error, s = e.progress.uploadStarted || t, o = e.progress.uploadStarted && !e.progress.uploadComplete || t, a = e.error || !1, { isGhost: l } = e, h = (this.props.individualCancellation || !o) && !r; r && this.props.showRemoveButtonAfterComplete && (h = !0); let c = (0, _y.default)({ "uppy-Dashboard-Item": !0, "is-inprogress": o && !this.props.recoveredState, "is-processing": t, "is-complete": r, "is-error": !!a, "is-resumable": this.props.resumableUploads, "is-noIndividualCancellation": !this.props.individualCancellation, "is-ghost": l }); return u("div", { className: c, id: `uppy_${e.id}`, role: this.props.role }, u("div", { className: "uppy-Dashboard-Item-preview" }, u(Bc, { file: e, showLinkToFileUploadResult: this.props.showLinkToFileUploadResult, i18n: this.props.i18n, toggleFileCard: this.props.toggleFileCard, metaFields: this.props.metaFields }), u(zc, { uppy: this.props.uppy, file: e, error: a, isUploaded: r, hideRetryButton: this.props.hideRetryButton, hideCancelButton: this.props.hideCancelButton, hidePauseResumeButton: this.props.hidePauseResumeButton, recoveredState: this.props.recoveredState, showRemoveButtonAfterComplete: this.props.showRemoveButtonAfterComplete, resumableUploads: this.props.resumableUploads, individualCancellation: this.props.individualCancellation, i18n: this.props.i18n })), u("div", { className: "uppy-Dashboard-Item-fileInfoAndButtons" }, u(Hc, { file: e, id: this.props.id, acquirers: this.props.acquirers, containerWidth: this.props.containerWidth, containerHeight: this.props.containerHeight, i18n: this.props.i18n, toggleAddFilesPanel: this.props.toggleAddFilesPanel, toggleFileCard: this.props.toggleFileCard, metaFields: this.props.metaFields, isSingleFile: this.props.isSingleFile }), u($c, { file: e, metaFields: this.props.metaFields, showLinkToFileUploadResult: this.props.showLinkToFileUploadResult, showRemoveButton: h, canEditFile: this.props.canEditFile, uploadInProgressOrComplete: s, toggleFileCard: this.props.toggleFileCard, openFileEditor: this.props.openFileEditor, uppy: this.props.uppy, i18n: this.props.i18n }))) } }; n(jo, "FileItem"); function gP(i, e) { let t = [], r = []; return i.forEach(s => { r.length < e ? r.push(s) : (t.push(r), r = [s]) }), r.length && t.push(r), t } n(gP, "chunks"); var Ey = n(i => { let { id: e, error: t, i18n: r, uppy: s, files: o, acquirers: a, resumableUploads: l, hideRetryButton: h, hidePauseResumeButton: c, hideCancelButton: d, showLinkToFileUploadResult: p, showRemoveButtonAfterComplete: y, isWide: v, metaFields: S, isSingleFile: x, toggleFileCard: E, handleRequestThumbnail: F, handleCancelThumbnail: k, recoveredState: B, individualCancellation: H, itemsPerRow: W, openFileEditor: I, canEditFile: q, toggleAddFilesPanel: $, containerWidth: V, containerHeight: xe } = i, Pt = W === 1 ? 71 : 200, ut = Co(() => { let st = n((Ee, ai) => o[ai].isGhost - o[Ee].isGhost, "sortByGhostComesFirst"), We = Object.keys(o); return B && We.sort(st), gP(We, W) }, [o, W, B]), rt = n(st => u("div", { class: "uppy-Dashboard-filesInner", role: "presentation", key: st[0] }, st.map(We => u(jo, { key: We, uppy: s, id: e, error: t, i18n: r, acquirers: a, resumableUploads: l, individualCancellation: H, hideRetryButton: h, hidePauseResumeButton: c, hideCancelButton: d, showLinkToFileUploadResult: p, showRemoveButtonAfterComplete: y, isWide: v, metaFields: S, recoveredState: B, isSingleFile: x, containerWidth: V, containerHeight: xe, toggleFileCard: E, handleRequestThumbnail: F, handleCancelThumbnail: k, role: "listitem", openFileEditor: I, canEditFile: q, toggleAddFilesPanel: $, file: o[We] }))), "renderRow"); return x ? u("div", { class: "uppy-Dashboard-files" }, rt(ut[0])) : u(cu, { class: "uppy-Dashboard-files", role: "list", data: ut, renderRow: rt, rowHeight: Pt }) }, "default"); var Fy; Fy = Symbol.for("uppy test: disable unused locale key warning"); var ku = class extends ue { constructor() { super(...arguments), this.triggerFileInputClick = () => { this.fileInput.click() }, this.triggerFolderInputClick = () => { this.folderInput.click() }, this.triggerVideoCameraInputClick = () => { this.mobileVideoFileInput.click() }, this.triggerPhotoCameraInputClick = () => { this.mobilePhotoFileInput.click() }, this.onFileInputChange = e => { this.props.handleInputChange(e), e.target.value = null }, this.renderHiddenInput = (e, t) => u("input", { className: "uppy-Dashboard-input", hidden: !0, "aria-hidden": "true", tabIndex: -1, webkitdirectory: e, type: "file", name: "files[]", multiple: this.props.maxNumberOfFiles !== 1, onChange: this.onFileInputChange, accept: this.props.allowedFileTypes, ref: t }), this.renderHiddenCameraInput = (e, t, r) => { let o = { photo: "image/*", video: "video/*" }[e]; return u("input", { className: "uppy-Dashboard-input", hidden: !0, "aria-hidden": "true", tabIndex: -1, type: "file", name: `camera-${e}`, onChange: this.onFileInputChange, capture: t, accept: o, ref: r }) }, this.renderMyDeviceAcquirer = () => u("div", { className: "uppy-DashboardTab", role: "presentation", "data-uppy-acquirer-id": "MyDevice" }, u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn", role: "tab", tabIndex: 0, "data-uppy-super-focusable": !0, onClick: this.triggerFileInputClick }, u("div", { className: "uppy-DashboardTab-inner" }, u("svg", { className: "uppy-DashboardTab-iconMyDevice", "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("path", { d: "M8.45 22.087l-1.305-6.674h17.678l-1.572 6.674H8.45zm4.975-12.412l1.083 1.765a.823.823 0 00.715.386h7.951V13.5H8.587V9.675h4.838zM26.043 13.5h-1.195v-2.598c0-.463-.336-.75-.798-.75h-8.356l-1.082-1.766A.823.823 0 0013.897 8H7.728c-.462 0-.815.256-.815.718V13.5h-.956a.97.97 0 00-.746.37.972.972 0 00-.19.81l1.724 8.565c.095.44.484.755.933.755H24c.44 0 .824-.3.929-.727l2.043-8.568a.972.972 0 00-.176-.825.967.967 0 00-.753-.38z", fill: "currentcolor", "fill-rule": "evenodd" }))), u("div", { className: "uppy-DashboardTab-name" }, this.props.i18n("myDevice")))), this.renderPhotoCamera = () => u("div", { className: "uppy-DashboardTab", role: "presentation", "data-uppy-acquirer-id": "MobilePhotoCamera" }, u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn", role: "tab", tabIndex: 0, "data-uppy-super-focusable": !0, onClick: this.triggerPhotoCameraInputClick }, u("div", { className: "uppy-DashboardTab-inner" }, u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("path", { d: "M23.5 9.5c1.417 0 2.5 1.083 2.5 2.5v9.167c0 1.416-1.083 2.5-2.5 2.5h-15c-1.417 0-2.5-1.084-2.5-2.5V12c0-1.417 1.083-2.5 2.5-2.5h2.917l1.416-2.167C13 7.167 13.25 7 13.5 7h5c.25 0 .5.167.667.333L20.583 9.5H23.5zM16 11.417a4.706 4.706 0 00-4.75 4.75 4.704 4.704 0 004.75 4.75 4.703 4.703 0 004.75-4.75c0-2.663-2.09-4.75-4.75-4.75zm0 7.825c-1.744 0-3.076-1.332-3.076-3.074 0-1.745 1.333-3.077 3.076-3.077 1.744 0 3.074 1.333 3.074 3.076s-1.33 3.075-3.074 3.075z", fill: "#02B383", "fill-rule": "nonzero" }))), u("div", { className: "uppy-DashboardTab-name" }, this.props.i18n("takePictureBtn")))), this.renderVideoCamera = () => u("div", { className: "uppy-DashboardTab", role: "presentation", "data-uppy-acquirer-id": "MobileVideoCamera" }, u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn", role: "tab", tabIndex: 0, "data-uppy-super-focusable": !0, onClick: this.triggerVideoCameraInputClick }, u("div", { className: "uppy-DashboardTab-inner" }, u("svg", { "aria-hidden": "true", width: "32", height: "32", viewBox: "0 0 32 32" }, u("path", { fill: "#FF675E", fillRule: "nonzero", d: "m21.254 14.277 2.941-2.588c.797-.313 1.243.818 1.09 1.554-.01 2.094.02 4.189-.017 6.282-.126.915-1.145 1.08-1.58.34l-2.434-2.142c-.192.287-.504 1.305-.738.468-.104-1.293-.028-2.596-.05-3.894.047-.312.381.823.426 1.069.063-.384.206-.744.362-1.09zm-12.939-3.73c3.858.013 7.717-.025 11.574.02.912.129 1.492 1.237 1.351 2.217-.019 2.412.04 4.83-.03 7.239-.17 1.025-1.166 1.59-2.029 1.429-3.705-.012-7.41.025-11.114-.019-.913-.129-1.492-1.237-1.352-2.217.018-2.404-.036-4.813.029-7.214.136-.82.83-1.473 1.571-1.454z " }))), u("div", { className: "uppy-DashboardTab-name" }, this.props.i18n("recordVideoBtn")))), this.renderBrowseButton = (e, t) => { let r = this.props.acquirers.length; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-Dashboard-browse", onClick: t, "data-uppy-super-focusable": r === 0 }, e) }, this.renderDropPasteBrowseTagline = e => { let t = this.renderBrowseButton(this.props.i18n("browseFiles"), this.triggerFileInputClick), r = this.renderBrowseButton(this.props.i18n("browseFolders"), this.triggerFolderInputClick), s = this.props.fileManagerSelectionType, o = s.charAt(0).toUpperCase() + s.slice(1); return u("div", { class: "uppy-Dashboard-AddFiles-title" }, this.props.disableLocalFiles ? this.props.i18n("importFiles") : e > 0 ? this.props.i18nArray(`dropPasteImport${o}`, { browseFiles: t, browseFolders: r, browse: t }) : this.props.i18nArray(`dropPaste${o}`, { browseFiles: t, browseFolders: r, browse: t })) }, this.renderAcquirer = e => u("div", { className: "uppy-DashboardTab", role: "presentation", "data-uppy-acquirer-id": e.id }, u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn", role: "tab", tabIndex: 0, "data-cy": e.id, "aria-controls": `uppy-DashboardContent-panel--${e.id}`, "aria-selected": this.props.activePickerPanel.id === e.id, "data-uppy-super-focusable": !0, onClick: () => this.props.showPanel(e.id) }, u("div", { className: "uppy-DashboardTab-inner" }, e.icon()), u("div", { className: "uppy-DashboardTab-name" }, e.name))), this.renderAcquirers = e => { let t = [...e], r = t.splice(e.length - 2, e.length); return u(Et, null, t.map(s => this.renderAcquirer(s)), u("span", { role: "presentation", style: { "white-space": "nowrap" } }, r.map(s => this.renderAcquirer(s)))) }, this.renderSourcesList = (e, t) => { let { showNativePhotoCameraButton: r, showNativeVideoCameraButton: s } = this.props, o = [], a = "myDevice"; t || (o.push({ key: a, elements: this.renderMyDeviceAcquirer() }), r && o.push({ key: "nativePhotoCameraButton", elements: this.renderPhotoCamera() }), s && o.push({ key: "nativePhotoCameraButton", elements: this.renderVideoCamera() })), o.push(...e.map(p => ({ key: p.id, elements: this.renderAcquirer(p) }))), o.length === 1 && o[0].key === a && (o = []); let h = [...o], c = h.splice(o.length - 2, o.length), d = n(p => p.map(y => { let { key: v, elements: S } = y; return u(Et, { key: v }, S) }), "renderList"); return u(Et, null, this.renderDropPasteBrowseTagline(o.length), u("div", { className: "uppy-Dashboard-AddFiles-list", role: "tablist" }, d(h), u("span", { role: "presentation", style: { "white-space": "nowrap" } }, d(c)))) } } [Fy]() { this.props.i18nArray("dropPasteBoth"), this.props.i18nArray("dropPasteFiles"), this.props.i18nArray("dropPasteFolders"), this.props.i18nArray("dropPasteImportBoth"), this.props.i18nArray("dropPasteImportFiles"), this.props.i18nArray("dropPasteImportFolders") } renderPoweredByUppy() { let { i18nArray: e } = this.props, t = u("span", null, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon uppy-Dashboard-poweredByIcon", width: "11", height: "11", viewBox: "0 0 11 11" }, u("path", { d: "M7.365 10.5l-.01-4.045h2.612L5.5.806l-4.467 5.65h2.604l.01 4.044h3.718z", fillRule: "evenodd" })), u("span", { className: "uppy-Dashboard-poweredByUppy" }, "Uppy")), r = e("poweredBy", { uppy: t }); return u("a", { tabIndex: "-1", href: "https://uppy.io", rel: "noreferrer noopener", target: "_blank", className: "uppy-Dashboard-poweredBy" }, r) } render() { let { showNativePhotoCameraButton: e, showNativeVideoCameraButton: t, nativeCameraFacingMode: r } = this.props; return u("div", { className: "uppy-Dashboard-AddFiles" }, this.renderHiddenInput(!1, s => { this.fileInput = s }), this.renderHiddenInput(!0, s => { this.folderInput = s }), e && this.renderHiddenCameraInput("photo", r, s => { this.mobilePhotoFileInput = s }), t && this.renderHiddenCameraInput("video", r, s => { this.mobileVideoFileInput = s }), this.renderSourcesList(this.props.acquirers, this.props.disableLocalFiles), u("div", { className: "uppy-Dashboard-AddFiles-info" }, this.props.note && u("div", { className: "uppy-Dashboard-note" }, this.props.note), this.props.proudlyDisplayPoweredByUppy && this.renderPoweredByUppy(this.props))) } }; n(ku, "AddFiles"); var Uu = ku; var Oy = se(It(), 1); var yP = n(i => u("div", { className: (0, Oy.default)("uppy-Dashboard-AddFilesPanel", i.className), "data-uppy-panelType": "AddFiles", "aria-hidden": i.showAddFilesPanel }, u("div", { className: "uppy-DashboardContent-bar" }, u("div", { className: "uppy-DashboardContent-title", role: "heading", "aria-level": "1" }, i.i18n("addingMoreFiles")), u("button", { className: "uppy-DashboardContent-back", type: "button", onClick: () => i.toggleAddFilesPanel(!1) }, i.i18n("back"))), u(Uu, i)), "AddFilesPanel"), Ay = yP; var Ty = se(It(), 1); function vP(i) { let { tagName: e } = i.target; if (e === "INPUT" || e === "TEXTAREA") { i.stopPropagation(); return } i.preventDefault(), i.stopPropagation() } n(vP, "ignoreEvent"); var ki = vP; function bP(i) { let { activePickerPanel: e, className: t, hideAllPanels: r, i18n: s, state: o, uppy: a } = i; return u("div", { className: (0, Ty.default)("uppy-DashboardContent-panel", t), role: "tabpanel", "data-uppy-panelType": "PickerPanel", id: `uppy-DashboardContent-panel--${e.id}`, onDragOver: ki, onDragLeave: ki, onDrop: ki, onPaste: ki }, u("div", { className: "uppy-DashboardContent-bar" }, u("div", { className: "uppy-DashboardContent-title", role: "heading", "aria-level": "1" }, s("importFrom", { name: e.name })), u("button", { className: "uppy-DashboardContent-back", type: "button", onClick: r }, s("cancel"))), u("div", { className: "uppy-DashboardContent-panelBody" }, a.getPlugin(e.id).render(o))) } n(bP, "PickerPanelContent"); var Cy = bP; var Ry = se(It(), 1); function wP(i) { let e = i.files[i.fileCardFor]; return u("div", { className: (0, Ry.default)("uppy-DashboardContent-panel", i.className), role: "tabpanel", "data-uppy-panelType": "FileEditor", id: "uppy-DashboardContent-panel--editor" }, u("div", { className: "uppy-DashboardContent-bar" }, u("div", { className: "uppy-DashboardContent-title", role: "heading", "aria-level": "1" }, i.i18nArray("editing", { file: u("span", { className: "uppy-DashboardContent-titleFile" }, e.meta ? e.meta.name : e.name) })), u("button", { className: "uppy-DashboardContent-back", type: "button", onClick: i.hideAllPanels }, i.i18n("cancel")), u("button", { className: "uppy-DashboardContent-save", type: "button", onClick: i.saveFileEditor }, i.i18n("save"))), u("div", { className: "uppy-DashboardContent-panelBody" }, i.editors.map(t => i.uppy.getPlugin(t.id).render(i.state)))) } n(wP, "EditorPanel"); var ky = wP; var Ui = { STATE_ERROR: "error", STATE_WAITING: "waiting", STATE_PREPROCESSING: "preprocessing", STATE_UPLOADING: "uploading", STATE_POSTPROCESSING: "postprocessing", STATE_COMPLETE: "complete", STATE_PAUSED: "paused" }; function SP(i, e, t, r) { if (r === void 0 && (r = {}), i) return Ui.STATE_ERROR; if (e) return Ui.STATE_COMPLETE; if (t) return Ui.STATE_PAUSED; let s = Ui.STATE_WAITING, o = Object.keys(r); for (let a = 0; a < o.length; a++) { let { progress: l } = r[o[a]]; if (l.uploadStarted && !l.uploadComplete) return Ui.STATE_UPLOADING; l.preprocess && s !== Ui.STATE_UPLOADING && (s = Ui.STATE_PREPROCESSING), l.postprocess && s !== Ui.STATE_UPLOADING && s !== Ui.STATE_PREPROCESSING && (s = Ui.STATE_POSTPROCESSING) } return s } n(SP, "getUploadingState"); function PP(i) { let { files: e, i18n: t, isAllComplete: r, isAllErrored: s, isAllPaused: o, inProgressNotPausedFiles: a, newFiles: l, processingFiles: h } = i; switch (SP(s, r, o, e)) { case "uploading": return t("uploadingXFiles", { smart_count: a.length }); case "preprocessing": case "postprocessing": return t("processingXFiles", { smart_count: h.length }); case "paused": return t("uploadPaused"); case "waiting": return t("xFilesSelected", { smart_count: l.length }); case "complete": return t("uploadComplete"); case "error": return t("error"); default: } } n(PP, "UploadStatus"); function _P(i) { let { i18n: e, isAllComplete: t, hideCancelButton: r, maxNumberOfFiles: s, toggleAddFilesPanel: o, uppy: a } = i, { allowNewUpload: l } = i; return l && s && (l = i.totalFileCount < i.maxNumberOfFiles), u("div", { className: "uppy-DashboardContent-bar" }, !t && !r ? u("button", { className: "uppy-DashboardContent-back", type: "button", onClick: () => a.cancelAll() }, e("cancel")) : u("div", null), u("div", { className: "uppy-DashboardContent-title", role: "heading", "aria-level": "1" }, u(PP, i)), l ? u("button", { className: "uppy-DashboardContent-addMore", type: "button", "aria-label": e("addMoreFiles"), title: e("addMoreFiles"), onClick: () => o(!0) }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "15", height: "15", viewBox: "0 0 15 15" }, u("path", { d: "M8 6.5h6a.5.5 0 0 1 .5.5v.5a.5.5 0 0 1-.5.5H8v6a.5.5 0 0 1-.5.5H7a.5.5 0 0 1-.5-.5V8h-6a.5.5 0 0 1-.5-.5V7a.5.5 0 0 1 .5-.5h6v-6A.5.5 0 0 1 7 0h.5a.5.5 0 0 1 .5.5v6z" })), u("span", { className: "uppy-DashboardContent-addMoreCaption" }, e("addMore"))) : u("div", null)) } n(_P, "PanelTopBar"); var Uy = _P; var Dy = se(It(), 1); function Vc(i) { let { computedMetaFields: e, requiredMetaFields: t, updateMeta: r, form: s, formState: o } = i, a = { text: "uppy-u-reset uppy-c-textInput uppy-Dashboard-FileCard-input" }; return e.map(l => { let h = `uppy-Dashboard-FileCard-input-${l.id}`, c = t.includes(l.id); return u("fieldset", { key: l.id, className: "uppy-Dashboard-FileCard-fieldset" }, u("label", { className: "uppy-Dashboard-FileCard-label", htmlFor: h }, l.name), l.render !== void 0 ? l.render({ value: o[l.id], onChange: d => r(d, l.id), fieldCSSClasses: a, required: c, form: s.id }, u) : u("input", { className: a.text, id: h, form: s.id, type: l.type || "text", required: c, value: o[l.id], placeholder: l.placeholder, onInput: d => r(d.target.value, l.id), "data-uppy-super-focusable": !0 })) }) } n(Vc, "RenderMetaFields"); function Wc(i) { var e; let { uppy: t, files: r, fileCardFor: s, toggleFileCard: o, saveFileCard: a, metaFields: l, requiredMetaFields: h, openFileEditor: c, i18n: d, i18nArray: p, className: y, canEditFile: v } = i, S = n(() => typeof l == "function" ? l(r[s]) : l, "getMetaFields"), x = r[s], E = (e = S()) != null ? e : [], F = v(x), k = {}; E.forEach(V => { var xe; k[V.id] = (xe = x.meta[V.id]) != null ? xe : "" }); let [B, H] = To(k), W = jn(V => { V.preventDefault(), a(B, s) }, [a, B, s]), I = n((V, xe) => { H({ ...B, [xe]: V }) }, "updateMeta"), q = n(() => { t.emit("file-editor:cancel", x), o(!1) }, "handleCancel"), [$] = To(() => { let V = document.createElement("form"); return V.setAttribute("tabindex", "-1"), V.id = ot(), V }); return bs(() => (document.body.appendChild($), $.addEventListener("submit", W), () => { $.removeEventListener("submit", W), document.body.removeChild($) }), [$, W]), u("div", { className: (0, Dy.default)("uppy-Dashboard-FileCard", y), "data-uppy-panelType": "FileCard", onDragOver: ki, onDragLeave: ki, onDrop: ki, onPaste: ki }, u("div", { className: "uppy-DashboardContent-bar" }, u("div", { className: "uppy-DashboardContent-title", role: "heading", "aria-level": "1" }, p("editing", { file: u("span", { className: "uppy-DashboardContent-titleFile" }, x.meta ? x.meta.name : x.name) })), u("button", { className: "uppy-DashboardContent-back", type: "button", form: $.id, title: d("finishEditingFile"), onClick: q }, d("cancel"))), u("div", { className: "uppy-Dashboard-FileCard-inner" }, u("div", { className: "uppy-Dashboard-FileCard-preview", style: { backgroundColor: _s(x.type).color } }, u(da, { file: x }), F && u("button", { type: "button", className: "uppy-u-reset uppy-c-btn uppy-Dashboard-FileCard-edit", onClick: V => { W(V), c(x) } }, d("editFile"))), u("div", { className: "uppy-Dashboard-FileCard-info" }, u(Vc, { computedMetaFields: E, requiredMetaFields: h, updateMeta: I, form: $, formState: B })), u("div", { className: "uppy-Dashboard-FileCard-actions" }, u("button", { className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Dashboard-FileCard-actionsBtn", type: "submit", form: $.id }, d("saveChanges")), u("button", { className: "uppy-u-reset uppy-c-btn uppy-c-btn-link uppy-Dashboard-FileCard-actionsBtn", type: "button", onClick: q, form: $.id }, d("cancel"))))) } n(Wc, "FileCard"); var Iy = se(It(), 1); var Ho = "uppy-transition-slideDownUp", Ny = 250, Du = class extends ue { constructor(e) { super(e), this.state = { cachedChildren: null, className: "" } } componentWillUpdate(e) { let { cachedChildren: t } = this.state, r = ti(e.children)[0]; if (t === r) return null; let s = { cachedChildren: r }; r && !t && (s.className = `${Ho}-enter`, cancelAnimationFrame(this.animationFrame), clearTimeout(this.leaveTimeout), this.leaveTimeout = void 0, this.animationFrame = requestAnimationFrame(() => { this.setState({ className: `${Ho}-enter ${Ho}-enter-active` }), this.enterTimeout = setTimeout(() => { this.setState({ className: "" }) }, Ny) })), t && !r && this.leaveTimeout === void 0 && (s.cachedChildren = t, s.className = `${Ho}-leave`, cancelAnimationFrame(this.animationFrame), clearTimeout(this.enterTimeout), this.enterTimeout = void 0, this.animationFrame = requestAnimationFrame(() => { this.setState({ className: `${Ho}-leave ${Ho}-leave-active` }), this.leaveTimeout = setTimeout(() => { this.setState({ cachedChildren: null, className: "" }) }, Ny) })), this.setState(s) } render() { let { cachedChildren: e, className: t } = this.state; return e ? Wl(e, { className: (0, Iy.default)(t, e.props.className) }) : null } }; n(Du, "Slide"); var fa = Du; function xs() { return xs = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, xs.apply(this, arguments) } n(xs, "_extends"); var By = 900, Ly = 700, Kc = 576, My = 330; function Gc(i) { let e = i.totalFileCount === 0, t = i.totalFileCount === 1, r = i.containerWidth > Kc, s = i.containerHeight > My, o = (0, zy.default)({ "uppy-Dashboard": !0, "uppy-Dashboard--isDisabled": i.disabled, "uppy-Dashboard--animateOpenClose": i.animateOpenClose, "uppy-Dashboard--isClosing": i.isClosing, "uppy-Dashboard--isDraggingOver": i.isDraggingOver, "uppy-Dashboard--modal": !i.inline, "uppy-size--md": i.containerWidth > Kc, "uppy-size--lg": i.containerWidth > Ly, "uppy-size--xl": i.containerWidth > By, "uppy-size--height-md": i.containerHeight > My, "uppy-Dashboard--isAddFilesPanelVisible": i.showAddFilesPanel, "uppy-Dashboard--isInnerWrapVisible": i.areInsidesReadyToBeVisible, "uppy-Dashboard--singleFile": i.singleFileFullScreen && t && s }), a = 1; i.containerWidth > By ? a = 5 : i.containerWidth > Ly ? a = 4 : i.containerWidth > Kc && (a = 3); let l = i.showSelectedFiles && !e, h = i.recoveredState ? Object.keys(i.recoveredState.files).length : null, c = i.files ? Object.keys(i.files).filter(y => i.files[y].isGhost).length : null, d = n(() => c > 0 ? i.i18n("recoveredXFiles", { smart_count: c }) : i.i18n("recoveredAllFiles"), "renderRestoredText"); return u("div", { className: o, "data-uppy-theme": i.theme, "data-uppy-num-acquirers": i.acquirers.length, "data-uppy-drag-drop-supported": !i.disableLocalFiles && ca(), "aria-hidden": i.inline ? "false" : i.isHidden, "aria-disabled": i.disabled, "aria-label": i.inline ? i.i18n("dashboardTitle") : i.i18n("dashboardWindowTitle"), onPaste: i.handlePaste, onDragOver: i.handleDragOver, onDragLeave: i.handleDragLeave, onDrop: i.handleDrop }, u("div", { "aria-hidden": "true", className: "uppy-Dashboard-overlay", tabIndex: -1, onClick: i.handleClickOutside }), u("div", { className: "uppy-Dashboard-inner", "aria-modal": !i.inline && "true", role: !i.inline && "dialog", style: { width: i.inline && i.width ? i.width : "", height: i.inline && i.height ? i.height : "" } }, i.inline ? null : u("button", { className: "uppy-u-reset uppy-Dashboard-close", type: "button", "aria-label": i.i18n("closeModal"), title: i.i18n("closeModal"), onClick: i.closeModal }, u("span", { "aria-hidden": "true" }, "\xD7")), u("div", { className: "uppy-Dashboard-innerWrap" }, u("div", { className: "uppy-Dashboard-dropFilesHereHint" }, i.i18n("dropHint")), l && u(Uy, i), h && u("div", { className: "uppy-Dashboard-serviceMsg" }, u("svg", { className: "uppy-Dashboard-serviceMsg-icon", "aria-hidden": "true", focusable: "false", width: "21", height: "16", viewBox: "0 0 24 19" }, u("g", { transform: "translate(0 -1)", fill: "none", fillRule: "evenodd" }, u("path", { d: "M12.857 1.43l10.234 17.056A1 1 0 0122.234 20H1.766a1 1 0 01-.857-1.514L11.143 1.429a1 1 0 011.714 0z", fill: "#FFD300" }), u("path", { fill: "#000", d: "M11 6h2l-.3 8h-1.4z" }), u("circle", { fill: "#000", cx: "12", cy: "17", r: "1" }))), u("strong", { className: "uppy-Dashboard-serviceMsg-title" }, i.i18n("sessionRestored")), u("div", { className: "uppy-Dashboard-serviceMsg-text" }, d())), l ? u(Ey, { id: i.id, error: i.error, i18n: i.i18n, uppy: i.uppy, files: i.files, acquirers: i.acquirers, resumableUploads: i.resumableUploads, hideRetryButton: i.hideRetryButton, hidePauseResumeButton: i.hidePauseResumeButton, hideCancelButton: i.hideCancelButton, showLinkToFileUploadResult: i.showLinkToFileUploadResult, showRemoveButtonAfterComplete: i.showRemoveButtonAfterComplete, isWide: i.isWide, metaFields: i.metaFields, toggleFileCard: i.toggleFileCard, handleRequestThumbnail: i.handleRequestThumbnail, handleCancelThumbnail: i.handleCancelThumbnail, recoveredState: i.recoveredState, individualCancellation: i.individualCancellation, openFileEditor: i.openFileEditor, canEditFile: i.canEditFile, toggleAddFilesPanel: i.toggleAddFilesPanel, isSingleFile: t, itemsPerRow: a }) : u(Uu, xs({}, i, { isSizeMD: r })), u(fa, null, i.showAddFilesPanel ? u(Ay, xs({ key: "AddFiles" }, i, { isSizeMD: r })) : null), u(fa, null, i.fileCardFor ? u(Wc, xs({ key: "FileCard" }, i)) : null), u(fa, null, i.activePickerPanel ? u(Cy, xs({ key: "Picker" }, i)) : null), u(fa, null, i.showFileEditor ? u(ky, xs({ key: "Editor" }, i)) : null), u("div", { className: "uppy-Dashboard-progressindicators" }, i.progressindicators.map(y => i.uppy.getPlugin(y.id).render(i.state)))))) } n(Gc, "Dashboard"); var jy = { strings: { closeModal: "Close Modal", addMoreFiles: "Add more files", addingMoreFiles: "Adding more files", importFrom: "Import from %{name}", dashboardWindowTitle: "Uppy Dashboard Window (Press escape to close)", dashboardTitle: "Uppy Dashboard", copyLinkToClipboardSuccess: "Link copied to clipboard.", copyLinkToClipboardFallback: "Copy the URL below", copyLink: "Copy link", back: "Back", removeFile: "Remove file", editFile: "Edit file", editing: "Editing %{file}", error: "Error", finishEditingFile: "Finish editing file", saveChanges: "Save changes", myDevice: "My Device", dropHint: "Drop your files here", uploadComplete: "Upload complete", uploadPaused: "Upload paused", resumeUpload: "Resume upload", pauseUpload: "Pause upload", retryUpload: "Retry upload", cancelUpload: "Cancel upload", xFilesSelected: { 0: "%{smart_count} file selected", 1: "%{smart_count} files selected" }, uploadingXFiles: { 0: "Uploading %{smart_count} file", 1: "Uploading %{smart_count} files" }, processingXFiles: { 0: "Processing %{smart_count} file", 1: "Processing %{smart_count} files" }, poweredBy: "Powered by %{uppy}", addMore: "Add more", editFileWithFilename: "Edit file %{file}", save: "Save", cancel: "Cancel", dropPasteFiles: "Drop files here or %{browseFiles}", dropPasteFolders: "Drop files here or %{browseFolders}", dropPasteBoth: "Drop files here, %{browseFiles} or %{browseFolders}", dropPasteImportFiles: "Drop files here, %{browseFiles} or import from:", dropPasteImportFolders: "Drop files here, %{browseFolders} or import from:", dropPasteImportBoth: "Drop files here, %{browseFiles}, %{browseFolders} or import from:", importFiles: "Import files from:", browseFiles: "browse files", browseFolders: "browse folders", recoveredXFiles: { 0: "We could not fully recover 1 file. Please re-select it and resume the upload.", 1: "We could not fully recover %{smart_count} files. Please re-select them and resume the upload." }, recoveredAllFiles: "We restored all files. You can now resume the upload.", sessionRestored: "Session restored", reSelect: "Re-select", missingRequiredMetaFields: { 0: "Missing required meta field: %{fields}.", 1: "Missing required meta fields: %{fields}." }, takePictureBtn: "Take Picture", recordVideoBtn: "Record Video" } }; function Me(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Me, "_classPrivateFieldLooseBase"); var xP = 0; function jr(i) { return "__private_" + xP++ + "_" + i } n(jr, "_classPrivateFieldLooseKey"); var EP = { version: "3.5.1" }, Xc = Dc.default || Dc, Hy = 9, FP = 27; function qy() { let i = {}; return i.promise = new Promise((e, t) => { i.resolve = e, i.reject = t }), i } n(qy, "createPromise"); var Es = jr("disabledNodes"), mr = jr("generateLargeThumbnailIfSingleFile"), ma = jr("openFileEditorWhenFilesAdded"), Fs = jr("attachRenderFunctionToTarget"), Yc = jr("isTargetSupported"), Qc = jr("getAcquirers"), Jc = jr("getProgressIndicators"), gr = jr("getEditors"), Di = class extends G { constructor(e, t) { var r; super(e, t), r = this, Object.defineProperty(this, Es, { writable: !0, value: null }), this.removeTarget = o => { let l = this.getPluginState().targets.filter(h => h.id !== o.id); this.setPluginState({ targets: l }) }, this.addTarget = o => { let a = o.id || o.constructor.name, l = o.title || a, h = o.type; if (h !== "acquirer" && h !== "progressindicator" && h !== "editor") { let y = "Dashboard: can only be targeted by plugins of types: acquirer, progressindicator, editor"; this.uppy.log(y, "error"); return } let c = { id: a, name: l, type: h }, p = this.getPluginState().targets.slice(); return p.push(c), this.setPluginState({ targets: p }), this.el }, this.hideAllPanels = () => { let o = this.getPluginState(), a = { activePickerPanel: !1, showAddFilesPanel: !1, activeOverlayType: null, fileCardFor: null, showFileEditor: !1 }; o.activePickerPanel === a.activePickerPanel && o.showAddFilesPanel === a.showAddFilesPanel && o.showFileEditor === a.showFileEditor && o.activeOverlayType === a.activeOverlayType || (this.setPluginState(a), this.uppy.emit("dashboard:close-panel", o.activePickerPanel.id)) }, this.showPanel = o => { let { targets: a } = this.getPluginState(), l = a.filter(h => h.type === "acquirer" && h.id === o)[0]; this.setPluginState({ activePickerPanel: l, activeOverlayType: "PickerPanel" }), this.uppy.emit("dashboard:show-panel", o) }, this.canEditFile = o => { let { targets: a } = this.getPluginState(); return Me(this, gr)[gr](a).some(h => this.uppy.getPlugin(h.id).canEditFile(o)) }, this.openFileEditor = o => { let { targets: a } = this.getPluginState(), l = Me(this, gr)[gr](a); this.setPluginState({ showFileEditor: !0, fileCardFor: o.id || null, activeOverlayType: "FileEditor" }), l.forEach(h => { this.uppy.getPlugin(h.id).selectFile(o) }) }, this.saveFileEditor = () => { let { targets: o } = this.getPluginState(); Me(this, gr)[gr](o).forEach(l => { this.uppy.getPlugin(l.id).save() }), this.hideAllPanels() }, this.openModal = () => { let { promise: o, resolve: a } = qy(); if (this.savedScrollPosition = window.pageYOffset, this.savedActiveElement = document.activeElement, this.opts.disablePageScrollWhenModalOpen && document.body.classList.add("uppy-Dashboard-isFixed"), this.opts.animateOpenClose && this.getPluginState().isClosing) { let l = n(() => { this.setPluginState({ isHidden: !1 }), this.el.removeEventListener("animationend", l, !1), a() }, "handler"); this.el.addEventListener("animationend", l, !1) } else this.setPluginState({ isHidden: !1 }), a(); return this.opts.browserBackButtonClose && this.updateBrowserHistory(), document.addEventListener("keydown", this.handleKeyDownInModal), this.uppy.emit("dashboard:modal-open"), o }, this.closeModal = function (o) { o === void 0 && (o = {}); let { manualClose: a = !0 } = o, { isHidden: l, isClosing: h } = r.getPluginState(); if (l || h) return; let { promise: c, resolve: d } = qy(); if (r.opts.disablePageScrollWhenModalOpen && document.body.classList.remove("uppy-Dashboard-isFixed"), r.opts.animateOpenClose) { r.setPluginState({ isClosing: !0 }); let y = n(() => { r.setPluginState({ isHidden: !0, isClosing: !1 }), r.superFocus.cancel(), r.savedActiveElement.focus(), r.el.removeEventListener("animationend", y, !1), d() }, "handler"); r.el.addEventListener("animationend", y, !1) } else r.setPluginState({ isHidden: !0 }), r.superFocus.cancel(), r.savedActiveElement.focus(), d(); if (document.removeEventListener("keydown", r.handleKeyDownInModal), a && r.opts.browserBackButtonClose) { var p; (p = history.state) != null && p[r.modalName] && history.back() } return r.uppy.emit("dashboard:modal-closed"), c }, this.isModalOpen = () => !this.getPluginState().isHidden || !1, this.requestCloseModal = () => this.opts.onRequestCloseModal ? this.opts.onRequestCloseModal() : this.closeModal(), this.setDarkModeCapability = o => { let { capabilities: a } = this.uppy.getState(); this.uppy.setState({ capabilities: { ...a, darkMode: o } }) }, this.handleSystemDarkModeChange = o => { let a = o.matches; this.uppy.log(`[Dashboard] Dark mode is ${a ? "on" : "off"}`), this.setDarkModeCapability(a) }, this.toggleFileCard = (o, a) => { let l = this.uppy.getFile(a); o ? this.uppy.emit("dashboard:file-edit-start", l) : this.uppy.emit("dashboard:file-edit-complete", l), this.setPluginState({ fileCardFor: o ? a : null, activeOverlayType: o ? "FileCard" : null }) }, this.toggleAddFilesPanel = o => { this.setPluginState({ showAddFilesPanel: o, activeOverlayType: o ? "AddFiles" : null }) }, this.addFiles = o => { let a = o.map(l => ({ source: this.id, name: l.name, type: l.type, data: l, meta: { relativePath: l.relativePath || l.webkitRelativePath || null } })); try { this.uppy.addFiles(a) } catch (l) { this.uppy.log(l) } }, this.startListeningToResize = () => { this.resizeObserver = new ResizeObserver(o => { let a = o[0], { width: l, height: h } = a.contentRect; this.setPluginState({ containerWidth: l, containerHeight: h, areInsidesReadyToBeVisible: !0 }) }), this.resizeObserver.observe(this.el.querySelector(".uppy-Dashboard-inner")), this.makeDashboardInsidesVisibleAnywayTimeout = setTimeout(() => { let o = this.getPluginState(), a = !this.opts.inline && o.isHidden; !o.areInsidesReadyToBeVisible && !a && (this.uppy.log("[Dashboard] resize event didn\u2019t fire on time: defaulted to mobile layout", "warning"), this.setPluginState({ areInsidesReadyToBeVisible: !0 })) }, 1e3) }, this.stopListeningToResize = () => { this.resizeObserver.disconnect(), clearTimeout(this.makeDashboardInsidesVisibleAnywayTimeout) }, this.recordIfFocusedOnUppyRecently = o => { this.el.contains(o.target) ? this.ifFocusedOnUppyRecently = !0 : (this.ifFocusedOnUppyRecently = !1, this.superFocus.cancel()) }, this.disableInteractiveElements = o => { var a; let l = ["a[href]", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", '[role="button"]:not([disabled])'], h = (a = Me(this, Es)[Es]) != null ? a : De(this.el.querySelectorAll(l)).filter(c => !c.classList.contains("uppy-Dashboard-close")); for (let c of h) c.tagName === "A" ? c.setAttribute("aria-disabled", o) : c.disabled = o; o ? Me(this, Es)[Es] = h : Me(this, Es)[Es] = null, this.dashboardIsDisabled = o }, this.updateBrowserHistory = () => { var o; (o = history.state) != null && o[this.modalName] || history.pushState({ ...history.state, [this.modalName]: !0 }, ""), window.addEventListener("popstate", this.handlePopState, !1) }, this.handlePopState = o => { var a; this.isModalOpen() && (!o.state || !o.state[this.modalName]) && this.closeModal({ manualClose: !1 }), !this.isModalOpen() && (a = o.state) != null && a[this.modalName] && history.back() }, this.handleKeyDownInModal = o => { o.keyCode === FP && this.requestCloseModal(o), o.keyCode === Hy && Nc(o, this.getPluginState().activeOverlayType, this.el) }, this.handleClickOutside = () => { this.opts.closeModalOnClickOutside && this.requestCloseModal() }, this.handlePaste = o => { this.uppy.iteratePlugins(l => { l.type === "acquirer" && (l.handleRootPaste == null || l.handleRootPaste(o)) }); let a = De(o.clipboardData.files); a.length > 0 && (this.uppy.log("[Dashboard] Files pasted"), this.addFiles(a)) }, this.handleInputChange = o => { o.preventDefault(); let a = De(o.target.files); a.length > 0 && (this.uppy.log("[Dashboard] Files selected through input"), this.addFiles(a)) }, this.handleDragOver = o => { var a, l; o.preventDefault(), o.stopPropagation(); let h = n(() => { let y = !0; return this.uppy.iteratePlugins(v => { v.canHandleRootDrop != null && v.canHandleRootDrop(o) && (y = !0) }), y }, "canSomePluginHandleRootDrop"), c = n(() => { let { types: y } = o.dataTransfer; return y.some(v => v === "Files") }, "doesEventHaveFiles"), d = h(o), p = c(o); if (!d && !p || this.opts.disabled || this.opts.disableLocalFiles && (p || !d) || !this.uppy.getState().allowNewUpload) { o.dataTransfer.dropEffect = "none", clearTimeout(this.removeDragOverClassTimeout); return } o.dataTransfer.dropEffect = "copy", clearTimeout(this.removeDragOverClassTimeout), this.setPluginState({ isDraggingOver: !0 }), (a = (l = this.opts).onDragOver) == null || a.call(l, o) }, this.handleDragLeave = o => { var a, l; o.preventDefault(), o.stopPropagation(), clearTimeout(this.removeDragOverClassTimeout), this.removeDragOverClassTimeout = setTimeout(() => { this.setPluginState({ isDraggingOver: !1 }) }, 50), (a = (l = this.opts).onDragLeave) == null || a.call(l, o) }, this.handleDrop = async o => { var a, l; o.preventDefault(), o.stopPropagation(), clearTimeout(this.removeDragOverClassTimeout), this.setPluginState({ isDraggingOver: !1 }), this.uppy.iteratePlugins(p => { p.type === "acquirer" && (p.handleRootDrop == null || p.handleRootDrop(o)) }); let h = !1, c = n(p => { this.uppy.log(p, "error"), h || (this.uppy.info(p.message, "error"), h = !0) }, "logDropError"); this.uppy.log("[Dashboard] Processing dropped files"); let d = await Ps(o.dataTransfer, { logDropError: c }); d.length > 0 && (this.uppy.log("[Dashboard] Files dropped"), this.addFiles(d)), (a = (l = this.opts).onDrop) == null || a.call(l, o) }, this.handleRequestThumbnail = o => { this.opts.waitForThumbnailsBeforeUpload || this.uppy.emit("thumbnail:request", o) }, this.handleCancelThumbnail = o => { this.opts.waitForThumbnailsBeforeUpload || this.uppy.emit("thumbnail:cancel", o) }, this.handleKeyDownInInline = o => { o.keyCode === Hy && my(o, this.getPluginState().activeOverlayType, this.el) }, this.handlePasteOnBody = o => { this.el.contains(document.activeElement) && this.handlePaste(o) }, this.handleComplete = o => { let { failed: a } = o; this.opts.closeAfterFinish && a.length === 0 && this.requestCloseModal() }, this.handleCancelRestore = () => { this.uppy.emit("restore-canceled") }, Object.defineProperty(this, mr, { writable: !0, value: () => { if (this.opts.disableThumbnailGenerator) return; let o = 600, a = this.uppy.getFiles(); if (a.length === 1) { let l = this.uppy.getPlugin(`${this.id}:ThumbnailGenerator`); l?.setOptions({ thumbnailWidth: o }); let h = { ...a[0], preview: void 0 }; l.requestThumbnail(h).then(() => { l?.setOptions({ thumbnailWidth: this.opts.thumbnailWidth }) }) } } }), Object.defineProperty(this, ma, { writable: !0, value: o => { let a = o[0]; this.canEditFile(a) && this.openFileEditor(a) } }), this.initEvents = () => { if (this.opts.trigger && !this.opts.inline) { let o = Ou(this.opts.trigger); o ? o.forEach(a => a.addEventListener("click", this.openModal)) : this.uppy.log("Dashboard modal trigger not found. Make sure `trigger` is set in Dashboard options, unless you are planning to call `dashboard.openModal()` method yourself", "warning") } this.startListeningToResize(), document.addEventListener("paste", this.handlePasteOnBody), this.uppy.on("plugin-remove", this.removeTarget), this.uppy.on("file-added", this.hideAllPanels), this.uppy.on("dashboard:modal-closed", this.hideAllPanels), this.uppy.on("file-editor:complete", this.hideAllPanels), this.uppy.on("complete", this.handleComplete), this.uppy.on("files-added", Me(this, mr)[mr]), this.uppy.on("file-removed", Me(this, mr)[mr]), document.addEventListener("focus", this.recordIfFocusedOnUppyRecently, !0), document.addEventListener("click", this.recordIfFocusedOnUppyRecently, !0), this.opts.inline && this.el.addEventListener("keydown", this.handleKeyDownInInline), this.opts.autoOpenFileEditor && this.uppy.on("files-added", Me(this, ma)[ma]) }, this.removeEvents = () => { let o = Ou(this.opts.trigger); !this.opts.inline && o && o.forEach(a => a.removeEventListener("click", this.openModal)), this.stopListeningToResize(), document.removeEventListener("paste", this.handlePasteOnBody), window.removeEventListener("popstate", this.handlePopState, !1), this.uppy.off("plugin-remove", this.removeTarget), this.uppy.off("file-added", this.hideAllPanels), this.uppy.off("dashboard:modal-closed", this.hideAllPanels), this.uppy.off("file-editor:complete", this.hideAllPanels), this.uppy.off("complete", this.handleComplete), this.uppy.off("files-added", Me(this, mr)[mr]), this.uppy.off("file-removed", Me(this, mr)[mr]), document.removeEventListener("focus", this.recordIfFocusedOnUppyRecently), document.removeEventListener("click", this.recordIfFocusedOnUppyRecently), this.opts.inline && this.el.removeEventListener("keydown", this.handleKeyDownInInline), this.opts.autoOpenFileEditor && this.uppy.off("files-added", Me(this, ma)[ma]) }, this.superFocusOnEachUpdate = () => { let o = this.el.contains(document.activeElement), a = document.activeElement === document.body || document.activeElement === null, l = this.uppy.getState().info.length === 0, h = !this.opts.inline; l && (h || o || a && this.ifFocusedOnUppyRecently) ? this.superFocus(this.el, this.getPluginState().activeOverlayType) : this.superFocus.cancel() }, this.afterUpdate = () => { if (this.opts.disabled && !this.dashboardIsDisabled) { this.disableInteractiveElements(!0); return } !this.opts.disabled && this.dashboardIsDisabled && this.disableInteractiveElements(!1), this.superFocusOnEachUpdate() }, this.saveFileCard = (o, a) => { this.uppy.setFileMeta(a, o), this.toggleFileCard(!1, a) }, Object.defineProperty(this, Fs, { writable: !0, value: o => { let a = this.uppy.getPlugin(o.id); return { ...o, icon: a.icon || this.opts.defaultPickerIcon, render: a.render } } }), Object.defineProperty(this, Yc, { writable: !0, value: o => { let a = this.uppy.getPlugin(o.id); return typeof a.isSupported != "function" ? !0 : a.isSupported() } }), Object.defineProperty(this, Qc, { writable: !0, value: Xc(o => o.filter(a => a.type === "acquirer" && Me(this, Yc)[Yc](a)).map(Me(this, Fs)[Fs])) }), Object.defineProperty(this, Jc, { writable: !0, value: Xc(o => o.filter(a => a.type === "progressindicator").map(Me(this, Fs)[Fs])) }), Object.defineProperty(this, gr, { writable: !0, value: Xc(o => o.filter(a => a.type === "editor").map(Me(this, Fs)[Fs])) }), this.render = o => { let a = this.getPluginState(), { files: l, capabilities: h, allowNewUpload: c } = o, { newFiles: d, uploadStartedFiles: p, completeFiles: y, erroredFiles: v, inProgressFiles: S, inProgressNotPausedFiles: x, processingFiles: E, isUploadStarted: F, isAllComplete: k, isAllErrored: B, isAllPaused: H } = this.uppy.getObjectOfFilesPerState(), W = Me(this, Qc)[Qc](a.targets), I = Me(this, Jc)[Jc](a.targets), q = Me(this, gr)[gr](a.targets), $; return this.opts.theme === "auto" ? $ = h.darkMode ? "dark" : "light" : $ = this.opts.theme, ["files", "folders", "both"].indexOf(this.opts.fileManagerSelectionType) < 0 && (this.opts.fileManagerSelectionType = "files", console.warn(`Unsupported option for "fileManagerSelectionType". Using default of "${this.opts.fileManagerSelectionType}".`)), Gc({ state: o, isHidden: a.isHidden, files: l, newFiles: d, uploadStartedFiles: p, completeFiles: y, erroredFiles: v, inProgressFiles: S, inProgressNotPausedFiles: x, processingFiles: E, isUploadStarted: F, isAllComplete: k, isAllErrored: B, isAllPaused: H, totalFileCount: Object.keys(l).length, totalProgress: o.totalProgress, allowNewUpload: c, acquirers: W, theme: $, disabled: this.opts.disabled, disableLocalFiles: this.opts.disableLocalFiles, direction: this.opts.direction, activePickerPanel: a.activePickerPanel, showFileEditor: a.showFileEditor, saveFileEditor: this.saveFileEditor, disableInteractiveElements: this.disableInteractiveElements, animateOpenClose: this.opts.animateOpenClose, isClosing: a.isClosing, progressindicators: I, editors: q, autoProceed: this.uppy.opts.autoProceed, id: this.id, closeModal: this.requestCloseModal, handleClickOutside: this.handleClickOutside, handleInputChange: this.handleInputChange, handlePaste: this.handlePaste, inline: this.opts.inline, showPanel: this.showPanel, hideAllPanels: this.hideAllPanels, i18n: this.i18n, i18nArray: this.i18nArray, uppy: this.uppy, note: this.opts.note, recoveredState: o.recoveredState, metaFields: a.metaFields, resumableUploads: h.resumableUploads || !1, individualCancellation: h.individualCancellation, isMobileDevice: h.isMobileDevice, fileCardFor: a.fileCardFor, toggleFileCard: this.toggleFileCard, toggleAddFilesPanel: this.toggleAddFilesPanel, showAddFilesPanel: a.showAddFilesPanel, saveFileCard: this.saveFileCard, openFileEditor: this.openFileEditor, canEditFile: this.canEditFile, width: this.opts.width, height: this.opts.height, showLinkToFileUploadResult: this.opts.showLinkToFileUploadResult, fileManagerSelectionType: this.opts.fileManagerSelectionType, proudlyDisplayPoweredByUppy: this.opts.proudlyDisplayPoweredByUppy, hideCancelButton: this.opts.hideCancelButton, hideRetryButton: this.opts.hideRetryButton, hidePauseResumeButton: this.opts.hidePauseResumeButton, showRemoveButtonAfterComplete: this.opts.showRemoveButtonAfterComplete, containerWidth: a.containerWidth, containerHeight: a.containerHeight, areInsidesReadyToBeVisible: a.areInsidesReadyToBeVisible, isTargetDOMEl: this.isTargetDOMEl, parentElement: this.el, allowedFileTypes: this.uppy.opts.restrictions.allowedFileTypes, maxNumberOfFiles: this.uppy.opts.restrictions.maxNumberOfFiles, requiredMetaFields: this.uppy.opts.restrictions.requiredMetaFields, showSelectedFiles: this.opts.showSelectedFiles, showNativePhotoCameraButton: this.opts.showNativePhotoCameraButton, showNativeVideoCameraButton: this.opts.showNativeVideoCameraButton, nativeCameraFacingMode: this.opts.nativeCameraFacingMode, singleFileFullScreen: this.opts.singleFileFullScreen, handleCancelRestore: this.handleCancelRestore, handleRequestThumbnail: this.handleRequestThumbnail, handleCancelThumbnail: this.handleCancelThumbnail, isDraggingOver: a.isDraggingOver, handleDragOver: this.handleDragOver, handleDragLeave: this.handleDragLeave, handleDrop: this.handleDrop }) }, this.discoverProviderPlugins = () => { this.uppy.iteratePlugins(o => { o && !o.target && o.opts && o.opts.target === this.constructor && this.addTarget(o) }) }, this.install = () => { this.setPluginState({ isHidden: !0, fileCardFor: null, activeOverlayType: null, showAddFilesPanel: !1, activePickerPanel: !1, showFileEditor: !1, metaFields: this.opts.metaFields, targets: [], areInsidesReadyToBeVisible: !1, isDraggingOver: !1 }); let { inline: o, closeAfterFinish: a } = this.opts; if (o && a) throw new Error("[Dashboard] `closeAfterFinish: true` cannot be used on an inline Dashboard, because an inline Dashboard cannot be closed at all. Either set `inline: false`, or disable the `closeAfterFinish` option."); let { allowMultipleUploads: l, allowMultipleUploadBatches: h } = this.uppy.opts; (l || h) && a && this.uppy.log("[Dashboard] When using `closeAfterFinish`, we recommended setting the `allowMultipleUploadBatches` option to `false` in the Uppy constructor. See https://uppy.io/docs/uppy/#allowMultipleUploads-true", "warning"); let { target: c } = this.opts; c && this.mount(c, this), (this.opts.plugins || []).forEach(y => { let v = this.uppy.getPlugin(y); v && v.mount(this, v) }), this.opts.disableStatusBar || this.uppy.use(Ci, { id: `${this.id}:StatusBar`, target: this, hideUploadButton: this.opts.hideUploadButton, hideRetryButton: this.opts.hideRetryButton, hidePauseResumeButton: this.opts.hidePauseResumeButton, hideCancelButton: this.opts.hideCancelButton, showProgressDetails: this.opts.showProgressDetails, hideAfterFinish: this.opts.hideProgressAfterFinish, locale: this.opts.locale, doneButtonHandler: this.opts.doneButtonHandler }), this.opts.disableInformer || this.uppy.use(Ri, { id: `${this.id}:Informer`, target: this }), this.opts.disableThumbnailGenerator || this.uppy.use(fr, { id: `${this.id}:ThumbnailGenerator`, thumbnailWidth: this.opts.thumbnailWidth, thumbnailHeight: this.opts.thumbnailHeight, thumbnailType: this.opts.thumbnailType, waitForThumbnailsBeforeUpload: this.opts.waitForThumbnailsBeforeUpload, lazy: !this.opts.waitForThumbnailsBeforeUpload }), this.darkModeMediaQuery = typeof window < "u" && window.matchMedia ? window.matchMedia("(prefers-color-scheme: dark)") : null; let p = this.darkModeMediaQuery ? this.darkModeMediaQuery.matches : !1; this.uppy.log(`[Dashboard] Dark mode is ${p ? "on" : "off"}`), this.setDarkModeCapability(p), this.opts.theme === "auto" && this.darkModeMediaQuery.addListener(this.handleSystemDarkModeChange), this.discoverProviderPlugins(), this.initEvents() }, this.uninstall = () => { if (!this.opts.disableInformer) { let a = this.uppy.getPlugin(`${this.id}:Informer`); a && this.uppy.removePlugin(a) } if (!this.opts.disableStatusBar) { let a = this.uppy.getPlugin(`${this.id}:StatusBar`); a && this.uppy.removePlugin(a) } if (!this.opts.disableThumbnailGenerator) { let a = this.uppy.getPlugin(`${this.id}:ThumbnailGenerator`); a && this.uppy.removePlugin(a) } (this.opts.plugins || []).forEach(a => { let l = this.uppy.getPlugin(a); l && l.unmount() }), this.opts.theme === "auto" && this.darkModeMediaQuery.removeListener(this.handleSystemDarkModeChange), this.unmount(), this.removeEvents() }, this.id = this.opts.id || "Dashboard", this.title = "Dashboard", this.type = "orchestrator", this.modalName = `uppy-Dashboard-${ot()}`, this.defaultLocale = jy; let s = { target: "body", metaFields: [], trigger: null, inline: !1, width: 750, height: 550, thumbnailWidth: 280, thumbnailType: "image/jpeg", waitForThumbnailsBeforeUpload: !1, defaultPickerIcon: ko, showLinkToFileUploadResult: !1, showProgressDetails: !1, hideUploadButton: !1, hideCancelButton: !1, hideRetryButton: !1, hidePauseResumeButton: !1, hideProgressAfterFinish: !1, doneButtonHandler: () => { this.uppy.cancelAll(), this.requestCloseModal() }, note: null, closeModalOnClickOutside: !1, closeAfterFinish: !1, singleFileFullScreen: !0, disableStatusBar: !1, disableInformer: !1, disableThumbnailGenerator: !1, disablePageScrollWhenModalOpen: !0, animateOpenClose: !0, fileManagerSelectionType: "files", proudlyDisplayPoweredByUppy: !0, onRequestCloseModal: () => this.closeModal(), showSelectedFiles: !0, showRemoveButtonAfterComplete: !1, browserBackButtonClose: !1, showNativePhotoCameraButton: !1, showNativeVideoCameraButton: !1, theme: "light", autoOpenFileEditor: !1, disabled: !1, disableLocalFiles: !1 }; this.opts = { ...s, ...t }, this.i18nInit(), this.superFocus = Ic(), this.ifFocusedOnUppyRecently = !1, this.makeDashboardInsidesVisibleAnywayTimeout = null, this.removeDragOverClassTimeout = null } }; n(Di, "Dashboard"); Di.VERSION = EP.version; var $y = { strings: { dropHereOr: "Drop here or %{browse}", browse: "browse" } }; var OP = { version: "3.0.3" }, Ni = class extends G {
        constructor(e, t) { super(e, t), this.handleDrop = async s => { var o, a; s.preventDefault(), s.stopPropagation(), clearTimeout(this.removeDragOverClassTimeout), this.setPluginState({ isDraggingOver: !1 }); let l = n(c => { this.uppy.log(c, "error") }, "logDropError"), h = await Ps(s.dataTransfer, { logDropError: l }); h.length > 0 && (this.uppy.log("[DragDrop] Files dropped"), this.addFiles(h)), (o = (a = this.opts).onDrop) == null || o.call(a, s) }, this.type = "acquirer", this.id = this.opts.id || "DragDrop", this.title = "Drag & Drop", this.defaultLocale = $y; let r = { target: null, inputName: "files[]", width: "100%", height: "100%", note: null }; this.opts = { ...r, ...t }, this.i18nInit(), this.isDragDropSupported = ca(), this.removeDragOverClassTimeout = null, this.onInputChange = this.onInputChange.bind(this), this.handleDragOver = this.handleDragOver.bind(this), this.handleDragLeave = this.handleDragLeave.bind(this), this.handleDrop = this.handleDrop.bind(this), this.addFiles = this.addFiles.bind(this), this.render = this.render.bind(this) } addFiles(e) { let t = e.map(r => ({ source: this.id, name: r.name, type: r.type, data: r, meta: { relativePath: r.relativePath || null } })); try { this.uppy.addFiles(t) } catch (r) { this.uppy.log(r) } } onInputChange(e) { let t = De(e.target.files); t.length > 0 && (this.uppy.log("[DragDrop] Files selected through input"), this.addFiles(t)), e.target.value = null } handleDragOver(e) { var t, r; e.preventDefault(), e.stopPropagation(); let { types: s } = e.dataTransfer, o = s.some(l => l === "Files"), { allowNewUpload: a } = this.uppy.getState(); if (!o || !a) { e.dataTransfer.dropEffect = "none", clearTimeout(this.removeDragOverClassTimeout); return } e.dataTransfer.dropEffect = "copy", clearTimeout(this.removeDragOverClassTimeout), this.setPluginState({ isDraggingOver: !0 }), (t = (r = this.opts).onDragOver) == null || t.call(r, e) } handleDragLeave(e) { var t, r; e.preventDefault(), e.stopPropagation(), clearTimeout(this.removeDragOverClassTimeout), this.removeDragOverClassTimeout = setTimeout(() => { this.setPluginState({ isDraggingOver: !1 }) }, 50), (t = (r = this.opts).onDragLeave) == null || t.call(r, e) } renderHiddenFileInput() { let { restrictions: e } = this.uppy.opts; return u("input", { className: "uppy-DragDrop-input", type: "file", hidden: !0, ref: t => { this.fileInputRef = t }, name: this.opts.inputName, multiple: e.maxNumberOfFiles !== 1, accept: e.allowedFileTypes, onChange: this.onInputChange }) } static renderArrowSvg() { return u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon uppy-DragDrop-arrow", width: "16", height: "16", viewBox: "0 0 16 16" }, u("path", { d: "M11 10V0H5v10H2l6 6 6-6h-3zm0 0", fillRule: "evenodd" })) } renderLabel() { return u("div", { className: "uppy-DragDrop-label" }, this.i18nArray("dropHereOr", { browse: u("span", { className: "uppy-DragDrop-browse" }, this.i18n("browse")) })) } renderNote() { return u("span", { className: "uppy-DragDrop-note" }, this.opts.note) } render() {
            let e = `uppy-u-reset
      uppy-DragDrop-container
      ${this.isDragDropSupported ? "uppy-DragDrop--isDragDropSupported" : ""}
      ${this.getPluginState().isDraggingOver ? "uppy-DragDrop--isDraggingOver" : ""}
    `, t = { width: this.opts.width, height: this.opts.height }; return u("button", { type: "button", className: e, style: t, onClick: () => this.fileInputRef.click(), onDragOver: this.handleDragOver, onDragLeave: this.handleDragLeave, onDrop: this.handleDrop }, this.renderHiddenFileInput(), u("div", { className: "uppy-DragDrop-inner" }, Ni.renderArrowSvg(), this.renderLabel(), this.renderNote()))
        } install() { let { target: e } = this.opts; this.setPluginState({ isDraggingOver: !1 }), e && this.mount(e, this) } uninstall() { this.unmount() }
    }; n(Ni, "DragDrop"); Ni.VERSION = OP.version; var AP = { version: "2.0.1" }; function Zc(i) { var e, t; return (e = (t = i.dataTransfer.types) == null ? void 0 : t.some(r => r === "Files")) != null ? e : !1 } n(Zc, "isFileTransfer"); var Os = class extends Fe { constructor(e, t) { super(e, t), this.addFiles = s => { let o = s.map(a => ({ source: this.id, name: a.name, type: a.type, data: a, meta: { relativePath: a.relativePath || null } })); try { this.uppy.addFiles(o) } catch (a) { this.uppy.log(a) } }, this.handleDrop = async s => { var o, a; if (!Zc(s)) return; s.preventDefault(), s.stopPropagation(), clearTimeout(this.removeDragOverClassTimeout), s.currentTarget.classList.remove("uppy-is-drag-over"), this.setPluginState({ isDraggingOver: !1 }), this.uppy.iteratePlugins(d => { d.type === "acquirer" && (d.handleRootDrop == null || d.handleRootDrop(s)) }); let l = !1, h = n(d => { this.uppy.log(d, "error"), l || (this.uppy.info(d.message, "error"), l = !0) }, "logDropError"), c = await Ps(s.dataTransfer, { logDropError: h }); c.length > 0 && (this.uppy.log("[DropTarget] Files were dropped"), this.addFiles(c)), (o = (a = this.opts).onDrop) == null || o.call(a, s) }, this.handleDragOver = s => { var o, a; Zc(s) && (s.preventDefault(), s.stopPropagation(), s.dataTransfer.dropEffect = "copy", clearTimeout(this.removeDragOverClassTimeout), s.currentTarget.classList.add("uppy-is-drag-over"), this.setPluginState({ isDraggingOver: !0 }), (o = (a = this.opts).onDragOver) == null || o.call(a, s)) }, this.handleDragLeave = s => { var o, a; if (!Zc(s)) return; s.preventDefault(), s.stopPropagation(); let { currentTarget: l } = s; clearTimeout(this.removeDragOverClassTimeout), this.removeDragOverClassTimeout = setTimeout(() => { l.classList.remove("uppy-is-drag-over"), this.setPluginState({ isDraggingOver: !1 }) }, 50), (o = (a = this.opts).onDragLeave) == null || o.call(a, s) }, this.addListeners = () => { let { target: s } = this.opts; if (s instanceof Element ? this.nodes = [s] : typeof s == "string" && (this.nodes = De(document.querySelectorAll(s))), !this.nodes && !this.nodes.length > 0) throw new Error(`"${s}" does not match any HTML elements`); this.nodes.forEach(o => { o.addEventListener("dragover", this.handleDragOver, !1), o.addEventListener("dragleave", this.handleDragLeave, !1), o.addEventListener("drop", this.handleDrop, !1) }) }, this.removeListeners = () => { this.nodes && this.nodes.forEach(s => { s.removeEventListener("dragover", this.handleDragOver, !1), s.removeEventListener("dragleave", this.handleDragLeave, !1), s.removeEventListener("drop", this.handleDrop, !1) }) }, this.type = "acquirer", this.id = this.opts.id || "DropTarget", this.title = "Drop Target"; let r = { target: null }; this.opts = { ...r, ...t }, this.removeDragOverClassTimeout = null } install() { this.setPluginState({ isDraggingOver: !1 }), this.addListeners() } uninstall() { this.removeListeners() } }; n(Os, "DropTarget"); Os.VERSION = AP.version; var Vy = { strings: { chooseFiles: "Choose files" } }; var TP = { version: "3.0.3" }, Hr = class extends G { constructor(e, t) { super(e, t), this.id = this.opts.id || "FileInput", this.title = "File Input", this.type = "acquirer", this.defaultLocale = Vy; let r = { target: null, pretty: !0, inputName: "files[]" }; this.opts = { ...r, ...t }, this.i18nInit(), this.render = this.render.bind(this), this.handleInputChange = this.handleInputChange.bind(this), this.handleClick = this.handleClick.bind(this) } addFiles(e) { let t = e.map(r => ({ source: this.id, name: r.name, type: r.type, data: r })); try { this.uppy.addFiles(t) } catch (r) { this.uppy.log(r) } } handleInputChange(e) { this.uppy.log("[FileInput] Something selected through input..."); let t = De(e.target.files); this.addFiles(t), e.target.value = null } handleClick() { this.input.click() } render() { let e = { width: "0.1px", height: "0.1px", opacity: 0, overflow: "hidden", position: "absolute", zIndex: -1 }, { restrictions: t } = this.uppy.opts, r = t.allowedFileTypes ? t.allowedFileTypes.join(",") : null; return u("div", { className: "uppy-FileInput-container" }, u("input", { className: "uppy-FileInput-input", style: this.opts.pretty && e, type: "file", name: this.opts.inputName, onChange: this.handleInputChange, multiple: t.maxNumberOfFiles !== 1, accept: r, ref: s => { this.input = s } }), this.opts.pretty && u("button", { className: "uppy-FileInput-btn", type: "button", onClick: this.handleClick }, this.i18n("chooseFiles"))) } install() { let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.unmount() } }; n(Hr, "FileInput"); Hr.VERSION = TP.version; var Ky = se(Wy(), 1); var qo = class extends ue { constructor(e) { super(e), this.granularRotateOnChange = t => { let { rotationAngle: r, rotationDelta: s } = this.state, o = Number(t.target.value) - s; if (cancelAnimationFrame(this.granularRotateOnInputNextFrame), o !== 0) { let a = r + o; this.granularRotateOnInputNextFrame = requestAnimationFrame(() => { this.cropper.rotateTo(a) }) } }, this.state = { rotationAngle: 0, rotationDelta: 0 } } componentDidMount() { let { opts: e, storeCropperInstance: t } = this.props; this.cropper = new Ky.default(this.imgElement, e.cropperOptions), t(this.cropper), e.actions.granularRotate && this.imgElement.addEventListener("crop", r => { let s = r.detail.rotate; this.setState({ rotationAngle: s, rotationDelta: (s + 405) % 90 - 45 }) }) } componentWillUnmount() { this.cropper.destroy() } renderGranularRotate() { let { i18n: e } = this.props, { rotationDelta: t, rotationAngle: r } = this.state; return u("label", { "data-microtip-position": "top", role: "tooltip", "aria-label": `${r}\xBA`, className: "uppy-ImageCropper-rangeWrapper uppy-u-reset" }, u("input", { className: "uppy-ImageCropper-range uppy-u-reset", type: "range", onInput: this.granularRotateOnChange, onChange: this.granularRotateOnChange, value: t, min: "-45", max: "44", "aria-label": e("rotate") })) } renderRevert() { let { i18n: e } = this.props; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", "aria-label": e("revert"), "data-microtip-position": "top", onClick: () => { this.cropper.reset(), this.cropper.setAspectRatio(0) } }, u("svg", { "aria-hidden": "true", className: "uppy-c-icon", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M0 0h24v24H0z", fill: "none" }), u("path", { d: "M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z" }))) } renderRotate() { let { i18n: e } = this.props; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", onClick: () => this.cropper.rotate(-90), "aria-label": e("rotate"), "data-microtip-position": "top" }, u("svg", { "aria-hidden": "true", className: "uppy-c-icon", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M0 0h24v24H0V0zm0 0h24v24H0V0z", fill: "none" }), u("path", { d: "M14 10a2 2 0 012 2v7a2 2 0 01-2 2H6a2 2 0 01-2-2v-7a2 2 0 012-2h8zm0 1.75H6a.25.25 0 00-.243.193L5.75 12v7a.25.25 0 00.193.243L6 19.25h8a.25.25 0 00.243-.193L14.25 19v-7a.25.25 0 00-.193-.243L14 11.75zM12 .76V4c2.3 0 4.61.88 6.36 2.64a8.95 8.95 0 012.634 6.025L21 13a1 1 0 01-1.993.117L19 13h-.003a6.979 6.979 0 00-2.047-4.95 6.97 6.97 0 00-4.652-2.044L12 6v3.24L7.76 5 12 .76z" }))) } renderFlip() { let { i18n: e } = this.props; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", "aria-label": e("flipHorizontal"), "data-microtip-position": "top", onClick: () => this.cropper.scaleX(-this.cropper.getData().scaleX || -1) }, u("svg", { "aria-hidden": "true", className: "uppy-c-icon", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M0 0h24v24H0z", fill: "none" }), u("path", { d: "M15 21h2v-2h-2v2zm4-12h2V7h-2v2zM3 5v14c0 1.1.9 2 2 2h4v-2H5V5h4V3H5c-1.1 0-2 .9-2 2zm16-2v2h2c0-1.1-.9-2-2-2zm-8 20h2V1h-2v22zm8-6h2v-2h-2v2zM15 5h2V3h-2v2zm4 8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2z" }))) } renderZoomIn() { let { i18n: e } = this.props; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", "aria-label": e("zoomIn"), "data-microtip-position": "top", onClick: () => this.cropper.zoom(.1) }, u("svg", { "aria-hidden": "true", className: "uppy-c-icon", height: "24", viewBox: "0 0 24 24", width: "24" }, u("path", { d: "M0 0h24v24H0V0z", fill: "none" }), u("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }), u("path", { d: "M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z" }))) } renderZoomOut() { let { i18n: e } = this.props; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", "aria-label": e("zoomOut"), "data-microtip-position": "top", onClick: () => this.cropper.zoom(-.1) }, u("svg", { "aria-hidden": "true", className: "uppy-c-icon", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M0 0h24v24H0V0z", fill: "none" }), u("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z" }))) } renderCropSquare() { let { i18n: e } = this.props; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", "aria-label": e("aspectRatioSquare"), "data-microtip-position": "top", onClick: () => this.cropper.setAspectRatio(1) }, u("svg", { "aria-hidden": "true", className: "uppy-c-icon", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M0 0h24v24H0z", fill: "none" }), u("path", { d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z" }))) } renderCropWidescreen() { let { i18n: e } = this.props; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", "aria-label": e("aspectRatioLandscape"), "data-microtip-position": "top", onClick: () => this.cropper.setAspectRatio(16 / 9) }, u("svg", { "aria-hidden": "true", className: "uppy-c-icon", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M 19,4.9999992 V 17.000001 H 4.9999998 V 6.9999992 H 19 m 0,-2 H 4.9999998 c -1.0999999,0 -1.9999999,0.9000001 -1.9999999,2 V 17.000001 c 0,1.1 0.9,2 1.9999999,2 H 19 c 1.1,0 2,-0.9 2,-2 V 6.9999992 c 0,-1.0999999 -0.9,-2 -2,-2 z" }), u("path", { fill: "none", d: "M0 0h24v24H0z" }))) } renderCropWidescreenVertical() { let { i18n: e } = this.props; return u("button", { type: "button", className: "uppy-u-reset uppy-c-btn", "aria-label": e("aspectRatioPortrait"), "data-microtip-position": "top", onClick: () => this.cropper.setAspectRatio(9 / 16) }, u("svg", { "aria-hidden": "true", className: "uppy-c-icon", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M 19.000001,19 H 6.999999 V 5 h 10.000002 v 14 m 2,0 V 5 c 0,-1.0999999 -0.9,-1.9999999 -2,-1.9999999 H 6.999999 c -1.1,0 -2,0.9 -2,1.9999999 v 14 c 0,1.1 0.9,2 2,2 h 10.000002 c 1.1,0 2,-0.9 2,-2 z" }), u("path", { d: "M0 0h24v24H0z", fill: "none" }))) } render() { let { currentImage: e, opts: t } = this.props, { actions: r } = t, s = URL.createObjectURL(e.data); return u("div", { className: "uppy-ImageCropper" }, u("div", { className: "uppy-ImageCropper-container" }, u("img", { className: "uppy-ImageCropper-image", alt: e.name, src: s, ref: o => { this.imgElement = o } })), u("div", { className: "uppy-ImageCropper-controls" }, r.revert && this.renderRevert(), r.rotate && this.renderRotate(), r.granularRotate && this.renderGranularRotate(), r.flip && this.renderFlip(), r.zoomIn && this.renderZoomIn(), r.zoomOut && this.renderZoomOut(), r.cropSquare && this.renderCropSquare(), r.cropWidescreen && this.renderCropWidescreen(), r.cropWidescreenVertical && this.renderCropWidescreenVertical())) } }; n(qo, "Editor"); var Gy = { strings: { revert: "Revert", rotate: "Rotate", zoomIn: "Zoom in", zoomOut: "Zoom out", flipHorizontal: "Flip horizontal", aspectRatioSquare: "Crop square", aspectRatioLandscape: "Crop landscape (16:9)", aspectRatioPortrait: "Crop portrait (9:16)" } }; var CP = { version: "2.1.3" }, qr = class extends G { constructor(e, t) { super(e, t), this.save = () => { let a = n(h => { let { currentImage: c } = this.getPluginState(); this.uppy.setFileState(c.id, { data: h, size: h.size, preview: null }); let d = this.uppy.getFile(c.id); this.uppy.emit("thumbnail:request", d), this.setPluginState({ currentImage: d }), this.uppy.emit("file-editor:complete", d) }, "saveBlobCallback"), { currentImage: l } = this.getPluginState(); this.cropper.getCroppedCanvas(this.opts.cropperOptions.croppedCanvasOptions).toBlob(a, l.type, this.opts.quality) }, this.storeCropperInstance = a => { this.cropper = a }, this.selectFile = a => { this.uppy.emit("file-editor:start", a), this.setPluginState({ currentImage: a }) }, this.id = this.opts.id || "ImageEditor", this.title = "Image Editor", this.type = "editor", this.defaultLocale = Gy; let r = { viewMode: 1, background: !1, autoCropArea: 1, responsive: !0, croppedCanvasOptions: {} }, s = { revert: !0, rotate: !0, granularRotate: !0, flip: !0, zoomIn: !0, zoomOut: !0, cropSquare: !0, cropWidescreen: !0, cropWidescreenVertical: !0 }, o = { quality: .8 }; this.opts = { ...o, ...t, actions: { ...s, ...t.actions }, cropperOptions: { ...r, ...t.cropperOptions } }, this.i18nInit() } canEditFile(e) { if (!e.type || e.isRemote) return !1; let t = e.type.split("/")[1]; return !!/^(jpe?g|gif|png|bmp|webp)$/.test(t) } install() { this.setPluginState({ currentImage: null }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { let { currentImage: e } = this.getPluginState(); if (e) { let t = this.uppy.getFile(e.id); this.uppy.emit("file-editor:cancel", t) } this.unmount() } render() { let { currentImage: e } = this.getPluginState(); return e === null || e.isRemote ? null : u(qo, { currentImage: e, storeCropperInstance: this.storeCropperInstance, save: this.save, opts: this.opts, i18n: this.i18n }) } }; n(qr, "ImageEditor"); qr.VERSION = CP.version; var RP = { version: "3.0.3" }, $r = class extends G { constructor(e, t) { super(e, t), this.id = this.opts.id || "ProgressBar", this.title = "Progress Bar", this.type = "progressindicator"; let r = { target: "body", fixed: !1, hideAfterFinish: !0 }; this.opts = { ...r, ...t }, this.render = this.render.bind(this) } render(e) { let t = e.totalProgress || 0, r = (t === 0 || t === 100) && this.opts.hideAfterFinish; return u("div", { className: "uppy uppy-ProgressBar", style: { position: this.opts.fixed ? "fixed" : "initial" }, "aria-hidden": r }, u("div", { className: "uppy-ProgressBar-inner", style: { width: `${t}%` } }), u("div", { className: "uppy-ProgressBar-percentage" }, t)) } install() { let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.unmount() } }; n($r, "ProgressBar"); $r.VERSION = RP.version; var kP = { "audio/mp3": "mp3", "audio/mp4": "mp4", "audio/ogg": "ogg", "audio/webm": "webm", "image/gif": "gif", "image/heic": "heic", "image/heif": "heif", "image/jpeg": "jpg", "image/png": "png", "image/svg+xml": "svg", "video/mp4": "mp4", "video/ogg": "ogv", "video/quicktime": "mov", "video/webm": "webm", "video/x-matroska": "mkv", "video/x-msvideo": "avi" }; function Ii(i) { return [i] = i.split(";", 1), kP[i] || null } n(Ii, "getFileTypeExtension"); function id() { var i; return typeof MediaRecorder == "function" && typeof ((i = MediaRecorder.prototype) == null ? void 0 : i.start) == "function" } n(id, "supportsMediaRecorder"); function rd(i) { let { recording: e, onStartRecording: t, onStopRecording: r, i18n: s } = i; return e ? u("button", { className: "uppy-u-reset uppy-c-btn uppy-Audio-button", type: "button", title: s("stopAudioRecording"), "aria-label": s("stopAudioRecording"), onClick: r, "data-uppy-super-focusable": !0 }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "100", height: "100", viewBox: "0 0 100 100" }, u("rect", { x: "15", y: "15", width: "70", height: "70" }))) : u("button", { className: "uppy-u-reset uppy-c-btn uppy-Audio-button", type: "button", title: s("startAudioRecording"), "aria-label": s("startAudioRecording"), onClick: t, "data-uppy-super-focusable": !0 }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "14px", height: "20px", viewBox: "0 0 14 20" }, u("path", { d: "M7 14c2.21 0 4-1.71 4-3.818V3.818C11 1.71 9.21 0 7 0S3 1.71 3 3.818v6.364C3 12.29 4.79 14 7 14zm6.364-7h-.637a.643.643 0 0 0-.636.65V9.6c0 3.039-2.565 5.477-5.6 5.175-2.645-.264-4.582-2.692-4.582-5.407V7.65c0-.36-.285-.65-.636-.65H.636A.643.643 0 0 0 0 7.65v1.631c0 3.642 2.544 6.888 6.045 7.382v1.387H3.818a.643.643 0 0 0-.636.65v.65c0 .36.285.65.636.65h6.364c.351 0 .636-.29.636-.65v-.65c0-.36-.285-.65-.636-.65H7.955v-1.372C11.363 16.2 14 13.212 14 9.6V7.65c0-.36-.285-.65-.636-.65z", fill: "#FFF", "fill-rule": "nonzero" }))) } n(rd, "RecordButton"); function sd(i) { return `${Math.floor(i / 60)}:${String(i % 60).padStart(2, 0)}` } n(sd, "formatSeconds"); function od(i) { let { recordingLengthSeconds: e, i18n: t } = i, r = sd(e); return u("span", { "aria-label": t("recordingLength", { recording_length: r }) }, r) } n(od, "RecordingLength"); var Xy = n(i => { let { currentDeviceId: e, audioSources: t, onChangeSource: r } = i; return u("div", { className: "uppy-Audio-videoSource" }, u("select", { className: "uppy-u-reset uppy-Audio-audioSource-select", onChange: s => { r(s.target.value) } }, t.map(s => u("option", { key: s.deviceId, value: s.deviceId, selected: s.deviceId === e }, s.label)))) }, "default"); function UP(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(UP, "_classPrivateFieldLooseBase"); var DP = 0; function NP(i) { return "__private_" + DP++ + "_" + i } n(NP, "_classPrivateFieldLooseKey"); function Yy(i) { return typeof i == "function" } n(Yy, "isFunction"); function ga(i) { return Yy(i) ? i() : i } n(ga, "result"); var nd = NP("draw"), $o = class { constructor(e, t) { t === void 0 && (t = {}), Object.defineProperty(this, nd, { writable: !0, value: () => this.draw() }); let r = t.canvas || {}, s = t.canvasContext || {}; this.analyser = null, this.bufferLength = 0, this.dataArray = [], this.canvas = e, this.width = ga(r.width) || this.canvas.width, this.height = ga(r.height) || this.canvas.height, this.canvas.width = this.width, this.canvas.height = this.height, this.canvasContext = this.canvas.getContext("2d"), this.canvasContext.fillStyle = ga(s.fillStyle) || "rgb(255, 255, 255)", this.canvasContext.strokeStyle = ga(s.strokeStyle) || "rgb(0, 0, 0)", this.canvasContext.lineWidth = ga(s.lineWidth) || 1, this.onDrawFrame = Yy(t.onDrawFrame) ? t.onDrawFrame : () => { } } addSource(e) { this.streamSource = e, this.audioContext = this.streamSource.context, this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = 2048, this.bufferLength = this.analyser.frequencyBinCount, this.source = this.audioContext.createBufferSource(), this.dataArray = new Uint8Array(this.bufferLength), this.analyser.getByteTimeDomainData(this.dataArray), this.streamSource.connect(this.analyser) } draw() { let { analyser: e, dataArray: t, bufferLength: r } = this, s = this.canvasContext, o = this.width, a = this.height; e && e.getByteTimeDomainData(t), s.fillRect(0, 0, o, a), s.beginPath(); let l = o * 1 / r, h = 0; r || s.moveTo(0, this.height / 2); for (let c = 0; c < r; c++) { let p = t[c] / 128 * (a / 2); c === 0 ? s.moveTo(h, p) : s.lineTo(h, p), h += l } s.lineTo(o, a / 2), s.stroke(), this.onDrawFrame(this), requestAnimationFrame(UP(this, nd)[nd]) } }; n($o, "AudioOscilloscope"); function IP(i) { let { onSubmit: e, i18n: t } = i; return u("button", { className: "uppy-u-reset uppy-c-btn uppy-Audio-button uppy-Audio-button--submit", type: "button", title: t("submitRecordedFile"), "aria-label": t("submitRecordedFile"), onClick: e, "data-uppy-super-focusable": !0 }, u("svg", { width: "12", height: "9", viewBox: "0 0 12 9", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", focusable: "false", className: "uppy-c-icon" }, u("path", { fill: "#fff", fillRule: "nonzero", d: "M10.66 0L12 1.31 4.136 9 0 4.956l1.34-1.31L4.136 6.38z" }))) } n(IP, "SubmitButton"); var Qy = IP; function BP(i) { let { onDiscard: e, i18n: t } = i; return u("button", { className: "uppy-u-reset uppy-c-btn uppy-Audio-button", type: "button", title: t("discardRecordedFile"), "aria-label": t("discardRecordedFile"), onClick: e, "data-uppy-super-focusable": !0 }, u("svg", { width: "13", height: "13", viewBox: "0 0 13 13", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", className: "uppy-c-icon" }, u("g", { fill: "#FFF", fillRule: "evenodd" }, u("path", { d: "M.496 11.367L11.103.76l1.414 1.414L1.911 12.781z" }), u("path", { d: "M11.104 12.782L.497 2.175 1.911.76l10.607 10.606z" })))) } n(BP, "DiscardButton"); var Jy = BP; function ad(i) { let { stream: e, recordedAudio: t, onStop: r, recording: s, supportsRecording: o, audioSources: a, showAudioSourceDropdown: l, onSubmit: h, i18n: c, onStartRecording: d, onStopRecording: p, onDiscardRecordedAudio: y, recordingLengthSeconds: v } = i, S = nc(null), x = nc(null); bs(() => () => { x.current = null, r() }, [r]), bs(() => { if (!t && (x.current = new $o(S.current, { canvas: { width: 600, height: 600 }, canvasContext: { lineWidth: 2, fillStyle: "rgb(0,0,0)", strokeStyle: "green" } }), x.current.draw(), e)) { let H = new AudioContext().createMediaStreamSource(e); x.current.addSource(H) } }, [t, e]); let E = t != null, F = !E && o, k = l && !E && a && a.length > 1; return u("div", { className: "uppy-Audio-container" }, u("div", { className: "uppy-Audio-audioContainer" }, E ? u("audio", { className: "uppy-Audio-player", controls: !0, src: t }) : u("canvas", { ref: S, className: "uppy-Audio-canvas" })), u("div", { className: "uppy-Audio-footer" }, u("div", { className: "uppy-Audio-audioSourceContainer" }, k ? Xy(i) : null), u("div", { className: "uppy-Audio-buttonContainer" }, F && u(rd, { recording: s, onStartRecording: d, onStopRecording: p, i18n: c }), E && u(Qy, { onSubmit: h, i18n: c }), E && u(Jy, { onDiscard: y, i18n: c })), u("div", { className: "uppy-Audio-recordingLength" }, !E && u(od, { recordingLengthSeconds: v, i18n: c })))) } n(ad, "RecordingScreen"); var Zy = n(i => { let { icon: e, hasAudio: t, i18n: r } = i; return u("div", { className: "uppy-Audio-permissons" }, u("div", { className: "uppy-Audio-permissonsIcon" }, e()), u("h1", { className: "uppy-Audio-title" }, r(t ? "allowAudioAccessTitle" : "noAudioTitle")), u("p", null, r(t ? "allowAudioAccessDescription" : "noAudioDescription"))) }, "default"); var ev = { strings: { pluginNameAudio: "Audio", startAudioRecording: "Begin audio recording", stopAudioRecording: "Stop audio recording", allowAudioAccessTitle: "Please allow access to your microphone", allowAudioAccessDescription: "In order to record audio, please allow microphone access for this site.", noAudioTitle: "Microphone Not Available", noAudioDescription: "In order to record audio, please connect a microphone or another audio input device", recordingStoppedMaxSize: "Recording stopped because the file size is about to exceed the limit", recordingLength: "Recording length %{recording_length}", submitRecordedFile: "Submit recorded file", discardRecordedFile: "Discard recorded file" } }; function fd() { return fd = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, fd.apply(this, arguments) } n(fd, "_extends"); function L(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(L, "_classPrivateFieldLooseBase"); var LP = 0; function Ye(i) { return "__private_" + LP++ + "_" + i } n(Ye, "_classPrivateFieldLooseKey"); var MP = { version: "1.1.2" }, Ge = Ye("stream"), yr = Ye("audioActive"), we = Ye("recordingChunks"), be = Ye("recorder"), vr = Ye("capturedMediaFile"), Xe = Ye("mediaDevices"), ya = Ye("supportsUserMedia"), ld = Ye("hasAudioCheck"), As = Ye("start"), ud = Ye("startRecording"), va = Ye("stopRecording"), hd = Ye("discardRecordedAudio"), cd = Ye("submit"), br = Ye("stop"), dd = Ye("getAudio"), pd = Ye("changeSource"), Ts = Ye("updateSources"), Vr = class extends G { constructor(e, t) { var r; super(e, t), r = this, Object.defineProperty(this, dd, { value: jP }), Object.defineProperty(this, ld, { value: zP }), Object.defineProperty(this, Ge, { writable: !0, value: null }), Object.defineProperty(this, yr, { writable: !0, value: !1 }), Object.defineProperty(this, we, { writable: !0, value: null }), Object.defineProperty(this, be, { writable: !0, value: null }), Object.defineProperty(this, vr, { writable: !0, value: null }), Object.defineProperty(this, Xe, { writable: !0, value: null }), Object.defineProperty(this, ya, { writable: !0, value: null }), Object.defineProperty(this, As, { writable: !0, value: function (s) { if (s === void 0 && (s = null), !L(r, ya)[ya]) return Promise.reject(new Error("Microphone access not supported")); L(r, yr)[yr] = !0, L(r, ld)[ld]().then(o => (r.setPluginState({ hasAudio: o }), L(r, Xe)[Xe].getUserMedia({ audio: !0 }).then(a => { L(r, Ge)[Ge] = a; let l = null, h = a.getAudioTracks(); !s || !s.deviceId ? l = h[0].getSettings().deviceId : h.forEach(c => { c.getSettings().deviceId === s.deviceId && (l = c.getSettings().deviceId) }), L(r, Ts)[Ts](), r.setPluginState({ currentDeviceId: l, audioReady: !0 }) }).catch(a => { r.setPluginState({ audioReady: !1, cameraError: a }), r.uppy.info(a.message, "error") }))) } }), Object.defineProperty(this, ud, { writable: !0, value: () => { L(this, be)[be] = new MediaRecorder(L(this, Ge)[Ge]), L(this, we)[we] = []; let s = !1; L(this, be)[be].addEventListener("dataavailable", o => { L(this, we)[we].push(o.data); let { restrictions: a } = this.uppy.opts; if (L(this, we)[we].length > 1 && a.maxFileSize != null && !s) { let l = L(this, we)[we].reduce((p, y) => p + y.size, 0), c = (l - L(this, we)[we][0].size) / (L(this, we)[we].length - 1) * 3, d = Math.max(0, a.maxFileSize - c); l > d && (s = !0, this.uppy.info(this.i18n("recordingStoppedMaxSize"), "warning", 4e3), L(this, va)[va]()) } }), L(this, be)[be].start(500), this.recordingLengthTimer = setInterval(() => { let o = this.getPluginState().recordingLengthSeconds; this.setPluginState({ recordingLengthSeconds: o + 1 }) }, 1e3), this.setPluginState({ isRecording: !0 }) } }), Object.defineProperty(this, va, { writable: !0, value: () => new Promise(o => { L(this, be)[be].addEventListener("stop", () => { o() }), L(this, be)[be].stop(), clearInterval(this.recordingLengthTimer), this.setPluginState({ recordingLengthSeconds: 0 }) }).then(() => (this.setPluginState({ isRecording: !1 }), L(this, dd)[dd]())).then(o => { try { L(this, vr)[vr] = o, this.setPluginState({ recordedAudio: URL.createObjectURL(o.data) }) } catch (a) { a.isRestriction || this.uppy.log(a) } }).then(() => { L(this, we)[we] = null, L(this, be)[be] = null }, o => { throw L(this, we)[we] = null, L(this, be)[be] = null, o }) }), Object.defineProperty(this, hd, { writable: !0, value: () => { this.setPluginState({ recordedAudio: null }), L(this, vr)[vr] = null } }), Object.defineProperty(this, cd, { writable: !0, value: () => { try { L(this, vr)[vr] && this.uppy.addFile(L(this, vr)[vr]) } catch (s) { s.isRestriction || this.uppy.log(s, "warning") } } }), Object.defineProperty(this, br, { writable: !0, value: async () => { L(this, Ge)[Ge] && L(this, Ge)[Ge].getAudioTracks().forEach(o => o.stop()), L(this, be)[be] && await new Promise(s => { L(this, be)[be].addEventListener("stop", s, { once: !0 }), L(this, be)[be].stop(), clearInterval(this.recordingLengthTimer) }), L(this, we)[we] = null, L(this, be)[be] = null, L(this, yr)[yr] = !1, L(this, Ge)[Ge] = null, this.setPluginState({ recordedAudio: null, isRecording: !1, recordingLengthSeconds: 0 }) } }), Object.defineProperty(this, pd, { writable: !0, value: s => { L(this, br)[br](), L(this, As)[As]({ deviceId: s }) } }), Object.defineProperty(this, Ts, { writable: !0, value: () => { L(this, Xe)[Xe].enumerateDevices().then(s => { this.setPluginState({ audioSources: s.filter(o => o.kind === "audioinput") }) }) } }), L(this, Xe)[Xe] = navigator.mediaDevices, L(this, ya)[ya] = L(this, Xe)[Xe] != null, this.id = this.opts.id || "Audio", this.type = "acquirer", this.icon = () => u("svg", { className: "uppy-DashboardTab-iconAudio", "aria-hidden": "true", focusable: "false", width: "32px", height: "32px", viewBox: "0 0 32 32" }, u("path", { d: "M21.143 12.297c.473 0 .857.383.857.857v2.572c0 3.016-2.24 5.513-5.143 5.931v2.64h2.572a.857.857 0 110 1.714H12.57a.857.857 0 110-1.714h2.572v-2.64C12.24 21.24 10 18.742 10 15.726v-2.572a.857.857 0 111.714 0v2.572A4.29 4.29 0 0016 20.01a4.29 4.29 0 004.286-4.285v-2.572c0-.474.384-.857.857-.857zM16 6.5a3 3 0 013 3v6a3 3 0 01-6 0v-6a3 3 0 013-3z", fill: "currentcolor", "fill-rule": "nonzero" })), this.defaultLocale = ev, this.opts = { ...t }, this.i18nInit(), this.title = this.i18n("pluginNameAudio"), this.setPluginState({ hasAudio: !1, audioReady: !1, cameraError: null, recordingLengthSeconds: 0, audioSources: [], currentDeviceId: null }) } render() { L(this, yr)[yr] || L(this, As)[As](); let e = this.getPluginState(); return !e.audioReady || !e.hasAudio ? u(Zy, { icon: this.icon, i18n: this.i18n, hasAudio: e.hasAudio }) : u(ad, fd({}, e, { audioActive: L(this, yr)[yr], onChangeSource: L(this, pd)[pd], onStartRecording: L(this, ud)[ud], onStopRecording: L(this, va)[va], onDiscardRecordedAudio: L(this, hd)[hd], onSubmit: L(this, cd)[cd], onStop: L(this, br)[br], i18n: this.i18n, showAudioSourceDropdown: this.opts.showAudioSourceDropdown, supportsRecording: id(), recording: e.isRecording, stream: L(this, Ge)[Ge] })) } install() { this.setPluginState({ audioReady: !1, recordingLengthSeconds: 0 }); let { target: e } = this.opts; e && this.mount(e, this), L(this, Xe)[Xe] && (L(this, Ts)[Ts](), L(this, Xe)[Xe].ondevicechange = () => { if (L(this, Ts)[Ts](), L(this, Ge)[Ge]) { let t = !0, { audioSources: r, currentDeviceId: s } = this.getPluginState(); r.forEach(o => { s === o.deviceId && (t = !1) }), t && (L(this, br)[br](), L(this, As)[As]()) } }) } uninstall() { L(this, Ge)[Ge] && L(this, br)[br](), this.unmount() } }; n(Vr, "Audio"); function zP() { return L(this, Xe)[Xe] ? L(this, Xe)[Xe].enumerateDevices().then(i => i.some(e => e.kind === "audioinput")) : Promise.resolve(!1) } n(zP, "_hasAudioCheck2"); function jP() { let i = L(this, we)[we].find(o => { var a; return ((a = o.type) == null ? void 0 : a.length) > 0 }).type, e = Ii(i); if (!e) return Promise.reject(new Error(`Could not retrieve recording: Unsupported media type "${i}"`)); let t = `audio-${Date.now()}.${e}`, r = new Blob(L(this, we)[we], { type: i }), s = { source: this.id, name: t, data: new Blob([r], { type: i }), type: i }; return Promise.resolve(s) } n(jP, "_getAudio2"); Vr.VERSION = MP.version; var tv = { strings: { pluginNameBox: "Box" } }; var HP = { version: "2.1.3" }, Bi = class extends G { constructor(e, t) { super(e, t), this.id = this.opts.id || "Box", Q.initPlugin(this, t), this.title = this.opts.title || "Box", this.icon = () => u("svg", { className: "uppy-DashboardTab-iconBox", "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("g", { fill: "currentcolor", fillRule: "nonzero" }, u("path", { d: "m16.4 13.5c-1.6 0-3 0.9-3.7 2.2-0.7-1.3-2.1-2.2-3.7-2.2-1 0-1.8 0.3-2.5 0.8v-3.6c-0.1-0.3-0.5-0.7-1-0.7s-0.8 0.4-0.8 0.8v7c0 2.3 1.9 4.2 4.2 4.2 1.6 0 3-0.9 3.7-2.2 0.7 1.3 2.1 2.2 3.7 2.2 2.3 0 4.2-1.9 4.2-4.2 0.1-2.4-1.8-4.3-4.1-4.3m-7.5 6.8c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5m7.5 0c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5-1.1 2.5-2.5 2.5" }), u("path", { d: "m27.2 20.6l-2.3-2.8 2.3-2.8c0.3-0.4 0.2-0.9-0.2-1.2s-1-0.2-1.3 0.2l-2 2.4-2-2.4c-0.3-0.4-0.9-0.4-1.3-0.2-0.4 0.3-0.5 0.8-0.2 1.2l2.3 2.8-2.3 2.8c-0.3 0.4-0.2 0.9 0.2 1.2s1 0.2 1.3-0.2l2-2.4 2 2.4c0.3 0.4 0.9 0.4 1.3 0.2 0.4-0.3 0.4-0.8 0.2-1.2" }))), this.provider = new Q(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionKeysParams: this.opts.companionKeysParams, companionCookiesRule: this.opts.companionCookiesRule, provider: "box", pluginId: this.id }), this.defaultLocale = tv, this.i18nInit(), this.title = this.i18n("pluginNameBox"), this.onFirstRender = this.onFirstRender.bind(this), this.render = this.render.bind(this) } install() { this.view = new ge(this, { provider: this.provider, loadAllFiles: !0 }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.view.tearDown(), this.unmount() } onFirstRender() { return this.view.getFolder() } render(e) { return this.view.render(e) } }; n(Bi, "Box"); Bi.VERSION = HP.version; var iv = { strings: { pluginNameDropbox: "Dropbox" } }; var qP = { version: "3.1.3" }, Li = class extends G { constructor(e, t) { super(e, t), this.id = this.opts.id || "Dropbox", Q.initPlugin(this, t), this.title = this.opts.title || "Dropbox", this.icon = () => u("svg", { className: "uppy-DashboardTab-iconDropbox", "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("path", { d: "M10.5 7.5L5 10.955l5.5 3.454 5.5-3.454 5.5 3.454 5.5-3.454L21.5 7.5 16 10.955zM10.5 21.319L5 17.864l5.5-3.455 5.5 3.455zM16 17.864l5.5-3.455 5.5 3.455-5.5 3.455zM16 25.925l-5.5-3.455 5.5-3.454 5.5 3.454z", fill: "currentcolor", fillRule: "nonzero" })), this.provider = new Q(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionKeysParams: this.opts.companionKeysParams, companionCookiesRule: this.opts.companionCookiesRule, provider: "dropbox", pluginId: this.id }), this.defaultLocale = iv, this.i18nInit(), this.title = this.i18n("pluginNameDropbox"), this.onFirstRender = this.onFirstRender.bind(this), this.render = this.render.bind(this) } install() { this.view = new ge(this, { provider: this.provider, loadAllFiles: !0 }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.view.tearDown(), this.unmount() } onFirstRender() { return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]) } render(e) { return this.view.render(e) } }; n(Li, "Dropbox"); Li.VERSION = qP.version; var rv = { strings: { pluginNameFacebook: "Facebook" } }; var $P = { version: "3.1.2" }, Mi = class extends G { constructor(e, t) { super(e, t), this.id = this.opts.id || "Facebook", Q.initPlugin(this, t), this.title = this.opts.title || "Facebook", this.icon = () => u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("g", { fill: "none", fillRule: "evenodd" }, u("path", { d: "M27 16c0-6.075-4.925-11-11-11S5 9.925 5 16c0 5.49 4.023 10.041 9.281 10.866V19.18h-2.793V16h2.793v-2.423c0-2.757 1.642-4.28 4.155-4.28 1.204 0 2.462.215 2.462.215v2.707h-1.387c-1.366 0-1.792.848-1.792 1.718V16h3.05l-.487 3.18h-2.563v7.686C22.977 26.041 27 21.49 27 16", fill: "#1777F2" }), u("path", { d: "M20.282 19.18L20.77 16h-3.051v-2.063c0-.87.426-1.718 1.792-1.718h1.387V9.512s-1.258-.215-2.462-.215c-2.513 0-4.155 1.523-4.155 4.28V16h-2.793v3.18h2.793v7.686a11.082 11.082 0 003.438 0V19.18h2.563", fill: "#FFFFFE" }))), this.provider = new Q(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionKeysParams: this.opts.companionKeysParams, companionCookiesRule: this.opts.companionCookiesRule, provider: "facebook", pluginId: this.id }), this.defaultLocale = rv, this.i18nInit(), this.title = this.i18n("pluginNameFacebook"), this.onFirstRender = this.onFirstRender.bind(this), this.render = this.render.bind(this) } install() { this.view = new ge(this, { provider: this.provider }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.view.tearDown(), this.unmount() } onFirstRender() { return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]) } render(e) { let t = {}; return this.getPluginState().files.length && !this.getPluginState().folders.length && (t.viewType = "grid", t.showFilter = !1, t.showTitles = !1), this.view.render(e, t) } }; n(Mi, "Facebook"); Mi.VERSION = $P.version; var Vo = class extends ge { toggleCheckbox(e, t) { e.stopPropagation(), e.preventDefault(), t.custom.isSharedDrive || super.toggleCheckbox(e, t) } }; n(Vo, "DriveProviderViews"); var sv = { strings: { pluginNameGoogleDrive: "Google Drive" } }; var VP = { version: "3.2.1" }, zi = class extends G { constructor(e, t) { super(e, t), this.id = this.opts.id || "GoogleDrive", this.title = this.opts.title || "Google Drive", Q.initPlugin(this, t), this.title = this.opts.title || "Google Drive", this.icon = () => u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("g", { fillRule: "nonzero", fill: "none" }, u("path", { d: "M6.663 22.284l.97 1.62c.202.34.492.609.832.804l3.465-5.798H5c0 .378.1.755.302 1.096l1.361 2.278z", fill: "#0066DA" }), u("path", { d: "M16 12.09l-3.465-5.798c-.34.195-.63.463-.832.804l-6.4 10.718A2.15 2.15 0 005 18.91h6.93L16 12.09z", fill: "#00AC47" }), u("path", { d: "M23.535 24.708c.34-.195.63-.463.832-.804l.403-.67 1.928-3.228c.201-.34.302-.718.302-1.096h-6.93l1.474 2.802 1.991 2.996z", fill: "#EA4335" }), u("path", { d: "M16 12.09l3.465-5.798A2.274 2.274 0 0018.331 6h-4.662c-.403 0-.794.11-1.134.292L16 12.09z", fill: "#00832D" }), u("path", { d: "M20.07 18.91h-8.14l-3.465 5.798c.34.195.73.292 1.134.292h12.802c.403 0 .794-.11 1.134-.292L20.07 18.91z", fill: "#2684FC" }), u("path", { d: "M23.497 12.455l-3.2-5.359a2.252 2.252 0 00-.832-.804L16 12.09l4.07 6.82h6.917c0-.377-.1-.755-.302-1.096l-3.188-5.359z", fill: "#FFBA00" }))), this.provider = new Q(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionKeysParams: this.opts.companionKeysParams, companionCookiesRule: this.opts.companionCookiesRule, provider: "drive", pluginId: this.id }), this.defaultLocale = sv, this.i18nInit(), this.title = this.i18n("pluginNameGoogleDrive"), this.onFirstRender = this.onFirstRender.bind(this), this.render = this.render.bind(this) } install() { this.view = new Vo(this, { provider: this.provider, loadAllFiles: !0 }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.view.tearDown(), this.unmount() } onFirstRender() { return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder("root")]) } render(e) { return this.view.render(e) } }; n(zi, "GoogleDrive"); zi.VERSION = VP.version; var ov = { strings: { pluginNameInstagram: "Instagram" } }; var WP = { version: "3.1.2" }, ji = class extends G { constructor(e, t) { super(e, t), this.id = this.opts.id || "Instagram", Q.initPlugin(this, t), this.icon = () => u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("defs", null, u("path", { d: "M16.825 5l.483-.001.799.002c1.168.005 1.598.021 2.407.057 1.17.05 1.97.235 2.67.506.725.28 1.34.655 1.951 1.265.613.61.99 1.223 1.273 1.946.273.7.46 1.498.516 2.67l.025.552.008.205c.029.748.037 1.51.042 3.777l.001.846v.703l-.001.398a50.82 50.82 0 01-.058 2.588c-.05 1.17-.235 1.97-.506 2.67a5.394 5.394 0 01-1.265 1.951c-.61.613-1.222.99-1.946 1.273-.699.273-1.498.46-2.668.516-.243.012-.451.022-.656.03l-.204.007c-.719.026-1.512.034-3.676.038l-.847.001h-1.1a50.279 50.279 0 01-2.587-.059c-1.171-.05-1.971-.235-2.671-.506a5.394 5.394 0 01-1.951-1.265 5.385 5.385 0 01-1.272-1.946c-.274-.699-.46-1.498-.517-2.668a88.15 88.15 0 01-.03-.656l-.007-.205c-.026-.718-.034-1.512-.038-3.674v-2.129c.006-1.168.022-1.597.058-2.406.051-1.171.235-1.971.506-2.672a5.39 5.39 0 011.265-1.95 5.381 5.381 0 011.946-1.272c.699-.274 1.498-.462 2.669-.517l.656-.03.204-.007c.718-.026 1.511-.034 3.674-.038zm.678 1.981h-1.226l-.295.001c-2.307.005-3.016.013-3.777.043l-.21.009-.457.02c-1.072.052-1.654.232-2.042.383-.513.2-.879.44-1.263.825a3.413 3.413 0 00-.82 1.267c-.15.388-.33.97-.375 2.043a48.89 48.89 0 00-.056 2.482v.398 1.565c.006 2.937.018 3.285.073 4.444.05 1.073.231 1.654.382 2.043.2.512.44.878.825 1.263.386.383.753.621 1.267.82.388.15.97.328 2.043.374.207.01.388.017.563.024l.208.007a63.28 63.28 0 002.109.026h1.564c2.938-.006 3.286-.019 4.446-.073 1.071-.051 1.654-.232 2.04-.383.514-.2.88-.44 1.264-.825.384-.386.622-.753.82-1.266.15-.389.328-.971.375-2.044.039-.88.054-1.292.057-2.723v-1.15-.572c-.006-2.936-.019-3.284-.074-4.445-.05-1.071-.23-1.654-.382-2.04-.2-.515-.44-.88-.825-1.264a3.405 3.405 0 00-1.267-.82c-.388-.15-.97-.328-2.042-.375a48.987 48.987 0 00-2.535-.056zm-1.515 3.37a5.65 5.65 0 11.021 11.299 5.65 5.65 0 01-.02-11.3zm.004 1.982a3.667 3.667 0 10.015 7.334 3.667 3.667 0 00-.015-7.334zm5.865-3.536a1.32 1.32 0 11.005 2.64 1.32 1.32 0 01-.005-2.64z", id: "a" })), u("g", { fill: "none", "fill-rule": "evenodd" }, u("mask", { id: "b", fill: "#fff" }, u("use", { xlinkHref: "#a" })), u("image", { mask: "url(#b)", x: "4", y: "4", width: "24", height: "24", xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAYAAAAehFoBAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAALKADAAQAAAABAAAALAAAAAD8buejAAALZklEQVRYCVWZC2LbNhAFCRKykvP0bD1506SxRKIzbwHJoU3jv5h9WICU3P7+6zlG2zZvr8s/rW1tN7U0rMll8aDYufdzbLfc1JHmpv3jpPy8tsO+3O2s/O6YMSjTl/qdCds4mIIG60m8vdq2Z+phm2V4vAb9+o7BbZeuoM0NyYazvTvbvlN1MGjHUAesZ/IWWOsCeF0BOwAK4ITR0WYd/QKHEPv2DEymmorZtiubjOHEMYEzXmC9GMxu+95Kz+kuwxjDBKb8iUoCAdqZoAeyALreW6ZNx9Y4Jz8cLwjTZOEoR+HU05k2RzgP2iafGgfZiEdZbEr94zpX/xkPtDtGAxF+LRcgTsp9CAZg0rnEnXmPqFshY5vLnVWxLXO/bah2sZQgBZppGSe8NbjNPN5kc/WbIYEn8U+jXCOezT4zfgS1eoVEhceVeK74Fe4N6CoYEoLWykzHsd+GMAUqdTTVvvqT1uWqB3lVCLb12/ORAe8/5Zu9mp7lqoEFUCAFDIxqz7i1bq2AY1U9jqq2QK/7DYl+1AeZlAFcEc+U/jkRUqsvCHQ/nyGvjrOl6EuZWRWVGCKUMCkntQ5o+u2AZ3OxakbTcoBZnY0xhgGCUM4Kp1xtBTnBnXM5ASRms/Fs7d9OpX8bXN45pibQY/ML1MmA5G9CINBuCpdftexr6i2c5qd9J441LNJm3zk1GVusJ7v6mPJ7HPxJR0Li/vg9O1XHTEgvsQoSgExU0NnlLF0paK+6d06aOMKE2nCKV0ofNw4WsWmLsWrv6lPLnhGpr9E137QkHOMB/jh/T8MOqOadXarR44zPBW5NvDccnBxVmdK81+7RQ5p6qnQoRDZPh9+xWj0N2XpqxX1HzMty9UlFnKya/h3gulziAsyxwkSmpTIPB8vagKLyktRdDuBEHNGZMm4oCFWgjq31WPHpaC93gGNqpOpP4Ez4spa+nMNvhTWcuPKAJ79fqIxVoUvdjEG9qSy2WhpQlz61yG/gnKEA25IrIOYK6DIsQs2EE9LR/sTKq38Nd1y/X//FXG0QDHkEqSz3EYVV2dhb00rgLPSDcqmrScs55NNOD2zVqKmYnYTFnkACp520dkW5vBxK99BVzr792/iZ+VVo92UkKU2oG5WFTb6mNiA1H2C8KC0E44qaQleR3EQvQNwLrECOVAiSwM5gpF7nvDND0lZvYuQ9JbZfqdTrqCgwMcVrRS0z9QkLu9NWmkgEHb8p2zDRylj9VWA3lXD2vObEdWpT3w5MiFqQ1W/lteG4eipastxv2w+TeTBP0ypK84HiOW9fUzLcjRDwCW2b2VxmnGSKTX6uRSwMnC9YX4l05Mh2uwI+QVWdWUOSTWd5Xjjf7/tPYk2stSh053XTGN5RJMCMSajMcS8Trn3j/E1ajthlxCkmJXVi47PSUsyyq+jyexsayQNuv5GVYJaszprNsQD3RkgYiy49kFl2JlJJxlf8Uu/lpkq7+aWqzEzjr5cTVpFaJvSVr8AKRtiTlVPFk5t1nO30W+o6jrbAk76kxFa/tX+dom4C1wDPk03gqCw8HTBSxx4FHxIA+mh2pM3rKu5SNqBAuOSZnHzsB9JwW7DV/ge8dlVsOh375PvH8YO8EALU1HuecIC6qQgXifNuSx9XAoLaoGIYDjkWFrawX1U1XrknuMFw7QBSPtg79XovmBvwqnDICrhClEO6wgKFj9vPqJWlthUvdgH1DOA8+wFMexzQc5BUS1d1IsdBSjEv4Fe1LgBO1CpFPTpV1JuPSFNt4y/trzbtaUfwBWwM3/6JsrL6MSQYwLKXAm9YJBxsM8992MblZ63Gami0+rnwOMyPykVpQsyl9eYNOfVC6kRBkwaop//LgcAKWivkHF791g0JK5kMmCgKPas2QRkUFQsuTvm6R1946Wg95k764ZRLW59yO5UVGsawwELupCfAbdCuAwvcz5Xk18rIVEdgSRBRgO77R206QdXHuA2goaGiCQ0GmUfN1JlmFayjv0IcKGkfYt4HAj0yuQBRGDjzuS/rTmAf29Gov1S+FF7QBayNcpoBOEsMt3vFcIUC7VxOnE+pxmkgqEzduzwsPykrjBszCusgdarsRIAL6CM/KqsqcAf1vj8P1TXFyN6e5G8ao48fjKfDQJYizIdIfb+Xwp6Z2fE2C7mUfUEzMKqSBp4VUV1A49Sz1M2LzVzahEfyHUAcQNltR0nADYkBvHXDZQo8H9dQvHF7qhjPtSolBJ0A/vaLwdRz5YFFGoWBy8E/4aKcjqimaUBXXnjBpzOZnMlIVXsTVEBBUa+dD0BR0xVopgAD70psY0KjMHpmHB2kApea9o23NS83mpsref5OZet4U/0CMhSEDpwnxB9lVKSfk5djllXRFPizQmKcqMpnyZ3ycPntf96Ym9ChzU8vCQnhgWZ2UuySArw+cVBG4gqNCS6YoSEEziRWVStKUpe4FfCd91V0XA/qgOJuF7FpGjjyQgsFoNDtibp8cm+cyXxbB6zh4pMUO4H06yzsv4E/A6rg/uRJRnMRmrhMDIhyOjABX9CMDFhBFxx19KujjqWeim5PwVFU6IBiewfyk7IPETcg52kjXN7nsbaoEykKf/cjUgVxpTZZVtnqFMgv4FHa8oSOisawinMLHfUBzJcK1j8BeqquedKDtgcgnA4bym4P6gBWYVM3W/pn41ku5L4RElFWtlk5SXHEThhOWDiIyVROlQNM+wyHimlgATI/PPIm4BB8qfqwHnhgL89gzs+Ww1xQb4821SZ/4IwOJiRqH/X9u7Hj08JLSZfawOQcpRzwgk1oBNzzcgLn1FBNHspMENik9OG4awIDaUjw9rKNT1KXPl9neua6sSbkgqfs/CNfBdNfDDhQuL4AKXEXeOgZID91eOiRUnEFOIA5rnTkBU0/IT05gByoq5KBJF4Hym4Pxh3UcxZ7HjdhEhKWURbhavNR9rjLBwk3ryDcrGzfvk9I69b1yhMGWQ4bqMwv/RMSplQkjjVKXzZX8wESVcuB7QG0YUCMjk/aOmWgc/vC4oMCVYfghIGP6MT1zpeUhM1rQzOnGxmFKwTCir1Xaj5vN7T7nDZvnbDGHbCKnwji2zofNsOvbold3zlUtKGosBun3PbJSrrReHEaCQVCIDEMaCCBs+P+AbybkbIhmbNecGwF+E5/L2ECuPKCWsUESQkKnyyJ93TGACk7OrAY9P8XG//fGCoM7DAEUGnj5Mw7aQfelySWOm9iPuFyvrL8rKQR6mM6qdCUDQsfNPVu4yv/HaPOT1e/yDaviMKmTkg/I/F7MUG9OlrmDrBLRVd3c8KBJlPEKoVRcIJuhoQAmZDUkPC00W5OI1dOpQ1F61kFNqr9SmFcaHdBheOaDHF6QZMOP6QyiZ804oj98wLiAMIgcWw4UDYkDAWfR+4d5s0zP2GgUZX04i+NeSgYGokvbDhIZYUWHgd9K8zZzir264NxZUFbsfM1jdqpV2naA48tx6hsvBSabE4IMtlcOGgq8PqCjoly2rw2soqy4RJWQtPZl6PUCU14ZUWENuZV2Honn3f+k6R6wrkqgTStyQ0bFY+XAaafMRFgUlVeXxXFUcpLEYfZz3FrVUzZrOOJK+4B/wnIZ8TGRvb9OB8EUM0w8uNYj/oa9iK9AMoy6gA72o02srMxpAPUD+EDnVEF7P5xw896VyAbFk8MgnpVpR3gfLnt/wECq3rYFvYLcKCpqvcI+/hVl8AumXDeApklDRRKJSS+KOaq1Rgg4igOYtiQK1hJy46TBtDjznDp3iqJff5j0/LfSZbYVdauqXccJ9W+czupp0sU9gMlqkQ52lU1E6tUwoDUukAD6YRpAwqDrAErzA8QCRvXm98KEep0xIdY1CN1ye27IP0IHvvYIW18qGz8S7VWUZuMkUOb3P8DHTl67ur/i1UAAAAASUVORK5CYII=" }))), this.defaultLocale = ov, this.i18nInit(), this.title = this.i18n("pluginNameInstagram"), this.provider = new Q(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionKeysParams: this.opts.companionKeysParams, companionCookiesRule: this.opts.companionCookiesRule, provider: "instagram", pluginId: this.id }), this.onFirstRender = this.onFirstRender.bind(this), this.render = this.render.bind(this) } install() { this.view = new ge(this, { provider: this.provider, viewType: "grid", showTitles: !1, showFilter: !1, showBreadcrumbs: !1 }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.view.tearDown(), this.unmount() } onFirstRender() { return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder("recent")]) } render(e) { return this.view.render(e) } }; n(ji, "Instagram"); ji.VERSION = WP.version; var nv = { strings: { pluginNameOneDrive: "OneDrive" } }; var KP = { version: "3.1.3" }, Hi = class extends G { constructor(e, t) { super(e, t), this.id = this.opts.id || "OneDrive", Q.initPlugin(this, t), this.title = this.opts.title || "OneDrive", this.icon = () => u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("g", { fill: "none", fillRule: "nonzero" }, u("path", { d: "M13.39 12.888l4.618 2.747 2.752-1.15a4.478 4.478 0 012.073-.352 6.858 6.858 0 00-5.527-5.04 6.895 6.895 0 00-6.876 2.982l.07-.002a5.5 5.5 0 012.89.815z", fill: "#0364B8" }), u("path", { d: "M13.39 12.887v.001a5.5 5.5 0 00-2.89-.815l-.07.002a5.502 5.502 0 00-4.822 2.964 5.43 5.43 0 00.38 5.62l4.073-1.702 1.81-.757 4.032-1.685 2.105-.88-4.619-2.748z", fill: "#0078D4" }), u("path", { d: "M22.833 14.133a4.479 4.479 0 00-2.073.352l-2.752 1.15.798.475 2.616 1.556 1.141.68 3.902 2.321a4.413 4.413 0 00-.022-4.25 4.471 4.471 0 00-3.61-2.284z", fill: "#1490DF" }), u("path", { d: "M22.563 18.346l-1.141-.68-2.616-1.556-.798-.475-2.105.88L11.87 18.2l-1.81.757-4.073 1.702A5.503 5.503 0 0010.5 23h12.031a4.472 4.472 0 003.934-2.333l-3.902-2.321z", fill: "#28A8EA" }))), this.provider = new Q(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionCookiesRule: this.opts.companionCookiesRule, provider: "onedrive", pluginId: this.id }), this.defaultLocale = nv, this.i18nInit(), this.title = this.i18n("pluginNameOneDrive"), this.onFirstRender = this.onFirstRender.bind(this), this.render = this.render.bind(this) } install() { this.view = new ge(this, { provider: this.provider, loadAllFiles: !0 }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.view.tearDown(), this.unmount() } onFirstRender() { return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]) } render(e) { return this.view.render(e) } }; n(Hi, "OneDrive"); Hi.VERSION = KP.version; var GP = { version: "3.2.2" }, qi = class extends G { constructor(e, t) { if (super(e, t), this.id = this.opts.id || "Unsplash", this.title = this.opts.title || "Unsplash", Q.initPlugin(this, t, {}), this.icon = () => u("svg", { className: "uppy-DashboardTab-iconUnsplash", viewBox: "0 0 32 32", height: "32", width: "32", "aria-hidden": "true" }, u("g", { fill: "currentcolor" }, u("path", { d: "M46.575 10.883v-9h12v9zm12 5h10v18h-32v-18h10v9h12z" }), u("path", { d: "M13 12.5V8h6v4.5zm6 2.5h5v9H8v-9h5v4.5h6z" }))), !this.opts.companionUrl) throw new Error("Companion hostname is required, please consult https://uppy.io/docs/companion"); this.hostname = this.opts.companionUrl, this.provider = new Nr(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionCookiesRule: this.opts.companionCookiesRule, provider: "unsplash", pluginId: this.id }) } install() { this.view = new Ai(this, { provider: this.provider, viewType: "unsplash", showFilter: !0 }); let { target: e } = this.opts; e && this.mount(e, this) } onFirstRender() { } render(e) { return this.view.render(e) } uninstall() { this.unmount() } }; n(qi, "Unsplash"); qi.VERSION = GP.version; function av(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(av, "_classPrivateFieldLooseBase"); var XP = 0; function YP(i) { return "__private_" + XP++ + "_" + i } n(YP, "_classPrivateFieldLooseKey"); var ba = YP("handleSubmit"), Nu = class extends ue { constructor(e) { super(e), this.form = document.createElement("form"), Object.defineProperty(this, ba, { writable: !0, value: t => { t.preventDefault(); let { addFile: r } = this.props, s = this.input.value.trim(); r(s) } }), this.form.id = ot() } componentDidMount() { this.input.value = "", this.form.addEventListener("submit", av(this, ba)[ba]), document.body.appendChild(this.form) } componentWillUnmount() { this.form.removeEventListener("submit", av(this, ba)[ba]), document.body.removeChild(this.form) } render() { let { i18n: e } = this.props; return u("div", { className: "uppy-Url" }, u("input", { className: "uppy-u-reset uppy-c-textInput uppy-Url-input", type: "text", "aria-label": e("enterUrlToImport"), placeholder: e("enterUrlToImport"), ref: t => { this.input = t }, "data-uppy-super-focusable": !0, form: this.form.id }), u("button", { className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Url-importButton", type: "submit", form: this.form.id }, e("import"))) } }; n(Nu, "UrlUI"); var lv = Nu; function Iu(i, e, t) { let r = De(i.items), s; switch (e) { case "paste": { if (r.some(a => a.kind === "file")) return; s = r.filter(a => a.kind === "string" && a.type === "text/plain"); break } case "drop": { s = r.filter(o => o.kind === "string" && o.type === "text/uri-list"); break } default: throw new Error(`isDropOrPaste must be either 'drop' or 'paste', but it's ${e}`) }s.forEach(o => { o.getAsString(a => t(a)) }) } n(Iu, "forEachDroppedOrPastedUrl"); var uv = { strings: { import: "Import", enterUrlToImport: "Enter URL to import a file", failedToFetch: "Companion failed to fetch this URL, please make sure it\u2019s correct", enterCorrectUrl: "Incorrect URL: Please make sure you are entering a direct link to a file" } }; var QP = { version: "3.3.3" }; function JP() { return u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("path", { d: "M23.637 15.312l-2.474 2.464a3.582 3.582 0 01-.577.491c-.907.657-1.897.986-2.968.986a4.925 4.925 0 01-3.959-1.971c-.248-.329-.164-.902.165-1.149.33-.247.907-.164 1.155.164 1.072 1.478 3.133 1.724 4.618.656a.642.642 0 00.33-.328l2.473-2.463c1.238-1.313 1.238-3.366-.082-4.597a3.348 3.348 0 00-4.618 0l-1.402 1.395a.799.799 0 01-1.154 0 .79.79 0 010-1.15l1.402-1.394a4.843 4.843 0 016.843 0c2.062 1.805 2.144 5.007.248 6.896zm-8.081 5.664l-1.402 1.395a3.348 3.348 0 01-4.618 0c-1.319-1.23-1.319-3.365-.082-4.596l2.475-2.464.328-.328c.743-.492 1.567-.739 2.475-.657.906.165 1.648.574 2.143 1.314.248.329.825.411 1.155.165.33-.248.412-.822.165-1.15-.825-1.068-1.98-1.724-3.216-1.888-1.238-.247-2.556.082-3.628.902l-.495.493-2.474 2.464c-1.897 1.969-1.814 5.09.083 6.977.99.904 2.226 1.396 3.463 1.396s2.473-.492 3.463-1.395l1.402-1.396a.79.79 0 000-1.15c-.33-.328-.908-.41-1.237-.082z", fill: "#FF753E", "fill-rule": "nonzero" })) } n(JP, "UrlIcon"); function ZP(i) { let e = /^[a-z0-9]+:\/\//, t = "http://"; return e.test(i) ? i : t + i } n(ZP, "addProtocolToURL"); function e_(i) { return De(i.dataTransfer.items).filter(r => r.kind === "string" && r.type === "text/uri-list").length > 0 } n(e_, "canHandleRootDrop"); function t_(i) { if (!i) return !1; let e = i.match(/^([a-z0-9]+):\/\//)[1]; return !(e !== "http" && e !== "https") } n(t_, "checkIfCorrectURL"); function i_(i) { let { pathname: e } = new URL(i); return e.substring(e.lastIndexOf("/") + 1) } n(i_, "getFileNameFromUrl"); var gi = class extends G { constructor(e, t) { super(e, t), this.id = this.opts.id || "Url", this.title = this.opts.title || "Link", this.type = "acquirer", this.icon = () => u(JP, null), this.defaultLocale = uv; let r = {}; if (this.opts = { ...r, ...t }, this.i18nInit(), this.hostname = this.opts.companionUrl, !this.hostname) throw new Error("Companion hostname is required, please consult https://uppy.io/docs/companion"); this.getMeta = this.getMeta.bind(this), this.addFile = this.addFile.bind(this), this.handleRootDrop = this.handleRootDrop.bind(this), this.handleRootPaste = this.handleRootPaste.bind(this), this.client = new de(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionCookiesRule: this.opts.companionCookiesRule }) } getMeta(e) { return this.client.post("url/meta", { url: e }).then(t => { if (t.error) throw this.uppy.log("[URL] Error:"), this.uppy.log(t.error), new Error("Failed to fetch the file"); return t }) } async addFile(e, t) { t === void 0 && (t = void 0); let r = ZP(e); if (!t_(r)) { this.uppy.log(`[URL] Incorrect URL entered: ${r}`), this.uppy.info(this.i18n("enterCorrectUrl"), "error", 4e3); return } try { let s = await this.getMeta(r), o = { meta: t, source: this.id, name: s.name || i_(r), type: s.type, data: { size: s.size }, isRemote: !0, body: { url: r }, remote: { companionUrl: this.opts.companionUrl, url: `${this.hostname}/url/get`, body: { fileId: r, url: r }, providerOptions: this.client.opts } }; this.uppy.log("[Url] Adding remote file"); try { return this.uppy.addFile(o) } catch (a) { return a.isRestriction || this.uppy.log(a), a } } catch (s) { return this.uppy.log(s), this.uppy.info({ message: this.i18n("failedToFetch"), details: s }, "error", 4e3), s } } handleRootDrop(e) { Iu(e.dataTransfer, "drop", t => { this.uppy.log(`[URL] Adding file from dropped url: ${t}`), this.addFile(t) }) } handleRootPaste(e) { Iu(e.clipboardData, "paste", t => { this.uppy.log(`[URL] Adding file from pasted url: ${t}`), this.addFile(t) }) } render() { return u(lv, { i18n: this.i18n, addFile: this.addFile }) } install() { let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.unmount() } }; n(gi, "Url"); gi.VERSION = QP.version; gi.prototype.canHandleRootDrop = e_; var hv = { strings: { pluginNameZoom: "Zoom" } }; var r_ = { version: "2.1.2" }, $i = class extends G { constructor(e, t) { super(e, t), this.id = this.opts.id || "Zoom", Q.initPlugin(this, t), this.title = this.opts.title || "Zoom", this.icon = () => u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("path", { d: "M24.5 11.125l-2.75 2.063c-.473.353-.75.91-.75 1.5v3.124c0 .59.277 1.147.75 1.5l2.75 2.063a.938.938 0 001.5-.75v-8.75a.938.938 0 00-1.5-.75zm-4.75 9.5c0 1.035-.84 1.875-1.875 1.875H9.75A3.75 3.75 0 016 18.75v-6.875C6 10.84 6.84 10 7.875 10H16a3.75 3.75 0 013.75 3.75v6.875z", fill: "#2E8CFF", "fill-rule": "evenodd" })), this.provider = new Q(e, { companionUrl: this.opts.companionUrl, companionHeaders: this.opts.companionHeaders, companionKeysParams: this.opts.companionKeysParams, companionCookiesRule: this.opts.companionCookiesRule, provider: "zoom", pluginId: this.id }), this.defaultLocale = hv, this.i18nInit(), this.title = this.i18n("pluginNameZoom"), this.onFirstRender = this.onFirstRender.bind(this), this.render = this.render.bind(this) } install() { this.view = new ge(this, { provider: this.provider }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.view.tearDown(), this.unmount() } onFirstRender() { return Promise.all([this.provider.fetchPreAuthToken(), this.view.getFolder()]) } render(e) { return this.view.render(e) } }; n($i, "Zoom"); $i.VERSION = r_.version; function md(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(md, "_classPrivateFieldLooseBase"); var s_ = 0; function o_(i) { return "__private_" + s_++ + "_" + i } n(o_, "_classPrivateFieldLooseKey"); var n_ = { version: "1.0.3" }, gd = { __proto__: null, Box: Bi, Dropbox: Li, Facebook: Mi, GoogleDrive: zi, Instagram: ji, OneDrive: Hi, Unsplash: qi, Url: gi, Zoom: $i }, Cs = o_("installedPlugins"), Rs = class extends Fe { constructor(e, t) { super(e, t), Object.defineProperty(this, Cs, { writable: !0, value: new Set }), this.id = this.opts.id || "RemoteSources", this.type = "acquirer"; let r = { sources: Object.keys(gd), target: Di }; if (this.opts = { ...r, ...t }, this.opts.companionUrl == null) throw new Error("Please specify companionUrl for RemoteSources to work, see https://uppy.io/docs/remote-sources#companionUrl") } setOptions(e) { this.uninstall(), super.setOptions(e), this.install() } install() { this.opts.sources.forEach(e => { let t = { ...this.opts, sources: void 0 }, r = gd[e]; if (r == null) { let s = Object.keys(gd), o = new Intl.ListFormat("en", { style: "long", type: "disjunction" }); throw new Error(`Invalid plugin: "${e}" is not one of: ${o.format(s)}.`) } this.uppy.use(r, t), md(this, Cs)[Cs].add(this.uppy.getPlugin(e)) }) } uninstall() { for (let e of md(this, Cs)[Cs]) this.uppy.removePlugin(e); md(this, Cs)[Cs].clear() } }; n(Rs, "RemoteSources"); Rs.VERSION = n_.version; var cv = n(() => u("svg", { className: "uppy-DashboardTab-iconScreenRec", "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("g", { fill: "currentcolor", fillRule: "evenodd" }, u("path", { d: "M24.182 9H7.818C6.81 9 6 9.742 6 10.667v10c0 .916.81 1.666 1.818 1.666h4.546V24h7.272v-1.667h4.546c1 0 1.809-.75 1.809-1.666l.009-10C26 9.742 25.182 9 24.182 9zM24 21H8V11h16v10z" }), u("circle", { cx: "16", cy: "16", r: "2" }))), "default"); function yd(i) { let { recording: e, onStartRecording: t, onStopRecording: r, i18n: s } = i; return e ? u("button", { className: "uppy-u-reset uppy-c-btn uppy-ScreenCapture-button uppy-ScreenCapture-button--video uppy-ScreenCapture-button--stop-rec", type: "button", title: s("stopCapturing"), "aria-label": s("stopCapturing"), onClick: r, "data-uppy-super-focusable": !0 }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "100", height: "100", viewBox: "0 0 100 100" }, u("rect", { x: "15", y: "15", width: "70", height: "70" }))) : u("button", { className: "uppy-u-reset uppy-c-btn uppy-ScreenCapture-button uppy-ScreenCapture-button--video", type: "button", title: s("startCapturing"), "aria-label": s("startCapturing"), onClick: t, "data-uppy-super-focusable": !0 }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "100", height: "100", viewBox: "0 0 100 100" }, u("circle", { cx: "50", cy: "50", r: "40" }))) } n(yd, "RecordButton"); function vd(i) { let { recording: e, recordedVideo: t, onSubmit: r, i18n: s } = i; return t && !e ? u("button", { className: "uppy-u-reset uppy-c-btn uppy-ScreenCapture-button uppy-ScreenCapture-button--submit", type: "button", title: s("submitRecordedFile"), "aria-label": s("submitRecordedFile"), onClick: r, "data-uppy-super-focusable": !0 }, u("svg", { width: "12", height: "9", viewBox: "0 0 12 9", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", focusable: "false", className: "uppy-c-icon" }, u("path", { fill: "#fff", fillRule: "nonzero", d: "M10.66 0L12 1.31 4.136 9 0 4.956l1.34-1.31L4.136 6.38z" }))) : null } n(vd, "SubmitButton"); var Bu = class extends ue { constructor(e) { super(e), this.state = { elapsedTime: 0 }, this.wrapperStyle = { width: "100%", height: "100%", display: "flex" }, this.overlayStyle = { position: "absolute", width: "100%", height: "100%", background: "black", opacity: .7 }, this.infoContainerStyle = { marginLeft: "auto", marginRight: "auto", marginTop: "auto", marginBottom: "auto", zIndex: 1, color: "white" }, this.infotextStyle = { marginLeft: "auto", marginRight: "auto", marginBottom: "1rem", fontSize: "1.5rem" }, this.timeStyle = { display: "block", fontWeight: "bold", marginLeft: "auto", marginRight: "auto", fontSize: "3rem", fontFamily: "Courier New" } } startTimer() { this.timerTick(), this.timerRunning = !0 } resetTimer() { clearTimeout(this.timer), this.setState({ elapsedTime: 0 }), this.timerRunning = !1 } timerTick() { this.timer = setTimeout(() => { this.setState(e => ({ elapsedTime: e.elapsedTime + 1 })), this.timerTick() }, 1e3) } fmtMSS(e) { return (e - (e %= 60)) / 60 + (e > 9 ? ":" : ":0") + e } render() { let { recording: e, i18n: t } = { ...this.props }, { elapsedTime: r } = this.state, s = this.fmtMSS(r); return e && !this.timerRunning && this.startTimer(), !e && this.timerRunning && this.resetTimer(), e ? u("div", { style: this.wrapperStyle }, u("div", { style: this.overlayStyle }), u("div", { style: this.infoContainerStyle }, u("div", { style: this.infotextStyle }, t("recording")), u("div", { style: this.timeStyle }, s))) : null } }; n(Bu, "StopWatch"); var dv = Bu; var pv = n(i => { let { streamActive: e, i18n: t } = i; return e ? u("div", { title: t("streamActive"), "aria-label": t("streamActive"), className: "uppy-ScreenCapture-icon--stream uppy-ScreenCapture-icon--streamActive" }, u("svg", { "aria-hidden": "true", focusable: "false", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M0 0h24v24H0z", opacity: ".1", fill: "none" }), u("path", { d: "M0 0h24v24H0z", fill: "none" }), u("path", { d: "M1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm18-7H5v1.63c3.96 1.28 7.09 4.41 8.37 8.37H19V7zM1 10v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11zm20-7H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z" }))) : u("div", { title: t("streamPassive"), "aria-label": t("streamPassive"), className: "uppy-ScreenCapture-icon--stream" }, u("svg", { "aria-hidden": "true", focusable: "false", width: "24", height: "24", viewBox: "0 0 24 24" }, u("path", { d: "M0 0h24v24H0z", opacity: ".1", fill: "none" }), u("path", { d: "M0 0h24v24H0z", fill: "none" }), u("path", { d: "M21 3H3c-1.1 0-2 .9-2 2v3h2V5h18v14h-7v2h7c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM1 18v3h3c0-1.66-1.34-3-3-3zm0-4v2c2.76 0 5 2.24 5 5h2c0-3.87-3.13-7-7-7zm0-4v2c4.97 0 9 4.03 9 9h2c0-6.08-4.93-11-11-11z" }))) }, "default"); function bd() { return bd = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, bd.apply(this, arguments) } n(bd, "_extends"); var Lu = class extends ue { componentWillUnmount() { let { onStop: e } = this.props; e() } render() { let { recording: e, stream: t, recordedVideo: r } = this.props, s = { playsinline: !0 }; return (e || !r && !e) && (s.muted = !0, s.autoplay = !0, s.srcObject = t), r && !e && (s.muted = !1, s.controls = !0, s.src = r, this.videoElement && (this.videoElement.srcObject = void 0)), u("div", { className: "uppy uppy-ScreenCapture-container" }, u("div", { className: "uppy-ScreenCapture-videoContainer" }, u(pv, this.props), u("video", bd({ ref: o => { this.videoElement = o }, className: "uppy-ScreenCapture-video" }, s)), u(dv, this.props)), u("div", { className: "uppy-ScreenCapture-buttonContainer" }, u(yd, this.props), u(vd, this.props))) } }; n(Lu, "RecorderScreen"); var fv = Lu; var mv = { strings: { startCapturing: "Begin screen capturing", stopCapturing: "Stop screen capturing", submitRecordedFile: "Submit recorded file", streamActive: "Stream active", streamPassive: "Stream passive", micDisabled: "Microphone access denied by user", recording: "Recording" } }; function wd() { return wd = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, wd.apply(this, arguments) } n(wd, "_extends"); var a_ = { version: "3.1.2" }; function l_() { var i; return window.MediaRecorder && ((i = navigator.mediaDevices) == null ? void 0 : i.getDisplayMedia) } n(l_, "isScreenRecordingSupported"); function u_() { return window.MediaRecorder && navigator.mediaDevices } n(u_, "getMediaDevices"); var Wr = class extends G { constructor(e, t) { super(e, t), this.mediaDevices = u_(), this.protocol = location.protocol === "https:" ? "https" : "http", this.id = this.opts.id || "ScreenCapture", this.title = this.opts.title || "Screencast", this.type = "acquirer", this.icon = cv, this.defaultLocale = mv; let r = { displayMediaConstraints: { video: { width: 1280, height: 720, frameRate: { ideal: 3, max: 5 }, cursor: "motion", displaySurface: "monitor" } }, userMediaConstraints: { audio: !0 }, preferredVideoMimeType: "video/webm" }; this.opts = { ...r, ...t }, this.i18nInit(), this.install = this.install.bind(this), this.setPluginState = this.setPluginState.bind(this), this.render = this.render.bind(this), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this.startRecording = this.startRecording.bind(this), this.stopRecording = this.stopRecording.bind(this), this.submit = this.submit.bind(this), this.streamInterrupted = this.streamInactivated.bind(this), this.captureActive = !1, this.capturedMediaFile = null } install() { if (!l_()) return this.uppy.log("Screen recorder access is not supported", "warning"), null; this.setPluginState({ streamActive: !1, audioStreamActive: !1 }); let { target: e } = this.opts; e && this.mount(e, this) } uninstall() { this.videoStream && this.stop(), this.unmount() } start() { return this.mediaDevices ? (this.captureActive = !0, this.selectAudioStreamSource(), this.selectVideoStreamSource().then(e => { e === !1 && this.parent && this.parent.hideAllPanels && (this.parent.hideAllPanels(), this.captureActive = !1) })) : Promise.reject(new Error("Screen recorder access not supported")) } selectVideoStreamSource() { return this.videoStream ? new Promise(e => e(this.videoStream)) : this.mediaDevices.getDisplayMedia(this.opts.displayMediaConstraints).then(e => (this.videoStream = e, this.videoStream.addEventListener("inactive", () => { this.streamInactivated() }), this.setPluginState({ streamActive: !0 }), e)).catch(e => (this.setPluginState({ screenRecError: e }), this.userDenied = !0, setTimeout(() => { this.userDenied = !1 }, 1e3), !1)) } selectAudioStreamSource() { return this.audioStream ? new Promise(e => e(this.audioStream)) : this.mediaDevices.getUserMedia(this.opts.userMediaConstraints).then(e => (this.audioStream = e, this.setPluginState({ audioStreamActive: !0 }), e)).catch(e => (e.name === "NotAllowedError" && (this.uppy.info(this.i18n("micDisabled"), "error", 5e3), this.uppy.log(this.i18n("micDisabled"), "warning")), !1)) } startRecording() { let e = {}; this.capturedMediaFile = null, this.recordingChunks = []; let { preferredVideoMimeType: t } = this.opts; this.selectVideoStreamSource().then(r => { t && MediaRecorder.isTypeSupported(t) && Ii(t) && (e.mimeType = t); let s = [r.getVideoTracks()[0]]; this.audioStream && s.push(this.audioStream.getAudioTracks()[0]), this.outputStream = new MediaStream(s), this.recorder = new MediaRecorder(this.outputStream, e), this.recorder.addEventListener("dataavailable", o => { this.recordingChunks.push(o.data) }), this.recorder.start(), this.setPluginState({ recording: !0 }) }).catch(r => { this.uppy.log(r, "error") }) } streamInactivated() { let { recordedVideo: e, recording: t } = { ...this.getPluginState() }; !e && !t ? this.parent && this.parent.hideAllPanels && this.parent.hideAllPanels() : t && (this.uppy.log("Capture stream inactive \u2014 stop recording"), this.stopRecording()), this.videoStream = null, this.audioStream = null, this.setPluginState({ streamActive: !1, audioStreamActive: !1 }) } stopRecording() { return new Promise(t => { this.recorder.addEventListener("stop", () => { t() }), this.recorder.stop() }).then(() => (this.setPluginState({ recording: !1 }), this.getVideo())).then(t => { this.capturedMediaFile = t, this.setPluginState({ recordedVideo: URL.createObjectURL(t.data) }) }).then(() => { this.recordingChunks = null, this.recorder = null }, t => { throw this.recordingChunks = null, this.recorder = null, t }) } submit() { try { this.capturedMediaFile && this.uppy.addFile(this.capturedMediaFile) } catch (e) { e.isRestriction || this.uppy.log(e, "warning") } } stop() { this.videoStream && (this.videoStream.getVideoTracks().forEach(e => { e.stop() }), this.videoStream.getAudioTracks().forEach(e => { e.stop() }), this.videoStream = null), this.audioStream && (this.audioStream.getAudioTracks().forEach(e => { e.stop() }), this.audioStream.getVideoTracks().forEach(e => { e.stop() }), this.audioStream = null), this.outputStream && (this.outputStream.getAudioTracks().forEach(e => { e.stop() }), this.outputStream.getVideoTracks().forEach(e => { e.stop() }), this.outputStream = null), this.setPluginState({ recordedVideo: null }), this.captureActive = !1 } getVideo() { let e = this.recordingChunks[0].type, t = Ii(e); if (!t) return Promise.reject(new Error(`Could not retrieve recording: Unsupported media type "${e}"`)); let r = `screencap-${Date.now()}.${t}`, s = new Blob(this.recordingChunks, { type: e }), o = { source: this.id, name: r, data: new Blob([s], { type: e }), type: e }; return Promise.resolve(o) } render() { let e = this.getPluginState(); return !e.streamActive && !this.captureActive && !this.userDenied && this.start(), u(fv, wd({}, e, { onStartRecording: this.startRecording, onStopRecording: this.stopRecording, onStop: this.stop, onSubmit: this.submit, i18n: this.i18n, stream: this.videoStream })) } }; n(Wr, "ScreenCapture"); Wr.VERSION = a_.version; var Ev = se(gv(), 1); function Pd(i, e, t) { return new Promise(r => { i.toBlob(r, e, t) }) } n(Pd, "canvasToBlob"); function _d() { return typeof MediaRecorder == "function" && !!MediaRecorder.prototype && typeof MediaRecorder.prototype.start == "function" } n(_d, "supportsMediaRecorder"); var zu = n(() => u("svg", { "aria-hidden": "true", focusable: "false", fill: "#0097DC", width: "66", height: "55", viewBox: "0 0 66 55" }, u("path", { d: "M57.3 8.433c4.59 0 8.1 3.51 8.1 8.1v29.7c0 4.59-3.51 8.1-8.1 8.1H8.7c-4.59 0-8.1-3.51-8.1-8.1v-29.7c0-4.59 3.51-8.1 8.1-8.1h9.45l4.59-7.02c.54-.54 1.35-1.08 2.16-1.08h16.2c.81 0 1.62.54 2.16 1.08l4.59 7.02h9.45zM33 14.64c-8.62 0-15.393 6.773-15.393 15.393 0 8.62 6.773 15.393 15.393 15.393 8.62 0 15.393-6.773 15.393-15.393 0-8.62-6.773-15.393-15.393-15.393zM33 40c-5.648 0-9.966-4.319-9.966-9.967 0-5.647 4.318-9.966 9.966-9.966s9.966 4.319 9.966 9.966C42.966 35.681 38.648 40 33 40z", fillRule: "evenodd" })), "default"); var yv = n(i => { let { onSnapshot: e, i18n: t } = i; return u("button", { className: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--picture", type: "button", title: t("takePicture"), "aria-label": t("takePicture"), onClick: e, "data-uppy-super-focusable": !0 }, zu()) }, "default"); function xd(i) { let { recording: e, onStartRecording: t, onStopRecording: r, i18n: s } = i; return e ? u("button", { className: "uppy-u-reset uppy-c-btn uppy-Webcam-button", type: "button", title: s("stopRecording"), "aria-label": s("stopRecording"), onClick: r, "data-uppy-super-focusable": !0 }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "100", height: "100", viewBox: "0 0 100 100" }, u("rect", { x: "15", y: "15", width: "70", height: "70" }))) : u("button", { className: "uppy-u-reset uppy-c-btn uppy-Webcam-button", type: "button", title: s("startRecording"), "aria-label": s("startRecording"), onClick: t, "data-uppy-super-focusable": !0 }, u("svg", { "aria-hidden": "true", focusable: "false", className: "uppy-c-icon", width: "100", height: "100", viewBox: "0 0 100 100" }, u("circle", { cx: "50", cy: "50", r: "40" }))) } n(xd, "RecordButton"); function Ed(i) { return `${Math.floor(i / 60)}:${String(i % 60).padStart(2, 0)}` } n(Ed, "formatSeconds"); function Fd(i) { let { recordingLengthSeconds: e, i18n: t } = i, r = Ed(e); return u("span", { "aria-label": t("recordingLength", { recording_length: r }) }, r) } n(Fd, "RecordingLength"); var vv = n(i => { let { currentDeviceId: e, videoSources: t, onChangeVideoSource: r } = i; return u("div", { className: "uppy-Webcam-videoSource" }, u("select", { className: "uppy-u-reset uppy-Webcam-videoSource-select", onChange: s => { r(s.target.value) } }, t.map(s => u("option", { key: s.deviceId, value: s.deviceId, selected: s.deviceId === e }, s.label)))) }, "default"); function p_(i) { let { onSubmit: e, i18n: t } = i; return u("button", { className: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--submit", type: "button", title: t("submitRecordedFile"), "aria-label": t("submitRecordedFile"), onClick: e, "data-uppy-super-focusable": !0 }, u("svg", { width: "12", height: "9", viewBox: "0 0 12 9", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", focusable: "false", className: "uppy-c-icon" }, u("path", { fill: "#fff", fillRule: "nonzero", d: "M10.66 0L12 1.31 4.136 9 0 4.956l1.34-1.31L4.136 6.38z" }))) } n(p_, "SubmitButton"); var bv = p_; function f_(i) { let { onDiscard: e, i18n: t } = i; return u("button", { className: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--discard", type: "button", title: t("discardRecordedFile"), "aria-label": t("discardRecordedFile"), onClick: e, "data-uppy-super-focusable": !0 }, u("svg", { width: "13", height: "13", viewBox: "0 0 13 13", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": "true", focusable: "false", className: "uppy-c-icon" }, u("g", { fill: "#FFF", fillRule: "evenodd" }, u("path", { d: "M.496 11.367L11.103.76l1.414 1.414L1.911 12.781z" }), u("path", { d: "M11.104 12.782L.497 2.175 1.911.76l10.607 10.606z" })))) } n(f_, "DiscardButton"); var wv = f_; function Od() { return Od = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, Od.apply(this, arguments) } n(Od, "_extends"); function ju(i, e) { return i.includes(e) } n(ju, "isModeAvailable"); var Hu = class extends ue { componentDidMount() { let { onFocus: e } = this.props; e() } componentWillUnmount() { let { onStop: e } = this.props; e() } render() { let { src: e, recordedVideo: t, recording: r, modes: s, supportsRecording: o, videoSources: a, showVideoSourceDropdown: l, showRecordingLength: h, onSubmit: c, i18n: d, mirror: p, onSnapshot: y, onStartRecording: v, onStopRecording: S, onDiscardRecordedVideo: x, recordingLengthSeconds: E } = this.props, F = !!t, k = !F && o && (ju(s, "video-only") || ju(s, "audio-only") || ju(s, "video-audio")), B = !F && ju(s, "picture"), H = o && h && !F, W = l && a && a.length > 1, I = { playsinline: !0 }; return t ? (I.muted = !1, I.controls = !0, I.src = t, this.videoElement && (this.videoElement.srcObject = void 0)) : (I.muted = !0, I.autoplay = !0, I.srcObject = e), u("div", { className: "uppy uppy-Webcam-container" }, u("div", { className: "uppy-Webcam-videoContainer" }, u("video", Od({ ref: q => this.videoElement = q, className: `uppy-Webcam-video  ${p ? "uppy-Webcam-video--mirrored" : ""}` }, I))), u("div", { className: "uppy-Webcam-footer" }, u("div", { className: "uppy-Webcam-videoSourceContainer" }, W ? vv(this.props) : null), u("div", { className: "uppy-Webcam-buttonContainer" }, B && u(yv, { onSnapshot: y, i18n: d }), k && u(xd, { recording: r, onStartRecording: v, onStopRecording: S, i18n: d }), F && u(bv, { onSubmit: c, i18n: d }), F && u(wv, { onDiscard: x, i18n: d })), u("div", { className: "uppy-Webcam-recordingLength" }, H && u(Fd, { recordingLengthSeconds: E, i18n: d })))) } }; n(Hu, "CameraScreen"); var Sv = Hu; var Pv = n(i => { let { icon: e, i18n: t, hasCamera: r } = i; return u("div", { className: "uppy-Webcam-permissons" }, u("div", { className: "uppy-Webcam-permissonsIcon" }, e()), u("h1", { className: "uppy-Webcam-title" }, t(r ? "allowAccessTitle" : "noCameraTitle")), u("p", null, t(r ? "allowAccessDescription" : "noCameraDescription"))) }, "default"); var _v = { strings: { pluginNameCamera: "Camera", noCameraTitle: "Camera Not Available", noCameraDescription: "In order to take pictures or record video, please connect a camera device", recordingStoppedMaxSize: "Recording stopped because the file size is about to exceed the limit", submitRecordedFile: "Submit recorded file", discardRecordedFile: "Discard recorded file", smile: "Smile!", takePicture: "Take a picture", startRecording: "Begin video recording", stopRecording: "Stop video recording", recordingLength: "Recording length %{recording_length}", allowAccessTitle: "Please allow access to your camera", allowAccessDescription: "In order to take pictures or record video with your camera, please allow camera access for this site." } }; function Td() { return Td = Object.assign ? Object.assign.bind() : function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, Td.apply(this, arguments) } n(Td, "_extends"); function wa(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(wa, "_classPrivateFieldLooseBase"); var m_ = 0; function g_(i) { return "__private_" + m_++ + "_" + i } n(g_, "_classPrivateFieldLooseKey"); var y_ = { version: "3.3.2" }; function xv(i) { return i[0] === "." ? mn[i.slice(1)] : i } n(xv, "toMimeType"); function v_(i) { return /^video\/[^*]+$/.test(i) } n(v_, "isVideoMimeType"); function b_(i) { return /^image\/[^*]+$/.test(i) } n(b_, "isImageMimeType"); function w_() { return navigator.mediaDevices } n(w_, "getMediaDevices"); function Ad(i, e) { return i.includes(e) } n(Ad, "isModeAvailable"); var yi = g_("enableMirror"), Kr = class extends G { constructor(e, t) { super(e, t), Object.defineProperty(this, yi, { writable: !0, value: void 0 }), this.mediaDevices = w_(), this.supportsUserMedia = !!this.mediaDevices, this.protocol = location.protocol.match(/https/i) ? "https" : "http", this.id = this.opts.id || "Webcam", this.type = "acquirer", this.capturedMediaFile = null, this.icon = () => u("svg", { "aria-hidden": "true", focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32" }, u("path", { d: "M23.5 9.5c1.417 0 2.5 1.083 2.5 2.5v9.167c0 1.416-1.083 2.5-2.5 2.5h-15c-1.417 0-2.5-1.084-2.5-2.5V12c0-1.417 1.083-2.5 2.5-2.5h2.917l1.416-2.167C13 7.167 13.25 7 13.5 7h5c.25 0 .5.167.667.333L20.583 9.5H23.5zM16 11.417a4.706 4.706 0 00-4.75 4.75 4.704 4.704 0 004.75 4.75 4.703 4.703 0 004.75-4.75c0-2.663-2.09-4.75-4.75-4.75zm0 7.825c-1.744 0-3.076-1.332-3.076-3.074 0-1.745 1.333-3.077 3.076-3.077 1.744 0 3.074 1.333 3.074 3.076s-1.33 3.075-3.074 3.075z", fill: "#02B383", fillRule: "nonzero" })), this.defaultLocale = _v; let r = { onBeforeSnapshot: () => Promise.resolve(), countdown: !1, modes: ["video-audio", "video-only", "audio-only", "picture"], mirror: !0, showVideoSourceDropdown: !1, facingMode: "user", videoConstraints: void 0, preferredImageMimeType: null, preferredVideoMimeType: null, showRecordingLength: !1, mobileNativeCamera: (0, Ev.default)({ tablet: !0 }) }; this.opts = { ...r, ...t }, this.i18nInit(), this.title = this.i18n("pluginNameCamera"), wa(this, yi)[yi] = this.opts.mirror, this.install = this.install.bind(this), this.setPluginState = this.setPluginState.bind(this), this.render = this.render.bind(this), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this.takeSnapshot = this.takeSnapshot.bind(this), this.startRecording = this.startRecording.bind(this), this.stopRecording = this.stopRecording.bind(this), this.discardRecordedVideo = this.discardRecordedVideo.bind(this), this.submit = this.submit.bind(this), this.oneTwoThreeSmile = this.oneTwoThreeSmile.bind(this), this.focus = this.focus.bind(this), this.changeVideoSource = this.changeVideoSource.bind(this), this.webcamActive = !1, this.opts.countdown && (this.opts.onBeforeSnapshot = this.oneTwoThreeSmile), this.setPluginState({ hasCamera: !1, cameraReady: !1, cameraError: null, recordingLengthSeconds: 0, videoSources: [], currentDeviceId: null }) } setOptions(e) { super.setOptions({ ...e, videoConstraints: { ...this.opts.videoConstraints, ...e?.videoConstraints } }) } hasCameraCheck() { return this.mediaDevices ? this.mediaDevices.enumerateDevices().then(e => e.some(t => t.kind === "videoinput")) : Promise.resolve(!1) } isAudioOnly() { return this.opts.modes.length === 1 && this.opts.modes[0] === "audio-only" } getConstraints(e) { e === void 0 && (e = null); let t = this.opts.modes.indexOf("video-audio") !== -1 || this.opts.modes.indexOf("audio-only") !== -1, r = !this.isAudioOnly() && (this.opts.modes.indexOf("video-audio") !== -1 || this.opts.modes.indexOf("video-only") !== -1 || this.opts.modes.indexOf("picture") !== -1), s = { ...this.opts.videoConstraints || { facingMode: this.opts.facingMode }, ...e ? { deviceId: e, facingMode: null } : {} }; return { audio: t, video: r ? s : !1 } } start(e) { if (e === void 0 && (e = null), !this.supportsUserMedia) return Promise.reject(new Error("Webcam access not supported")); this.webcamActive = !0, this.opts.mirror && (wa(this, yi)[yi] = !0); let t = this.getConstraints(e && e.deviceId ? e.deviceId : null); this.hasCameraCheck().then(r => (this.setPluginState({ hasCamera: r }), this.mediaDevices.getUserMedia(t).then(s => { this.stream = s; let o = null, a = this.isAudioOnly() ? s.getAudioTracks() : s.getVideoTracks(); !e || !e.deviceId ? o = a[0].getSettings().deviceId : a.forEach(l => { l.getSettings().deviceId === e.deviceId && (o = l.getSettings().deviceId) }), this.updateVideoSources(), this.setPluginState({ currentDeviceId: o, cameraReady: !0 }) }).catch(s => { this.setPluginState({ cameraReady: !1, cameraError: s }), this.uppy.info(s.message, "error") }))) } getMediaRecorderOptions() { let e = {}; if (MediaRecorder.isTypeSupported) { let { restrictions: t } = this.uppy.opts, r = []; this.opts.preferredVideoMimeType ? r = [this.opts.preferredVideoMimeType] : t.allowedFileTypes && (r = t.allowedFileTypes.map(xv).filter(v_)); let s = n(a => MediaRecorder.isTypeSupported(a) && Ii(a), "filterSupportedTypes"), o = r.filter(s); o.length > 0 && (e.mimeType = o[0]) } return e } startRecording() { this.recorder = new MediaRecorder(this.stream, this.getMediaRecorderOptions()), this.recordingChunks = []; let e = !1; this.recorder.addEventListener("dataavailable", t => { this.recordingChunks.push(t.data); let { restrictions: r } = this.uppy.opts; if (this.recordingChunks.length > 1 && r.maxFileSize != null && !e) { let s = this.recordingChunks.reduce((h, c) => h + c.size, 0), a = (s - this.recordingChunks[0].size) / (this.recordingChunks.length - 1) * 3, l = Math.max(0, r.maxFileSize - a); s > l && (e = !0, this.uppy.info(this.i18n("recordingStoppedMaxSize"), "warning", 4e3), this.stopRecording()) } }), this.recorder.start(500), this.opts.showRecordingLength && (this.recordingLengthTimer = setInterval(() => { let t = this.getPluginState().recordingLengthSeconds; this.setPluginState({ recordingLengthSeconds: t + 1 }) }, 1e3)), this.setPluginState({ isRecording: !0 }) } stopRecording() { return new Promise(t => { this.recorder.addEventListener("stop", () => { t() }), this.recorder.stop(), this.opts.showRecordingLength && (clearInterval(this.recordingLengthTimer), this.setPluginState({ recordingLengthSeconds: 0 })) }).then(() => (this.setPluginState({ isRecording: !1 }), this.getVideo())).then(t => { try { this.capturedMediaFile = t, this.setPluginState({ recordedVideo: URL.createObjectURL(t.data) }), wa(this, yi)[yi] = !1 } catch (r) { r.isRestriction || this.uppy.log(r) } }).then(() => { this.recordingChunks = null, this.recorder = null }, t => { throw this.recordingChunks = null, this.recorder = null, t }) } discardRecordedVideo() { this.setPluginState({ recordedVideo: null }), this.opts.mirror && (wa(this, yi)[yi] = !0), this.capturedMediaFile = null } submit() { try { this.capturedMediaFile && this.uppy.addFile(this.capturedMediaFile) } catch (e) { e.isRestriction || this.uppy.log(e, "error") } } async stop() { if (this.stream) { let e = this.stream.getAudioTracks(), t = this.stream.getVideoTracks(); e.concat(t).forEach(r => r.stop()) } this.recorder && await new Promise(e => { this.recorder.addEventListener("stop", e, { once: !0 }), this.recorder.stop(), this.opts.showRecordingLength && clearInterval(this.recordingLengthTimer) }), this.recordingChunks = null, this.recorder = null, this.webcamActive = !1, this.stream = null, this.setPluginState({ recordedVideo: null, isRecording: !1, recordingLengthSeconds: 0 }) } getVideoElement() { return this.el.querySelector(".uppy-Webcam-video") } oneTwoThreeSmile() { return new Promise((e, t) => { let r = this.opts.countdown, s = setInterval(() => { if (!this.webcamActive) return clearInterval(s), this.captureInProgress = !1, t(new Error("Webcam is not active")); r > 0 ? (this.uppy.info(`${r}...`, "warning", 800), r--) : (clearInterval(s), this.uppy.info(this.i18n("smile"), "success", 1500), setTimeout(() => e(), 1500)) }, 1e3) }) } takeSnapshot() { this.captureInProgress || (this.captureInProgress = !0, this.opts.onBeforeSnapshot().catch(e => { let t = typeof e == "object" ? e.message : e; return this.uppy.info(t, "error", 5e3), Promise.reject(new Error(`onBeforeSnapshot: ${t}`)) }).then(() => this.getImage()).then(e => { this.captureInProgress = !1; try { this.uppy.addFile(e) } catch (t) { t.isRestriction || this.uppy.log(t) } }, e => { throw this.captureInProgress = !1, e })) } getImage() { let e = this.getVideoElement(); if (!e) return Promise.reject(new Error("No video element found, likely due to the Webcam tab being closed.")); let t = e.videoWidth, r = e.videoHeight, s = document.createElement("canvas"); s.width = t, s.height = r, s.getContext("2d").drawImage(e, 0, 0); let { restrictions: a } = this.uppy.opts, l = []; this.opts.preferredImageMimeType ? l = [this.opts.preferredImageMimeType] : a.allowedFileTypes && (l = a.allowedFileTypes.map(xv).filter(b_)); let h = l[0] || "image/jpeg", c = Ii(h) || "jpg", d = `cam-${Date.now()}.${c}`; return Pd(s, h).then(p => ({ source: this.id, name: d, data: new Blob([p], { type: h }), type: h })) } getVideo() { let e = this.recordingChunks.find(a => { var l; return ((l = a.type) == null ? void 0 : l.length) > 0 }).type, t = Ii(e); if (!t) return Promise.reject(new Error(`Could not retrieve recording: Unsupported media type "${e}"`)); let r = `webcam-${Date.now()}.${t}`, s = new Blob(this.recordingChunks, { type: e }), o = { source: this.id, name: r, data: new Blob([s], { type: e }), type: e }; return Promise.resolve(o) } focus() { this.opts.countdown && setTimeout(() => { this.uppy.info(this.i18n("smile"), "success", 1500) }, 1e3) } changeVideoSource(e) { this.stop(), this.start({ deviceId: e }) } updateVideoSources() { this.mediaDevices.enumerateDevices().then(e => { this.setPluginState({ videoSources: e.filter(t => t.kind === "videoinput") }) }) } render() { this.webcamActive || this.start(); let e = this.getPluginState(); return !e.cameraReady || !e.hasCamera ? u(Pv, { icon: zu, i18n: this.i18n, hasCamera: e.hasCamera }) : u(Sv, Td({}, e, { onChangeVideoSource: this.changeVideoSource, onSnapshot: this.takeSnapshot, onStartRecording: this.startRecording, onStopRecording: this.stopRecording, onDiscardRecordedVideo: this.discardRecordedVideo, onSubmit: this.submit, onFocus: this.focus, onStop: this.stop, i18n: this.i18n, modes: this.opts.modes, showRecordingLength: this.opts.showRecordingLength, showVideoSourceDropdown: this.opts.showVideoSourceDropdown, supportsRecording: _d(), recording: e.isRecording, mirror: wa(this, yi)[yi], src: this.stream })) } install() { let { mobileNativeCamera: e, modes: t, facingMode: r, videoConstraints: s } = this.opts, { target: o } = this.opts; if (e && o) { var a; (a = this.getTargetPlugin(o)) == null || a.setOptions({ showNativeVideoCameraButton: Ad(t, "video-only") || Ad(t, "video-audio"), showNativePhotoCameraButton: Ad(t, "picture"), nativeCameraFacingMode: s?.facingMode || r }); return } this.setPluginState({ cameraReady: !1, recordingLengthSeconds: 0 }), o && this.mount(o, this), this.mediaDevices && (this.updateVideoSources(), this.mediaDevices.ondevicechange = () => { if (this.updateVideoSources(), this.stream) { let l = !0, { videoSources: h, currentDeviceId: c } = this.getPluginState(); h.forEach(d => { c === d.deviceId && (l = !1) }), l && (this.stop(), this.start()) } }) } uninstall() { this.stop(), this.unmount() } onUnmount() { this.stop() } }; n(Kr, "Webcam"); Kr.VERSION = y_.version; function Fv(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Fv, "_classPrivateFieldLooseBase"); var S_ = 0; function P_(i) { return "__private_" + S_++ + "_" + i } n(P_, "_classPrivateFieldLooseKey"); var Sa = P_("queueRequestSocketToken"), ri = class extends Fe { constructor() { super(...arguments), Object.defineProperty(this, Sa, { writable: !0, value: void 0 }) } setQueueRequestSocketToken(e) { Fv(this, Sa)[Sa] = e } async uploadRemoteFile(e, t) { t === void 0 && (t = {}); try { if (e.serverToken) return await this.connectToServerSocket(e); let s = await Fv(this, Sa)[Sa](e).abortOn(t.signal); return this.uppy.getState().files[e.id] ? (this.uppy.setFileState(e.id, { serverToken: s }), await this.connectToServerSocket(this.uppy.getFile(e.id))) : void 0 } catch (s) { var r; if ((s == null || (r = s.cause) == null ? void 0 : r.name) === "AbortError") return; throw this.uppy.setFileState(e.id, { serverToken: void 0 }), this.uppy.emit("upload-error", e, s), s } } }; n(ri, "UploaderPlugin"); function Pa(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Pa, "_classPrivateFieldLooseBase"); var __ = 0; function Ov(i) { return "__private_" + __++ + "_" + i } n(Ov, "_classPrivateFieldLooseKey"); var ks = Ov("emitter"), _a = Ov("events"), at = class { constructor(e) { Object.defineProperty(this, ks, { writable: !0, value: void 0 }), Object.defineProperty(this, _a, { writable: !0, value: [] }), Pa(this, ks)[ks] = e } on(e, t) { return Pa(this, _a)[_a].push([e, t]), Pa(this, ks)[ks].on(e, t) } remove() { for (let [e, t] of Pa(this, _a)[_a].splice(0)) Pa(this, ks)[ks].off(e, t) } }; n(at, "EventManager"); var Av = se(Il(), 1); function x_(i, e, t) { let { progress: r, bytesUploaded: s, bytesTotal: o } = e; r && (i.uppy.log(`Upload progress: ${r}`), i.uppy.emit("upload-progress", t, { uploader: i, bytesUploaded: s, bytesTotal: o })) } n(x_, "emitSocketProgress"); var Gr = (0, Av.default)(x_, 300, { leading: !0, trailing: !0 }); function wr(i) { let t = /^(?:https?:\/\/|\/\/)?(?:[^@\n]+@)?(?:www\.)?([^\n]+)/i.exec(i)[1]; return `${/^http:\/\//i.test(i) ? "ws" : "wss"}://${t}` } n(wr, "getSocketHost"); function K(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(K, "_classPrivateFieldLooseBase"); var E_ = 0; function At(i) { return "__private_" + E_++ + "_" + i } n(At, "_classPrivateFieldLooseKey"); function F_(i) { return new Error("Cancelled", { cause: i }) } n(F_, "createCancelError"); function Tv(i) { if (i != null) { var e; let t = n(() => this.abort(i.reason), "abortPromise"); i.addEventListener("abort", t, { once: !0 }); let r = n(() => { i.removeEventListener("abort", t) }, "removeAbortListener"); (e = this.then) == null || e.call(this, r, r) } return this } n(Tv, "abortOn"); var jt = At("activeRequests"), yt = At("queuedHandlers"), zt = At("paused"), Us = At("pauseTimer"), gt = At("downLimit"), Ds = At("upperLimit"), Sr = At("rateLimitingTimer"), xa = At("call"), Pr = At("queueNext"), kd = At("next"), Cd = At("queue"), Ud = At("dequeue"), Rd = At("resume"), Ns = At("increaseLimit"), vt = class { constructor(e) { Object.defineProperty(this, Ud, { value: R_ }), Object.defineProperty(this, Cd, { value: C_ }), Object.defineProperty(this, kd, { value: T_ }), Object.defineProperty(this, Pr, { value: A_ }), Object.defineProperty(this, xa, { value: O_ }), Object.defineProperty(this, jt, { writable: !0, value: 0 }), Object.defineProperty(this, yt, { writable: !0, value: [] }), Object.defineProperty(this, zt, { writable: !0, value: !1 }), Object.defineProperty(this, Us, { writable: !0, value: void 0 }), Object.defineProperty(this, gt, { writable: !0, value: 1 }), Object.defineProperty(this, Ds, { writable: !0, value: void 0 }), Object.defineProperty(this, Sr, { writable: !0, value: void 0 }), Object.defineProperty(this, Rd, { writable: !0, value: () => this.resume() }), Object.defineProperty(this, Ns, { writable: !0, value: () => { if (K(this, zt)[zt]) { K(this, Sr)[Sr] = setTimeout(K(this, Ns)[Ns], 0); return } K(this, gt)[gt] = this.limit, this.limit = Math.ceil((K(this, Ds)[Ds] + K(this, gt)[gt]) / 2); for (let t = K(this, gt)[gt]; t <= this.limit; t++)K(this, Pr)[Pr](); K(this, Ds)[Ds] - K(this, gt)[gt] > 3 ? K(this, Sr)[Sr] = setTimeout(K(this, Ns)[Ns], 2e3) : K(this, gt)[gt] = Math.floor(K(this, gt)[gt] / 2) } }), typeof e != "number" || e === 0 ? this.limit = 1 / 0 : this.limit = e } run(e, t) { return !K(this, zt)[zt] && K(this, jt)[jt] < this.limit ? K(this, xa)[xa](e) : K(this, Cd)[Cd](e, t) } wrapSyncFunction(e, t) { var r = this; return function () { for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++)o[a] = arguments[a]; let l = r.run(() => (e(...o), queueMicrotask(() => l.done()), () => { }), t); return { abortOn: Tv, abort() { l.abort() } } } } wrapPromiseFunction(e, t) { var r = this; return function () { for (var s = arguments.length, o = new Array(s), a = 0; a < s; a++)o[a] = arguments[a]; let l, h = new Promise((c, d) => { l = r.run(() => { let p, y; try { y = Promise.resolve(e(...o)) } catch (v) { y = Promise.reject(v) } return y.then(v => { p ? d(p) : (l.done(), c(v)) }, v => { p ? d(p) : (l.done(), d(v)) }), v => { p = F_(v) } }, t) }); return h.abort = c => { l.abort(c) }, h.abortOn = Tv, h } } resume() { K(this, zt)[zt] = !1, clearTimeout(K(this, Us)[Us]); for (let e = 0; e < this.limit; e++)K(this, Pr)[Pr]() } pause(e) { e === void 0 && (e = null), K(this, zt)[zt] = !0, clearTimeout(K(this, Us)[Us]), e != null && (K(this, Us)[Us] = setTimeout(K(this, Rd)[Rd], e)) } rateLimit(e) { clearTimeout(K(this, Sr)[Sr]), this.pause(e), this.limit > 1 && Number.isFinite(this.limit) && (K(this, Ds)[Ds] = this.limit - 1, this.limit = K(this, gt)[gt], K(this, Sr)[Sr] = setTimeout(K(this, Ns)[Ns], e)) } get isPaused() { return K(this, zt)[zt] } }; n(vt, "RateLimitedQueue"); function O_(i) { K(this, jt)[jt] += 1; let e = !1, t; try { t = i() } catch (r) { throw K(this, jt)[jt] -= 1, r } return { abort: r => { e || (e = !0, K(this, jt)[jt] -= 1, t(r), K(this, Pr)[Pr]()) }, done: () => { e || (e = !0, K(this, jt)[jt] -= 1, K(this, Pr)[Pr]()) } } } n(O_, "_call2"); function A_() { queueMicrotask(() => K(this, kd)[kd]()) } n(A_, "_queueNext2"); function T_() { if (K(this, zt)[zt] || K(this, jt)[jt] >= this.limit || K(this, yt)[yt].length === 0) return; let i = K(this, yt)[yt].shift(), e = K(this, xa)[xa](i.fn); i.abort = e.abort, i.done = e.done } n(T_, "_next2"); function C_(i, e) { e === void 0 && (e = {}); let t = { fn: i, priority: e.priority || 0, abort: () => { K(this, Ud)[Ud](t) }, done: () => { throw new Error("Cannot mark a queued request as done: this indicates a bug") } }, r = K(this, yt)[yt].findIndex(s => t.priority > s.priority); return r === -1 ? K(this, yt)[yt].push(t) : K(this, yt)[yt].splice(r, 0, t), t } n(C_, "_queue2"); function R_(i) { let e = K(this, yt)[yt].indexOf(i); e !== -1 && K(this, yt)[yt].splice(e, 1) } n(R_, "_dequeue2"); var Xr = Symbol("__queue"); function Yr(i) { let e = n(t => "error" in t && t.error, "hasError"); return i.filter(t => !e(t)) } n(Yr, "filterNonFailedFiles"); function Qr(i) { return i.filter(e => !e.progress.uploadStarted || !e.isRestored) } n(Qr, "filterFilesToEmitUploadStarted"); var { AbortController: qu } = globalThis, { AbortSignal: kN } = globalThis, Dd = n(function (i, e) { i === void 0 && (i = "Aborted"); let t = new DOMException(i, "AbortError"); return e != null && ht(e, "cause") && Object.defineProperty(t, "cause", { __proto__: null, configurable: !0, writable: !0, value: e.cause }), t }, "createAbortError"); function M(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(M, "_classPrivateFieldLooseBase"); var k_ = 0; function je(i) { return "__private_" + k_++ + "_" + i } n(je, "_classPrivateFieldLooseKey"); var U_ = 1024 * 1024, Cv = { getChunkSize(i) { return Math.ceil(i.size / 1e4) }, onProgress() { }, onPartComplete() { }, onSuccess() { }, onError(i) { throw i } }; function D_(i) { if (typeof i == "string") return parseInt(i, 10); if (typeof i == "number") return i; throw new TypeError("Expected a number") } n(D_, "ensureInt"); var Ca = Symbol("pausing upload, not an actual error"), Qe = je("abortController"), ze = je("chunks"), bt = je("chunkState"), Ht = je("data"), qt = je("file"), Ra = je("uploadHasStarted"), Ea = je("onError"), Ls = je("onSuccess"), _r = je("shouldUseMultipart"), Bs = je("isRestoring"), ka = je("onReject"), Is = je("maxMultipartParts"), Oa = je("minPartSize"), Nd = je("initChunks"), Id = je("createUpload"), Fa = je("resumeUpload"), Aa = je("onPartProgress"), Ta = je("onPartComplete"), Bd = je("abortUpload"), $u = class { constructor(e, t) { var r, s; Object.defineProperty(this, Bd, { value: L_ }), Object.defineProperty(this, Fa, { value: B_ }), Object.defineProperty(this, Id, { value: I_ }), Object.defineProperty(this, Nd, { value: N_ }), Object.defineProperty(this, Qe, { writable: !0, value: new qu }), Object.defineProperty(this, ze, { writable: !0, value: void 0 }), Object.defineProperty(this, bt, { writable: !0, value: void 0 }), Object.defineProperty(this, Ht, { writable: !0, value: void 0 }), Object.defineProperty(this, qt, { writable: !0, value: void 0 }), Object.defineProperty(this, Ra, { writable: !0, value: !1 }), Object.defineProperty(this, Ea, { writable: !0, value: void 0 }), Object.defineProperty(this, Ls, { writable: !0, value: void 0 }), Object.defineProperty(this, _r, { writable: !0, value: void 0 }), Object.defineProperty(this, Bs, { writable: !0, value: void 0 }), Object.defineProperty(this, ka, { writable: !0, value: o => o?.cause === Ca ? null : M(this, Ea)[Ea](o) }), Object.defineProperty(this, Is, { writable: !0, value: 1e4 }), Object.defineProperty(this, Oa, { writable: !0, value: 5 * U_ }), Object.defineProperty(this, Aa, { writable: !0, value: o => a => { if (!a.lengthComputable) return; M(this, bt)[bt][o].uploaded = D_(a.loaded); let l = M(this, bt)[bt].reduce((h, c) => h + c.uploaded, 0); this.options.onProgress(l, M(this, Ht)[Ht].size) } }), Object.defineProperty(this, Ta, { writable: !0, value: o => a => { M(this, ze)[ze][o] = null, M(this, bt)[bt][o].etag = a, M(this, bt)[bt][o].done = !0; let l = { PartNumber: o + 1, ETag: a }; this.options.onPartComplete(l) } }), this.options = { ...Cv, ...t }, (s = (r = this.options).getChunkSize) != null || (r.getChunkSize = Cv.getChunkSize), M(this, Ht)[Ht] = e, M(this, qt)[qt] = t.file, M(this, Ls)[Ls] = this.options.onSuccess, M(this, Ea)[Ea] = this.options.onError, M(this, _r)[_r] = this.options.shouldUseMultipart, M(this, Bs)[Bs] = t.uploadId && t.key, M(this, Nd)[Nd]() } start() { M(this, Ra)[Ra] ? (M(this, Qe)[Qe].signal.aborted || M(this, Qe)[Qe].abort(Ca), M(this, Qe)[Qe] = new qu, M(this, Fa)[Fa]()) : M(this, Bs)[Bs] ? (this.options.companionComm.restoreUploadFile(M(this, qt)[qt], { uploadId: this.options.uploadId, key: this.options.key }), M(this, Fa)[Fa]()) : M(this, Id)[Id]() } pause() { M(this, Qe)[Qe].abort(Ca), M(this, Qe)[Qe] = new qu } abort(e) { var t; e === void 0 && (e = void 0), (t = e) != null && t.really ? M(this, Bd)[Bd]() : this.pause() } get chunkState() { return M(this, bt)[bt] } }; n($u, "MultipartUploader"); function N_() { let i = M(this, Ht)[Ht].size, e = typeof M(this, _r)[_r] == "function" ? M(this, _r)[_r](M(this, qt)[qt]) : !!M(this, _r)[_r]; if (e && i > M(this, Oa)[Oa]) { let t = Math.max(this.options.getChunkSize(M(this, Ht)[Ht]), M(this, Oa)[Oa]), r = Math.floor(i / t); r > M(this, Is)[Is] && (r = M(this, Is)[Is], t = i / M(this, Is)[Is]), M(this, ze)[ze] = Array(r); for (let s = 0, o = 0; s < i; s += t, o++) { let a = Math.min(i, s + t), l = n(() => { let h = s; return M(this, Ht)[Ht].slice(h, a) }, "getData"); if (M(this, ze)[ze][o] = { getData: l, onProgress: M(this, Aa)[Aa](o), onComplete: M(this, Ta)[Ta](o), shouldUseMultipart: e }, M(this, Bs)[Bs]) { let h = s + t > i ? i - s : t; M(this, ze)[ze][o].setAsUploaded = () => { M(this, ze)[ze][o] = null, M(this, bt)[bt][o].uploaded = h } } } } else M(this, ze)[ze] = [{ getData: () => M(this, Ht)[Ht], onProgress: M(this, Aa)[Aa](0), onComplete: M(this, Ta)[Ta](0), shouldUseMultipart: e }]; M(this, bt)[bt] = M(this, ze)[ze].map(() => ({ uploaded: 0 })) } n(N_, "_initChunks2"); function I_() { this.options.companionComm.uploadFile(M(this, qt)[qt], M(this, ze)[ze], M(this, Qe)[Qe].signal).then(M(this, Ls)[Ls], M(this, ka)[ka]), M(this, Ra)[Ra] = !0 } n(I_, "_createUpload2"); function B_() { this.options.companionComm.resumeUploadFile(M(this, qt)[qt], M(this, ze)[ze], M(this, Qe)[Qe].signal).then(M(this, Ls)[Ls], M(this, ka)[ka]) } n(B_, "_resumeUpload2"); function L_() { M(this, Qe)[Qe].abort(), this.options.companionComm.abortFileUpload(M(this, qt)[qt]).catch(i => this.options.log(i)) } n(L_, "_abortUpload2"); var Rv = $u; function M_(i) {
        let { method: e = "PUT", CanonicalUri: t = "/", CanonicalQueryString: r = "", SignedHeaders: s, HashedPayload: o } = i, a = Object.keys(s).map(l => l.toLowerCase()).sort(); return [e, t, r, ...a.map(l => `${l}:${s[l]}`), "", a.join(";"), o].join(`
`)
    } n(M_, "createCanonicalRequest"); var Ld = new TextEncoder, Md = { name: "HMAC", hash: "SHA-256" }; async function z_(i) { let { subtle: e } = globalThis.crypto; return e.digest(Md.hash, Ld.encode(i)) } n(z_, "digest"); async function j_(i) { let { subtle: e } = globalThis.crypto; return e.importKey("raw", typeof i == "string" ? Ld.encode(i) : i, Md, !1, ["sign"]) } n(j_, "generateHmacKey"); function kv(i) { let e = new Uint8Array(i), t = ""; for (let r = 0; r < e.length; r++)t += e[r].toString(16).padStart(2, "0"); return t } n(kv, "arrayBufferToHexString"); async function Ua(i, e) { let { subtle: t } = globalThis.crypto; return t.sign(Md, await j_(i), Ld.encode(e)) } n(Ua, "hash"); async function zd(i) {
        let { accountKey: e, accountSecret: t, sessionToken: r, bucketName: s, Key: o, Region: a, expires: l, uploadId: h, partNumber: c } = i, d = "s3", p = `${s}.${d}.${a}.amazonaws.com`, y = `/${encodeURI(o)}`, v = "UNSIGNED-PAYLOAD", S = new Date().toISOString().replace(/[-:]|\.\d+/g, ""), x = S.slice(0, 8), E = `${x}/${a}/${d}/aws4_request`, F = new URL(`https://${p}${y}`); F.searchParams.set("X-Amz-Algorithm", "AWS4-HMAC-SHA256"), F.searchParams.set("X-Amz-Content-Sha256", v), F.searchParams.set("X-Amz-Credential", `${e}/${E}`), F.searchParams.set("X-Amz-Date", S), F.searchParams.set("X-Amz-Expires", l), F.searchParams.set("X-Amz-Security-Token", r), F.searchParams.set("X-Amz-SignedHeaders", "host"), c && F.searchParams.set("partNumber", c), h && F.searchParams.set("uploadId", h), F.searchParams.set("x-id", c && h ? "UploadPart" : "PutObject"); let k = M_({ CanonicalUri: y, CanonicalQueryString: F.search.slice(1), SignedHeaders: { host: p }, HashedPayload: v }), B = kv(await z_(k)), H = ["AWS4-HMAC-SHA256", S, E, B].join(`
`), W = await Ua(`AWS4${t}`, x), I = await Ua(W, a), q = await Ua(I, d), $ = await Ua(q, "aws4_request"), V = kv(await Ua($, H)); return F.searchParams.set("X-Amz-Signature", V), F
    } n(zd, "createSignedURL"); var Dv; function D(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(D, "_classPrivateFieldLooseBase"); var H_ = 0; function he(i) { return "__private_" + H_++ + "_" + i } n(he, "_classPrivateFieldLooseKey"); var q_ = { version: "3.5.4" }; function Wo(i) { if (i && i.error) { let e = new Error(i.message); throw Object.assign(e, i.error), e } return i } n(Wo, "assertServerError"); function Nv(i) { let e = i.Expiration; if (e) { let t = Math.floor((new Date(e) - Date.now()) / 1e3); if (t > 9) return t } } n(Nv, "getExpiry"); function Uv(i) { let { meta: e, allowedMetaFields: t, querify: r = !1 } = i, s = t ?? Object.keys(e); return e ? Object.fromEntries(s.filter(o => e[o] != null).map(o => { let a = r ? `metadata[${o}]` : o, l = String(e[o]); return [a, l] })) : {} } n(Uv, "getAllowedMetadata"); function lt(i) { if (i != null && i.aborted) throw Dd("The operation was aborted", { cause: i.reason }) } n(lt, "throwIfAborted"); var Da = he("abortMultipartUpload"), Je = he("cache"), Na = he("createMultipartUpload"), Ia = he("fetchSignature"), Ha = he("getUploadParameters"), Ba = he("listParts"), js = he("previousRetryDelay"), Hs = he("requests"), Er = he("retryDelayIterator"), Ms = he("sendCompletionRequest"), zs = he("setS3MultipartState"), qs = he("uploadPartBytes"), et = he("getFile"), jd = he("shouldRetry"), La = he("nonMultipartUpload"), Vu = class { constructor(e, t, r, s) { Object.defineProperty(this, La, { value: V_ }), Object.defineProperty(this, jd, { value: $_ }), Object.defineProperty(this, Da, { writable: !0, value: void 0 }), Object.defineProperty(this, Je, { writable: !0, value: new WeakMap }), Object.defineProperty(this, Na, { writable: !0, value: void 0 }), Object.defineProperty(this, Ia, { writable: !0, value: void 0 }), Object.defineProperty(this, Ha, { writable: !0, value: void 0 }), Object.defineProperty(this, Ba, { writable: !0, value: void 0 }), Object.defineProperty(this, js, { writable: !0, value: void 0 }), Object.defineProperty(this, Hs, { writable: !0, value: void 0 }), Object.defineProperty(this, Er, { writable: !0, value: void 0 }), Object.defineProperty(this, Ms, { writable: !0, value: void 0 }), Object.defineProperty(this, zs, { writable: !0, value: void 0 }), Object.defineProperty(this, qs, { writable: !0, value: void 0 }), Object.defineProperty(this, et, { writable: !0, value: void 0 }), D(this, Hs)[Hs] = e, D(this, zs)[zs] = r, D(this, et)[et] = s, this.setOptions(t) } setOptions(e) { let t = D(this, Hs)[Hs]; if ("abortMultipartUpload" in e && (D(this, Da)[Da] = t.wrapPromiseFunction(e.abortMultipartUpload, { priority: 1 })), "createMultipartUpload" in e && (D(this, Na)[Na] = t.wrapPromiseFunction(e.createMultipartUpload, { priority: -1 })), "signPart" in e && (D(this, Ia)[Ia] = t.wrapPromiseFunction(e.signPart)), "listParts" in e && (D(this, Ba)[Ba] = t.wrapPromiseFunction(e.listParts)), "completeMultipartUpload" in e && (D(this, Ms)[Ms] = t.wrapPromiseFunction(e.completeMultipartUpload, { priority: 1 })), "retryDelays" in e) { var r; D(this, Er)[Er] = (r = e.retryDelays) == null ? void 0 : r.values() } "uploadPartBytes" in e && (D(this, qs)[qs] = t.wrapPromiseFunction(e.uploadPartBytes, { priority: 1 / 0 })), "getUploadParameters" in e && (D(this, Ha)[Ha] = t.wrapPromiseFunction(e.getUploadParameters)) } async getUploadId(e, t) { let r; for (; (r = D(this, Je)[Je].get(e.data)) != null;)try { return await r } catch { } let s = D(this, Na)[Na](D(this, et)[et](e), t), o = n(() => { s.abort(t.reason), D(this, Je)[Je].delete(e.data) }, "abortPromise"); return t.addEventListener("abort", o, { once: !0 }), D(this, Je)[Je].set(e.data, s), s.then(async a => { t.removeEventListener("abort", o), D(this, zs)[zs](e, a), D(this, Je)[Je].set(e.data, a) }, () => { t.removeEventListener("abort", o), D(this, Je)[Je].delete(e.data) }), s } async abortFileUpload(e) { let t = D(this, Je)[Je].get(e.data); if (t == null) return; D(this, Je)[Je].delete(e.data), D(this, zs)[zs](e, Object.create(null)); let r; try { r = await t } catch { return } await D(this, Da)[Da](D(this, et)[et](e), r) } async uploadFile(e, t, r) { if (lt(r), t.length === 1 && !t[0].shouldUseMultipart) return D(this, La)[La](e, t[0], r); let { uploadId: s, key: o } = await this.getUploadId(e, r); lt(r); try { let a = await Promise.all(t.map((l, h) => this.uploadChunk(e, h + 1, l, r))); return lt(r), await D(this, Ms)[Ms](D(this, et)[et](e), { key: o, uploadId: s, parts: a, signal: r }).abortOn(r) } catch (a) { throw a?.cause !== Ca && a?.name !== "AbortError" && this.abortFileUpload(e), a } } restoreUploadFile(e, t) { D(this, Je)[Je].set(e.data, t) } async resumeUploadFile(e, t, r) { if (lt(r), t.length === 1 && !t[0].shouldUseMultipart) return D(this, La)[La](e, t[0], r); let { uploadId: s, key: o } = await this.getUploadId(e, r); lt(r); let a = await D(this, Ba)[Ba](D(this, et)[et](e), { uploadId: s, key: o, signal: r }).abortOn(r); lt(r); let l = await Promise.all(t.map((h, c) => { let d = c + 1, p = a.find(y => { let { PartNumber: v } = y; return v === d }); return p == null ? this.uploadChunk(e, d, h, r) : (h == null || h.setAsUploaded == null || h.setAsUploaded(), { PartNumber: d, ETag: p.ETag }) })); return lt(r), D(this, Ms)[Ms](D(this, et)[et](e), { key: o, uploadId: s, parts: l, signal: r }).abortOn(r) } async uploadChunk(e, t, r, s) { lt(s); let { uploadId: o, key: a } = await this.getUploadId(e, s); for (lt(s); ;) { let l = r.getData(), { onProgress: h, onComplete: c } = r, d = await D(this, Ia)[Ia](D(this, et)[et](e), { uploadId: o, key: a, partNumber: t, body: l, signal: s }).abortOn(s); lt(s); try { return { PartNumber: t, ...await D(this, qs)[qs]({ signature: d, body: l, size: l.size, onProgress: h, onComplete: c, signal: s }).abortOn(s) } } catch (p) { if (!await D(this, jd)[jd](p)) throw p } } } }; n(Vu, "HTTPCommunicationQueue"); async function $_(i) { var e; let t = D(this, Hs)[Hs], r = i == null || (e = i.source) == null ? void 0 : e.status; if (r == null) return !1; if (r === 403 && i.message === "Request has expired") { if (!t.isPaused) { if (t.limit === 1 || D(this, js)[js] == null) { var s; let l = (s = D(this, Er)[Er]) == null ? void 0 : s.next(); if (l == null || l.done) return !1; D(this, js)[js] = l.value } t.rateLimit(0), await new Promise(l => setTimeout(l, D(this, js)[js])) } } else if (r === 429) { if (!t.isPaused) { var o; let l = (o = D(this, Er)[Er]) == null ? void 0 : o.next(); if (l == null || l.done) return !1; t.rateLimit(l.value) } } else { if (r > 400 && r < 500 && r !== 409) return !1; if (typeof navigator < "u" && navigator.onLine === !1) t.isPaused || (t.pause(), window.addEventListener("online", () => { t.resume() }, { once: !0 })); else { var a; let l = (a = D(this, Er)[Er]) == null ? void 0 : a.next(); if (l == null || l.done) return !1; await new Promise(h => setTimeout(h, l.value)) } } return !0 } n($_, "_shouldRetry2"); async function V_(i, e, t) { let { method: r = "POST", url: s, fields: o, headers: a } = await D(this, Ha)[Ha](D(this, et)[et](i), { signal: t }).abortOn(t), l, h = e.getData(); if (r.toUpperCase() === "POST") { let p = new FormData; Object.entries(o).forEach(y => { let [v, S] = y; return p.set(v, S) }), p.set("file", h), l = p } else l = h; let { onProgress: c, onComplete: d } = e; return D(this, qs)[qs]({ signature: { url: s, headers: a, method: r }, body: l, size: h.size, onProgress: c, onComplete: d, signal: t }).abortOn(t) } n(V_, "_nonMultipartUpload2"); var $s = he("companionCommunicationQueue"), Ae = he("client"), Ze = he("cachedTemporaryCredentials"), Hd = he("getTemporarySecurityCredentials"), qd = he("setS3MultipartState"), Vs = he("getFile"), $d = he("uploadFile"), Vd = he("requestSocketToken"), Ma = he("upload"), za = he("setCompanionHeaders"), xr = he("setResumableUploadsCapability"), ja = he("resetResumableCapability"); Dv = Symbol.for("uppy test: getClient"); var vi = class extends ri { constructor(e, t) { var r; super(e, t), Object.defineProperty(this, $d, { value: K_ }), Object.defineProperty(this, Hd, { value: W_ }), Object.defineProperty(this, $s, { writable: !0, value: void 0 }), Object.defineProperty(this, Ae, { writable: !0, value: void 0 }), Object.defineProperty(this, Ze, { writable: !0, value: void 0 }), Object.defineProperty(this, qd, { writable: !0, value: (o, a) => { let { key: l, uploadId: h } = a, c = this.uppy.getFile(o.id); c != null && this.uppy.setFileState(o.id, { s3Multipart: { ...c.s3Multipart, key: l, uploadId: h } }) } }), Object.defineProperty(this, Vs, { writable: !0, value: o => this.uppy.getFile(o.id) || o }), Object.defineProperty(this, Vd, { writable: !0, value: async (o, a) => { let l = o.remote.providerOptions.provider ? Q : de, h = new l(this.uppy, o.remote.providerOptions), c = { ...this.opts }; if (o.tus && Object.assign(c, o.tus), o.remote.url == null) throw new Error("Cannot connect to an undefined URL"); return (await h.post(o.remote.url, { ...o.remote.body, protocol: "s3-multipart", size: o.data.size, metadata: o.meta }, a)).token } }), Object.defineProperty(this, Ma, { writable: !0, value: async o => { if (o.length === 0) return; let a = this.uppy.getFilesByIds(o), l = Yr(a), h = Qr(l); this.uppy.emit("upload-start", h); let c = l.map(p => { if (p.isRemote) { D(this, xr)[xr](!1); let y = new AbortController, v = n(x => { x.id === p.id && y.abort() }, "removedHandler"); this.uppy.on("file-removed", v), this.resetUploaderReferences(p.id); let S = this.uploadRemoteFile(p, { signal: y.signal }); return this.requests.wrapSyncFunction(() => { this.uppy.off("file-removed", v) }, { priority: -1 })(), S } return D(this, $d)[$d](p) }), d = await Promise.all(c); return D(this, xr)[xr](!0), d } }), Object.defineProperty(this, za, { writable: !0, value: () => { D(this, Ae)[Ae].setCompanionHeaders(this.opts.companionHeaders) } }), Object.defineProperty(this, xr, { writable: !0, value: o => { let { capabilities: a } = this.uppy.getState(); this.uppy.setState({ capabilities: { ...a, resumableUploads: o } }) } }), Object.defineProperty(this, ja, { writable: !0, value: () => { D(this, xr)[xr](!0) } }), this.type = "uploader", this.id = this.opts.id || "AwsS3Multipart", this.title = "AWS S3 Multipart", D(this, Ae)[Ae] = new de(e, t); let s = { allowedMetaFields: null, limit: 6, shouldUseMultipart: o => o.size !== 0, retryDelays: [0, 1e3, 3e3, 5e3], createMultipartUpload: this.createMultipartUpload.bind(this), listParts: this.listParts.bind(this), abortMultipartUpload: this.abortMultipartUpload.bind(this), completeMultipartUpload: this.completeMultipartUpload.bind(this), getTemporarySecurityCredentials: !1, signPart: t != null && t.getTemporarySecurityCredentials ? this.createSignedURL.bind(this) : this.signPart.bind(this), uploadPartBytes: vi.uploadPartBytes, getUploadParameters: t != null && t.getTemporarySecurityCredentials ? this.createSignedURL.bind(this) : this.getUploadParameters.bind(this), companionHeaders: {} }; this.opts = { ...s, ...t }, t?.prepareUploadParts != null && t.signPart == null && (this.opts.signPart = async (o, a) => { let { uploadId: l, key: h, partNumber: c, body: d, signal: p } = a, { presignedUrls: y, headers: v } = await t.prepareUploadParts(o, { uploadId: l, key: h, parts: [{ number: c, chunk: d }], signal: p }); return { url: y?.[c], headers: v?.[c] } }), this.requests = (r = this.opts.rateLimitedQueue) != null ? r : new vt(this.opts.limit), D(this, $s)[$s] = new Vu(this.requests, this.opts, D(this, qd)[qd], D(this, Vs)[Vs]), this.uploaders = Object.create(null), this.uploaderEvents = Object.create(null), this.uploaderSockets = Object.create(null), this.setQueueRequestSocketToken(this.requests.wrapPromiseFunction(D(this, Vd)[Vd], { priority: -1 })) } [Dv]() { return D(this, Ae)[Ae] } setOptions(e) { return D(this, $s)[$s].setOptions(e), super.setOptions(e) } resetUploaderReferences(e, t) { t === void 0 && (t = {}), this.uploaders[e] && (this.uploaders[e].abort({ really: t.abort || !1 }), this.uploaders[e] = null), this.uploaderEvents[e] && (this.uploaderEvents[e].remove(), this.uploaderEvents[e] = null), this.uploaderSockets[e] && (this.uploaderSockets[e].close(), this.uploaderSockets[e] = null) } assertHost(e) { if (!this.opts.companionUrl) throw new Error(`Expected a \`companionUrl\` option containing a Companion address, or if you are not using Companion, a custom \`${e}\` implementation.`) } createMultipartUpload(e, t) { this.assertHost("createMultipartUpload"), lt(t); let r = Uv({ meta: e.meta, allowedMetaFields: this.opts.allowedMetaFields }); return D(this, Ae)[Ae].post("s3/multipart", { filename: e.name, type: e.type, metadata: r }, { signal: t }).then(Wo) } listParts(e, t, r) { let { key: s, uploadId: o } = t; this.assertHost("listParts"), lt(r); let a = encodeURIComponent(s); return D(this, Ae)[Ae].get(`s3/multipart/${o}?key=${a}`, { signal: r }).then(Wo) } completeMultipartUpload(e, t, r) { let { key: s, uploadId: o, parts: a } = t; this.assertHost("completeMultipartUpload"), lt(r); let l = encodeURIComponent(s), h = encodeURIComponent(o); return D(this, Ae)[Ae].post(`s3/multipart/${h}/complete?key=${l}`, { parts: a }, { signal: r }).then(Wo) } async createSignedURL(e, t) { let r = await D(this, Hd)[Hd](t), s = Nv(r.credentials) || 604800, { uploadId: o, key: a, partNumber: l, signal: h } = t; return { method: "PUT", expires: s, fields: {}, url: `${await zd({ accountKey: r.credentials.AccessKeyId, accountSecret: r.credentials.SecretAccessKey, sessionToken: r.credentials.SessionToken, expires: s, bucketName: r.bucket, Region: r.region, Key: a ?? `${crypto.randomUUID()}-${e.name}`, uploadId: o, partNumber: l, signal: h })}`, headers: { "Content-Type": e.type } } } signPart(e, t) { let { uploadId: r, key: s, partNumber: o, signal: a } = t; if (this.assertHost("signPart"), lt(a), r == null || s == null || o == null) throw new Error("Cannot sign without a key, an uploadId, and a partNumber"); let l = encodeURIComponent(s); return D(this, Ae)[Ae].get(`s3/multipart/${r}/${o}?key=${l}`, { signal: a }).then(Wo) } abortMultipartUpload(e, t, r) { let { key: s, uploadId: o } = t; this.assertHost("abortMultipartUpload"); let a = encodeURIComponent(s), l = encodeURIComponent(o); return D(this, Ae)[Ae].delete(`s3/multipart/${l}?key=${a}`, void 0, { signal: r }).then(Wo) } getUploadParameters(e, t) { let { meta: r } = e, { type: s, name: o } = r, a = Uv({ meta: r, allowedMetaFields: this.opts.allowedMetaFields, querify: !0 }), l = new URLSearchParams({ filename: o, type: s, ...a }); return D(this, Ae)[Ae].get(`s3/params?${l}`, t) } static async uploadPartBytes(e) { let { signature: { url: t, expires: r, headers: s, method: o = "PUT" }, body: a, size: l = a.size, onProgress: h, onComplete: c, signal: d } = e; if (lt(d), t == null) throw new Error("Cannot upload to an undefined URL"); return new Promise((p, y) => { let v = new XMLHttpRequest; v.open(o, t, !0), s && Object.keys(s).forEach(E => { v.setRequestHeader(E, s[E]) }), v.responseType = "text", typeof r == "number" && (v.timeout = r * 1e3); function S() { v.abort() } n(S, "onabort"); function x() { d.removeEventListener("abort", S) } n(x, "cleanup"), d.addEventListener("abort", S), v.upload.addEventListener("progress", E => { h(E) }), v.addEventListener("abort", () => { x(), y(Dd()) }), v.addEventListener("timeout", () => { x(); let E = new Error("Request has expired"); E.source = { status: 403 }, y(E) }), v.addEventListener("load", E => { if (x(), E.target.status === 403 && E.target.responseText.includes("<Message>Request has expired</Message>")) { let B = new Error("Request has expired"); B.source = E.target, y(B); return } if (E.target.status < 200 || E.target.status >= 300) { let B = new Error("Non 2xx"); B.source = E.target, y(B); return } h?.({ loaded: l, lengthComputable: !0 }); let F = E.target.getResponseHeader("ETag"), k = E.target.getResponseHeader("Location"); if (o.toUpperCase() === "POST" && k === null && console.warn("AwsS3/Multipart: Could not read the Location header. This likely means CORS is not configured correctly on the S3 Bucket. See https://uppy.io/docs/aws-s3-multipart#S3-Bucket-Configuration for instructions."), F === null) { y(new Error("AwsS3/Multipart: Could not read the ETag header. This likely means CORS is not configured correctly on the S3 Bucket. See https://uppy.io/docs/aws-s3-multipart#S3-Bucket-Configuration for instructions.")); return } c?.(F), p({ ETag: F, ...k ? { location: k } : void 0 }) }), v.addEventListener("error", E => { x(); let F = new Error("Unknown error"); F.source = E.target, y(F) }), v.send(a) }) } async connectToServerSocket(e) { var t = this; return new Promise((r, s) => { let o, a = e.serverToken, l = wr(e.remote.companionUrl), h = new Ft({ target: `${l}/api/${a}`, autoOpen: !1 }); this.uploaderSockets[e.id] = h, this.uploaderEvents[e.id] = new at(this.uppy), this.onFileRemove(e.id, () => { h.send("cancel", {}), o.abort(), this.resetUploaderReferences(e.id, { abort: !0 }), r(`upload ${e.id} was removed`) }), this.onFilePause(e.id, c => { c ? (h.send("pause", {}), o.abort()) : (o.abort(), o = this.requests.run(() => (h.open(), h.send("resume", {}), () => { }))) }), this.onPauseAll(e.id, () => { h.send("pause", {}), o.abort() }), this.onCancelAll(e.id, function (c) { let { reason: d } = c === void 0 ? {} : c; d === "user" && (h.send("cancel", {}), o.abort(), t.resetUploaderReferences(e.id)), r(`upload ${e.id} was canceled`) }), this.onResumeAll(e.id, () => { o.abort(), e.error && h.send("pause", {}), o = this.requests.run(() => (h.open(), h.send("resume", {}), () => { })) }), this.onRetry(e.id, () => { h.isOpen && (h.send("pause", {}), h.send("resume", {})) }), this.onRetryAll(e.id, () => { h.isOpen && (h.send("pause", {}), h.send("resume", {})) }), h.on("progress", c => Gr(this, c, e)), h.on("error", c => { this.uppy.emit("upload-error", e, new Error(c.error)), this.resetUploaderReferences(e.id), h.close(), o.done(), s(new Error(c.error)) }), h.on("success", c => { let d = { uploadURL: c.url }; this.uppy.emit("upload-success", e, d), this.resetUploaderReferences(e.id), h.close(), o.done(), r() }), o = this.requests.run(() => (e.isPaused ? h.send("pause", {}) : h.open(), () => { })) }) } onFileRemove(e, t) { this.uploaderEvents[e].on("file-removed", r => { e === r.id && t(r.id) }) } onFilePause(e, t) { this.uploaderEvents[e].on("upload-pause", (r, s) => { e === r && t(s) }) } onRetry(e, t) { this.uploaderEvents[e].on("upload-retry", r => { e === r && t() }) } onRetryAll(e, t) { this.uploaderEvents[e].on("retry-all", () => { this.uppy.getFile(e) && t() }) } onPauseAll(e, t) { this.uploaderEvents[e].on("pause-all", () => { this.uppy.getFile(e) && t() }) } onCancelAll(e, t) { var r = this; this.uploaderEvents[e].on("cancel-all", function () { r.uppy.getFile(e) && t(...arguments) }) } onResumeAll(e, t) { this.uploaderEvents[e].on("resume-all", () => { this.uppy.getFile(e) && t() }) } install() { D(this, xr)[xr](!0), this.uppy.addPreProcessor(D(this, za)[za]), this.uppy.addUploader(D(this, Ma)[Ma]), this.uppy.on("cancel-all", D(this, ja)[ja]) } uninstall() { this.uppy.removePreProcessor(D(this, za)[za]), this.uppy.removeUploader(D(this, Ma)[Ma]), this.uppy.off("cancel-all", D(this, ja)[ja]) } }; n(vi, "AwsS3Multipart"); async function W_(i) { return lt(i?.signal), D(this, Ze)[Ze] == null && (this.opts.getTemporarySecurityCredentials === !0 ? (this.assertHost("getTemporarySecurityCredentials"), D(this, Ze)[Ze] = D(this, Ae)[Ae].get("s3/sts", null, i).then(Wo)) : D(this, Ze)[Ze] = this.opts.getTemporarySecurityCredentials(i), D(this, Ze)[Ze] = await D(this, Ze)[Ze], setTimeout(() => { D(this, Ze)[Ze] = null }, (Nv(D(this, Ze)[Ze].credentials) || 0) * 500)), D(this, Ze)[Ze] } n(W_, "_getTemporarySecurityCredentials2"); function K_(i) { var e = this; return new Promise((t, r) => { let s = n((c, d) => { this.uppy.emit("upload-progress", i, { uploader: this, bytesUploaded: c, bytesTotal: d }) }, "onProgress"), o = n(c => { this.uppy.log(c), this.uppy.emit("upload-error", i, c), this.resetUploaderReferences(i.id), r(c) }, "onError"), a = n(c => { let d = { body: { ...c }, uploadURL: c.location }; this.resetUploaderReferences(i.id), this.uppy.emit("upload-success", D(this, Vs)[Vs](i), d), c.location && this.uppy.log(`Download ${i.name} from ${c.location}`), t() }, "onSuccess"), l = n(c => { this.uppy.emit("s3-multipart:part-uploaded", D(this, Vs)[Vs](i), c) }, "onPartComplete"), h = new Rv(i.data, { companionComm: D(this, $s)[$s], log: function () { return e.uppy.log(...arguments) }, getChunkSize: this.opts.getChunkSize ? this.opts.getChunkSize.bind(this) : null, onProgress: s, onError: o, onSuccess: a, onPartComplete: l, file: i, shouldUseMultipart: this.opts.shouldUseMultipart, ...i.s3Multipart }); this.uploaders[i.id] = h, this.uploaderEvents[i.id] = new at(this.uppy), this.onFileRemove(i.id, c => { h.abort(), this.resetUploaderReferences(i.id, { abort: !0 }), t(`upload ${c.id} was removed`) }), this.onCancelAll(i.id, function (c) { let { reason: d } = c === void 0 ? {} : c; d === "user" && (h.abort(), e.resetUploaderReferences(i.id, { abort: !0 })), t(`upload ${i.id} was canceled`) }), this.onFilePause(i.id, c => { c ? h.pause() : h.start() }), this.onPauseAll(i.id, () => { h.pause() }), this.onResumeAll(i.id, () => { h.start() }), h.start() }) } n(K_, "_uploadFile2"); vi.VERSION = q_.version; function si(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(si, "_classPrivateFieldLooseBase"); var G_ = 0; function Ku(i) { return "__private_" + G_++ + "_" + i } n(Ku, "_classPrivateFieldLooseKey"); var Fr = Ku("aliveTimer"), Ws = Ku("isDone"), qa = Ku("onTimedOut"), Ks = Ku("timeout"), Wu = class { constructor(e, t) { Object.defineProperty(this, Fr, { writable: !0, value: void 0 }), Object.defineProperty(this, Ws, { writable: !0, value: !1 }), Object.defineProperty(this, qa, { writable: !0, value: void 0 }), Object.defineProperty(this, Ks, { writable: !0, value: void 0 }), si(this, Ks)[Ks] = e, si(this, qa)[qa] = t } progress() { si(this, Ws)[Ws] || si(this, Ks)[Ks] > 0 && (clearTimeout(si(this, Fr)[Fr]), si(this, Fr)[Fr] = setTimeout(si(this, qa)[qa], si(this, Ks)[Ks])) } done() { si(this, Ws)[Ws] || (clearTimeout(si(this, Fr)[Fr]), si(this, Fr)[Fr] = null, si(this, Ws)[Ws] = !0) } }; n(Wu, "ProgressTimeout"); var $a = Wu; function X_(i) { return i ? i.readyState !== 0 && i.readyState !== 4 || i.status === 0 : !1 } n(X_, "isNetworkError"); var Gs = X_; function Ko(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Ko, "_classPrivateFieldLooseBase"); var Y_ = 0; function Bv(i) { return "__private_" + Y_++ + "_" + i } n(Bv, "_classPrivateFieldLooseKey"); function Iv(i, e) { if (Gs(i)) return new hi(e, i); let t = new Oi("Upload error", { cause: e }); return t.request = i, t } n(Iv, "buildResponseError"); function Q_(i) { return i.data.slice(0, i.data.size, i.meta.type) } n(Q_, "setTypeInBlob"); function J_(i, e, t) { (Array.isArray(t.allowedMetaFields) ? t.allowedMetaFields : Object.keys(e)).forEach(s => { i.append(s, e[s]) }) } n(J_, "addMetadata"); function Z_(i, e) { let t = new FormData; J_(t, i.meta, e); let r = Q_(i); return i.name ? t.append(e.fieldName, r, i.meta.name) : t.append(e.fieldName, r), t } n(Z_, "createFormDataUpload"); var e5 = n(i => i.data, "createBareUpload"), Xs = Bv("addEventHandlerForFile"), Ys = Bv("addEventHandlerIfFileStillExists"), Go = class { constructor(e, t) { Object.defineProperty(this, Ys, { value: i5 }), Object.defineProperty(this, Xs, { value: t5 }), this.uppy = e, this.opts = { validateStatus(r) { return r >= 200 && r < 300 }, ...t }, this.requests = t[Xr], this.uploaderEvents = Object.create(null), this.i18n = t.i18n } getOptions(e) { var t; let { uppy: r } = this, s = r.getState().xhrUpload; return { ...this.opts, ...s || {}, ...e.xhrUpload || {}, headers: { ...this.opts.headers, ...s?.headers, ...(t = e.xhrUpload) == null ? void 0 : t.headers } } } uploadLocalFile(e) { let t = this.getOptions(e); return new Promise((r, s) => { let o = t.formData ? Z_(e, t) : e5(e, t), a = new XMLHttpRequest; this.uploaderEvents[e.id] = new at(this.uppy); let l = new $a(t.timeout, () => { a.abort(), c.done(); let d = new Error(this.i18n("timedOut", { seconds: Math.ceil(t.timeout / 1e3) })); this.uppy.emit("upload-error", e, d), s(d) }), h = ot(); a.upload.addEventListener("loadstart", () => { this.uppy.log(`[AwsS3/XHRUpload] ${h} started`) }), a.upload.addEventListener("progress", d => { this.uppy.log(`[AwsS3/XHRUpload] ${h} progress: ${d.loaded} / ${d.total}`), l.progress(), d.lengthComputable && this.uppy.emit("upload-progress", e, { uploader: this, bytesUploaded: d.loaded, bytesTotal: d.total }) }), a.addEventListener("load", d => { if (this.uppy.log(`[AwsS3/XHRUpload] ${h} finished`), l.done(), c.done(), this.uploaderEvents[e.id] && (this.uploaderEvents[e.id].remove(), this.uploaderEvents[e.id] = null), t.validateStatus(d.target.status, a.responseText, a)) { let S = t.getResponseData(a.responseText, a), x = S[t.responseUrlFieldName], E = { status: d.target.status, body: S, uploadURL: x }; return this.uppy.emit("upload-success", e, E), x && this.uppy.log(`Download ${e.name} from ${x}`), r(e) } let p = t.getResponseData(a.responseText, a), y = Iv(a, t.getResponseError(a.responseText, a)), v = { status: d.target.status, body: p }; return this.uppy.emit("upload-error", e, y, v), s(y) }), a.addEventListener("error", () => { this.uppy.log(`[AwsS3/XHRUpload] ${h} errored`), l.done(), c.done(), this.uploaderEvents[e.id] && (this.uploaderEvents[e.id].remove(), this.uploaderEvents[e.id] = null); let d = Iv(a, t.getResponseError(a.responseText, a)); return this.uppy.emit("upload-error", e, d), s(d) }), a.open(t.method.toUpperCase(), t.endpoint, !0), a.withCredentials = !!t.withCredentials, t.responseType !== "" && (a.responseType = t.responseType), Object.keys(t.headers).forEach(d => { a.setRequestHeader(d, t.headers[d]) }); let c = this.requests.run(() => (a.send(o), () => { l.done(), a.abort() }), { priority: 1 }); Ko(this, Xs)[Xs]("file-removed", e.id, () => { c.abort(), s(new Error("File removed")) }), Ko(this, Ys)[Ys]("cancel-all", e.id, function (d) { let { reason: p } = d === void 0 ? {} : d; p === "user" && c.abort(), s(new Error("Upload cancelled")) }) }) } async connectToServerSocket(e) { return new Promise((t, r) => { let s = this.getOptions(e), o = e.serverToken, a = wr(e.remote.companionUrl), l, h = n(() => { l == null && (l = new Ft({ target: `${a}/api/${o}` }), l.on("progress", p => Gr(this, p, e)), l.on("success", p => { let y = s.getResponseData(p.response.responseText, p.response), v = y[s.responseUrlFieldName], S = { status: p.response.status, body: y, uploadURL: v, bytesUploaded: p.bytesUploaded }; return this.uppy.emit("upload-success", e, S), c.done(), l.close(), this.uploaderEvents[e.id] && (this.uploaderEvents[e.id].remove(), this.uploaderEvents[e.id] = null), t() }), l.on("error", p => { let y = p.response, v = y ? s.getResponseError(y.responseText, y) : new Oi(p.error.message, { cause: p.error }); this.uppy.emit("upload-error", e, v), c.done(), this.uploaderEvents[e.id] && (this.uploaderEvents[e.id].remove(), this.uploaderEvents[e.id] = null), r(v) })) }, "createSocket"); this.uploaderEvents[e.id] = new at(this.uppy); let c = this.requests.run(() => { if (e.isPaused) { var p; (p = l) == null || p.send("pause", {}) } else h(); return () => l.close() }); Ko(this, Xs)[Xs]("file-removed", e.id, () => { var p; (p = l) == null || p.send("cancel", {}), c.abort(), t(`upload ${e.id} was removed`) }), Ko(this, Ys)[Ys]("cancel-all", e.id, function (p) { let { reason: y } = p === void 0 ? {} : p; if (y === "user") { var v; (v = l) == null || v.send("cancel", {}), c.abort() } t(`upload ${e.id} was canceled`) }); let d = n(() => { l == null ? c.abort() : (l.send("pause", {}), c.done()), c = this.requests.run(() => (e.isPaused || (l == null ? h() : l.send("resume", {})), () => l.close())) }, "onRetryRequest"); Ko(this, Xs)[Xs]("upload-retry", e.id, d), Ko(this, Ys)[Ys]("retry-all", e.id, d) }).catch(t => (this.uppy.emit("upload-error", e, t), Promise.reject(t))) } }; n(Go, "MiniXHRUpload"); function t5(i, e, t) { this.uploaderEvents[e].on(i, r => { var s; let o = (s = r?.id) != null ? s : r; e === o && t() }) } n(t5, "_addEventHandlerForFile2"); function i5(i, e, t) { var r = this; this.uploaderEvents[e].on(i, function () { r.uppy.getFile(e) && t(...arguments) }) } n(i5, "_addEventHandlerIfFileStillExists2"); function r5(i) { return i.replace(/;.*$/, "") } n(r5, "removeMimeParameters"); function s5(i, e) { let t = e.headers ? e.headers["content-type"] : e.getResponseHeader("Content-Type"); if (typeof t == "string") { let r = r5(t).toLowerCase(); if (r === "application/xml" || r === "text/xml" || r === "text/html" && /^<\?xml /.test(i)) return !0 } return !1 } n(s5, "isXml"); var Wd = s5; var Lv = { strings: { timedOut: "Upload stalled for %{seconds} seconds, aborting." } }; var zv; function Ne(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Ne, "_classPrivateFieldLooseBase"); var o5 = 0; function Xo(i) { return "__private_" + o5++ + "_" + i } n(Xo, "_classPrivateFieldLooseKey"); var n5 = { version: "3.2.3" }; function a5(i, e) { return !i && !e.startsWith("https://") && !e.startsWith("http://") && (e = `https://${e}`), new URL(e, i || void 0).toString() } n(a5, "resolveUrl"); function Ka(i, e) { let t = i.indexOf(`<${e}>`), r = i.indexOf(`</${e}>`, t); return t !== -1 && r !== -1 ? i.slice(t + e.length + 2, r) : "" } n(Ka, "getXmlValue"); function l5(i) { if (i && i.error) { let e = new Error(i.message); throw Object.assign(e, i.error), e } return i } n(l5, "assertServerError"); function u5(i, e) {
        if (!(e != null && typeof e.url == "string" && (typeof e.fields == "object" || e.fields == null))) throw new TypeError(`AwsS3: got incorrect result from 'getUploadParameters()' for file '${i.name}', expected an object '{ url, method, fields, headers }' but got '${JSON.stringify(e)}' instead.
See https://uppy.io/docs/aws-s3/#getUploadParameters-file for more on the expected format.`); if (!(e.method == null || /^p(u|os)t$/i.test(e.method))) throw new TypeError(`AwsS3: got incorrect method from 'getUploadParameters()' for file '${i.name}', expected  'PUT' or 'POST' but got '${e.method}' instead.
See https://uppy.io/docs/aws-s3/#getUploadParameters-file for more on the expected format.`)
    } n(u5, "validateParameters"); function h5(i, e) { if (!Wd(i, e)) return; let t = Ka(i, "Message"); return new Error(t) } n(h5, "defaultGetResponseError"); var Mv = !1, $t = Xo("client"), bi = Xo("requests"), Or = Xo("uploader"), Va = Xo("handleUpload"), Wa = Xo("setCompanionHeaders"), Kd = Xo("requestSocketToken"); zv = Symbol.for("uppy test: getClient"); var Qs = class extends ri { constructor(e, t) { if (t?.shouldUseMultipart != null) return new vi(e, t); super(e, t), Object.defineProperty(this, $t, { writable: !0, value: void 0 }), Object.defineProperty(this, bi, { writable: !0, value: void 0 }), Object.defineProperty(this, Or, { writable: !0, value: void 0 }), Object.defineProperty(this, Va, { writable: !0, value: async s => { let o = Object.create(null); function a(y) { var v; let { id: S } = y; (v = o[S]) == null || v.abort() } n(a, "onremove"), this.uppy.on("file-removed", a); let l = this.uppy.getFilesByIds(s), h = Yr(l), c = Qr(h); this.uppy.emit("upload-start", c); let d = Ne(this, bi)[bi].wrapPromiseFunction(y => this.opts.getUploadParameters(y)), p = s.length; return Promise.allSettled(s.map((y, v) => (o[y] = d(this.uppy.getFile(y)), o[y].then(S => { delete o[y]; let x = this.uppy.getFile(y); u5(x, S); let { method: E = "POST", url: F, fields: k, headers: B } = S, H = { method: E, formData: E.toUpperCase() === "POST", endpoint: F, allowedMetaFields: k ? Object.keys(k) : [] }; return B && (H.headers = B), this.uppy.setFileState(x.id, { meta: { ...x.meta, ...k }, xhrUpload: H }), this.uploadFile(x.id, v, p) }).catch(S => { delete o[y]; let x = this.uppy.getFile(y); return this.uppy.emit("upload-error", x, S), Promise.reject(S) })))).finally(() => { this.uppy.off("file-removed", a) }) } }), Object.defineProperty(this, Wa, { writable: !0, value: () => (Ne(this, $t)[$t].setCompanionHeaders(this.opts.companionHeaders), Promise.resolve()) }), Object.defineProperty(this, Kd, { writable: !0, value: async s => { let o = Ne(this, Or)[Or].getOptions(s), a = s.remote.providerOptions.provider ? Q : de, l = new a(this.uppy, s.remote.providerOptions), h = Array.isArray(o.allowedMetaFields) ? o.allowedMetaFields : Object.keys(s.meta); return s.tus && Object.assign(o, s.tus), (await l.post(s.remote.url, { ...s.remote.body, protocol: "multipart", endpoint: o.endpoint, size: s.data.size, fieldname: o.fieldName, metadata: Object.fromEntries(h.map(d => [d, s.meta[d]])), httpMethod: o.method, useFormData: o.formData, headers: typeof o.headers == "function" ? o.headers(s) : o.headers })).token } }), this.type = "uploader", this.id = this.opts.id || "AwsS3", this.title = "AWS S3", this.defaultLocale = Lv; let r = { timeout: 30 * 1e3, limit: 0, allowedMetaFields: [], getUploadParameters: this.getUploadParameters.bind(this), shouldUseMultipart: !1, companionHeaders: {} }; if (this.opts = { ...r, ...t }, t?.allowedMetaFields === void 0 && "metaFields" in this.opts) throw new Error("The `metaFields` option has been renamed to `allowedMetaFields`."); this.i18nInit(), Ne(this, $t)[$t] = new de(e, t), Ne(this, bi)[bi] = new vt(this.opts.limit), this.setQueueRequestSocketToken(Ne(this, bi)[bi].wrapPromiseFunction(Ne(this, Kd)[Kd], { priority: -1 })) } [zv]() { return Ne(this, $t)[$t] } get client() { return Ne(this, $t)[$t] } set client(e) { Ne(this, $t)[$t] = e } getUploadParameters(e) { if (!this.opts.companionUrl) throw new Error("Expected a `companionUrl` option containing a Companion address."); let t = e.meta.name, { type: r } = e.meta, s = Object.fromEntries(this.opts.allowedMetaFields.filter(a => e.meta[a] != null).map(a => [`metadata[${a}]`, e.meta[a].toString()])), o = new URLSearchParams({ filename: t, type: r, ...s }); return Ne(this, $t)[$t].get(`s3/params?${o}`).then(l5) } connectToServerSocket(e) { return Ne(this, Or)[Or].connectToServerSocket(e) } uploadFile(e, t, r) { let s = this.uppy.getFile(e); if (this.uppy.log(`uploading ${t} of ${r}`), s.error) throw new Error(s.error); if (s.isRemote) { let o = new AbortController, a = n(h => { h.id === s.id && o.abort() }, "removedHandler"); this.uppy.on("file-removed", a); let l = this.uploadRemoteFile(s, { signal: o.signal }); return Ne(this, bi)[bi].wrapSyncFunction(() => { this.uppy.off("file-removed", a) }, { priority: -1 })(), l } return Ne(this, Or)[Or].uploadLocalFile(s, t, r) } install() { let { uppy: e } = this; e.addPreProcessor(Ne(this, Wa)[Wa]), e.addUploader(Ne(this, Va)[Va]); function t(s, o) { let a = this; return Wd(s, o) ? { location: a5(o.responseURL, Ka(s, "Location")), bucket: Ka(s, "Bucket"), key: Ka(s, "Key"), etag: Ka(s, "ETag") } : a.method.toUpperCase() === "POST" ? (Mv || (e.log("[AwsS3] No response data found, make sure to set the success_action_status AWS SDK option to 201. See https://uppy.io/docs/aws-s3/#POST-Uploads", "warning"), Mv = !0), { location: null }) : o.responseURL ? { location: o.responseURL.replace(/\?.*$/, "") } : { location: null } } n(t, "defaultGetResponseData"); let r = { fieldName: "file", responseUrlFieldName: "location", timeout: this.opts.timeout, [Xr]: Ne(this, bi)[bi], responseType: "text", getResponseData: this.opts.getResponseData || t, getResponseError: h5 }; r.i18n = this.i18n, Ne(this, Or)[Or] = new Go(e, r) } uninstall() { this.uppy.removePreProcessor(Ne(this, Wa)[Wa]), this.uppy.removeUploader(Ne(this, Va)[Va]) } }; n(Qs, "AwsS3"); Qs.VERSION = n5.version; var Wv = "3.7.2", c5 = Wv, d5 = typeof atob == "function", p5 = typeof btoa == "function", Qo = typeof Buffer == "function", jv = typeof TextDecoder == "function" ? new TextDecoder : void 0, Hv = typeof TextEncoder == "function" ? new TextEncoder : void 0, f5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", Ga = Array.prototype.slice.call(f5), Gu = (i => { let e = {}; return i.forEach((t, r) => e[t] = r), e })(Ga), m5 = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, tt = String.fromCharCode.bind(String), qv = typeof Uint8Array.from == "function" ? Uint8Array.from.bind(Uint8Array) : (i, e = t => t) => new Uint8Array(Array.prototype.slice.call(i, 0).map(e)), Kv = n(i => i.replace(/=/g, "").replace(/[+\/]/g, e => e == "+" ? "-" : "_"), "_mkUriSafe"), Gv = n(i => i.replace(/[^A-Za-z0-9\+\/]/g, ""), "_tidyB64"), Xv = n(i => { let e, t, r, s, o = "", a = i.length % 3; for (let l = 0; l < i.length;) { if ((t = i.charCodeAt(l++)) > 255 || (r = i.charCodeAt(l++)) > 255 || (s = i.charCodeAt(l++)) > 255) throw new TypeError("invalid character found"); e = t << 16 | r << 8 | s, o += Ga[e >> 18 & 63] + Ga[e >> 12 & 63] + Ga[e >> 6 & 63] + Ga[e & 63] } return a ? o.slice(0, a - 3) + "===".substring(a) : o }, "btoaPolyfill"), Yd = p5 ? i => btoa(i) : Qo ? i => Buffer.from(i, "binary").toString("base64") : Xv, Gd = Qo ? i => Buffer.from(i).toString("base64") : i => { let t = []; for (let r = 0, s = i.length; r < s; r += 4096)t.push(tt.apply(null, i.subarray(r, r + 4096))); return Yd(t.join("")) }, Xu = n((i, e = !1) => e ? Kv(Gd(i)) : Gd(i), "fromUint8Array"), g5 = n(i => { if (i.length < 2) { var e = i.charCodeAt(0); return e < 128 ? i : e < 2048 ? tt(192 | e >>> 6) + tt(128 | e & 63) : tt(224 | e >>> 12 & 15) + tt(128 | e >>> 6 & 63) + tt(128 | e & 63) } else { var e = 65536 + (i.charCodeAt(0) - 55296) * 1024 + (i.charCodeAt(1) - 56320); return tt(240 | e >>> 18 & 7) + tt(128 | e >>> 12 & 63) + tt(128 | e >>> 6 & 63) + tt(128 | e & 63) } }, "cb_utob"), y5 = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, Yv = n(i => i.replace(y5, g5), "utob"), $v = Qo ? i => Buffer.from(i, "utf8").toString("base64") : Hv ? i => Gd(Hv.encode(i)) : i => Yd(Yv(i)), Yo = n((i, e = !1) => e ? Kv($v(i)) : $v(i), "encode"), Vv = n(i => Yo(i, !0), "encodeURI"), v5 = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, b5 = n(i => { switch (i.length) { case 4: var e = (7 & i.charCodeAt(0)) << 18 | (63 & i.charCodeAt(1)) << 12 | (63 & i.charCodeAt(2)) << 6 | 63 & i.charCodeAt(3), t = e - 65536; return tt((t >>> 10) + 55296) + tt((t & 1023) + 56320); case 3: return tt((15 & i.charCodeAt(0)) << 12 | (63 & i.charCodeAt(1)) << 6 | 63 & i.charCodeAt(2)); default: return tt((31 & i.charCodeAt(0)) << 6 | 63 & i.charCodeAt(1)) } }, "cb_btou"), Qv = n(i => i.replace(v5, b5), "btou"), Jv = n(i => { if (i = i.replace(/\s+/g, ""), !m5.test(i)) throw new TypeError("malformed base64."); i += "==".slice(2 - (i.length & 3)); let e, t = "", r, s; for (let o = 0; o < i.length;)e = Gu[i.charAt(o++)] << 18 | Gu[i.charAt(o++)] << 12 | (r = Gu[i.charAt(o++)]) << 6 | (s = Gu[i.charAt(o++)]), t += r === 64 ? tt(e >> 16 & 255) : s === 64 ? tt(e >> 16 & 255, e >> 8 & 255) : tt(e >> 16 & 255, e >> 8 & 255, e & 255); return t }, "atobPolyfill"), Qd = d5 ? i => atob(Gv(i)) : Qo ? i => Buffer.from(i, "base64").toString("binary") : Jv, Zv = Qo ? i => qv(Buffer.from(i, "base64")) : i => qv(Qd(i), e => e.charCodeAt(0)), e0 = n(i => Zv(t0(i)), "toUint8Array"), w5 = Qo ? i => Buffer.from(i, "base64").toString("utf8") : jv ? i => jv.decode(Zv(i)) : i => Qv(Qd(i)), t0 = n(i => Gv(i.replace(/[-_]/g, e => e == "-" ? "+" : "/")), "_unURI"), Xd = n(i => w5(t0(i)), "decode"), S5 = n(i => { if (typeof i != "string") return !1; let e = i.replace(/\s+/g, "").replace(/={0,2}$/, ""); return !/[^\s0-9a-zA-Z\+/]/.test(e) || !/[^\s0-9a-zA-Z\-_]/.test(e) }, "isValid"), i0 = n(i => ({ value: i, enumerable: !1, writable: !0, configurable: !0 }), "_noEnum"), r0 = n(function () { let i = n((e, t) => Object.defineProperty(String.prototype, e, i0(t)), "_add"); i("fromBase64", function () { return Xd(this) }), i("toBase64", function (e) { return Yo(this, e) }), i("toBase64URI", function () { return Yo(this, !0) }), i("toBase64URL", function () { return Yo(this, !0) }), i("toUint8Array", function () { return e0(this) }) }, "extendString"), s0 = n(function () { let i = n((e, t) => Object.defineProperty(Uint8Array.prototype, e, i0(t)), "_add"); i("toBase64", function (e) { return Xu(this, e) }), i("toBase64URI", function () { return Xu(this, !0) }), i("toBase64URL", function () { return Xu(this, !0) }) }, "extendUint8Array"), P5 = n(() => { r0(), s0() }, "extendBuiltins"), o0 = { version: Wv, VERSION: c5, atob: Qd, atobPolyfill: Jv, btoa: Yd, btoaPolyfill: Xv, fromBase64: Xd, toBase64: Yo, encode: Yo, encodeURI: Vv, encodeURL: Vv, utob: Yv, btou: Qv, decode: Xd, isValid: S5, fromUint8Array: Xu, toUint8Array: e0, extendString: r0, extendUint8Array: s0, extendBuiltins: P5 }; var C0 = se(v0()); function tp(i) { "@babel/helpers - typeof"; return tp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, tp(i) } n(tp, "_typeof"); function b0(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(b0, "_defineProperties"); function D5(i, e, t) { return e && b0(i.prototype, e), t && b0(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(D5, "_createClass"); function N5(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(N5, "_classCallCheck"); function I5(i, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); i.prototype = Object.create(e && e.prototype, { constructor: { value: i, writable: !0, configurable: !0 } }), Object.defineProperty(i, "prototype", { writable: !1 }), e && Xa(i, e) } n(I5, "_inherits"); function B5(i) { var e = w0(); return n(function () { var r = Ya(i), s; if (e) { var o = Ya(this).constructor; s = Reflect.construct(r, arguments, o) } else s = r.apply(this, arguments); return L5(this, s) }, "_createSuperInternal") } n(B5, "_createSuper"); function L5(i, e) { if (e && (tp(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return M5(i) } n(L5, "_possibleConstructorReturn"); function M5(i) { if (i === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return i } n(M5, "_assertThisInitialized"); function ip(i) { var e = typeof Map == "function" ? new Map : void 0; return ip = n(function (r) { if (r === null || !z5(r)) return r; if (typeof r != "function") throw new TypeError("Super expression must either be null or a function"); if (typeof e < "u") { if (e.has(r)) return e.get(r); e.set(r, s) } function s() { return Qu(r, arguments, Ya(this).constructor) } return n(s, "Wrapper"), s.prototype = Object.create(r.prototype, { constructor: { value: s, enumerable: !1, writable: !0, configurable: !0 } }), Xa(s, r) }, "_wrapNativeSuper"), ip(i) } n(ip, "_wrapNativeSuper"); function Qu(i, e, t) { return w0() ? Qu = Reflect.construct.bind() : Qu = n(function (s, o, a) { var l = [null]; l.push.apply(l, o); var h = Function.bind.apply(s, l), c = new h; return a && Xa(c, a.prototype), c }, "_construct"), Qu.apply(null, arguments) } n(Qu, "_construct"); function w0() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch { return !1 } } n(w0, "_isNativeReflectConstruct"); function z5(i) { return Function.toString.call(i).indexOf("[native code]") !== -1 } n(z5, "_isNativeFunction"); function Xa(i, e) { return Xa = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : n(function (r, s) { return r.__proto__ = s, r }, "_setPrototypeOf"), Xa(i, e) } n(Xa, "_setPrototypeOf"); function Ya(i) { return Ya = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : n(function (t) { return t.__proto__ || Object.getPrototypeOf(t) }, "_getPrototypeOf"), Ya(i) } n(Ya, "_getPrototypeOf"); var j5 = function (i) { I5(t, i); var e = B5(t); function t(r) { var s, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null; if (N5(this, t), s = e.call(this, r), s.originalRequest = a, s.originalResponse = l, s.causingError = o, o != null && (r += ", caused by ".concat(o.toString())), a != null) { var h = a.getHeader("X-Request-ID") || "n/a", c = a.getMethod(), d = a.getURL(), p = l ? l.getStatus() : "n/a", y = l ? l.getBody() || "" : "n/a"; r += ", originated from request (method: ".concat(c, ", url: ").concat(d, ", response code: ").concat(p, ", response text: ").concat(y, ", request id: ").concat(h, ")") } return s.message = r, s } return n(t, "DetailedError"), D5(t) }(ip(Error)), Jo = j5; var H5 = !1; function Jr(i) { H5 && console.log(i) } n(Jr, "log"); function rp() { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (i) { var e = Math.random() * 16 | 0, t = i === "x" ? e : e & 3 | 8; return t.toString(16) }) } n(rp, "uuid"); function T0(i, e) { return W5(i) || V5(i, e) || $5(i, e) || q5() } n(T0, "_slicedToArray"); function q5() {
        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    } n(q5, "_nonIterableRest"); function $5(i, e) { if (i) { if (typeof i == "string") return S0(i, e); var t = Object.prototype.toString.call(i).slice(8, -1); if (t === "Object" && i.constructor && (t = i.constructor.name), t === "Map" || t === "Set") return Array.from(i); if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return S0(i, e) } } n($5, "_unsupportedIterableToArray"); function S0(i, e) { (e == null || e > i.length) && (e = i.length); for (var t = 0, r = new Array(e); t < e; t++)r[t] = i[t]; return r } n(S0, "_arrayLikeToArray"); function V5(i, e) { var t = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"]; if (t != null) { var r = [], s = !0, o = !1, a, l; try { for (t = t.call(i); !(s = (a = t.next()).done) && (r.push(a.value), !(e && r.length === e)); s = !0); } catch (h) { o = !0, l = h } finally { try { !s && t.return != null && t.return() } finally { if (o) throw l } } return r } } n(V5, "_iterableToArrayLimit"); function W5(i) { if (Array.isArray(i)) return i } n(W5, "_arrayWithHoles"); function P0(i, e) { var t = Object.keys(i); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(i); e && (r = r.filter(function (s) { return Object.getOwnPropertyDescriptor(i, s).enumerable })), t.push.apply(t, r) } return t } n(P0, "ownKeys"); function Zo(i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? P0(Object(t), !0).forEach(function (r) { K5(i, r, t[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t)) : P0(Object(t)).forEach(function (r) { Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(t, r)) }) } return i } n(Zo, "_objectSpread"); function K5(i, e, t) { return e in i ? Object.defineProperty(i, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = t, i } n(K5, "_defineProperty"); function G5(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(G5, "_classCallCheck"); function _0(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(_0, "_defineProperties"); function X5(i, e, t) { return e && _0(i.prototype, e), t && _0(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(X5, "_createClass"); var Y5 = { endpoint: null, uploadUrl: null, metadata: {}, fingerprint: null, uploadSize: null, onProgress: null, onChunkComplete: null, onSuccess: null, onError: null, _onUploadUrlAvailable: null, overridePatchMethod: !1, headers: {}, addRequestId: !1, onBeforeRequest: null, onAfterResponse: null, onShouldRetry: null, chunkSize: 1 / 0, retryDelays: [0, 1e3, 3e3, 5e3], parallelUploads: 1, parallelUploadBoundaries: null, storeFingerprintForResuming: !0, removeFingerprintOnSuccess: !1, uploadLengthDeferred: !1, uploadDataDuringCreation: !1, urlStorage: null, fileReader: null, httpStack: null }, R0 = function () { function i(e, t) { G5(this, i), "resume" in t && console.log("tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead."), this.options = t, this.options.chunkSize = Number(this.options.chunkSize), this._urlStorage = this.options.urlStorage, this.file = e, this.url = null, this._req = null, this._fingerprint = null, this._urlStorageKey = null, this._offset = null, this._aborted = !1, this._size = null, this._source = null, this._retryAttempt = 0, this._retryTimeout = null, this._offsetBeforeRetry = 0, this._parallelUploads = null, this._parallelUploadUrls = null } return n(i, "BaseUpload"), X5(i, [{ key: "findPreviousUploads", value: n(function () { var t = this; return this.options.fingerprint(this.file, this.options).then(function (r) { return t._urlStorage.findUploadsByFingerprint(r) }) }, "findPreviousUploads") }, { key: "resumeFromPreviousUpload", value: n(function (t) { this.url = t.uploadUrl || null, this._parallelUploadUrls = t.parallelUploadUrls || null, this._urlStorageKey = t.urlStorageKey }, "resumeFromPreviousUpload") }, { key: "start", value: n(function () { var t = this, r = this.file; if (!r) { this._emitError(new Error("tus: no file or stream to upload provided")); return } if (!this.options.endpoint && !this.options.uploadUrl && !this.url) { this._emitError(new Error("tus: neither an endpoint or an upload URL is provided")); return } var s = this.options.retryDelays; if (s != null && Object.prototype.toString.call(s) !== "[object Array]") { this._emitError(new Error("tus: the `retryDelays` option must either be an array or null")); return } if (this.options.parallelUploads > 1) for (var o = 0, a = ["uploadUrl", "uploadSize", "uploadLengthDeferred"]; o < a.length; o++) { var l = a[o]; if (this.options[l]) { this._emitError(new Error("tus: cannot use the ".concat(l, " option when parallelUploads is enabled"))); return } } if (this.options.parallelUploadBoundaries) { if (this.options.parallelUploads <= 1) { this._emitError(new Error("tus: cannot use the `parallelUploadBoundaries` option when `parallelUploads` is disabled")); return } if (this.options.parallelUploads !== this.options.parallelUploadBoundaries.length) { this._emitError(new Error("tus: the `parallelUploadBoundaries` must have the same length as the value of `parallelUploads`")); return } } this.options.fingerprint(r, this.options).then(function (h) { return h == null ? Jr("No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.") : Jr("Calculated fingerprint: ".concat(h)), t._fingerprint = h, t._source ? t._source : t.options.fileReader.openFile(r, t.options.chunkSize) }).then(function (h) { if (t._source = h, t.options.uploadLengthDeferred) t._size = null; else if (t.options.uploadSize != null) { if (t._size = Number(t.options.uploadSize), Number.isNaN(t._size)) { t._emitError(new Error("tus: cannot convert `uploadSize` option into a number")); return } } else if (t._size = t._source.size, t._size == null) { t._emitError(new Error("tus: cannot automatically derive upload's size from input. Specify it manually using the `uploadSize` option or use the `uploadLengthDeferred` option")); return } t.options.parallelUploads > 1 || t._parallelUploadUrls != null ? t._startParallelUpload() : t._startSingleUpload() }).catch(function (h) { t._emitError(h) }) }, "start") }, { key: "_startParallelUpload", value: n(function () { var t, r = this, s = this._size, o = 0; this._parallelUploads = []; var a = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads, l = (t = this.options.parallelUploadBoundaries) !== null && t !== void 0 ? t : J5(this._source.size, a); this._parallelUploadUrls && l.forEach(function (d, p) { d.uploadUrl = r._parallelUploadUrls[p] || null }), this._parallelUploadUrls = new Array(l.length); var h = l.map(function (d, p) { var y = 0; return r._source.slice(d.start, d.end).then(function (v) { var S = v.value; return new Promise(function (x, E) { var F = Zo(Zo({}, r.options), {}, { uploadUrl: d.uploadUrl || null, storeFingerprintForResuming: !1, removeFingerprintOnSuccess: !1, parallelUploads: 1, parallelUploadBoundaries: null, metadata: {}, headers: Zo(Zo({}, r.options.headers), {}, { "Upload-Concat": "partial" }), onSuccess: x, onError: E, onProgress: n(function (H) { o = o - y + H, y = H, r._emitProgress(o, s) }, "onProgress"), _onUploadUrlAvailable: n(function () { r._parallelUploadUrls[p] = k.url, r._parallelUploadUrls.filter(function (H) { return !!H }).length === l.length && r._saveUploadInUrlStorage() }, "_onUploadUrlAvailable") }), k = new i(S, F); k.start(), r._parallelUploads.push(k) }) }) }), c; Promise.all(h).then(function () { c = r._openRequest("POST", r.options.endpoint), c.setHeader("Upload-Concat", "final;".concat(r._parallelUploadUrls.join(" "))); var d = x0(r.options.metadata); return d !== "" && c.setHeader("Upload-Metadata", d), r._sendRequest(c, null) }).then(function (d) { if (!en(d.getStatus(), 200)) { r._emitHttpError(c, d, "tus: unexpected response while creating upload"); return } var p = d.getHeader("Location"); if (p == null) { r._emitHttpError(c, d, "tus: invalid or missing Location header"); return } r.url = A0(r.options.endpoint, p), Jr("Created upload at ".concat(r.url)), r._emitSuccess() }).catch(function (d) { r._emitError(d) }) }, "_startParallelUpload") }, { key: "_startSingleUpload", value: n(function () { if (this._aborted = !1, this.url != null) { Jr("Resuming upload from previous URL: ".concat(this.url)), this._resumeUpload(); return } if (this.options.uploadUrl != null) { Jr("Resuming upload from provided URL: ".concat(this.options.uploadUrl)), this.url = this.options.uploadUrl, this._resumeUpload(); return } Jr("Creating a new upload"), this._createUpload() }, "_startSingleUpload") }, { key: "abort", value: n(function (t) { var r = this; return this._parallelUploads != null && this._parallelUploads.forEach(function (s) { s.abort(t) }), this._req !== null && this._req.abort(), this._aborted = !0, this._retryTimeout != null && (clearTimeout(this._retryTimeout), this._retryTimeout = null), !t || this.url == null ? Promise.resolve() : i.terminate(this.url, this.options).then(function () { return r._removeFromUrlStorage() }) }, "abort") }, { key: "_emitHttpError", value: n(function (t, r, s, o) { this._emitError(new Jo(s, o, t, r)) }, "_emitHttpError") }, { key: "_emitError", value: n(function (t) { var r = this; if (!this._aborted) { if (this.options.retryDelays != null) { var s = this._offset != null && this._offset > this._offsetBeforeRetry; if (s && (this._retryAttempt = 0), O0(t, this._retryAttempt, this.options)) { var o = this.options.retryDelays[this._retryAttempt++]; this._offsetBeforeRetry = this._offset, this._retryTimeout = setTimeout(function () { r.start() }, o); return } } if (typeof this.options.onError == "function") this.options.onError(t); else throw t } }, "_emitError") }, { key: "_emitSuccess", value: n(function () { this.options.removeFingerprintOnSuccess && this._removeFromUrlStorage(), typeof this.options.onSuccess == "function" && this.options.onSuccess() }, "_emitSuccess") }, { key: "_emitProgress", value: n(function (t, r) { typeof this.options.onProgress == "function" && this.options.onProgress(t, r) }, "_emitProgress") }, { key: "_emitChunkComplete", value: n(function (t, r, s) { typeof this.options.onChunkComplete == "function" && this.options.onChunkComplete(t, r, s) }, "_emitChunkComplete") }, { key: "_createUpload", value: n(function () { var t = this; if (!this.options.endpoint) { this._emitError(new Error("tus: unable to create upload because no endpoint is provided")); return } var r = this._openRequest("POST", this.options.endpoint); this.options.uploadLengthDeferred ? r.setHeader("Upload-Defer-Length", 1) : r.setHeader("Upload-Length", this._size); var s = x0(this.options.metadata); s !== "" && r.setHeader("Upload-Metadata", s); var o; this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred ? (this._offset = 0, o = this._addChunkToRequest(r)) : o = this._sendRequest(r, null), o.then(function (a) { if (!en(a.getStatus(), 200)) { t._emitHttpError(r, a, "tus: unexpected response while creating upload"); return } var l = a.getHeader("Location"); if (l == null) { t._emitHttpError(r, a, "tus: invalid or missing Location header"); return } if (t.url = A0(t.options.endpoint, l), Jr("Created upload at ".concat(t.url)), typeof t.options._onUploadUrlAvailable == "function" && t.options._onUploadUrlAvailable(), t._size === 0) { t._emitSuccess(), t._source.close(); return } t._saveUploadInUrlStorage().then(function () { t.options.uploadDataDuringCreation ? t._handleUploadResponse(r, a) : (t._offset = 0, t._performUpload()) }) }).catch(function (a) { t._emitHttpError(r, null, "tus: failed to create upload", a) }) }, "_createUpload") }, { key: "_resumeUpload", value: n(function () { var t = this, r = this._openRequest("HEAD", this.url), s = this._sendRequest(r, null); s.then(function (o) { var a = o.getStatus(); if (!en(a, 200)) { if (a === 423) { t._emitHttpError(r, o, "tus: upload is currently locked; retry later"); return } if (en(a, 400) && t._removeFromUrlStorage(), !t.options.endpoint) { t._emitHttpError(r, o, "tus: unable to resume upload (new upload cannot be created without an endpoint)"); return } t.url = null, t._createUpload(); return } var l = parseInt(o.getHeader("Upload-Offset"), 10); if (Number.isNaN(l)) { t._emitHttpError(r, o, "tus: invalid or missing offset value"); return } var h = parseInt(o.getHeader("Upload-Length"), 10); if (Number.isNaN(h) && !t.options.uploadLengthDeferred) { t._emitHttpError(r, o, "tus: invalid or missing length value"); return } typeof t.options._onUploadUrlAvailable == "function" && t.options._onUploadUrlAvailable(), t._saveUploadInUrlStorage().then(function () { if (l === h) { t._emitProgress(h, h), t._emitSuccess(); return } t._offset = l, t._performUpload() }) }).catch(function (o) { t._emitHttpError(r, null, "tus: failed to resume upload", o) }) }, "_resumeUpload") }, { key: "_performUpload", value: n(function () { var t = this; if (!this._aborted) { var r; this.options.overridePatchMethod ? (r = this._openRequest("POST", this.url), r.setHeader("X-HTTP-Method-Override", "PATCH")) : r = this._openRequest("PATCH", this.url), r.setHeader("Upload-Offset", this._offset); var s = this._addChunkToRequest(r); s.then(function (o) { if (!en(o.getStatus(), 200)) { t._emitHttpError(r, o, "tus: unexpected response while uploading chunk"); return } t._handleUploadResponse(r, o) }).catch(function (o) { t._aborted || t._emitHttpError(r, null, "tus: failed to upload chunk at offset ".concat(t._offset), o) }) } }, "_performUpload") }, { key: "_addChunkToRequest", value: n(function (t) { var r = this, s = this._offset, o = this._offset + this.options.chunkSize; return t.setProgressHandler(function (a) { r._emitProgress(s + a, r._size) }), t.setHeader("Content-Type", "application/offset+octet-stream"), (o === 1 / 0 || o > this._size) && !this.options.uploadLengthDeferred && (o = this._size), this._source.slice(s, o).then(function (a) { var l = a.value, h = a.done; return r.options.uploadLengthDeferred && h && (r._size = r._offset + (l && l.size ? l.size : 0), t.setHeader("Upload-Length", r._size)), l === null ? r._sendRequest(t) : (r._emitProgress(r._offset, r._size), r._sendRequest(t, l)) }) }, "_addChunkToRequest") }, { key: "_handleUploadResponse", value: n(function (t, r) { var s = parseInt(r.getHeader("Upload-Offset"), 10); if (Number.isNaN(s)) { this._emitHttpError(t, r, "tus: invalid or missing offset value"); return } if (this._emitProgress(s, this._size), this._emitChunkComplete(s - this._offset, s, this._size), this._offset = s, s === this._size) { this._emitSuccess(), this._source.close(); return } this._performUpload() }, "_handleUploadResponse") }, { key: "_openRequest", value: n(function (t, r) { var s = E0(t, r, this.options); return this._req = s, s }, "_openRequest") }, { key: "_removeFromUrlStorage", value: n(function () { var t = this; this._urlStorageKey && (this._urlStorage.removeUpload(this._urlStorageKey).catch(function (r) { t._emitError(r) }), this._urlStorageKey = null) }, "_removeFromUrlStorage") }, { key: "_saveUploadInUrlStorage", value: n(function () { var t = this; if (!this.options.storeFingerprintForResuming || !this._fingerprint || this._urlStorageKey !== null) return Promise.resolve(); var r = { size: this._size, metadata: this.options.metadata, creationTime: new Date().toString() }; return this._parallelUploads ? r.parallelUploadUrls = this._parallelUploadUrls : r.uploadUrl = this.url, this._urlStorage.addUpload(this._fingerprint, r).then(function (s) { t._urlStorageKey = s }) }, "_saveUploadInUrlStorage") }, { key: "_sendRequest", value: n(function (t) { var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null; return F0(t, r, this.options) }, "_sendRequest") }], [{ key: "terminate", value: n(function (t) { var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = E0("DELETE", t, r); return F0(s, null, r).then(function (o) { if (o.getStatus() !== 204) throw new Jo("tus: unexpected response while terminating upload", null, s, o) }).catch(function (o) { if (o instanceof Jo || (o = new Jo("tus: failed to terminate upload", o, s, null)), !O0(o, 0, r)) throw o; var a = r.retryDelays[0], l = r.retryDelays.slice(1), h = Zo(Zo({}, r), {}, { retryDelays: l }); return new Promise(function (c) { return setTimeout(c, a) }).then(function () { return i.terminate(t, h) }) }) }, "terminate") }]), i }(); function x0(i) { return Object.entries(i).map(function (e) { var t = T0(e, 2), r = t[0], s = t[1]; return "".concat(r, " ").concat(o0.encode(String(s))) }).join(",") } n(x0, "encodeMetadata"); function en(i, e) { return i >= e && i < e + 100 } n(en, "inStatusCategory"); function E0(i, e, t) { var r = t.httpStack.createRequest(i, e); r.setHeader("Tus-Resumable", "1.0.0"); var s = t.headers || {}; if (Object.entries(s).forEach(function (a) { var l = T0(a, 2), h = l[0], c = l[1]; r.setHeader(h, c) }), t.addRequestId) { var o = rp(); r.setHeader("X-Request-ID", o) } return r } n(E0, "openRequest"); function F0(i, e, t) { var r = typeof t.onBeforeRequest == "function" ? Promise.resolve(t.onBeforeRequest(i)) : Promise.resolve(); return r.then(function () { return i.send(e).then(function (s) { var o = typeof t.onAfterResponse == "function" ? Promise.resolve(t.onAfterResponse(i, s)) : Promise.resolve(); return o.then(function () { return s }) }) }) } n(F0, "sendRequest"); function Q5() { var i = !0; return typeof window < "u" && "navigator" in window && window.navigator.onLine === !1 && (i = !1), i } n(Q5, "isOnline"); function O0(i, e, t) { if (t.retryDelays == null || e >= t.retryDelays.length || i.originalRequest == null) return !1; if (t && typeof t.onShouldRetry == "function") return t.onShouldRetry(i, e, t); var r = i.originalResponse ? i.originalResponse.getStatus() : 0; return (!en(r, 400) || r === 409 || r === 423) && Q5() } n(O0, "shouldRetry"); function A0(i, e) { return new C0.default(e, i).toString() } n(A0, "resolveUrl"); function J5(i, e) { for (var t = Math.floor(i / e), r = [], s = 0; s < e; s++)r.push({ start: t * s, end: t * (s + 1) }); return r[e - 1].end = i, r } n(J5, "splitSizeIntoParts"); R0.defaultOptions = Y5; var Ju = R0; function Z5(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(Z5, "_classCallCheck"); function k0(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(k0, "_defineProperties"); function ex(i, e, t) { return e && k0(i.prototype, e), t && k0(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(ex, "_createClass"); var U0 = function () { function i() { Z5(this, i) } return n(i, "NoopUrlStorage"), ex(i, [{ key: "listAllUploads", value: n(function () { return Promise.resolve([]) }, "listAllUploads") }, { key: "findUploadsByFingerprint", value: n(function (t) { return Promise.resolve([]) }, "findUploadsByFingerprint") }, { key: "removeUpload", value: n(function (t) { return Promise.resolve() }, "removeUpload") }, { key: "addUpload", value: n(function (t, r) { return Promise.resolve(null) }, "addUpload") }]), i }(); function tx(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(tx, "_classCallCheck"); function D0(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(D0, "_defineProperties"); function ix(i, e, t) { return e && D0(i.prototype, e), t && D0(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(ix, "_createClass"); var op = !1; try { op = "localStorage" in window, sp = "tusSupport", localStorage.setItem(sp, localStorage.getItem(sp)) } catch (i) { if (i.code === i.SECURITY_ERR || i.code === i.QUOTA_EXCEEDED_ERR) op = !1; else throw i } var sp, N0 = op, I0 = function () { function i() { tx(this, i) } return n(i, "WebStorageUrlStorage"), ix(i, [{ key: "findAllUploads", value: n(function () { var t = this._findEntries("tus::"); return Promise.resolve(t) }, "findAllUploads") }, { key: "findUploadsByFingerprint", value: n(function (t) { var r = this._findEntries("tus::".concat(t, "::")); return Promise.resolve(r) }, "findUploadsByFingerprint") }, { key: "removeUpload", value: n(function (t) { return localStorage.removeItem(t), Promise.resolve() }, "removeUpload") }, { key: "addUpload", value: n(function (t, r) { var s = Math.round(Math.random() * 1e12), o = "tus::".concat(t, "::").concat(s); return localStorage.setItem(o, JSON.stringify(r)), Promise.resolve(o) }, "addUpload") }, { key: "_findEntries", value: n(function (t) { for (var r = [], s = 0; s < localStorage.length; s++) { var o = localStorage.key(s); if (o.indexOf(t) === 0) try { var a = JSON.parse(localStorage.getItem(o)); a.urlStorageKey = o, r.push(a) } catch { } } return r }, "_findEntries") }]), i }(); function np(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(np, "_classCallCheck"); function B0(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(B0, "_defineProperties"); function ap(i, e, t) { return e && B0(i.prototype, e), t && B0(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(ap, "_createClass"); var L0 = function () { function i() { np(this, i) } return n(i, "XHRHttpStack"), ap(i, [{ key: "createRequest", value: n(function (t, r) { return new rx(t, r) }, "createRequest") }, { key: "getName", value: n(function () { return "XHRHttpStack" }, "getName") }]), i }(); var rx = function () { function i(e, t) { np(this, i), this._xhr = new XMLHttpRequest, this._xhr.open(e, t, !0), this._method = e, this._url = t, this._headers = {} } return n(i, "Request"), ap(i, [{ key: "getMethod", value: n(function () { return this._method }, "getMethod") }, { key: "getURL", value: n(function () { return this._url }, "getURL") }, { key: "setHeader", value: n(function (t, r) { this._xhr.setRequestHeader(t, r), this._headers[t] = r }, "setHeader") }, { key: "getHeader", value: n(function (t) { return this._headers[t] }, "getHeader") }, { key: "setProgressHandler", value: n(function (t) { "upload" in this._xhr && (this._xhr.upload.onprogress = function (r) { r.lengthComputable && t(r.loaded) }) }, "setProgressHandler") }, { key: "send", value: n(function () { var t = this, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null; return new Promise(function (s, o) { t._xhr.onload = function () { s(new sx(t._xhr)) }, t._xhr.onerror = function (a) { o(a) }, t._xhr.send(r) }) }, "send") }, { key: "abort", value: n(function () { return this._xhr.abort(), Promise.resolve() }, "abort") }, { key: "getUnderlyingObject", value: n(function () { return this._xhr }, "getUnderlyingObject") }]), i }(), sx = function () { function i(e) { np(this, i), this._xhr = e } return n(i, "Response"), ap(i, [{ key: "getStatus", value: n(function () { return this._xhr.status }, "getStatus") }, { key: "getHeader", value: n(function (t) { return this._xhr.getResponseHeader(t) }, "getHeader") }, { key: "getBody", value: n(function () { return this._xhr.responseText }, "getBody") }, { key: "getUnderlyingObject", value: n(function () { return this._xhr }, "getUnderlyingObject") }]), i }(); var ox = n(function () { return typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative" }, "isReactNative"), Zu = ox; function lp(i) { return new Promise(function (e, t) { var r = new XMLHttpRequest; r.responseType = "blob", r.onload = function () { var s = r.response; e(s) }, r.onerror = function (s) { t(s) }, r.open("GET", i), r.send() }) } n(lp, "uriToBlob"); var nx = n(function () { return typeof window < "u" && (typeof window.PhoneGap < "u" || typeof window.Cordova < "u" || typeof window.cordova < "u") }, "isCordova"), M0 = nx; function up(i) { return new Promise(function (e, t) { var r = new FileReader; r.onload = function () { var s = new Uint8Array(r.result); e({ value: s }) }, r.onerror = function (s) { t(s) }, r.readAsArrayBuffer(i) }) } n(up, "readAsByteArray"); function ax(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(ax, "_classCallCheck"); function z0(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(z0, "_defineProperties"); function lx(i, e, t) { return e && z0(i.prototype, e), t && z0(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(lx, "_createClass"); var hp = function () { function i(e) { ax(this, i), this._file = e, this.size = e.size } return n(i, "FileSource"), lx(i, [{ key: "slice", value: n(function (t, r) { if (M0()) return up(this._file.slice(t, r)); var s = this._file.slice(t, r); return Promise.resolve({ value: s }) }, "slice") }, { key: "close", value: n(function () { }, "close") }]), i }(); function ux(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(ux, "_classCallCheck"); function j0(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(j0, "_defineProperties"); function hx(i, e, t) { return e && j0(i.prototype, e), t && j0(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(hx, "_createClass"); function H0(i) { return i === void 0 ? 0 : i.size !== void 0 ? i.size : i.length } n(H0, "len"); function cx(i, e) { if (i.concat) return i.concat(e); if (i instanceof Blob) return new Blob([i, e], { type: i.type }); if (i.set) { var t = new i.constructor(i.length + e.length); return t.set(i), t.set(e, i.length), t } throw new Error("Unknown data type") } n(cx, "concat"); var q0 = function () { function i(e) { ux(this, i), this._buffer = void 0, this._bufferOffset = 0, this._reader = e, this._done = !1 } return n(i, "StreamSource"), hx(i, [{ key: "slice", value: n(function (t, r) { return t < this._bufferOffset ? Promise.reject(new Error("Requested data is before the reader's current offset")) : this._readUntilEnoughDataOrDone(t, r) }, "slice") }, { key: "_readUntilEnoughDataOrDone", value: n(function (t, r) { var s = this, o = r <= this._bufferOffset + H0(this._buffer); if (this._done || o) { var a = this._getDataFromBuffer(t, r), l = a == null ? this._done : !1; return Promise.resolve({ value: a, done: l }) } return this._reader.read().then(function (h) { var c = h.value, d = h.done; return d ? s._done = !0 : s._buffer === void 0 ? s._buffer = c : s._buffer = cx(s._buffer, c), s._readUntilEnoughDataOrDone(t, r) }) }, "_readUntilEnoughDataOrDone") }, { key: "_getDataFromBuffer", value: n(function (t, r) { t > this._bufferOffset && (this._buffer = this._buffer.slice(t - this._bufferOffset), this._bufferOffset = t); var s = H0(this._buffer) === 0; return this._done && s ? null : this._buffer.slice(0, r - t) }, "_getDataFromBuffer") }, { key: "close", value: n(function () { this._reader.cancel && this._reader.cancel() }, "close") }]), i }(); function dx(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(dx, "_classCallCheck"); function $0(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n($0, "_defineProperties"); function px(i, e, t) { return e && $0(i.prototype, e), t && $0(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(px, "_createClass"); var V0 = function () { function i() { dx(this, i) } return n(i, "FileReader"), px(i, [{ key: "openFile", value: n(function (t, r) { return Zu() && t && typeof t.uri < "u" ? lp(t.uri).then(function (s) { return new hp(s) }).catch(function (s) { throw new Error("tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. ".concat(s)) }) : typeof t.slice == "function" && typeof t.size < "u" ? Promise.resolve(new hp(t)) : typeof t.read == "function" ? (r = Number(r), Number.isFinite(r) ? Promise.resolve(new q0(t, r)) : Promise.reject(new Error("cannot create source for stream without a finite value for the `chunkSize` option"))) : Promise.reject(new Error("source object may only be an instance of File, Blob, or Reader in this environment")) }, "openFile") }]), i }(); function cp(i, e) { return Zu() ? Promise.resolve(fx(i, e)) : Promise.resolve(["tus-br", i.name, i.type, i.size, i.lastModified, e.endpoint].join("-")) } n(cp, "fingerprint"); function fx(i, e) { var t = i.exif ? mx(JSON.stringify(i.exif)) : "noexif"; return ["tus-rn", i.name || "noname", i.size || "nosize", t, e.endpoint].join("/") } n(fx, "reactNativeFingerprint"); function mx(i) { var e = 0; if (i.length === 0) return e; for (var t = 0; t < i.length; t++) { var r = i.charCodeAt(t); e = (e << 5) - e + r, e &= e } return e } n(mx, "hashCode"); function dp(i) { "@babel/helpers - typeof"; return dp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, dp(i) } n(dp, "_typeof"); function gx(i, e) { if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function") } n(gx, "_classCallCheck"); function W0(i, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(i, r.key, r) } } n(W0, "_defineProperties"); function yx(i, e, t) { return e && W0(i.prototype, e), t && W0(i, t), Object.defineProperty(i, "prototype", { writable: !1 }), i } n(yx, "_createClass"); function vx(i, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function"); i.prototype = Object.create(e && e.prototype, { constructor: { value: i, writable: !0, configurable: !0 } }), Object.defineProperty(i, "prototype", { writable: !1 }), e && pp(i, e) } n(vx, "_inherits"); function pp(i, e) { return pp = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : n(function (r, s) { return r.__proto__ = s, r }, "_setPrototypeOf"), pp(i, e) } n(pp, "_setPrototypeOf"); function bx(i) { var e = Px(); return n(function () { var r = eh(i), s; if (e) { var o = eh(this).constructor; s = Reflect.construct(r, arguments, o) } else s = r.apply(this, arguments); return wx(this, s) }, "_createSuperInternal") } n(bx, "_createSuper"); function wx(i, e) { if (e && (dp(e) === "object" || typeof e == "function")) return e; if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return Sx(i) } n(wx, "_possibleConstructorReturn"); function Sx(i) { if (i === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return i } n(Sx, "_assertThisInitialized"); function Px() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch { return !1 } } n(Px, "_isNativeReflectConstruct"); function eh(i) { return eh = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : n(function (t) { return t.__proto__ || Object.getPrototypeOf(t) }, "_getPrototypeOf"), eh(i) } n(eh, "_getPrototypeOf"); function K0(i, e) { var t = Object.keys(i); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(i); e && (r = r.filter(function (s) { return Object.getOwnPropertyDescriptor(i, s).enumerable })), t.push.apply(t, r) } return t } n(K0, "ownKeys"); function tn(i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? K0(Object(t), !0).forEach(function (r) { _x(i, r, t[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t)) : K0(Object(t)).forEach(function (r) { Object.defineProperty(i, r, Object.getOwnPropertyDescriptor(t, r)) }) } return i } n(tn, "_objectSpread"); function _x(i, e, t) { return e in i ? Object.defineProperty(i, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : i[e] = t, i } n(_x, "_defineProperty"); var th = tn(tn({}, Ju.defaultOptions), {}, { httpStack: new L0, fileReader: new V0, urlStorage: N0 ? new I0 : new U0, fingerprint: cp }), X0 = function (i) { vx(t, i); var e = bx(t); function t() { var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; return gx(this, t), s = tn(tn({}, th), s), e.call(this, r, s) } return n(t, "Upload"), yx(t, null, [{ key: "terminate", value: n(function (s, o, a) { return o = tn(tn({}, th), o), Ju.terminate(s, o, a) }, "terminate") }]), t }(Ju), Y0 = window, xx = Y0.XMLHttpRequest, G0 = Y0.Blob, RI = xx && G0 && typeof G0.prototype.slice == "function"; function Ex() { return typeof window < "u" && (typeof window.PhoneGap < "u" || typeof window.Cordova < "u" || typeof window.cordova < "u") } n(Ex, "isCordova"); function Fx() { return typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative" } n(Fx, "isReactNative"); function fp(i) { return (e, t) => { if (Ex() || Fx()) return th.fingerprint(e, t); let r = ["tus", i.id, t.endpoint].join("-"); return Promise.resolve(r) } } n(fp, "getFingerprint"); function Js(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Js, "_classPrivateFieldLooseBase"); var Ox = 0; function Za(i) { return "__private_" + Ox++ + "_" + i } n(Za, "_classPrivateFieldLooseKey"); var Ax = { version: "3.1.3" }, J0 = { endpoint: "", uploadUrl: null, metadata: {}, uploadSize: null, onProgress: null, onChunkComplete: null, onSuccess: null, onError: null, overridePatchMethod: !1, headers: {}, addRequestId: !1, chunkSize: 1 / 0, retryDelays: [100, 1e3, 3e3, 5e3], parallelUploads: 1, removeFingerprintOnSuccess: !1, uploadLengthDeferred: !1, uploadDataDuringCreation: !1 }, Ja = Za("retryDelayIterator"), yp = Za("upload"), mp = Za("requestSocketToken"), gp = Za("uploadFiles"), Qa = Za("handleUpload"), Ki = class extends ri { constructor(e, t) { var r, s; super(e, t), Object.defineProperty(this, gp, { value: Cx }), Object.defineProperty(this, yp, { value: Tx }), Object.defineProperty(this, Ja, { writable: !0, value: void 0 }), Object.defineProperty(this, mp, { writable: !0, value: async (a, l) => { let h = a.remote.providerOptions.provider ? Q : de, c = new h(this.uppy, a.remote.providerOptions), d = { ...this.opts }; return a.tus && Object.assign(d, a.tus), (await c.post(a.remote.url, { ...a.remote.body, endpoint: d.endpoint, uploadUrl: d.uploadUrl, protocol: "tus", size: a.data.size, headers: typeof d.headers == "function" ? d.headers(a) : d.headers, metadata: a.meta }, l)).token } }), Object.defineProperty(this, Qa, { writable: !0, value: async a => { if (a.length === 0) { this.uppy.log("[Tus] No files to upload"); return } this.opts.limit === 0 && this.uppy.log("[Tus] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/tus/#limit-0", "warning"), this.uppy.log("[Tus] Uploading..."); let l = this.uppy.getFilesByIds(a); await Js(this, gp)[gp](l) } }), this.type = "uploader", this.id = this.opts.id || "Tus", this.title = "Tus"; let o = { useFastRemoteRetry: !0, limit: 20, retryDelays: J0.retryDelays, withCredentials: !1 }; if (this.opts = { ...o, ...t }, t?.allowedMetaFields === void 0 && "metaFields" in this.opts) throw new Error("The `metaFields` option has been renamed to `allowedMetaFields`."); if ("autoRetry" in t) throw new Error("The `autoRetry` option was deprecated and has been removed."); this.requests = (r = this.opts.rateLimitedQueue) != null ? r : new vt(this.opts.limit), Js(this, Ja)[Ja] = (s = this.opts.retryDelays) == null ? void 0 : s.values(), this.uploaders = Object.create(null), this.uploaderEvents = Object.create(null), this.uploaderSockets = Object.create(null), this.handleResetProgress = this.handleResetProgress.bind(this), this.setQueueRequestSocketToken(this.requests.wrapPromiseFunction(Js(this, mp)[mp], { priority: -1 })) } handleResetProgress() { let e = { ...this.uppy.getState().files }; Object.keys(e).forEach(t => { if (e[t].tus && e[t].tus.uploadUrl) { let r = { ...e[t].tus }; delete r.uploadUrl, e[t] = { ...e[t], tus: r } } }), this.uppy.setState({ files: e }) } resetUploaderReferences(e, t) { if (t === void 0 && (t = {}), this.uploaders[e]) { let r = this.uploaders[e]; r.abort(), t.abort && r.abort(!0), this.uploaders[e] = null } this.uploaderEvents[e] && (this.uploaderEvents[e].remove(), this.uploaderEvents[e] = null), this.uploaderSockets[e] && (this.uploaderSockets[e].close(), this.uploaderSockets[e] = null) } async connectToServerSocket(e) { var t = this; return new Promise((r, s) => { let o = e.serverToken, a = wr(e.remote.companionUrl), l = new Ft({ target: `${a}/api/${o}`, autoOpen: !1 }); this.uploaderSockets[e.id] = l, this.uploaderEvents[e.id] = new at(this.uppy); let h; this.onFileRemove(e.id, () => { l.send("cancel", {}), h.abort(), this.resetUploaderReferences(e.id), r(`upload ${e.id} was removed`) }), this.onPause(e.id, c => { c ? (l.send("pause", {}), h.abort()) : (h.abort(), h = this.requests.run(() => (l.open(), l.send("resume", {}), () => { }))) }), this.onPauseAll(e.id, () => { l.send("pause", {}), h.abort() }), this.onCancelAll(e.id, function (c) { let { reason: d } = c === void 0 ? {} : c; d === "user" && (l.send("cancel", {}), h.abort(), t.resetUploaderReferences(e.id)), r(`upload ${e.id} was canceled`) }), this.onResumeAll(e.id, () => { h.abort(), e.error && l.send("pause", {}), h = this.requests.run(() => (l.open(), l.send("resume", {}), () => { })) }), this.onRetry(e.id, () => { l.isOpen && (l.send("pause", {}), l.send("resume", {})) }), this.onRetryAll(e.id, () => { l.isOpen && (l.send("pause", {}), l.send("resume", {})) }), l.on("progress", c => Gr(this, c, e)), l.on("error", c => { let { message: d } = c.error, p = Object.assign(new Error(d), { cause: c.error }); this.opts.useFastRemoteRetry ? l.close() : (this.resetUploaderReferences(e.id), this.uppy.setFileState(e.id, { serverToken: null })), this.uppy.emit("upload-error", e, p), h.done(), s(p) }), l.on("success", c => { let d = { uploadURL: c.url }; this.uppy.emit("upload-success", e, d), this.resetUploaderReferences(e.id), h.done(), l.close(), r() }), h = this.requests.run(() => (e.isPaused ? l.send("pause", {}) : l.open(), () => { })) }) } onReceiveUploadUrl(e, t) { let r = this.uppy.getFile(e.id); r && (!r.tus || r.tus.uploadUrl !== t) && (this.uppy.log("[Tus] Storing upload url"), this.uppy.setFileState(r.id, { tus: { ...r.tus, uploadUrl: t } })) } onFileRemove(e, t) { this.uploaderEvents[e].on("file-removed", r => { e === r.id && t(r.id) }) } onPause(e, t) { this.uploaderEvents[e].on("upload-pause", (r, s) => { e === r && t(s) }) } onRetry(e, t) { this.uploaderEvents[e].on("upload-retry", r => { e === r && t() }) } onRetryAll(e, t) { this.uploaderEvents[e].on("retry-all", () => { this.uppy.getFile(e) && t() }) } onPauseAll(e, t) { this.uploaderEvents[e].on("pause-all", () => { this.uppy.getFile(e) && t() }) } onCancelAll(e, t) { var r = this; this.uploaderEvents[e].on("cancel-all", function () { r.uppy.getFile(e) && t(...arguments) }) } onResumeAll(e, t) { this.uploaderEvents[e].on("resume-all", () => { this.uppy.getFile(e) && t() }) } install() { this.uppy.setState({ capabilities: { ...this.uppy.getState().capabilities, resumableUploads: !0 } }), this.uppy.addUploader(Js(this, Qa)[Qa]), this.uppy.on("reset-progress", this.handleResetProgress) } uninstall() { this.uppy.setState({ capabilities: { ...this.uppy.getState().capabilities, resumableUploads: !1 } }), this.uppy.removeUploader(Js(this, Qa)[Qa]) } }; n(Ki, "Tus"); function Tx(i) { var e = this; return this.resetUploaderReferences(i.id), new Promise((t, r) => { let s, o, a, l = { ...this.opts, ...i.tus || {} }; typeof l.headers == "function" && (l.headers = l.headers(i)); let h = { ...J0, ...l }; h.fingerprint = fp(i), h.onBeforeRequest = v => { let S = v.getUnderlyingObject(); S.withCredentials = !!l.withCredentials; let x; if (typeof l.onBeforeRequest == "function" && (x = l.onBeforeRequest(v, i)), ht(s, "shouldBeRequeued")) { if (!s.shouldBeRequeued) return Promise.reject(); let E, F = new Promise(k => { E = k }); return s = this.requests.run(() => (i.isPaused && s.abort(), E(), () => { })), Promise.all([F, x]) } return x }, h.onError = v => { var S; this.uppy.log(v); let x = v.originalRequest ? v.originalRequest.getUnderlyingObject() : null; Gs(x) && (v = new hi(v, x)), this.resetUploaderReferences(i.id), (S = s) == null || S.abort(), this.uppy.emit("upload-error", i, v), r(v) }, h.onProgress = (v, S) => { this.onReceiveUploadUrl(i, a.url), this.uppy.emit("upload-progress", i, { uploader: this, bytesUploaded: v, bytesTotal: S }) }, h.onSuccess = () => { let v = { uploadURL: a.url }; this.resetUploaderReferences(i.id), s.done(), this.uppy.emit("upload-success", i, v), a.url && this.uppy.log(`Download ${a.file.name} from ${a.url}`), t(a) }; let c = n(v => { var S; let x = v == null || (S = v.originalResponse) == null ? void 0 : S.getStatus(); if (x === 429) { if (!this.requests.isPaused) { var E; let F = (E = Js(this, Ja)[Ja]) == null ? void 0 : E.next(); if (F == null || F.done) return !1; this.requests.rateLimit(F.value) } } else { if (x > 400 && x < 500 && x !== 409 && x !== 423) return !1; typeof navigator < "u" && navigator.onLine === !1 && (this.requests.isPaused || (this.requests.pause(), window.addEventListener("online", () => { this.requests.resume() }, { once: !0 }))) } return s.abort(), s = { shouldBeRequeued: !0, abort() { this.shouldBeRequeued = !1 }, done() { throw new Error("Cannot mark a queued request as done: this indicates a bug") }, fn() { throw new Error("Cannot run a queued request: this indicates a bug") } }, !0 }, "defaultOnShouldRetry"); l.onShouldRetry != null ? h.onShouldRetry = function () { for (var v = arguments.length, S = new Array(v), x = 0; x < v; x++)S[x] = arguments[x]; return l.onShouldRetry(...S, c) } : h.onShouldRetry = c; let d = n((v, S, x) => { ht(v, S) && !ht(v, x) && (v[x] = v[S]) }, "copyProp"), p = {}; (Array.isArray(l.allowedMetaFields) ? l.allowedMetaFields : Object.keys(i.meta)).forEach(v => { p[v] = i.meta[v] }), d(p, "type", "filetype"), d(p, "name", "filename"), h.metadata = p, a = new X0(i.data, h), this.uploaders[i.id] = a, this.uploaderEvents[i.id] = new at(this.uppy), o = n(() => (i.isPaused || a.start(), () => { }), "qRequest"), a.findPreviousUploads().then(v => { let S = v[0]; S && (this.uppy.log(`[Tus] Resuming upload of ${i.id} started at ${S.creationTime}`), a.resumeFromPreviousUpload(S)) }), s = this.requests.run(o), this.onFileRemove(i.id, v => { s.abort(), this.resetUploaderReferences(i.id, { abort: !!a.url }), t(`upload ${v} was removed`) }), this.onPause(i.id, v => { s.abort(), v ? a.abort() : s = this.requests.run(o) }), this.onPauseAll(i.id, () => { s.abort(), a.abort() }), this.onCancelAll(i.id, function (v) { let { reason: S } = v === void 0 ? {} : v; S === "user" && (s.abort(), e.resetUploaderReferences(i.id, { abort: !!a.url })), t(`upload ${i.id} was canceled`) }), this.onResumeAll(i.id, () => { s.abort(), i.error && a.abort(), s = this.requests.run(o) }) }).catch(t => { throw this.uppy.emit("upload-error", i, t), t }) } n(Tx, "_upload2"); async function Cx(i) { let e = Yr(i), t = Qr(e); this.uppy.emit("upload-start", t), await Promise.allSettled(e.map((r, s) => { let o = s + 1, a = i.length; if (r.isRemote) { let l = new AbortController, h = n(d => { d.id === r.id && l.abort() }, "removedHandler"); this.uppy.on("file-removed", h), this.resetUploaderReferences(r.id); let c = this.uploadRemoteFile(r, { signal: l.signal }); return this.requests.wrapSyncFunction(() => { this.uppy.off("file-removed", h) }, { priority: -1 })(), c } return Js(this, yp)[yp](r, o, a) })) } n(Cx, "_uploadFiles2"); Ki.VERSION = Ax.version; var Eb = se(bp(), 1); var wi = Object.create(null); wi.open = "0"; wi.close = "1"; wi.ping = "2"; wi.pong = "3"; wi.message = "4"; wi.upgrade = "5"; wi.noop = "6"; var el = Object.create(null); Object.keys(wi).forEach(i => { el[wi[i]] = i }); var Z0 = { type: "error", data: "parser error" }; var kx = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", Ux = typeof ArrayBuffer == "function", Dx = n(i => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(i) : i && i.buffer instanceof ArrayBuffer, "isView"), Nx = n(({ type: i, data: e }, t, r) => kx && e instanceof Blob ? t ? r(e) : eb(e, r) : Ux && (e instanceof ArrayBuffer || Dx(e)) ? t ? r(e) : eb(new Blob([e]), r) : r(wi[i] + (e || "")), "encodePacket"), eb = n((i, e) => { let t = new FileReader; return t.onload = function () { let r = t.result.split(",")[1]; e("b" + r) }, t.readAsDataURL(i) }, "encodeBlobAsBase64"), ih = Nx; var tb = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", tl = typeof Uint8Array > "u" ? [] : new Uint8Array(256); for (let i = 0; i < tb.length; i++)tl[tb.charCodeAt(i)] = i; var ib = n(i => { let e = i.length * .75, t = i.length, r, s = 0, o, a, l, h; i[i.length - 1] === "=" && (e--, i[i.length - 2] === "=" && e--); let c = new ArrayBuffer(e), d = new Uint8Array(c); for (r = 0; r < t; r += 4)o = tl[i.charCodeAt(r)], a = tl[i.charCodeAt(r + 1)], l = tl[i.charCodeAt(r + 2)], h = tl[i.charCodeAt(r + 3)], d[s++] = o << 2 | a >> 4, d[s++] = (a & 15) << 4 | l >> 2, d[s++] = (l & 3) << 6 | h & 63; return c }, "decode"); var Ix = typeof ArrayBuffer == "function", Bx = n((i, e) => { if (typeof i != "string") return { type: "message", data: rb(i, e) }; let t = i.charAt(0); return t === "b" ? { type: "message", data: Lx(i.substring(1), e) } : el[t] ? i.length > 1 ? { type: el[t], data: i.substring(1) } : { type: el[t] } : Z0 }, "decodePacket"), Lx = n((i, e) => { if (Ix) { let t = ib(i); return rb(t, e) } else return { base64: !0, data: i } }, "decodeBase64Packet"), rb = n((i, e) => { switch (e) { case "blob": return i instanceof ArrayBuffer ? new Blob([i]) : i; case "arraybuffer": default: return i } }, "mapBinary"), rh = Bx; var sb = String.fromCharCode(30), ob = n((i, e) => { let t = i.length, r = new Array(t), s = 0; i.forEach((o, a) => { ih(o, !1, l => { r[a] = l, ++s === t && e(r.join(sb)) }) }) }, "encodePayload"), nb = n((i, e) => { let t = i.split(sb), r = []; for (let s = 0; s < t.length; s++) { let o = rh(t[s], e); if (r.push(o), o.type === "error") break } return r }, "decodePayload"), wp = 4; function ce(i) { if (i) return Mx(i) } n(ce, "Emitter"); function Mx(i) { for (var e in ce.prototype) i[e] = ce.prototype[e]; return i } n(Mx, "mixin"); ce.prototype.on = ce.prototype.addEventListener = function (i, e) { return this._callbacks = this._callbacks || {}, (this._callbacks["$" + i] = this._callbacks["$" + i] || []).push(e), this }; ce.prototype.once = function (i, e) { function t() { this.off(i, t), e.apply(this, arguments) } return n(t, "on"), t.fn = e, this.on(i, t), this }; ce.prototype.off = ce.prototype.removeListener = ce.prototype.removeAllListeners = ce.prototype.removeEventListener = function (i, e) { if (this._callbacks = this._callbacks || {}, arguments.length == 0) return this._callbacks = {}, this; var t = this._callbacks["$" + i]; if (!t) return this; if (arguments.length == 1) return delete this._callbacks["$" + i], this; for (var r, s = 0; s < t.length; s++)if (r = t[s], r === e || r.fn === e) { t.splice(s, 1); break } return t.length === 0 && delete this._callbacks["$" + i], this }; ce.prototype.emit = function (i) { this._callbacks = this._callbacks || {}; for (var e = new Array(arguments.length - 1), t = this._callbacks["$" + i], r = 1; r < arguments.length; r++)e[r - 1] = arguments[r]; if (t) { t = t.slice(0); for (var r = 0, s = t.length; r < s; ++r)t[r].apply(this, e) } return this }; ce.prototype.emitReserved = ce.prototype.emit; ce.prototype.listeners = function (i) { return this._callbacks = this._callbacks || {}, this._callbacks["$" + i] || [] }; ce.prototype.hasListeners = function (i) { return !!this.listeners(i).length }; var oi = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())(); function sh(i, ...e) { return e.reduce((t, r) => (i.hasOwnProperty(r) && (t[r] = i[r]), t), {}) } n(sh, "pick"); var zx = setTimeout, jx = clearTimeout; function Ar(i, e) { e.useNativeTimers ? (i.setTimeoutFn = zx.bind(oi), i.clearTimeoutFn = jx.bind(oi)) : (i.setTimeoutFn = setTimeout.bind(oi), i.clearTimeoutFn = clearTimeout.bind(oi)) } n(Ar, "installTimerFunctions"); var Hx = 1.33; function ab(i) { return typeof i == "string" ? qx(i) : Math.ceil((i.byteLength || i.size) * Hx) } n(ab, "byteLength"); function qx(i) { let e = 0, t = 0; for (let r = 0, s = i.length; r < s; r++)e = i.charCodeAt(r), e < 128 ? t += 1 : e < 2048 ? t += 2 : e < 55296 || e >= 57344 ? t += 3 : (r++, t += 4); return t } n(qx, "utf8Length"); var oh = class extends Error { constructor(e, t, r) { super(e), this.description = t, this.context = r, this.type = "TransportError" } }; n(oh, "TransportError"); var Zr = class extends ce { constructor(e) { super(), this.writable = !1, Ar(this, e), this.opts = e, this.query = e.query, this.readyState = "", this.socket = e.socket } onError(e, t, r) { return super.emitReserved("error", new oh(e, t, r)), this } open() { return (this.readyState === "closed" || this.readyState === "") && (this.readyState = "opening", this.doOpen()), this } close() { return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this } send(e) { this.readyState === "open" && this.write(e) } onOpen() { this.readyState = "open", this.writable = !0, super.emitReserved("open") } onData(e) { let t = rh(e, this.socket.binaryType); this.onPacket(t) } onPacket(e) { super.emitReserved("packet", e) } onClose(e) { this.readyState = "closed", super.emitReserved("close", e) } }; n(Zr, "Transport"); var cb = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), Sp = 64, $x = {}, lb = 0, nh = 0, ub; function hb(i) { let e = ""; do e = cb[i % Sp] + e, i = Math.floor(i / Sp); while (i > 0); return e } n(hb, "encode"); function ah() { let i = hb(+new Date); return i !== ub ? (lb = 0, ub = i) : i + "." + hb(lb++) } n(ah, "yeast"); for (; nh < Sp; nh++)$x[cb[nh]] = nh; function lh(i) { let e = ""; for (let t in i) i.hasOwnProperty(t) && (e.length && (e += "&"), e += encodeURIComponent(t) + "=" + encodeURIComponent(i[t])); return e } n(lh, "encode"); function db(i) { let e = {}, t = i.split("&"); for (let r = 0, s = t.length; r < s; r++) { let o = t[r].split("="); e[decodeURIComponent(o[0])] = decodeURIComponent(o[1]) } return e } n(db, "decode"); var pb = !1; try { pb = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest } catch { } var fb = pb; function Pp(i) { let e = i.xdomain; try { if (typeof XMLHttpRequest < "u" && (!e || fb)) return new XMLHttpRequest } catch { } if (!e) try { return new oi[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP") } catch { } } n(Pp, "XHR"); function Vx() { } n(Vx, "empty"); var Wx = function () { return new Pp({ xdomain: !1 }).responseType != null }(), il = class extends Zr { constructor(e) { if (super(e), this.polling = !1, typeof location < "u") { let r = location.protocol === "https:", s = location.port; s || (s = r ? "443" : "80"), this.xd = typeof location < "u" && e.hostname !== location.hostname || s !== e.port, this.xs = e.secure !== r } let t = e && e.forceBase64; this.supportsBinary = Wx && !t } get name() { return "polling" } doOpen() { this.poll() } pause(e) { this.readyState = "pausing"; let t = n(() => { this.readyState = "paused", e() }, "pause"); if (this.polling || !this.writable) { let r = 0; this.polling && (r++, this.once("pollComplete", function () { --r || t() })), this.writable || (r++, this.once("drain", function () { --r || t() })) } else t() } poll() { this.polling = !0, this.doPoll(), this.emitReserved("poll") } onData(e) { let t = n(r => { if (this.readyState === "opening" && r.type === "open" && this.onOpen(), r.type === "close") return this.onClose({ description: "transport closed by the server" }), !1; this.onPacket(r) }, "callback"); nb(e, this.socket.binaryType).forEach(t), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this.poll()) } doClose() { let e = n(() => { this.write([{ type: "close" }]) }, "close"); this.readyState === "open" ? e() : this.once("open", e) } write(e) { this.writable = !1, ob(e, t => { this.doWrite(t, () => { this.writable = !0, this.emitReserved("drain") }) }) } uri() { let e = this.query || {}, t = this.opts.secure ? "https" : "http", r = ""; this.opts.timestampRequests !== !1 && (e[this.opts.timestampParam] = ah()), !this.supportsBinary && !e.sid && (e.b64 = 1), this.opts.port && (t === "https" && Number(this.opts.port) !== 443 || t === "http" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port); let s = lh(e), o = this.opts.hostname.indexOf(":") !== -1; return t + "://" + (o ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (s.length ? "?" + s : "") } request(e = {}) { return Object.assign(e, { xd: this.xd, xs: this.xs }, this.opts), new Wt(this.uri(), e) } doWrite(e, t) { let r = this.request({ method: "POST", data: e }); r.on("success", t), r.on("error", (s, o) => { this.onError("xhr post error", s, o) }) } doPoll() { let e = this.request(); e.on("data", this.onData.bind(this)), e.on("error", (t, r) => { this.onError("xhr poll error", t, r) }), this.pollXhr = e } }; n(il, "Polling"); var Wt = class extends ce { constructor(e, t) { super(), Ar(this, t), this.opts = t, this.method = t.method || "GET", this.uri = e, this.async = t.async !== !1, this.data = t.data !== void 0 ? t.data : null, this.create() } create() { let e = sh(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref"); e.xdomain = !!this.opts.xd, e.xscheme = !!this.opts.xs; let t = this.xhr = new Pp(e); try { t.open(this.method, this.uri, this.async); try { if (this.opts.extraHeaders) { t.setDisableHeaderCheck && t.setDisableHeaderCheck(!0); for (let r in this.opts.extraHeaders) this.opts.extraHeaders.hasOwnProperty(r) && t.setRequestHeader(r, this.opts.extraHeaders[r]) } } catch { } if (this.method === "POST") try { t.setRequestHeader("Content-type", "text/plain;charset=UTF-8") } catch { } try { t.setRequestHeader("Accept", "*/*") } catch { } "withCredentials" in t && (t.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (t.timeout = this.opts.requestTimeout), t.onreadystatechange = () => { t.readyState === 4 && (t.status === 200 || t.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => { this.onError(typeof t.status == "number" ? t.status : 0) }, 0)) }, t.send(this.data) } catch (r) { this.setTimeoutFn(() => { this.onError(r) }, 0); return } typeof document < "u" && (this.index = Wt.requestsCount++, Wt.requests[this.index] = this) } onError(e) { this.emitReserved("error", e, this.xhr), this.cleanup(!0) } cleanup(e) { if (!(typeof this.xhr > "u" || this.xhr === null)) { if (this.xhr.onreadystatechange = Vx, e) try { this.xhr.abort() } catch { } typeof document < "u" && delete Wt.requests[this.index], this.xhr = null } } onLoad() { let e = this.xhr.responseText; e !== null && (this.emitReserved("data", e), this.emitReserved("success"), this.cleanup()) } abort() { this.cleanup() } }; n(Wt, "Request"); Wt.requestsCount = 0; Wt.requests = {}; if (typeof document < "u") { if (typeof attachEvent == "function") attachEvent("onunload", mb); else if (typeof addEventListener == "function") { let i = "onpagehide" in oi ? "pagehide" : "unload"; addEventListener(i, mb, !1) } } function mb() { for (let i in Wt.requests) Wt.requests.hasOwnProperty(i) && Wt.requests[i].abort() } n(mb, "unloadHandler"); var gb = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? e => Promise.resolve().then(e) : (e, t) => t(e, 0))(), rl = oi.WebSocket || oi.MozWebSocket, uh = !0, yb = "arraybuffer"; var vb = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative", sl = class extends Zr { constructor(e) { super(e), this.supportsBinary = !e.forceBase64 } get name() { return "websocket" } doOpen() { if (!this.check()) return; let e = this.uri(), t = this.opts.protocols, r = vb ? {} : sh(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity"); this.opts.extraHeaders && (r.headers = this.opts.extraHeaders); try { this.ws = uh && !vb ? t ? new rl(e, t) : new rl(e) : new rl(e, t, r) } catch (s) { return this.emitReserved("error", s) } this.ws.binaryType = this.socket.binaryType || yb, this.addEventListeners() } addEventListeners() { this.ws.onopen = () => { this.opts.autoUnref && this.ws._socket.unref(), this.onOpen() }, this.ws.onclose = e => this.onClose({ description: "websocket connection closed", context: e }), this.ws.onmessage = e => this.onData(e.data), this.ws.onerror = e => this.onError("websocket error", e) } write(e) { this.writable = !1; for (let t = 0; t < e.length; t++) { let r = e[t], s = t === e.length - 1; ih(r, this.supportsBinary, o => { let a = {}; uh || (r.options && (a.compress = r.options.compress), this.opts.perMessageDeflate && (typeof o == "string" ? Buffer.byteLength(o) : o.length) < this.opts.perMessageDeflate.threshold && (a.compress = !1)); try { uh ? this.ws.send(o) : this.ws.send(o, a) } catch { } s && gb(() => { this.writable = !0, this.emitReserved("drain") }, this.setTimeoutFn) }) } } doClose() { typeof this.ws < "u" && (this.ws.close(), this.ws = null) } uri() { let e = this.query || {}, t = this.opts.secure ? "wss" : "ws", r = ""; this.opts.port && (t === "wss" && Number(this.opts.port) !== 443 || t === "ws" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port), this.opts.timestampRequests && (e[this.opts.timestampParam] = ah()), this.supportsBinary || (e.b64 = 1); let s = lh(e), o = this.opts.hostname.indexOf(":") !== -1; return t + "://" + (o ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (s.length ? "?" + s : "") } check() { return !!rl } }; n(sl, "WS"); var _p = { websocket: sl, polling: il }; var Kx = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, Gx = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"]; function rn(i) { let e = i, t = i.indexOf("["), r = i.indexOf("]"); t != -1 && r != -1 && (i = i.substring(0, t) + i.substring(t, r).replace(/:/g, ";") + i.substring(r, i.length)); let s = Kx.exec(i || ""), o = {}, a = 14; for (; a--;)o[Gx[a]] = s[a] || ""; return t != -1 && r != -1 && (o.source = e, o.host = o.host.substring(1, o.host.length - 1).replace(/;/g, ":"), o.authority = o.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), o.ipv6uri = !0), o.pathNames = Xx(o, o.path), o.queryKey = Yx(o, o.query), o } n(rn, "parse"); function Xx(i, e) { let t = /\/{2,9}/g, r = e.replace(t, "/").split("/"); return (e.substr(0, 1) == "/" || e.length === 0) && r.splice(0, 1), e.substr(e.length - 1, 1) == "/" && r.splice(r.length - 1, 1), r } n(Xx, "pathNames"); function Yx(i, e) { let t = {}; return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (r, s, o) { s && (t[s] = o) }), t } n(Yx, "queryKey"); var Tt = class extends ce { constructor(e, t = {}) { super(), e && typeof e == "object" && (t = e, e = null), e ? (e = rn(e), t.hostname = e.host, t.secure = e.protocol === "https" || e.protocol === "wss", t.port = e.port, e.query && (t.query = e.query)) : t.host && (t.hostname = rn(t.host).host), Ar(this, t), this.secure = t.secure != null ? t.secure : typeof location < "u" && location.protocol === "https:", t.hostname && !t.port && (t.port = this.secure ? "443" : "80"), this.hostname = t.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = t.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = t.transports || ["polling", "websocket"], this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({ path: "/engine.io", agent: !1, withCredentials: !1, upgrade: !0, timestampParam: "t", rememberUpgrade: !1, rejectUnauthorized: !0, perMessageDeflate: { threshold: 1024 }, transportOptions: {}, closeOnBeforeunload: !0 }, t), this.opts.path = this.opts.path.replace(/\/$/, "") + "/", typeof this.opts.query == "string" && (this.opts.query = db(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && addEventListener("beforeunload", () => { this.transport && (this.transport.removeAllListeners(), this.transport.close()) }, !1), this.hostname !== "localhost" && (this.offlineEventListener = () => { this.onClose("transport close", { description: "network connection lost" }) }, addEventListener("offline", this.offlineEventListener, !1))), this.open() } createTransport(e) { let t = Object.assign({}, this.opts.query); t.EIO = wp, t.transport = e, this.id && (t.sid = this.id); let r = Object.assign({}, this.opts.transportOptions[e], this.opts, { query: t, socket: this, hostname: this.hostname, secure: this.secure, port: this.port }); return new _p[e](r) } open() { let e; if (this.opts.rememberUpgrade && Tt.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) e = "websocket"; else if (this.transports.length === 0) { this.setTimeoutFn(() => { this.emitReserved("error", "No transports available") }, 0); return } else e = this.transports[0]; this.readyState = "opening"; try { e = this.createTransport(e) } catch { this.transports.shift(), this.open(); return } e.open(), this.setTransport(e) } setTransport(e) { this.transport && this.transport.removeAllListeners(), this.transport = e, e.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", t => this.onClose("transport close", t)) } probe(e) { let t = this.createTransport(e), r = !1; Tt.priorWebsocketSuccess = !1; let s = n(() => { r || (t.send([{ type: "ping", data: "probe" }]), t.once("packet", p => { if (!r) if (p.type === "pong" && p.data === "probe") { if (this.upgrading = !0, this.emitReserved("upgrading", t), !t) return; Tt.priorWebsocketSuccess = t.name === "websocket", this.transport.pause(() => { r || this.readyState !== "closed" && (d(), this.setTransport(t), t.send([{ type: "upgrade" }]), this.emitReserved("upgrade", t), t = null, this.upgrading = !1, this.flush()) }) } else { let y = new Error("probe error"); y.transport = t.name, this.emitReserved("upgradeError", y) } })) }, "onTransportOpen"); function o() { r || (r = !0, d(), t.close(), t = null) } n(o, "freezeTransport"); let a = n(p => { let y = new Error("probe error: " + p); y.transport = t.name, o(), this.emitReserved("upgradeError", y) }, "onerror"); function l() { a("transport closed") } n(l, "onTransportClose"); function h() { a("socket closed") } n(h, "onclose"); function c(p) { t && p.name !== t.name && o() } n(c, "onupgrade"); let d = n(() => { t.removeListener("open", s), t.removeListener("error", a), t.removeListener("close", l), this.off("close", h), this.off("upgrading", c) }, "cleanup"); t.once("open", s), t.once("error", a), t.once("close", l), this.once("close", h), this.once("upgrading", c), t.open() } onOpen() { if (this.readyState = "open", Tt.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade && this.transport.pause) { let e = 0, t = this.upgrades.length; for (; e < t; e++)this.probe(this.upgrades[e]) } } onPacket(e) { if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") switch (this.emitReserved("packet", e), this.emitReserved("heartbeat"), e.type) { case "open": this.onHandshake(JSON.parse(e.data)); break; case "ping": this.resetPingTimeout(), this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"); break; case "error": let t = new Error("server error"); t.code = e.data, this.onError(t); break; case "message": this.emitReserved("data", e.data), this.emitReserved("message", e.data); break } } onHandshake(e) { this.emitReserved("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this.upgrades = this.filterUpgrades(e.upgrades), this.pingInterval = e.pingInterval, this.pingTimeout = e.pingTimeout, this.maxPayload = e.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout() } resetPingTimeout() { this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => { this.onClose("ping timeout") }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref() } onDrain() { this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush() } flush() { if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) { let e = this.getWritablePackets(); this.transport.send(e), this.prevBufferLen = e.length, this.emitReserved("flush") } } getWritablePackets() { if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1)) return this.writeBuffer; let t = 1; for (let r = 0; r < this.writeBuffer.length; r++) { let s = this.writeBuffer[r].data; if (s && (t += ab(s)), r > 0 && t > this.maxPayload) return this.writeBuffer.slice(0, r); t += 2 } return this.writeBuffer } write(e, t, r) { return this.sendPacket("message", e, t, r), this } send(e, t, r) { return this.sendPacket("message", e, t, r), this } sendPacket(e, t, r, s) { if (typeof t == "function" && (s = t, t = void 0), typeof r == "function" && (s = r, r = null), this.readyState === "closing" || this.readyState === "closed") return; r = r || {}, r.compress = r.compress !== !1; let o = { type: e, data: t, options: r }; this.emitReserved("packetCreate", o), this.writeBuffer.push(o), s && this.once("flush", s), this.flush() } close() { let e = n(() => { this.onClose("forced close"), this.transport.close() }, "close"), t = n(() => { this.off("upgrade", t), this.off("upgradeError", t), e() }, "cleanupAndClose"), r = n(() => { this.once("upgrade", t), this.once("upgradeError", t) }, "waitForUpgrade"); return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => { this.upgrading ? r() : e() }) : this.upgrading ? r() : e()), this } onError(e) { Tt.priorWebsocketSuccess = !1, this.emitReserved("error", e), this.onClose("transport error", e) } onClose(e, t) { (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && removeEventListener("offline", this.offlineEventListener, !1), this.readyState = "closed", this.id = null, this.emitReserved("close", e, t), this.writeBuffer = [], this.prevBufferLen = 0) } filterUpgrades(e) { let t = [], r = 0, s = e.length; for (; r < s; r++)~this.transports.indexOf(e[r]) && t.push(e[r]); return t } }; n(Tt, "Socket"); Tt.protocol = wp; var hL = Tt.protocol; function bb(i, e = "", t) { let r = i; t = t || typeof location < "u" && location, i == null && (i = t.protocol + "//" + t.host), typeof i == "string" && (i.charAt(0) === "/" && (i.charAt(1) === "/" ? i = t.protocol + i : i = t.host + i), /^(https?|wss?):\/\//.test(i) || (typeof t < "u" ? i = t.protocol + "//" + i : i = "https://" + i), r = rn(i)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/"; let o = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host; return r.id = r.protocol + "://" + o + ":" + r.port + e, r.href = r.protocol + "://" + o + (t && t.port === r.port ? "" : ":" + r.port), r } n(bb, "url"); var Fp = {}; cn(Fp, { Decoder: () => sn, Encoder: () => hh, PacketType: () => te, protocol: () => _b }); var Qx = typeof ArrayBuffer == "function", Jx = n(i => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(i) : i.buffer instanceof ArrayBuffer, "isView"), wb = Object.prototype.toString, Zx = typeof Blob == "function" || typeof Blob < "u" && wb.call(Blob) === "[object BlobConstructor]", eE = typeof File == "function" || typeof File < "u" && wb.call(File) === "[object FileConstructor]"; function nl(i) { return Qx && (i instanceof ArrayBuffer || Jx(i)) || Zx && i instanceof Blob || eE && i instanceof File } n(nl, "isBinary"); function ol(i, e) { if (!i || typeof i != "object") return !1; if (Array.isArray(i)) { for (let t = 0, r = i.length; t < r; t++)if (ol(i[t])) return !0; return !1 } if (nl(i)) return !0; if (i.toJSON && typeof i.toJSON == "function" && arguments.length === 1) return ol(i.toJSON(), !0); for (let t in i) if (Object.prototype.hasOwnProperty.call(i, t) && ol(i[t])) return !0; return !1 } n(ol, "hasBinary"); function Sb(i) { let e = [], t = i.data, r = i; return r.data = xp(t, e), r.attachments = e.length, { packet: r, buffers: e } } n(Sb, "deconstructPacket"); function xp(i, e) { if (!i) return i; if (nl(i)) { let t = { _placeholder: !0, num: e.length }; return e.push(i), t } else if (Array.isArray(i)) { let t = new Array(i.length); for (let r = 0; r < i.length; r++)t[r] = xp(i[r], e); return t } else if (typeof i == "object" && !(i instanceof Date)) { let t = {}; for (let r in i) Object.prototype.hasOwnProperty.call(i, r) && (t[r] = xp(i[r], e)); return t } return i } n(xp, "_deconstructPacket"); function Pb(i, e) { return i.data = Ep(i.data, e), i.attachments = void 0, i } n(Pb, "reconstructPacket"); function Ep(i, e) { if (!i) return i; if (i && i._placeholder === !0) { if (typeof i.num == "number" && i.num >= 0 && i.num < e.length) return e[i.num]; throw new Error("illegal attachments") } else if (Array.isArray(i)) for (let t = 0; t < i.length; t++)i[t] = Ep(i[t], e); else if (typeof i == "object") for (let t in i) Object.prototype.hasOwnProperty.call(i, t) && (i[t] = Ep(i[t], e)); return i } n(Ep, "_reconstructPacket"); var _b = 5, te; (function (i) { i[i.CONNECT = 0] = "CONNECT", i[i.DISCONNECT = 1] = "DISCONNECT", i[i.EVENT = 2] = "EVENT", i[i.ACK = 3] = "ACK", i[i.CONNECT_ERROR = 4] = "CONNECT_ERROR", i[i.BINARY_EVENT = 5] = "BINARY_EVENT", i[i.BINARY_ACK = 6] = "BINARY_ACK" })(te || (te = {})); var hh = class { constructor(e) { this.replacer = e } encode(e) { return (e.type === te.EVENT || e.type === te.ACK) && ol(e) ? (e.type = e.type === te.EVENT ? te.BINARY_EVENT : te.BINARY_ACK, this.encodeAsBinary(e)) : [this.encodeAsString(e)] } encodeAsString(e) { let t = "" + e.type; return (e.type === te.BINARY_EVENT || e.type === te.BINARY_ACK) && (t += e.attachments + "-"), e.nsp && e.nsp !== "/" && (t += e.nsp + ","), e.id != null && (t += e.id), e.data != null && (t += JSON.stringify(e.data, this.replacer)), t } encodeAsBinary(e) { let t = Sb(e), r = this.encodeAsString(t.packet), s = t.buffers; return s.unshift(r), s } }; n(hh, "Encoder"); var sn = class extends ce { constructor(e) { super(), this.reviver = e } add(e) { let t; if (typeof e == "string") { if (this.reconstructor) throw new Error("got plaintext data when reconstructing a packet"); t = this.decodeString(e), t.type === te.BINARY_EVENT || t.type === te.BINARY_ACK ? (this.reconstructor = new ch(t), t.attachments === 0 && super.emitReserved("decoded", t)) : super.emitReserved("decoded", t) } else if (nl(e) || e.base64) if (this.reconstructor) t = this.reconstructor.takeBinaryData(e), t && (this.reconstructor = null, super.emitReserved("decoded", t)); else throw new Error("got binary data when not reconstructing a packet"); else throw new Error("Unknown type: " + e) } decodeString(e) { let t = 0, r = { type: Number(e.charAt(0)) }; if (te[r.type] === void 0) throw new Error("unknown packet type " + r.type); if (r.type === te.BINARY_EVENT || r.type === te.BINARY_ACK) { let o = t + 1; for (; e.charAt(++t) !== "-" && t != e.length;); let a = e.substring(o, t); if (a != Number(a) || e.charAt(t) !== "-") throw new Error("Illegal attachments"); r.attachments = Number(a) } if (e.charAt(t + 1) === "/") { let o = t + 1; for (; ++t && !(e.charAt(t) === "," || t === e.length);); r.nsp = e.substring(o, t) } else r.nsp = "/"; let s = e.charAt(t + 1); if (s !== "" && Number(s) == s) { let o = t + 1; for (; ++t;) { let a = e.charAt(t); if (a == null || Number(a) != a) { --t; break } if (t === e.length) break } r.id = Number(e.substring(o, t + 1)) } if (e.charAt(++t)) { let o = this.tryParse(e.substr(t)); if (sn.isPayloadValid(r.type, o)) r.data = o; else throw new Error("invalid payload") } return r } tryParse(e) { try { return JSON.parse(e, this.reviver) } catch { return !1 } } static isPayloadValid(e, t) { switch (e) { case te.CONNECT: return typeof t == "object"; case te.DISCONNECT: return t === void 0; case te.CONNECT_ERROR: return typeof t == "string" || typeof t == "object"; case te.EVENT: case te.BINARY_EVENT: return Array.isArray(t) && t.length > 0; case te.ACK: case te.BINARY_ACK: return Array.isArray(t) } } destroy() { this.reconstructor && this.reconstructor.finishedReconstruction() } }; n(sn, "Decoder"); var ch = class { constructor(e) { this.packet = e, this.buffers = [], this.reconPack = e } takeBinaryData(e) { if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) { let t = Pb(this.reconPack, this.buffers); return this.finishedReconstruction(), t } return null } finishedReconstruction() { this.reconPack = null, this.buffers = [] } }; n(ch, "BinaryReconstructor"); function Kt(i, e, t) { return i.on(e, t), n(function () { i.off(e, t) }, "subDestroy") } n(Kt, "on"); var tE = Object.freeze({ connect: 1, connect_error: 1, disconnect: 1, disconnecting: 1, newListener: 1, removeListener: 1 }), Zs = class extends ce { constructor(e, t, r) { super(), this.connected = !1, this.receiveBuffer = [], this.sendBuffer = [], this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = t, r && r.auth && (this.auth = r.auth), this.io._autoConnect && this.open() } get disconnected() { return !this.connected } subEvents() { if (this.subs) return; let e = this.io; this.subs = [Kt(e, "open", this.onopen.bind(this)), Kt(e, "packet", this.onpacket.bind(this)), Kt(e, "error", this.onerror.bind(this)), Kt(e, "close", this.onclose.bind(this))] } get active() { return !!this.subs } connect() { return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this) } open() { return this.connect() } send(...e) { return e.unshift("message"), this.emit.apply(this, e), this } emit(e, ...t) { if (tE.hasOwnProperty(e)) throw new Error('"' + e + '" is a reserved event name'); t.unshift(e); let r = { type: te.EVENT, data: t }; if (r.options = {}, r.options.compress = this.flags.compress !== !1, typeof t[t.length - 1] == "function") { let a = this.ids++, l = t.pop(); this._registerAckCallback(a, l), r.id = a } let s = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable; return this.flags.volatile && (!s || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r)), this.flags = {}, this } _registerAckCallback(e, t) { let r = this.flags.timeout; if (r === void 0) { this.acks[e] = t; return } let s = this.io.setTimeoutFn(() => { delete this.acks[e]; for (let o = 0; o < this.sendBuffer.length; o++)this.sendBuffer[o].id === e && this.sendBuffer.splice(o, 1); t.call(this, new Error("operation has timed out")) }, r); this.acks[e] = (...o) => { this.io.clearTimeoutFn(s), t.apply(this, [null, ...o]) } } packet(e) { e.nsp = this.nsp, this.io._packet(e) } onopen() { typeof this.auth == "function" ? this.auth(e => { this.packet({ type: te.CONNECT, data: e }) }) : this.packet({ type: te.CONNECT, data: this.auth }) } onerror(e) { this.connected || this.emitReserved("connect_error", e) } onclose(e, t) { this.connected = !1, delete this.id, this.emitReserved("disconnect", e, t) } onpacket(e) { if (e.nsp === this.nsp) switch (e.type) { case te.CONNECT: if (e.data && e.data.sid) { let s = e.data.sid; this.onconnect(s) } else this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)")); break; case te.EVENT: case te.BINARY_EVENT: this.onevent(e); break; case te.ACK: case te.BINARY_ACK: this.onack(e); break; case te.DISCONNECT: this.ondisconnect(); break; case te.CONNECT_ERROR: this.destroy(); let r = new Error(e.data.message); r.data = e.data.data, this.emitReserved("connect_error", r); break } } onevent(e) { let t = e.data || []; e.id != null && t.push(this.ack(e.id)), this.connected ? this.emitEvent(t) : this.receiveBuffer.push(Object.freeze(t)) } emitEvent(e) { if (this._anyListeners && this._anyListeners.length) { let t = this._anyListeners.slice(); for (let r of t) r.apply(this, e) } super.emit.apply(this, e) } ack(e) { let t = this, r = !1; return function (...s) { r || (r = !0, t.packet({ type: te.ACK, id: e, data: s })) } } onack(e) { let t = this.acks[e.id]; typeof t == "function" && (t.apply(this, e.data), delete this.acks[e.id]) } onconnect(e) { this.id = e, this.connected = !0, this.emitBuffered(), this.emitReserved("connect") } emitBuffered() { this.receiveBuffer.forEach(e => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach(e => { this.notifyOutgoingListeners(e), this.packet(e) }), this.sendBuffer = [] } ondisconnect() { this.destroy(), this.onclose("io server disconnect") } destroy() { this.subs && (this.subs.forEach(e => e()), this.subs = void 0), this.io._destroy(this) } disconnect() { return this.connected && this.packet({ type: te.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this } close() { return this.disconnect() } compress(e) { return this.flags.compress = e, this } get volatile() { return this.flags.volatile = !0, this } timeout(e) { return this.flags.timeout = e, this } onAny(e) { return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this } prependAny(e) { return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this } offAny(e) { if (!this._anyListeners) return this; if (e) { let t = this._anyListeners; for (let r = 0; r < t.length; r++)if (e === t[r]) return t.splice(r, 1), this } else this._anyListeners = []; return this } listenersAny() { return this._anyListeners || [] } onAnyOutgoing(e) { return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this } prependAnyOutgoing(e) { return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this } offAnyOutgoing(e) { if (!this._anyOutgoingListeners) return this; if (e) { let t = this._anyOutgoingListeners; for (let r = 0; r < t.length; r++)if (e === t[r]) return t.splice(r, 1), this } else this._anyOutgoingListeners = []; return this } listenersAnyOutgoing() { return this._anyOutgoingListeners || [] } notifyOutgoingListeners(e) { if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) { let t = this._anyOutgoingListeners.slice(); for (let r of t) r.apply(this, e.data) } } }; n(Zs, "Socket"); function eo(i) { i = i || {}, this.ms = i.min || 100, this.max = i.max || 1e4, this.factor = i.factor || 2, this.jitter = i.jitter > 0 && i.jitter <= 1 ? i.jitter : 0, this.attempts = 0 } n(eo, "Backoff"); eo.prototype.duration = function () { var i = this.ms * Math.pow(this.factor, this.attempts++); if (this.jitter) { var e = Math.random(), t = Math.floor(e * this.jitter * i); i = Math.floor(e * 10) & 1 ? i + t : i - t } return Math.min(i, this.max) | 0 }; eo.prototype.reset = function () { this.attempts = 0 }; eo.prototype.setMin = function (i) { this.ms = i }; eo.prototype.setMax = function (i) { this.max = i }; eo.prototype.setJitter = function (i) { this.jitter = i }; var to = class extends ce { constructor(e, t) { var r; super(), this.nsps = {}, this.subs = [], e && typeof e == "object" && (t = e, e = void 0), t = t || {}, t.path = t.path || "/socket.io", this.opts = t, Ar(this, t), this.reconnection(t.reconnection !== !1), this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0), this.reconnectionDelay(t.reconnectionDelay || 1e3), this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3), this.randomizationFactor((r = t.randomizationFactor) !== null && r !== void 0 ? r : .5), this.backoff = new eo({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }), this.timeout(t.timeout == null ? 2e4 : t.timeout), this._readyState = "closed", this.uri = e; let s = t.parser || Fp; this.encoder = new s.Encoder, this.decoder = new s.Decoder, this._autoConnect = t.autoConnect !== !1, this._autoConnect && this.open() } reconnection(e) { return arguments.length ? (this._reconnection = !!e, this) : this._reconnection } reconnectionAttempts(e) { return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this) } reconnectionDelay(e) { var t; return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (t = this.backoff) === null || t === void 0 || t.setMin(e), this) } randomizationFactor(e) { var t; return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (t = this.backoff) === null || t === void 0 || t.setJitter(e), this) } reconnectionDelayMax(e) { var t; return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (t = this.backoff) === null || t === void 0 || t.setMax(e), this) } timeout(e) { return arguments.length ? (this._timeout = e, this) : this._timeout } maybeReconnectOnOpen() { !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect() } open(e) { if (~this._readyState.indexOf("open")) return this; this.engine = new Tt(this.uri, this.opts); let t = this.engine, r = this; this._readyState = "opening", this.skipReconnect = !1; let s = Kt(t, "open", function () { r.onopen(), e && e() }), o = Kt(t, "error", a => { r.cleanup(), r._readyState = "closed", this.emitReserved("error", a), e ? e(a) : r.maybeReconnectOnOpen() }); if (this._timeout !== !1) { let a = this._timeout; a === 0 && s(); let l = this.setTimeoutFn(() => { s(), t.close(), t.emit("error", new Error("timeout")) }, a); this.opts.autoUnref && l.unref(), this.subs.push(n(function () { clearTimeout(l) }, "subDestroy")) } return this.subs.push(s), this.subs.push(o), this } connect(e) { return this.open(e) } onopen() { this.cleanup(), this._readyState = "open", this.emitReserved("open"); let e = this.engine; this.subs.push(Kt(e, "ping", this.onping.bind(this)), Kt(e, "data", this.ondata.bind(this)), Kt(e, "error", this.onerror.bind(this)), Kt(e, "close", this.onclose.bind(this)), Kt(this.decoder, "decoded", this.ondecoded.bind(this))) } onping() { this.emitReserved("ping") } ondata(e) { this.decoder.add(e) } ondecoded(e) { this.emitReserved("packet", e) } onerror(e) { this.emitReserved("error", e) } socket(e, t) { let r = this.nsps[e]; return r || (r = new Zs(this, e, t), this.nsps[e] = r), r } _destroy(e) { let t = Object.keys(this.nsps); for (let r of t) if (this.nsps[r].active) return; this._close() } _packet(e) { let t = this.encoder.encode(e); for (let r = 0; r < t.length; r++)this.engine.write(t[r], e.options) } cleanup() { this.subs.forEach(e => e()), this.subs.length = 0, this.decoder.destroy() } _close() { this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close() } disconnect() { return this._close() } onclose(e, t) { this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e, t), this._reconnection && !this.skipReconnect && this.reconnect() } reconnect() { if (this._reconnecting || this.skipReconnect) return this; let e = this; if (this.backoff.attempts >= this._reconnectionAttempts) this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1; else { let t = this.backoff.duration(); this._reconnecting = !0; let r = this.setTimeoutFn(() => { e.skipReconnect || (this.emitReserved("reconnect_attempt", e.backoff.attempts), !e.skipReconnect && e.open(s => { s ? (e._reconnecting = !1, e.reconnect(), this.emitReserved("reconnect_error", s)) : e.onreconnect() })) }, t); this.opts.autoUnref && r.unref(), this.subs.push(n(function () { clearTimeout(r) }, "subDestroy")) } } onreconnect() { let e = this.backoff.attempts; this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", e) } }; n(to, "Manager"); var al = {}; function ll(i, e) { typeof i == "object" && (e = i, i = void 0), e = e || {}; let t = bb(i, e.path || "/socket.io"), r = t.source, s = t.id, o = t.path, a = al[s] && o in al[s].nsps, l = e.forceNew || e["force new connection"] || e.multiplex === !1 || a, h; return l ? h = new to(r, e) : (al[s] || (al[s] = new to(r, e)), h = al[s]), t.query && !e.query && (e.query = t.queryKey), h.socket(t.path, e) } n(ll, "lookup"); Object.assign(ll, { Manager: to, Socket: Zs, io: ll, connect: ll }); function Op(i) { let e = /^\w+:\/\//.exec(i), t = 0; e && (t = e[0].length + 1); let r = i.indexOf("/", t); return r === -1 ? { origin: i, pathname: "/" } : { origin: i.slice(0, r), pathname: i.slice(r) } } n(Op, "parseUrl"); function ie(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(ie, "_classPrivateFieldLooseBase"); var iE = 0; function Si(i) { return "__private_" + iE++ + "_" + i } n(Si, "_classPrivateFieldLooseKey"); var rE = "ASSEMBLY_UPLOADING", kp = "ASSEMBLY_EXECUTING", Up = "ASSEMBLY_COMPLETED", xb = [rE, kp, Up]; function dh(i, e) { return xb.indexOf(i) >= xb.indexOf(e) } n(dh, "isStatus"); var ro = Si("rateLimitedQueue"), ul = Si("fetchWithNetworkError"), io = Si("previousFetchStatusStillPending"), He = Si("sse"), hl = Si("onFinished"), Ap = Si("connectServerSentEvents"), Tp = Si("connectSocket"), Gt = Si("onError"), Cp = Si("beginPolling"), Xt = Si("fetchStatus"), Rp = Si("diffStatus"), ph = class extends Eb.default { constructor(e, t) { super(), Object.defineProperty(this, Rp, { value: hE }), Object.defineProperty(this, Xt, { value: uE }), Object.defineProperty(this, Cp, { value: lE }), Object.defineProperty(this, Gt, { value: aE }), Object.defineProperty(this, Tp, { value: nE }), Object.defineProperty(this, Ap, { value: oE }), Object.defineProperty(this, hl, { value: sE }), Object.defineProperty(this, ro, { writable: !0, value: void 0 }), Object.defineProperty(this, ul, { writable: !0, value: void 0 }), Object.defineProperty(this, io, { writable: !0, value: !1 }), Object.defineProperty(this, He, { writable: !0, value: void 0 }), this.status = e, this.socket = null, this.pollInterval = null, this.closed = !1, ie(this, ro)[ro] = t, ie(this, ul)[ul] = t.wrapPromiseFunction(ps) } connect() { ie(this, Ap)[Ap](), ie(this, Tp)[Tp](), ie(this, Cp)[Cp]() } update() { return ie(this, Xt)[Xt]({ diff: !0 }) } updateStatus(e) { ie(this, Rp)[Rp](this.status, e), this.status = e } close() { this.closed = !0, ie(this, He)[He] && (ie(this, He)[He].close(), ie(this, He)[He] = null), this.socket && (this.socket.disconnect(), this.socket = null), clearInterval(this.pollInterval), this.pollInterval = null } }; n(ph, "TransloaditAssembly"); function sE() { this.emit("finished"), this.close() } n(sE, "_onFinished2"); function oE() { ie(this, He)[He] = new EventSource(`${this.status.websocket_url}?assembly=${this.status.assembly_id}`), ie(this, He)[He].addEventListener("open", () => { this.socket && (this.socket.disconnect(), this.socket = null), clearInterval(this.pollInterval), this.pollInterval = null }), ie(this, He)[He].addEventListener("message", i => { i.data === "assembly_finished" && ie(this, hl)[hl](), i.data === "assembly_uploading_finished" && this.emit("executing"), i.data === "assembly_upload_meta_data_extracted" && (this.emit("metadata"), ie(this, Xt)[Xt]({ diff: !1 })) }), ie(this, He)[He].addEventListener("assembly_upload_finished", i => { let e = JSON.parse(i.data); this.emit("upload", e), this.status.uploads.push(e) }), ie(this, He)[He].addEventListener("assembly_result_finished", i => { var e, t; let [r, s] = JSON.parse(i.data); this.emit("result", r, s), ((t = (e = this.status.results)[r]) != null ? t : e[r] = []).push(s) }), ie(this, He)[He].addEventListener("assembly_error", i => { try { ie(this, Gt)[Gt](JSON.parse(i.data)) } catch { ie(this, Gt)[Gt]({ msg: i.data }) } ie(this, Xt)[Xt]({ diff: !1 }) }) } n(oE, "_connectServerSentEvents2"); function nE() { let i = Op(this.status.websocket_url), e = ll(i.origin, { transports: ["websocket"], path: i.pathname }); e.on("connect", () => { e.emit("assembly_connect", { id: this.status.assembly_id }), this.emit("connect") }), e.on("connect_error", () => { e.disconnect(), this.socket = null }), e.on("assembly_finished", () => { ie(this, hl)[hl]() }), e.on("assembly_upload_finished", t => { this.emit("upload", t), this.status.uploads.push(t) }), e.on("assembly_uploading_finished", () => { this.emit("executing") }), e.on("assembly_upload_meta_data_extracted", () => { this.emit("metadata"), ie(this, Xt)[Xt]({ diff: !1 }) }), e.on("assembly_result_finished", (t, r) => { var s, o; this.emit("result", t, r), ((o = (s = this.status.results)[t]) != null ? o : s[t] = []).push(r) }), e.on("assembly_error", t => { ie(this, Xt)[Xt]({ diff: !1 }), ie(this, Gt)[Gt](t) }), this.socket = e } n(nE, "_connectSocket2"); function aE(i) { this.emit("error", Object.assign(new Error(i.msg), i)), this.close() } n(aE, "_onError2"); function lE() { this.pollInterval = setInterval(() => { (!this.socket || !this.socket.connected) && ie(this, Xt)[Xt]() }, 2e3) } n(lE, "_beginPolling2"); async function uE(i) { let { diff: e = !0 } = i === void 0 ? {} : i; if (!(this.closed || ie(this, ro)[ro].isPaused || ie(this, io)[io])) try { ie(this, io)[io] = !0; let t = await ie(this, ul)[ul](this.status.assembly_ssl_url); if (ie(this, io)[io] = !1, this.closed) return; if (t.status === 429) { ie(this, ro)[ro].rateLimit(2e3); return } if (!t.ok) { ie(this, Gt)[Gt](new hi(t.statusText)); return } let r = await t.json(); if (this.closed) return; this.emit("status", r), e ? this.updateStatus(r) : this.status = r } catch (t) { ie(this, Gt)[Gt](t) } } n(uE, "_fetchStatus2"); function hE(i, e) { let t = i.ok, r = e.ok; if (e.error && !i.error) return ie(this, Gt)[Gt](e); let s = dh(r, kp) && !dh(t, kp); s && this.emit("executing"), Object.keys(e.uploads).filter(o => !ht(i.uploads, o)).forEach(o => { this.emit("upload", e.uploads[o]) }), s && this.emit("metadata"), Object.keys(e.results).forEach(o => { let a = e.results[o], l = i.results[o]; a.filter(h => !l || !l.some(c => c.id === h.id)).forEach(h => { this.emit("result", o, h) }) }), dh(r, Up) && !dh(t, Up) && this.emit("finished") } n(hE, "_diffStatus2"); var Dp = ph; function Se(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Se, "_classPrivateFieldLooseBase"); var cE = 0; function fh(i) { return "__private_" + cE++ + "_" + i } n(fh, "_classPrivateFieldLooseKey"); var Fb = "/assemblies", wt = fh("headers"), cl = fh("fetchWithNetworkError"), it = fh("fetchJSON"), Yt = fh("reportError"), on = class { constructor(e) { e === void 0 && (e = {}), Object.defineProperty(this, it, { value: dE }), Object.defineProperty(this, wt, { writable: !0, value: {} }), Object.defineProperty(this, cl, { writable: !0, value: void 0 }), Object.defineProperty(this, Yt, { writable: !0, value: (t, r) => { if (this.opts.errorReporting === !1) throw t; let s = { type: r.type }; throw r.assembly && (s.assembly = r.assembly.assembly_id, s.instance = r.assembly.instance), r.url && (s.endpoint = r.url), this.submitError(t, s).catch(() => { }), t } }), this.opts = e, this.opts.client != null && (Se(this, wt)[wt]["Transloadit-Client"] = this.opts.client), Se(this, cl)[cl] = this.opts.rateLimitedQueue.wrapPromiseFunction(ps) } createAssembly(e) { let { params: t, fields: r, signature: s, expectedFiles: o } = e, a = new FormData; a.append("params", typeof t == "string" ? t : JSON.stringify(t)), s && a.append("signature", s), Object.keys(r).forEach(h => { a.append(h, r[h]) }), a.append("num_expected_upload_files", o); let l = new URL(Fb, `${this.opts.service}`).href; return Se(this, it)[it](l, { method: "POST", headers: Se(this, wt)[wt], body: a }).catch(h => Se(this, Yt)[Yt](h, { url: l, type: "API_ERROR" })) } reserveFile(e, t) { let r = encodeURIComponent(t.size), s = `${e.assembly_ssl_url}/reserve_file?size=${r}`; return Se(this, it)[it](s, { method: "POST", headers: Se(this, wt)[wt] }).catch(o => Se(this, Yt)[Yt](o, { assembly: e, file: t, url: s, type: "API_ERROR" })) } addFile(e, t) { if (!t.uploadURL) return Promise.reject(new Error("File does not have an `uploadURL`.")); let r = encodeURIComponent(t.size), s = encodeURIComponent(t.uploadURL), o = encodeURIComponent(t.name), l = `size=${r}&filename=${o}&fieldname=file&s3Url=${s}`, h = `${e.assembly_ssl_url}/add_file?${l}`; return Se(this, it)[it](h, { method: "POST", headers: Se(this, wt)[wt] }).catch(c => Se(this, Yt)[Yt](c, { assembly: e, file: t, url: h, type: "API_ERROR" })) } updateNumberOfFilesInAssembly(e, t) { let r = new URL(e.assembly_ssl_url); r.pathname = "/update_assemblies"; let s = JSON.stringify({ assembly_updates: [{ assembly_id: e.assembly_id, num_expected_upload_files: t }] }); return Se(this, it)[it](r, { method: "POST", headers: Se(this, wt)[wt], body: s }).catch(o => Se(this, Yt)[Yt](o, { url: r, type: "API_ERROR" })) } cancelAssembly(e) { let t = e.assembly_ssl_url; return Se(this, it)[it](t, { method: "DELETE", headers: Se(this, wt)[wt] }).catch(r => Se(this, Yt)[Yt](r, { url: t, type: "API_ERROR" })) } getAssemblyStatus(e) { return Se(this, it)[it](e, { headers: Se(this, wt)[wt] }).catch(t => Se(this, Yt)[Yt](t, { url: e, type: "STATUS_ERROR" })) } submitError(e, t) { let { endpoint: r, instance: s, assembly: o } = t === void 0 ? {} : t, a = e.details ? `${e.message} (${e.details})` : e.message; return Se(this, it)[it]("https://transloaditstatus.com/client_error", { method: "POST", body: JSON.stringify({ endpoint: r, instance: s, assembly_id: o, agent: typeof navigator < "u" ? navigator.userAgent : "", client: this.opts.client, error: a }) }) } }; n(on, "Client"); function dE() { for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)e[t] = arguments[t]; return Se(this, cl)[cl](...e).then(r => { if (r.status === 429) return this.opts.rateLimitedQueue.rateLimit(2e3), Se(this, it)[it](...e); if (!r.ok) { let s = new Error(r.statusText); return s.statusCode = r.status, `${e[0]}`.endsWith(Fb) ? r.json().then(o => { if (!o.error) throw s; let a = new Error(o.error); throw a.details = o.message, a.assembly = o, o.assembly_id && (a.details += ` Assembly ID: ${o.assembly_id}`), a }, o => { throw o.cause = s, o }) : Promise.reject(s) } return r.json() }) } n(dE, "_fetchJSON2"); function Np(i) { if (i == null) throw new Error("Transloadit: The `params` option is required."); if (typeof i == "string") try { i = JSON.parse(i) } catch (e) { throw new Oi("Transloadit: The `params` option is a malformed JSON string.", { cause: e }) } if (!i.auth || !i.auth.key) throw new Error("Transloadit: The `params.auth.key` option is required. You can find your Transloadit API key at https://transloadit.com/c/template-credentials") } n(Np, "validateParams"); function pE(i) { let e = Object.create(null); for (let { fileIDs: t, options: r } of i.filter(Boolean)) { let s = JSON.stringify(r); s in e ? e[s].fileIDArrays.push(t) : e[s] = { options: r, fileIDArrays: [t] } } return Object.values(e).map(t => { let { options: r, fileIDArrays: s } = t; return { options: r, fileIDs: s.flat(1) } }) } n(pE, "dedupe"); async function Ob(i, e) { let t = typeof e.assemblyOptions == "function" ? await e.assemblyOptions(i, e) : e.assemblyOptions; Np(t.params); let { fields: r } = t; return Array.isArray(r) ? t.fields = i == null ? {} : Object.fromEntries(r.map(s => [s, i.meta[s]])) : r == null && (t.fields = {}), t } n(Ob, "getAssemblyOptions"); var mh = class { constructor(e, t) { this.files = e, this.opts = t } async build() { let e = this.opts; if (this.files.length > 0) return Promise.all(this.files.map(async t => { if (t == null) return; let r = await Ob(t, e); if (t != null) return { fileIDs: [t.id], options: r } })).then(pE); if (e.alwaysRunAssembly) { let t = await Ob(null, e); return [{ fileIDs: [], options: t }] } return [] } }; n(mh, "AssemblyOptions"); var Ab = mh; var Tb = se(bp(), 1); function Y(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Y, "_classPrivateFieldLooseBase"); var fE = 0; function Qt(i) { return "__private_" + fE++ + "_" + i } n(Qt, "_classPrivateFieldLooseKey"); var dl = Qt("assemblyIDs"), Ip = Qt("reject"), oo = Qt("remaining"), pl = Qt("resolve"), pe = Qt("uppy"), Tr = Qt("watching"), fl = Qt("onAssemblyComplete"), ml = Qt("onAssemblyCancel"), no = Qt("onAssemblyError"), gl = Qt("onImportError"), so = Qt("checkAllComplete"), Lp = Qt("removeListeners"), Bp = Qt("addListeners"), gh = class extends Tb.default { constructor(e, t) { super(), Object.defineProperty(this, Bp, { value: vE }), Object.defineProperty(this, Lp, { value: yE }), Object.defineProperty(this, so, { value: gE }), Object.defineProperty(this, Tr, { value: mE }), Object.defineProperty(this, dl, { writable: !0, value: void 0 }), Object.defineProperty(this, Ip, { writable: !0, value: void 0 }), Object.defineProperty(this, oo, { writable: !0, value: void 0 }), Object.defineProperty(this, pl, { writable: !0, value: void 0 }), Object.defineProperty(this, pe, { writable: !0, value: void 0 }), Object.defineProperty(this, fl, { writable: !0, value: r => { Y(this, Tr)[Tr](r.assembly_id) && (Y(this, pe)[pe].log(`[Transloadit] AssemblyWatcher: Got Assembly finish ${r.assembly_id}`), this.emit("assembly-complete", r.assembly_id), Y(this, so)[so]()) } }), Object.defineProperty(this, ml, { writable: !0, value: r => { Y(this, Tr)[Tr](r.assembly_id) && Y(this, so)[so]() } }), Object.defineProperty(this, no, { writable: !0, value: (r, s) => { Y(this, Tr)[Tr](r.assembly_id) && (Y(this, pe)[pe].log(`[Transloadit] AssemblyWatcher: Got Assembly error ${r.assembly_id}`), Y(this, pe)[pe].log(s), this.emit("assembly-error", r.assembly_id, s), Y(this, so)[so]()) } }), Object.defineProperty(this, gl, { writable: !0, value: (r, s, o) => { Y(this, Tr)[Tr](r.assembly_id) && Y(this, no)[no](r, o) } }), Y(this, pe)[pe] = e, Y(this, dl)[dl] = t, Y(this, oo)[oo] = t.length, this.promise = new Promise((r, s) => { Y(this, pl)[pl] = r, Y(this, Ip)[Ip] = s }), Y(this, Bp)[Bp]() } }; n(gh, "TransloaditAssemblyWatcher"); function mE(i) { return Y(this, dl)[dl].indexOf(i) !== -1 } n(mE, "_watching2"); function gE() { Y(this, oo)[oo] -= 1, Y(this, oo)[oo] === 0 && (Y(this, Lp)[Lp](), Y(this, pl)[pl]()) } n(gE, "_checkAllComplete2"); function yE() { Y(this, pe)[pe].off("transloadit:complete", Y(this, fl)[fl]), Y(this, pe)[pe].off("transloadit:assembly-cancel", Y(this, ml)[ml]), Y(this, pe)[pe].off("transloadit:assembly-error", Y(this, no)[no]), Y(this, pe)[pe].off("transloadit:import-error", Y(this, gl)[gl]) } n(yE, "_removeListeners2"); function vE() { Y(this, pe)[pe].on("transloadit:complete", Y(this, fl)[fl]), Y(this, pe)[pe].on("transloadit:assembly-cancel", Y(this, ml)[ml]), Y(this, pe)[pe].on("transloadit:assembly-error", Y(this, no)[no]), Y(this, pe)[pe].on("transloadit:import-error", Y(this, gl)[gl]) } n(vE, "_addListeners2"); var Cb = gh; var Rb = { strings: { creatingAssembly: "Preparing upload...", creatingAssemblyFailed: "Transloadit: Could not create Assembly", encoding: "Encoding..." } }; function J(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(J, "_classPrivateFieldLooseBase"); var bE = 0; function _e(i) { return "__private_" + bE++ + "_" + i } n(_e, "_classPrivateFieldLooseKey"); var wE = { version: "3.2.1" }, kb = n(i => e => { let t = new Oi("Failed to send error to the client", { cause: e }); console.error(t, i) }, "sendErrorToConsole"), Yp = "https://api2.transloadit.com/companion", Qp = /\.transloadit\.com$/, SE = /https?:\/\/api2(?:-\w+)?\.transloadit\.com\/companion/, Pi = _e("rateLimitedQueue"), Mp = _e("getClientVersion"), Kp = _e("attachAssemblyMetadata"), zp = _e("createAssembly"), yl = _e("createAssemblyWatcher"), jp = _e("shouldWaitAfterUpload"), Hp = _e("reserveFiles"), vl = _e("onFileUploadURLAvailable"), xl = _e("findFile"), Gp = _e("onFileUploadComplete"), Xp = _e("onResult"), _l = _e("onAssemblyFinished"), El = _e("cancelAssembly"), qp = _e("onCancelAll"), $p = _e("getPersistentData"), Vp = _e("onRestored"), bl = _e("connectAssembly"), wl = _e("prepareUpload"), ao = _e("afterUpload"), Sl = _e("closeAssemblyIfExists"), Pl = _e("onError"), Wp = _e("onTusError"), ni = class extends Fe { constructor(e, t) { var r, s, o, a; super(e, t), r = this, Object.defineProperty(this, bl, { value: UE }), Object.defineProperty(this, El, { value: kE }), Object.defineProperty(this, _l, { value: RE }), Object.defineProperty(this, Xp, { value: CE }), Object.defineProperty(this, Gp, { value: TE }), Object.defineProperty(this, xl, { value: AE }), Object.defineProperty(this, Hp, { value: OE }), Object.defineProperty(this, jp, { value: FE }), Object.defineProperty(this, yl, { value: EE }), Object.defineProperty(this, zp, { value: xE }), Object.defineProperty(this, Kp, { value: _E }), Object.defineProperty(this, Mp, { value: PE }), Object.defineProperty(this, Pi, { writable: !0, value: void 0 }), Object.defineProperty(this, vl, { writable: !0, value: h => { var c; let d = this.uppy.getFile(h.id); if (!(d != null && (c = d.transloadit) != null && c.assembly)) return; let { assemblies: p } = this.getPluginState(), y = p[d.transloadit.assembly]; this.client.addFile(y, d).catch(v => { this.uppy.log(v), this.uppy.emit("transloadit:import-error", y, d.id, v) }) } }), Object.defineProperty(this, qp, { writable: !0, value: async function (h) { let { reason: c } = h === void 0 ? {} : h; try { if (c !== "user") return; let { uploadsAssemblies: d } = r.getPluginState(), y = Object.values(d).flat(1).map(v => r.getAssembly(v)); await Promise.all(y.map(v => J(r, El)[El](v))) } catch (d) { r.uppy.log(d) } } }), Object.defineProperty(this, $p, { writable: !0, value: h => { let { assemblies: c, uploadsAssemblies: d } = this.getPluginState(); h({ [this.id]: { assemblies: c, uploadsAssemblies: d } }) } }), Object.defineProperty(this, Vp, { writable: !0, value: h => { let c = h && h[this.id] ? h[this.id] : {}, d = c.assemblies || {}, p = c.uploadsAssemblies || {}; if (Object.keys(p).length === 0) return; let y = n(x => { let E = {}, F = []; for (let [k, B] of Object.entries(x)) { B.uploads.forEach(W => { let I = J(this, xl)[xl](W); E[W.id] = { id: I.id, assembly: k, uploadedFile: W } }); let H = this.getPluginState(); Object.keys(B.results).forEach(W => { for (let I of B.results[W]) { let q = H.files[I.original_id]; I.localId = q ? q.id : null, F.push({ id: I.id, result: I, stepName: W, assembly: k }) } }) } this.setPluginState({ assemblies: x, files: E, results: F, uploadsAssemblies: p }) }, "restoreState"), v = n(() => { let { assemblies: x, uploadsAssemblies: E } = this.getPluginState(); Object.keys(E).forEach(k => { let B = E[k]; J(this, yl)[yl](B, k) }), Object.keys(x).forEach(k => { let B = new Dp(x[k], J(this, Pi)[Pi]); J(this, bl)[bl](B) }) }, "restoreAssemblies"), S = n(() => { let { assemblies: x } = this.getPluginState(); return Promise.all(Object.keys(x).map(E => this.activeAssemblies[E].update())) }, "updateAssemblies"); this.restored = Promise.resolve().then(() => (y(d), v(), S())), this.restored.then(() => { this.restored = null }) } }), Object.defineProperty(this, wl, { writable: !0, value: (h, c) => { let p = h.map(x => this.uppy.getFile(x)).filter(x => x.error ? !1 : (this.uppy.emit("preprocess-progress", x, { mode: "indeterminate", message: this.i18n("creatingAssembly") }), !0)), y = n(async x => { let { fileIDs: E, options: F } = x; try { let k = await J(this, zp)[zp](E, c, F); return this.opts.importFromUploadURLs && await J(this, Hp)[Hp](k, E), E.forEach(B => { let H = this.uppy.getFile(B); this.uppy.emit("preprocess-complete", H) }), k } catch (k) { throw E.forEach(B => { let H = this.uppy.getFile(B); this.uppy.emit("preprocess-complete", H), this.uppy.emit("upload-error", H, k) }), k } }, "createAssembly"), { uploadsAssemblies: v } = this.getPluginState(); return this.setPluginState({ uploadsAssemblies: { ...v, [c]: [] } }), new Ab(p, this.opts).build().then(x => Promise.all(x.map(y))).then(x => { let E = x.filter(Boolean), F = E.map(k => k.status.assembly_id); return J(this, yl)[yl](F, c), Promise.all(E.map(k => J(this, bl)[bl](k))) }).catch(x => { throw p.forEach(E => { this.uppy.emit("preprocess-complete", E), this.uppy.emit("upload-error", E, x) }), x }) } }), Object.defineProperty(this, ao, { writable: !0, value: (h, c) => { let d = h.map(F => this.uppy.getFile(F)), p = d.filter(F => !F.error).map(F => F.id), y = this.getPluginState(); if (this.restored) return this.restored.then(() => J(this, ao)[ao](p, c)); let v = y.uploadsAssemblies[c], S = n(() => { v.forEach(F => { this.activeAssemblies[F].close(), delete this.activeAssemblies[F] }) }, "closeSocketConnections"); if (!J(this, jp)[jp]()) { S(); let F = v.map(k => this.getAssembly(k)); return this.uppy.addResultData(c, { transloadit: F }), Promise.resolve() } return v.length === 0 ? (this.uppy.addResultData(c, { transloadit: [] }), Promise.resolve()) : (d.filter(F => !ht(this.completedFiles, F.id)).forEach(F => { this.uppy.emit("postprocess-progress", F, { mode: "indeterminate", message: this.i18n("encoding") }) }), this.assemblyWatchers[c].promise.then(() => { S(); let F = v.map(B => this.getAssembly(B)), k = { ...this.getPluginState().uploadsAssemblies }; delete k[c], this.setPluginState({ uploadsAssemblies: k }), this.uppy.addResultData(c, { transloadit: F }) })) } }), Object.defineProperty(this, Sl, { writable: !0, value: h => { var c; (c = this.activeAssemblies[h]) == null || c.close() } }), Object.defineProperty(this, Pl, { writable: !0, value: function (h, c) { h === void 0 && (h = null); let p = r.getPluginState().uploadsAssemblies[c]; p?.forEach(J(r, Sl)[Sl]), r.client.submitError(h).catch(kb(h)) } }), Object.defineProperty(this, Wp, { writable: !0, value: (h, c) => { var d, p; if (J(this, Sl)[Sl](h == null || (d = h.transloadit) == null ? void 0 : d.assembly), c != null && (p = c.message) != null && p.startsWith("tus: ")) { var y; let v = (y = c.originalRequest) == null || (y = y.getUnderlyingObject()) == null ? void 0 : y.responseURL; this.client.submitError(c, { endpoint: v, type: "TUS_ERROR" }).catch(kb(c)) } } }), this.type = "uploader", this.id = this.opts.id || "Transloadit", this.title = "Transloadit", this.defaultLocale = Rb; let l = { service: "https://api2.transloadit.com", errorReporting: !0, waitForEncoding: !1, waitForMetadata: !1, alwaysRunAssembly: !1, importFromUploadURLs: !1, signature: null, params: null, fields: null, getAssemblyOptions: null, limit: 20, retryDelays: [7e3, 1e4, 15e3, 2e4] }; this.opts = { ...l, ...t }, (o = (s = this.opts).assemblyOptions) != null || (s.assemblyOptions = (a = this.opts.getAssemblyOptions) != null ? a : { params: this.opts.params, signature: this.opts.signature, fields: this.opts.fields }), t?.params != null && t.getAssemblyOptions == null && t.assemblyOptions == null && Np(this.opts.assemblyOptions.params), J(this, Pi)[Pi] = new vt(this.opts.limit), this.i18nInit(), this.client = new on({ service: this.opts.service, client: J(this, Mp)[Mp](), errorReporting: this.opts.errorReporting, rateLimitedQueue: J(this, Pi)[Pi] }), this.activeAssemblies = {}, this.assemblyWatchers = {}, this.completedFiles = Object.create(null) } install() { this.uppy.addPreProcessor(J(this, wl)[wl]), this.uppy.addPostProcessor(J(this, ao)[ao]), this.uppy.on("error", J(this, Pl)[Pl]), this.uppy.on("cancel-all", J(this, qp)[qp]), this.uppy.on("upload-error", J(this, Wp)[Wp]), this.opts.importFromUploadURLs ? this.uppy.on("upload-success", J(this, vl)[vl]) : this.uppy.use(Ki, { storeFingerprintForResuming: !1, useFastRemoteRetry: !1, allowedMetaFields: ["assembly_url", "filename", "fieldname"], limit: this.opts.limit, rateLimitedQueue: J(this, Pi)[Pi], retryDelays: this.opts.retryDelays }), this.uppy.on("restore:get-data", J(this, $p)[$p]), this.uppy.on("restored", J(this, Vp)[Vp]), this.setPluginState({ assemblies: {}, uploadsAssemblies: {}, files: {}, results: [] }); let { capabilities: e } = this.uppy.getState(); this.uppy.setState({ capabilities: { ...e, individualCancellation: !1 } }) } uninstall() { this.uppy.removePreProcessor(J(this, wl)[wl]), this.uppy.removePostProcessor(J(this, ao)[ao]), this.uppy.off("error", J(this, Pl)[Pl]), this.opts.importFromUploadURLs && this.uppy.off("upload-success", J(this, vl)[vl]); let { capabilities: e } = this.uppy.getState(); this.uppy.setState({ capabilities: { ...e, individualCancellation: !0 } }) } getAssembly(e) { let { assemblies: t } = this.getPluginState(); return t[e] } getAssemblyFiles(e) { return this.uppy.getFiles().filter(t => { var r; return (t == null || (r = t.transloadit) == null ? void 0 : r.assembly) === e }) } }; n(ni, "Transloadit"); function PE() { let i = [`uppy-core:${this.uppy.constructor.VERSION}`, `uppy-transloadit:${this.constructor.VERSION}`, `uppy-tus:${Ki.VERSION}`], e = n((t, r) => { let s = this.uppy.getPlugin(t); s && i.push(`${r}:${s.constructor.VERSION}`) }, "addPluginVersion"); return this.opts.importFromUploadURLs && (e("XHRUpload", "uppy-xhr-upload"), e("AwsS3", "uppy-aws-s3"), e("AwsS3Multipart", "uppy-aws-s3-multipart")), e("Dropbox", "uppy-dropbox"), e("Box", "uppy-box"), e("Facebook", "uppy-facebook"), e("GoogleDrive", "uppy-google-drive"), e("Instagram", "uppy-instagram"), e("OneDrive", "uppy-onedrive"), e("Zoom", "uppy-zoom"), e("Url", "uppy-url"), i.join(",") } n(PE, "_getClientVersion2"); function _E(i, e) { let t = { ...i.meta, assembly_url: e.assembly_url, filename: i.name, fieldname: "file" }, r = { ...i.tus, endpoint: e.tus_url, addRequestId: !0 }, { remote: s } = i; if (i.remote && SE.test(i.remote.companionUrl)) { let a = e.companion_url.replace(/\/$/, ""), l = i.remote.url.replace(i.remote.companionUrl, "").replace(/^\//, ""); s = { ...i.remote, companionUrl: a, url: `${a}/${l}` } } let o = { ...i, transloadit: { assembly: e.assembly_id } }; return this.opts.importFromUploadURLs || Object.assign(o, { meta: t, tus: r, remote: s }), o } n(_E, "_attachAssemblyMetadata2"); function xE(i, e, t) { return this.uppy.log("[Transloadit] Create Assembly"), this.client.createAssembly({ ...t, expectedFiles: i.length }).then(async r => { let s = this.uppy.getFiles().filter(y => { let { id: v } = y; return i.includes(v) }); if (s.length !== i.length) { if (s.length === 0) return await this.client.cancelAssembly(r), null; await this.client.updateNumberOfFilesInAssembly(r, s.length) } let o = new Dp(r, J(this, Pi)[Pi]), { status: a } = o, l = a.assembly_id, { assemblies: h, uploadsAssemblies: c } = this.getPluginState(); this.setPluginState({ assemblies: { ...h, [l]: a }, uploadsAssemblies: { ...c, [e]: [...c[e], l] } }); let d = {}; s.forEach(y => { d[y.id] = J(this, Kp)[Kp](y, a) }), this.uppy.setState({ files: { ...this.uppy.getState().files, ...d } }); let p = n((y, v) => { var S; if (((S = o.status) == null ? void 0 : S.ok) === "ASSEMBLY_COMPLETED") { this.uppy.off("file-removed", p); return } if (v === "cancel-all") o.close(), this.uppy.off("file-removed", p); else if (y.id in d) { delete d[y.id]; let x = Object.keys(d).length; x === 0 ? (o.close(), J(this, El)[El](r).catch(() => { }), this.uppy.off("file-removed", p)) : this.client.updateNumberOfFilesInAssembly(r, x).catch(() => { }) } }, "fileRemovedHandler"); return this.uppy.on("file-removed", p), this.uppy.emit("transloadit:assembly-created", a, i), this.uppy.log(`[Transloadit] Created Assembly ${l}`), o }).catch(r => { let s = new Oi(`${this.i18n("creatingAssemblyFailed")}: ${r.message}`, { cause: r }); throw "details" in r && (s.details = r.details), "assembly" in r && (s.assembly = r.assembly), s }) } n(xE, "_createAssembly2"); function EE(i, e) { let t = new Cb(this.uppy, i); t.on("assembly-complete", r => { this.getAssemblyFiles(r).forEach(o => { this.completedFiles[o.id] = !0, this.uppy.emit("postprocess-complete", o) }) }), t.on("assembly-error", (r, s) => { let o = this.getAssemblyFiles(r); o.forEach(l => { this.uppy.emit("upload-error", l, s), this.uppy.emit("postprocess-complete", l) }); let a = { ...this.uppy.getState().files }; o.forEach(l => delete a[l.id].tus), this.uppy.setState({ files: a }), this.uppy.emit("error", s) }), this.assemblyWatchers[e] = t } n(EE, "_createAssemblyWatcher2"); function FE() { return this.opts.waitForEncoding || this.opts.waitForMetadata } n(FE, "_shouldWaitAfterUpload2"); function OE(i, e) { return Promise.all(e.map(t => { let r = this.uppy.getFile(t); return this.client.reserveFile(i.status, r) })) } n(OE, "_reserveFiles2"); function AE(i) { let e = this.uppy.getFiles(); for (let t = 0; t < e.length; t++) { let r = e[t]; if (r.uploadURL === i.tus_upload_url || r.tus && r.tus.uploadUrl === i.tus_upload_url || !i.is_tus_file && r.name === i.name && r.size === i.size) return r } } n(AE, "_findFile2"); function TE(i, e) { let t = this.getPluginState(), r = J(this, xl)[xl](e); if (!r) { this.uppy.log("[Transloadit] Couldn\u2019t find the file, it was likely removed in the process"); return } this.setPluginState({ files: { ...t.files, [e.id]: { assembly: i, id: r.id, uploadedFile: e } } }), this.uppy.emit("transloadit:upload", e, this.getAssembly(i)) } n(TE, "_onFileUploadComplete2"); function CE(i, e, t) { let r = this.getPluginState(), s = r.files[t.original_id]; t.localId = s ? s.id : null; let o = { result: t, stepName: e, id: t.id, assembly: i }; this.setPluginState({ results: [...r.results, o] }), this.uppy.emit("transloadit:result", e, t, this.getAssembly(i)) } n(CE, "_onResult2"); function RE(i) { let e = i.assembly_ssl_url; this.client.getAssemblyStatus(e).then(t => { let r = t.assembly_id, s = this.getPluginState(); this.setPluginState({ assemblies: { ...s.assemblies, [r]: t } }), this.uppy.emit("transloadit:complete", t) }) } n(RE, "_onAssemblyFinished2"); async function kE(i) { await this.client.cancelAssembly(i), this.uppy.emit("transloadit:assembly-cancelled", i) } n(kE, "_cancelAssembly2"); function UE(i) { let { status: e } = i, t = e.assembly_id; return this.activeAssemblies[t] = i, i.on("status", r => { let { assemblies: s } = this.getPluginState(); this.setPluginState({ assemblies: { ...s, [t]: r } }) }), i.on("upload", r => { J(this, Gp)[Gp](t, r) }), i.on("error", r => { r.assembly = i.status, this.uppy.emit("transloadit:assembly-error", i.status, r) }), i.on("executing", () => { this.uppy.emit("transloadit:assembly-executing", i.status) }), this.opts.waitForEncoding && i.on("result", (r, s) => { J(this, Xp)[Xp](t, r, s) }), this.opts.waitForEncoding ? i.on("finished", () => { J(this, _l)[_l](i.status) }) : this.opts.waitForMetadata && i.on("metadata", () => { J(this, _l)[_l](i.status) }), i.ok === "ASSEMBLY_COMPLETE" || i.connect(), i } n(UE, "_connectAssembly2"); ni.VERSION = wE.version; ni.COMPANION = Yp; ni.COMPANION_PATTERN = Qp; var Ub = { strings: { uploadStalled: "Upload has not made any progress for %{seconds} seconds. You may want to retry it." } }; function nn(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(nn, "_classPrivateFieldLooseBase"); var DE = 0; function Ol(i) { return "__private_" + DE++ + "_" + i } n(Ol, "_classPrivateFieldLooseKey"); var NE = { version: "3.3.2" }; function Db(i, e) { let t = e; return t || (t = new Error("Upload error")), typeof t == "string" && (t = new Error(t)), t instanceof Error || (t = Object.assign(new Error("Upload error"), { data: t })), Gs(i) ? (t = new hi(t, i), t) : (t.request = i, t) } n(Db, "buildResponseError"); function Nb(i) { return i.data.slice(0, i.data.size, i.meta.type) } n(Nb, "setTypeInBlob"); var tf = Ol("upload"), Jp = Ol("requestSocketToken"), Zp = Ol("uploadBundle"), ef = Ol("uploadFiles"), Fl = Ol("handleUpload"), lo = class extends ri { constructor(e, t) { super(e, t), Object.defineProperty(this, ef, { value: LE }), Object.defineProperty(this, Zp, { value: BE }), Object.defineProperty(this, tf, { value: IE }), Object.defineProperty(this, Jp, { writable: !0, value: async (s, o) => { let a = this.getOptions(s), l = s.remote.providerOptions.provider ? Q : de, h = new l(this.uppy, s.remote.providerOptions), c = Array.isArray(a.allowedMetaFields) ? a.allowedMetaFields : Object.keys(s.meta); return (await h.post(s.remote.url, { ...s.remote.body, protocol: "multipart", endpoint: a.endpoint, size: s.data.size, fieldname: a.fieldName, metadata: Object.fromEntries(c.map(p => [p, s.meta[p]])), httpMethod: a.method, useFormData: a.formData, headers: typeof a.headers == "function" ? a.headers(s) : a.headers }, o)).token } }), Object.defineProperty(this, Fl, { writable: !0, value: async s => { if (s.length === 0) { this.uppy.log("[XHRUpload] No files to upload!"); return } this.opts.limit === 0 && !this.opts[Xr] && this.uppy.log("[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0", "warning"), this.uppy.log("[XHRUpload] Uploading..."); let o = this.uppy.getFilesByIds(s), a = Yr(o), l = Qr(a); if (this.uppy.emit("upload-start", l), this.opts.bundle) { if (a.some(c => c.isRemote)) throw new Error("Can\u2019t upload remote files when the `bundle: true` option is set"); if (typeof this.opts.headers == "function") throw new TypeError("`headers` may not be a function when the `bundle: true` option is set"); await nn(this, Zp)[Zp](a) } else await nn(this, ef)[ef](a) } }), this.type = "uploader", this.id = this.opts.id || "XHRUpload", this.title = "XHRUpload", this.defaultLocale = Ub; let r = { formData: !0, fieldName: t.bundle ? "files[]" : "file", method: "POST", allowedMetaFields: null, responseUrlFieldName: "url", bundle: !1, headers: {}, timeout: 30 * 1e3, limit: 5, withCredentials: !1, responseType: "", getResponseData(s) { let o = {}; try { o = JSON.parse(s) } catch (a) { e.log(a) } return o }, getResponseError(s, o) { let a = new Error("Upload error"); return Gs(o) && (a = new hi(a, o)), a }, validateStatus(s) { return s >= 200 && s < 300 } }; if (this.opts = { ...r, ...t }, this.i18nInit(), Xr in this.opts ? this.requests = this.opts[Xr] : this.requests = new vt(this.opts.limit), this.opts.bundle && !this.opts.formData) throw new Error("`opts.formData` must be true when `opts.bundle` is enabled."); if (t?.allowedMetaFields === void 0 && "metaFields" in this.opts) throw new Error("The `metaFields` option has been renamed to `allowedMetaFields`."); this.uploaderEvents = Object.create(null), this.setQueueRequestSocketToken(this.requests.wrapPromiseFunction(nn(this, Jp)[Jp], { priority: -1 })) } getOptions(e) { let t = this.uppy.getState().xhrUpload, { headers: r } = this.opts, s = { ...this.opts, ...t || {}, ...e.xhrUpload || {}, headers: {} }; return typeof r == "function" ? s.headers = r(e) : Object.assign(s.headers, this.opts.headers), t && Object.assign(s.headers, t.headers), e.xhrUpload && Object.assign(s.headers, e.xhrUpload.headers), s } addMetadata(e, t, r) { (Array.isArray(r.allowedMetaFields) ? r.allowedMetaFields : Object.keys(t)).forEach(o => { Array.isArray(t[o]) ? t[o].forEach(a => e.append(o, a)) : e.append(o, t[o]) }) } createFormDataUpload(e, t) { let r = new FormData; this.addMetadata(r, e.meta, t); let s = Nb(e); return e.name ? r.append(t.fieldName, s, e.meta.name) : r.append(t.fieldName, s), r } createBundledUpload(e, t) { let r = new FormData, { meta: s } = this.uppy.getState(); return this.addMetadata(r, s, t), e.forEach(o => { let a = this.getOptions(o), l = Nb(o); o.name ? r.append(a.fieldName, l, o.name) : r.append(a.fieldName, l) }), r } async connectToServerSocket(e) { return new Promise((t, r) => { let s = this.getOptions(e), o = e.serverToken, a = wr(e.remote.companionUrl), l, h = n(() => { l == null && (l = new Ft({ target: `${a}/api/${o}` }), l.on("progress", p => Gr(this, p, e)), l.on("success", p => { let y = s.getResponseData(p.response.responseText, p.response), v = y[s.responseUrlFieldName], S = { status: p.response.status, body: y, uploadURL: v }; return this.uppy.emit("upload-success", e, S), c.done(), l.close(), this.uploaderEvents[e.id] && (this.uploaderEvents[e.id].remove(), this.uploaderEvents[e.id] = null), t() }), l.on("error", p => { let y = p.response, v = y ? s.getResponseError(y.responseText, y) : Object.assign(new Error(p.error.message), { cause: p.error }); this.uppy.emit("upload-error", e, v), c.done(), l.close(), this.uploaderEvents[e.id] && (this.uploaderEvents[e.id].remove(), this.uploaderEvents[e.id] = null), r(v) })) }, "createSocket"); this.uploaderEvents[e.id] = new at(this.uppy); let c = this.requests.run(() => { if (e.isPaused) { var p; (p = l) == null || p.send("pause", {}) } else h(); return () => { } }); this.onFileRemove(e.id, () => { var p; (p = l) == null || p.send("cancel", {}), l.close(), c.abort(), t(`upload ${e.id} was removed`) }), this.onCancelAll(e.id, function (p) { let { reason: y } = p === void 0 ? {} : p; if (y === "user") { var v; (v = l) == null || v.send("cancel", {}), c.abort() } t(`upload ${e.id} was canceled`) }); let d = n(() => { l == null ? c.abort() : c.done(), c = this.requests.run(() => (l == null && h(), () => { })) }, "onRetryRequest"); this.onRetry(e.id, d), this.onRetryAll(e.id, d) }).catch(t => (this.uppy.emit("upload-error", e, t), Promise.reject(t))) } onFileRemove(e, t) { this.uploaderEvents[e].on("file-removed", r => { e === r.id && t(r.id) }) } onRetry(e, t) { this.uploaderEvents[e].on("upload-retry", r => { e === r && t() }) } onRetryAll(e, t) { this.uploaderEvents[e].on("retry-all", () => { this.uppy.getFile(e) && t() }) } onCancelAll(e, t) { var r = this; this.uploaderEvents[e].on("cancel-all", function () { r.uppy.getFile(e) && t(...arguments) }) } install() { if (this.opts.bundle) { let { capabilities: e } = this.uppy.getState(); this.uppy.setState({ capabilities: { ...e, individualCancellation: !1 } }) } this.uppy.addUploader(nn(this, Fl)[Fl]) } uninstall() { if (this.opts.bundle) { let { capabilities: e } = this.uppy.getState(); this.uppy.setState({ capabilities: { ...e, individualCancellation: !0 } }) } this.uppy.removeUploader(nn(this, Fl)[Fl]) } }; n(lo, "XHRUpload"); async function IE(i, e, t) { let r = this.getOptions(i); return this.uppy.log(`uploading ${e} of ${t}`), new Promise((s, o) => { let a = r.formData ? this.createFormDataUpload(i, r) : i.data, l = new XMLHttpRequest; this.uploaderEvents[i.id] = new at(this.uppy); let h, c = new $a(r.timeout, () => { let p = new Error(this.i18n("uploadStalled", { seconds: Math.ceil(r.timeout / 1e3) })); this.uppy.emit("upload-stalled", p, [i]) }), d = ot(); l.upload.addEventListener("loadstart", () => { this.uppy.log(`[XHRUpload] ${d} started`) }), l.upload.addEventListener("progress", p => { this.uppy.log(`[XHRUpload] ${d} progress: ${p.loaded} / ${p.total}`), c.progress(), p.lengthComputable && this.uppy.emit("upload-progress", i, { uploader: this, bytesUploaded: p.loaded, bytesTotal: p.total }) }), l.addEventListener("load", () => { if (this.uppy.log(`[XHRUpload] ${d} finished`), c.done(), h.done(), this.uploaderEvents[i.id] && (this.uploaderEvents[i.id].remove(), this.uploaderEvents[i.id] = null), r.validateStatus(l.status, l.responseText, l)) { let S = r.getResponseData(l.responseText, l), x = S[r.responseUrlFieldName], E = { status: l.status, body: S, uploadURL: x }; return this.uppy.emit("upload-success", i, E), x && this.uppy.log(`Download ${i.name} from ${x}`), s(i) } let p = r.getResponseData(l.responseText, l), y = Db(l, r.getResponseError(l.responseText, l)), v = { status: l.status, body: p }; return this.uppy.emit("upload-error", i, y, v), o(y) }), l.addEventListener("error", () => { this.uppy.log(`[XHRUpload] ${d} errored`), c.done(), h.done(), this.uploaderEvents[i.id] && (this.uploaderEvents[i.id].remove(), this.uploaderEvents[i.id] = null); let p = Db(l, r.getResponseError(l.responseText, l)); return this.uppy.emit("upload-error", i, p), o(p) }), l.open(r.method.toUpperCase(), r.endpoint, !0), l.withCredentials = r.withCredentials, r.responseType !== "" && (l.responseType = r.responseType), h = this.requests.run(() => { let p = this.getOptions(i); return Object.keys(p.headers).forEach(y => { l.setRequestHeader(y, p.headers[y]) }), l.send(a), () => { c.done(), l.abort() } }), this.onFileRemove(i.id, () => { h.abort(), o(new Error("File removed")) }), this.onCancelAll(i.id, p => { let { reason: y } = p; y === "user" && h.abort(), o(new Error("Upload cancelled")) }) }) } n(IE, "_upload2"); function BE(i) { return new Promise((e, t) => { let { endpoint: r } = this.opts, { method: s } = this.opts, o = this.uppy.getState().xhrUpload, a = this.createBundledUpload(i, { ...this.opts, ...o || {} }), l = new XMLHttpRequest, h = n(d => { i.forEach(p => { this.uppy.emit("upload-error", p, d) }) }, "emitError"), c = new $a(this.opts.timeout, () => { let d = new Error(this.i18n("uploadStalled", { seconds: Math.ceil(this.opts.timeout / 1e3) })); this.uppy.emit("upload-stalled", d, i) }); l.upload.addEventListener("loadstart", () => { this.uppy.log("[XHRUpload] started uploading bundle"), c.progress() }), l.upload.addEventListener("progress", d => { c.progress(), d.lengthComputable && i.forEach(p => { this.uppy.emit("upload-progress", p, { uploader: this, bytesUploaded: d.loaded / d.total * p.size, bytesTotal: p.size }) }) }), l.addEventListener("load", d => { if (c.done(), this.opts.validateStatus(d.target.status, l.responseText, l)) { let y = this.opts.getResponseData(l.responseText, l), v = { status: d.target.status, body: y }; return i.forEach(S => { this.uppy.emit("upload-success", S, v) }), e() } let p = this.opts.getResponseError(l.responseText, l) || new Error("Upload error"); return p.request = l, h(p), t(p) }), l.addEventListener("error", () => { c.done(); let d = this.opts.getResponseError(l.responseText, l) || new Error("Upload error"); return h(d), t(d) }), this.uppy.on("cancel-all", function (d) { let { reason: p } = d === void 0 ? {} : d; p === "user" && (c.done(), l.abort()) }), l.open(s.toUpperCase(), r, !0), l.withCredentials = this.opts.withCredentials, this.opts.responseType !== "" && (l.responseType = this.opts.responseType), Object.keys(this.opts.headers).forEach(d => { l.setRequestHeader(d, this.opts.headers[d]) }), l.send(a) }) } n(BE, "_uploadBundle2"); async function LE(i) { await Promise.allSettled(i.map((e, t) => { let r = parseInt(t, 10) + 1, s = i.length; if (e.isRemote) { let o = new AbortController, a = n(h => { h.id === e.id && o.abort() }, "removedHandler"); this.uppy.on("file-removed", a); let l = this.uploadRemoteFile(e, { signal: o.signal }); return this.requests.wrapSyncFunction(() => { this.uppy.off("file-removed", a) }, { priority: -1 })(), l } return nn(this, tf)[tf](e, r, s) })) } n(LE, "_uploadFiles2"); lo.VERSION = NE.version; var sf = se(zl(), 1), Kb = se($b(), 1); var Vb = { strings: { compressingImages: "Compressing images...", compressedX: "Saved %{size} by compressing images" } }; function Wb(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Wb, "_classPrivateFieldLooseBase"); var oF = 0; function nF(i) { return "__private_" + oF++ + "_" + i } n(nF, "_classPrivateFieldLooseKey"); var Tl = nF("RateLimitedQueue"), an = class extends Fe { constructor(e, t) { super(e, t), Object.defineProperty(this, Tl, { writable: !0, value: void 0 }), this.id = this.opts.id || "Compressor", this.type = "modifier", this.defaultLocale = Vb; let r = { quality: .6, limit: 10 }; this.opts = { ...r, ...t }, Wb(this, Tl)[Tl] = new vt(this.opts.limit), this.i18nInit(), this.prepareUpload = this.prepareUpload.bind(this), this.compress = this.compress.bind(this) } compress(e) { return new Promise((t, r) => { new Kb.default(e, { ...this.opts, success: t, error: r }) }) } async prepareUpload(e) { let t = 0, r = [], s = Wb(this, Tl)[Tl].wrapPromiseFunction(async a => { try { let l = await this.compress(a.data), h = a.data.size - l.size; this.uppy.log(`[Image Compressor] Image ${a.id} compressed by ${(0, sf.default)(h)}`), t += h; let { name: c, type: d, size: p } = l, y = c && er(c).extension; this.uppy.setFileState(a.id, { ...c && { name: c }, ...y && { extension: y }, ...d && { type: d }, ...p && { size: p }, data: l }), this.uppy.setFileMeta(a.id, { type: d }), r.push(a) } catch (l) { this.uppy.log(`[Image Compressor] Failed to compress ${a.id}:`, "warning"), this.uppy.log(l, "warning") } }), o = e.map(a => { let l = this.uppy.getFile(a); return this.uppy.emit("preprocess-progress", l, { mode: "indeterminate", message: this.i18n("compressingImages") }), l.isRemote || (l.data.type || (l.data = l.data.slice(0, l.data.size, l.type)), !l.type.startsWith("image/")) ? Promise.resolve() : s(l) }); await Promise.all(o), this.uppy.emit("compressor:complete", r), t > 1024 && this.uppy.info(this.i18n("compressedX", { size: (0, sf.default)(t) }), "info"); for (let a of e) { let l = this.uppy.getFile(a); this.uppy.emit("preprocess-complete", l) } } install() { this.uppy.addPreProcessor(this.prepareUpload) } uninstall() { this.uppy.removePreProcessor(this.prepareUpload) } }; n(an, "Compressor"); function wh() { return wh = Object.assign || function (i) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]) } return i }, wh.apply(this, arguments) } n(wh, "_extends"); var aF = { "[object HTMLCollection]": !0, "[object NodeList]": !0, "[object RadioNodeList]": !0 }, lF = { button: !0, fieldset: !0, reset: !0, submit: !0 }, uF = { checkbox: !0, radio: !0 }, hF = /^\s+|\s+$/g, cF = Array.prototype.slice, Gb = Object.prototype.toString; function Sh(i, e) { if (!i) throw new Error("A form is required by getFormData, was given form=" + i); e = wh({ includeDisabled: !1, trim: !1 }, e); for (var t = {}, r, s = [], o = {}, a = 0, l = i.elements.length; a < l; a++) { var h = i.elements[a]; lF[h.type] || h.disabled && !e.includeDisabled || (r = h.name || h.id, r && !o[r] && (s.push(r), o[r] = !0)) } for (var c = 0, d = s.length; c < d; c++) { r = s[c]; var p = Yb(i, r, e); p != null && (t[r] = p) } return t } n(Sh, "getFormData"); function Yb(i, e, t) { if (!i) throw new Error("A form is required by getFieldData, was given form=" + i); if (!e && Gb.call(e) !== "[object String]") throw new Error("A field name is required by getFieldData, was given fieldName=" + e); t = wh({ includeDisabled: !1, trim: !1 }, t); var r = i.elements[e]; if (!r || r.disabled && !t.includeDisabled) return null; if (!aF[Gb.call(r)]) return Xb(r, t.trim); for (var s = [], o = !0, a = 0, l = r.length; a < l; a++)if (!(r[a].disabled && !t.includeDisabled)) { o && r[a].type !== "radio" && (o = !1); var h = Xb(r[a], t.trim); h != null && (s = s.concat(h)) } return o && s.length === 1 ? s[0] : s.length > 0 ? s : null } n(Yb, "getFieldData"); function Xb(i, e) { var t = null, r = i.type; if (r === "select-one") return i.options.length && (t = i.options[i.selectedIndex].value), t; if (r === "select-multiple") { t = []; for (var s = 0, o = i.options.length; s < o; s++)i.options[s].selected && t.push(i.options[s].value); return t.length === 0 && (t = null), t } return r === "file" && "files" in i ? (i.multiple ? (t = cF.call(i.files), t.length === 0 && (t = null)) : t = i.files[0], t) : (uF[r] ? i.checked && (r === "checkbox" && !i.hasAttribute("value") ? t = !0 : t = i.value) : t = e ? i.value.replace(hF, "") : i.value, t) } n(Xb, "getFormElementValue"); Sh.getFieldData = Yb; var dF = { version: "3.0.2" }, ho = class extends Fe { constructor(e, t) { super(e, t), this.type = "acquirer", this.id = this.opts.id || "Form", this.title = "Form"; let r = { target: null, resultName: "uppyResult", getMetaFromForm: !0, addResultToForm: !0, submitOnSuccess: !1, triggerUploadOnSubmit: !1 }; this.opts = { ...r, ...t }, this.handleFormSubmit = this.handleFormSubmit.bind(this), this.handleUploadStart = this.handleUploadStart.bind(this), this.handleSuccess = this.handleSuccess.bind(this), this.addResultToForm = this.addResultToForm.bind(this), this.getMetaFromForm = this.getMetaFromForm.bind(this) } handleUploadStart() { this.opts.getMetaFromForm && this.getMetaFromForm() } handleSuccess(e) { this.opts.addResultToForm && this.addResultToForm(e), this.opts.submitOnSuccess && this.form.submit() } handleFormSubmit(e) { if (this.opts.triggerUploadOnSubmit) { e.preventDefault(); let t = De(e.target.elements), r = []; t.forEach(s => { (s.tagName === "BUTTON" || s.tagName === "INPUT" && s.type === "submit") && !s.disabled && (s.disabled = !0, r.push(s)) }), this.uppy.upload().then(() => { r.forEach(s => { s.disabled = !1 }) }, s => (r.forEach(o => { o.disabled = !1 }), Promise.reject(s))).catch(s => { this.uppy.log(s.stack || s.message || s) }) } } addResultToForm(e) { this.uppy.log("[Form] Adding result to the original form:"), this.uppy.log(e); let t = this.form.querySelector(`[name="${this.opts.resultName}"]`); if (t) { let r; try { r = JSON.parse(t.value) } catch { } Array.isArray(r) || (r = []), r.push(e), t.value = JSON.stringify(r); return } t = document.createElement("input"), t.name = this.opts.resultName, t.type = "hidden", t.value = JSON.stringify([e]), this.form.appendChild(t) } getMetaFromForm() { let e = Sh(this.form); delete e[this.opts.resultName], this.uppy.setMeta(e) } install() { if (this.form = An(this.opts.target), !this.form || this.form.nodeName !== "FORM") { this.uppy.log("Form plugin requires a <form> target element passed in options to operate, none was found", "error"); return } this.form.addEventListener("submit", this.handleFormSubmit), this.uppy.on("upload", this.handleUploadStart), this.uppy.on("complete", this.handleSuccess) } uninstall() { this.form.removeEventListener("submit", this.handleFormSubmit), this.uppy.off("upload", this.handleUploadStart), this.uppy.off("complete", this.handleSuccess) } }; n(ho, "Form"); ho.VERSION = dF.version; var l1 = se(Il(), 1); function co(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(co, "_classPrivateFieldLooseBase"); var pF = 0; function fF(i) { return "__private_" + pF++ + "_" + i } n(fF, "_classPrivateFieldLooseKey"); var Qb = typeof navigator < "u" && "serviceWorker" in navigator; function mF() { return new Promise((i, e) => { Qb ? navigator.serviceWorker.controller ? i() : navigator.serviceWorker.addEventListener("controllerchange", () => { i() }) : e(new Error("Unsupported")) }) } n(mF, "waitForServiceWorker"); var St = fF("ready"), Cl = class { constructor(e) { Object.defineProperty(this, St, { writable: !0, value: void 0 }), co(this, St)[St] = mF().then(t => { co(this, St)[St] = t }), this.name = e.storeName } get ready() { return Promise.resolve(co(this, St)[St]) } set ready(e) { co(this, St)[St] = e } async list() { return await co(this, St)[St], new Promise((e, t) => { let r = n(s => { if (s.data.store === this.name) switch (s.data.type) { case "uppy/ALL_FILES": e(s.data.files), navigator.serviceWorker.removeEventListener("message", r); break; default: t() } }, "onMessage"); navigator.serviceWorker.addEventListener("message", r), navigator.serviceWorker.controller.postMessage({ type: "uppy/GET_FILES", store: this.name }) }) } async put(e) { await co(this, St)[St], navigator.serviceWorker.controller.postMessage({ type: "uppy/ADD_FILE", store: this.name, file: e }) } async delete(e) { await co(this, St)[St], navigator.serviceWorker.controller.postMessage({ type: "uppy/REMOVE_FILE", store: this.name, fileID: e }) } }; n(Cl, "ServiceWorkerStore"); Cl.isSupported = Qb; var Jb = Cl; function Gi(i, e) { if (!Object.prototype.hasOwnProperty.call(i, e)) throw new TypeError("attempted to use private field on non-instance"); return i } n(Gi, "_classPrivateFieldLooseBase"); var gF = 0; function yF(i) { return "__private_" + gF++ + "_" + i } n(yF, "_classPrivateFieldLooseKey"); var r1 = typeof window < "u" && (window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.OIndexedDB || window.msIndexedDB), vF = !!r1, Zb = "uppy-blobs", Ct = "files", s1 = 24 * 60 * 60 * 1e3, bF = 3, e1 = 1048576; function wF(i) { let e = i.openCursor(); e.onsuccess = t => { let r = t.target.result; if (!r) return; let s = r.value; s.expires = Date.now() + s1, r.update(s) } } n(wF, "migrateExpiration"); function t1(i) { let e = r1.open(i, bF); return new Promise((t, r) => { e.onupgradeneeded = s => { let o = s.target.result, { transaction: a } = s.currentTarget; if (s.oldVersion < 2 && o.createObjectStore(Ct, { keyPath: "id" }).createIndex("store", "store", { unique: !1 }), s.oldVersion < 3) { let l = a.objectStore(Ct); l.createIndex("expires", "expires", { unique: !1 }), wF(l) } a.oncomplete = () => { t(o) } }, e.onsuccess = s => { t(s.target.result) }, e.onerror = r }) } n(t1, "connect"); function Ph(i) { return new Promise((e, t) => { i.onsuccess = r => { e(r.target.result) }, i.onerror = t }) } n(Ph, "waitForRequest"); var i1 = !1, Te = yF("ready"), po = class { constructor(e) { Object.defineProperty(this, Te, { writable: !0, value: void 0 }), this.opts = { dbName: Zb, storeName: "default", expires: s1, maxFileSize: 10 * e1, maxTotalSize: 300 * e1, ...e }, this.name = this.opts.storeName; let t = n(async () => { let r = await t1(this.opts.dbName); return Gi(this, Te)[Te] = r, r }, "createConnection"); i1 ? Gi(this, Te)[Te] = t() : (i1 = !0, Gi(this, Te)[Te] = po.cleanup().then(t, t)) } get ready() { return Promise.resolve(Gi(this, Te)[Te]) } set ready(e) { Gi(this, Te)[Te] = e } key(e) { return `${this.name}!${e}` } async list() { let s = (await Gi(this, Te)[Te]).transaction([Ct], "readonly").objectStore(Ct).index("store").getAll(IDBKeyRange.only(this.name)), o = await Ph(s); return Object.fromEntries(o.map(a => [a.fileID, a.data])) } async get(e) { let s = (await Gi(this, Te)[Te]).transaction([Ct], "readonly").objectStore(Ct).get(this.key(e)), { data: o } = await Ph(s); return { id: o.fileID, data: o.data } } async getSize() { let s = (await Gi(this, Te)[Te]).transaction([Ct], "readonly").objectStore(Ct).index("store").openCursor(IDBKeyRange.only(this.name)); return new Promise((o, a) => { let l = 0; s.onsuccess = h => { let c = h.target.result; c ? (l += c.value.data.size, c.continue()) : o(l) }, s.onerror = () => { a(new Error("Could not retrieve stored blobs size")) } }) } async put(e) { if (e.data.size > this.opts.maxFileSize) throw new Error("File is too big to store."); if (await this.getSize() > this.opts.maxTotalSize) throw new Error("No space left"); let o = Gi(this, Te)[Te].transaction([Ct], "readwrite").objectStore(Ct).add({ id: this.key(e.id), fileID: e.id, store: this.name, expires: Date.now() + this.opts.expires, data: e.data }); return Ph(o) } async delete(e) { let s = (await Gi(this, Te)[Te]).transaction([Ct], "readwrite").objectStore(Ct).delete(this.key(e)); return Ph(s) } static async cleanup() { let e = await t1(Zb), s = e.transaction([Ct], "readwrite").objectStore(Ct).index("expires").openCursor(IDBKeyRange.upperBound(Date.now())); await new Promise((o, a) => { s.onsuccess = l => { let h = l.target.result; h ? (h.delete(), h.continue()) : o() }, s.onerror = a }), e.close() } }; n(po, "IndexedDBStore"); po.isSupported = vF; var o1 = po; function SF() { let i = []; for (let e = 0; e < localStorage.length; e++) { let t = localStorage.key(e); t.startsWith("uppyState:") && i.push(t.slice(10)) } return i } n(SF, "findUppyInstances"); function n1(i) { try { return JSON.parse(i) } catch { return null } } n(n1, "maybeParse"); var a1 = !1, _i = class { constructor(e) { this.opts = { expires: 24 * 60 * 60 * 1e3, ...e }, this.name = `uppyState:${e.storeName}`, a1 || (a1 = !0, _i.cleanup()) } load() { let e = localStorage.getItem(this.name); if (!e) return null; let t = n1(e); return t ? t.metadata ? t.metadata : (this.save(t), t) : null } save(e) { let t = Date.now() + this.opts.expires, r = JSON.stringify({ metadata: e, expires: t }); localStorage.setItem(this.name, r) } static cleanup(e) { if (e) { localStorage.removeItem(`uppyState:${e}`); return } let t = SF(), r = Date.now(); t.forEach(s => { let o = localStorage.getItem(`uppyState:${s}`); if (!o) return; let a = n1(o); a && a.expires && a.expires < r && localStorage.removeItem(`uppyState:${s}`) }) } }; n(_i, "MetaDataStore"); var PF = { version: "3.1.0" }, fo = class extends Fe { constructor(e, t) { super(e, t), this.addBlobToStores = s => { s.isRemote || (this.ServiceWorkerStore && this.ServiceWorkerStore.put(s).catch(o => { this.uppy.log("[GoldenRetriever] Could not store file", "warning"), this.uppy.log(o) }), this.IndexedDBStore.put(s).catch(o => { this.uppy.log("[GoldenRetriever] Could not store file", "warning"), this.uppy.log(o) })) }, this.removeBlobFromStores = s => { this.ServiceWorkerStore && this.ServiceWorkerStore.delete(s.id).catch(o => { this.uppy.log("[GoldenRetriever] Failed to remove file", "warning"), this.uppy.log(o) }), this.IndexedDBStore.delete(s.id).catch(o => { this.uppy.log("[GoldenRetriever] Failed to remove file", "warning"), this.uppy.log(o) }) }, this.replaceBlobInStores = s => { this.removeBlobFromStores(s), this.addBlobToStores(s) }, this.handleRestoreConfirmed = () => { this.uppy.log("[GoldenRetriever] Restore confirmed, proceeding..."); let { currentUploads: s } = this.uppy.getState(); s && (this.uppy.resumeAll(), Object.keys(s).forEach(o => { this.uppy.restore(o, s[o]) })), this.uppy.setState({ recoveredState: null }) }, this.abortRestore = () => { this.uppy.log("[GoldenRetriever] Aborting restore..."); let s = Object.keys(this.uppy.getState().files); this.deleteBlobs(s).then(() => { this.uppy.log(`[GoldenRetriever] Removed ${s.length} files`) }).catch(o => { this.uppy.log(`[GoldenRetriever] Could not remove ${s.length} files`, "warning"), this.uppy.log(o) }), this.uppy.cancelAll(), this.uppy.setState({ recoveredState: null }), _i.cleanup(this.uppy.opts.id) }, this.handleComplete = s => { let { successful: o } = s, a = o.map(l => l.id); this.deleteBlobs(a).then(() => { this.uppy.log(`[GoldenRetriever] Removed ${o.length} files that finished uploading`) }).catch(l => { this.uppy.log(`[GoldenRetriever] Could not remove ${o.length} files that finished uploading`, "warning"), this.uppy.log(l) }), this.uppy.setState({ recoveredState: null }), _i.cleanup(this.uppy.opts.id) }, this.restoreBlobs = () => { this.uppy.getFiles().length > 0 ? Promise.all([this.loadFileBlobsFromServiceWorker(), this.loadFileBlobsFromIndexedDB()]).then(s => { let o = { ...s[0], ...s[1] }; this.onBlobsLoaded(o) }) : this.uppy.log("[GoldenRetriever] No files need to be loaded, only restoring processing state...") }, this.type = "debugger", this.id = this.opts.id || "GoldenRetriever", this.title = "Golden Retriever"; let r = { expires: 24 * 60 * 60 * 1e3, serviceWorker: !1 }; this.opts = { ...r, ...t }, this.MetaDataStore = new _i({ expires: this.opts.expires, storeName: e.getID() }), this.ServiceWorkerStore = null, this.opts.serviceWorker && (this.ServiceWorkerStore = new Jb({ storeName: e.getID() })), this.IndexedDBStore = new o1({ expires: this.opts.expires, ...this.opts.indexedDB || {}, storeName: e.getID() }), this.saveFilesStateToLocalStorage = (0, l1.default)(this.saveFilesStateToLocalStorage.bind(this), 500, { leading: !0, trailing: !0 }), this.restoreState = this.restoreState.bind(this), this.loadFileBlobsFromServiceWorker = this.loadFileBlobsFromServiceWorker.bind(this), this.loadFileBlobsFromIndexedDB = this.loadFileBlobsFromIndexedDB.bind(this), this.onBlobsLoaded = this.onBlobsLoaded.bind(this) } restoreState() { let e = this.MetaDataStore.load(); e && (this.uppy.log("[GoldenRetriever] Recovered some state from Local Storage"), this.uppy.setState({ currentUploads: e.currentUploads || {}, files: e.files || {}, recoveredState: e }), this.savedPluginData = e.pluginData) } getWaitingFiles() { let e = {}; return this.uppy.getFiles().forEach(t => { (!t.progress || !t.progress.uploadStarted) && (e[t.id] = t) }), e } getUploadingFiles() { let e = {}, { currentUploads: t } = this.uppy.getState(); return t && Object.keys(t).forEach(s => { t[s].fileIDs.forEach(a => { e[a] = this.uppy.getFile(a) }) }), e } saveFilesStateToLocalStorage() { let e = { ...this.getWaitingFiles(), ...this.getUploadingFiles() }, t = Object.entries(e); if (t.length === 0) { this.uppy.getState().recoveredState !== null && this.uppy.setState({ recoveredState: null }), _i.cleanup(this.uppy.opts.id); return } let r = Object.fromEntries(t.map(a => { let [l, h] = a; return [l, h.isRemote ? { ...h, isRestored: !0 } : { ...h, isRestored: !0, data: null, preview: null }] })), s = {}; this.uppy.emit("restore:get-data", a => { Object.assign(s, a) }); let { currentUploads: o } = this.uppy.getState(); this.MetaDataStore.save({ currentUploads: o, files: r, pluginData: s }) } loadFileBlobsFromServiceWorker() { return this.ServiceWorkerStore ? this.ServiceWorkerStore.list().then(e => { let t = Object.keys(e).length; return t > 0 ? (this.uppy.log(`[GoldenRetriever] Successfully recovered ${t} blobs from Service Worker!`), e) : (this.uppy.log("[GoldenRetriever] No blobs found in Service Worker, trying IndexedDB now..."), {}) }).catch(e => (this.uppy.log("[GoldenRetriever] Failed to recover blobs from Service Worker", "warning"), this.uppy.log(e), {})) : Promise.resolve({}) } loadFileBlobsFromIndexedDB() { return this.IndexedDBStore.list().then(e => { let t = Object.keys(e).length; return t > 0 ? (this.uppy.log(`[GoldenRetriever] Successfully recovered ${t} blobs from IndexedDB!`), e) : (this.uppy.log("[GoldenRetriever] No blobs found in IndexedDB"), {}) }).catch(e => (this.uppy.log("[GoldenRetriever] Failed to recover blobs from IndexedDB", "warning"), this.uppy.log(e), {})) } onBlobsLoaded(e) { let t = [], r = { ...this.uppy.getState().files }; Object.keys(e).forEach(s => { let o = this.uppy.getFile(s); if (!o) { t.push(s); return } let l = { data: e[s], isRestored: !0, isGhost: !1 }; r[s] = { ...o, ...l } }), Object.keys(r).forEach(s => { r[s].data === null && (r[s] = { ...r[s], isGhost: !0 }) }), this.uppy.setState({ files: r }), this.uppy.emit("restored", this.savedPluginData), t.length && this.deleteBlobs(t).then(() => { this.uppy.log(`[GoldenRetriever] Cleaned up ${t.length} old files`) }).catch(s => { this.uppy.log(`[GoldenRetriever] Could not clean up ${t.length} old files`, "warning"), this.uppy.log(s) }) } deleteBlobs(e) { return Promise.all(e.map(t => { var r, s, o; return (r = (s = this.ServiceWorkerStore) == null ? void 0 : s.delete(t)) != null ? r : (o = this.IndexedDBStore) == null ? void 0 : o.delete(t) })) } install() { this.restoreState(), this.restoreBlobs(), this.uppy.on("file-added", this.addBlobToStores), this.uppy.on("file-editor:complete", this.replaceBlobInStores), this.uppy.on("file-removed", this.removeBlobFromStores), this.uppy.on("state-update", this.saveFilesStateToLocalStorage), this.uppy.on("restore-confirmed", this.handleRestoreConfirmed), this.uppy.on("restore-canceled", this.abortRestore), this.uppy.on("complete", this.handleComplete) } uninstall() { this.uppy.off("file-added", this.addBlobToStores), this.uppy.off("file-editor:complete", this.replaceBlobInStores), this.uppy.off("file-removed", this.removeBlobFromStores), this.uppy.off("state-update", this.saveFilesStateToLocalStorage), this.uppy.off("restore-confirmed", this.handleRestoreConfirmed), this.uppy.off("restore-canceled", this.abortRestore), this.uppy.off("complete", this.handleComplete) } }; n(fo, "GoldenRetriever"); fo.VERSION = PF.version; var _F = { version: "3.0.3" }, mo = class extends G { constructor(e, t) { super(e, t), this.type = "debugger", this.id = this.opts.id || "ReduxDevTools", this.title = "Redux DevTools"; let r = {}; this.opts = { ...r, ...t }, this.handleStateChange = this.handleStateChange.bind(this), this.initDevTools = this.initDevTools.bind(this) } handleStateChange(e, t) { this.devTools.send("UPPY_STATE_UPDATE", t) } initDevTools() { this.devTools = window.devToolsExtension.connect(), this.devToolsUnsubscribe = this.devTools.subscribe(e => { if (e.type === "DISPATCH") switch (e.payload.type) { case "RESET": this.uppy.cancelAll(); return; case "IMPORT_STATE": { let { computedStates: t } = e.payload.nextLiftedState; this.uppy.store.state = { ...this.uppy.getState(), ...t[t.length - 1].state }, this.uppy.updateAll(this.uppy.getState()); return } case "JUMP_TO_STATE": case "JUMP_TO_ACTION": this.uppy.store.state = { ...this.uppy.getState(), ...JSON.parse(e.state) }, this.uppy.updateAll(this.uppy.getState()); break; default: } }) } install() { this.withDevTools = typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION__, this.withDevTools && (this.initDevTools(), this.uppy.on("state-update", this.handleStateChange)) } uninstall() { this.withDevTools && (this.devToolsUnsubscribe(), this.uppy.off("state-update", this.handleStateUpdate)) } }; n(mo, "ReduxDevTools"); mo.VERSION = _F.version; function xF() { throw new Error("Core has been renamed to Uppy") } n(xF, "Core"); var EF = { ProviderView: dc }; ni.COMPANION_URL = Yp; ni.COMPANION_ALLOWED_HOSTS = Qp; var FF = {}; globalThis.Uppy = of;
})();
